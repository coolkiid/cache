/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 7351:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(2037));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 2186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(7351);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(2037));
const path = __importStar(__nccwpck_require__(1017));
const oidc_utils_1 = __nccwpck_require__(8041);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
    }
    command_1.issueCommand('set-env', { name }, convertedVal);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    if (options && options.trimWhitespace === false) {
        return inputs;
    }
    return inputs.map(input => input.trim());
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    const filePath = process.env['GITHUB_OUTPUT'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    const filePath = process.env['GITHUB_STATE'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(1327);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(1327);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __nccwpck_require__(2981);
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(7147));
const os = __importStar(__nccwpck_require__(2037));
const uuid_1 = __nccwpck_require__(8974);
const utils_1 = __nccwpck_require__(5278);
function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueFileCommand = issueFileCommand;
function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    // These should realistically never happen, but just in case someone finds a
    // way to exploit uuid generation let's not allow keys or values that contain
    // the delimiter.
    if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
}
exports.prepareKeyValueMessage = prepareKeyValueMessage;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 8041:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(6255);
const auth_1 = __nccwpck_require__(5526);
const core_1 = __nccwpck_require__(2186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 2981:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__nccwpck_require__(1017));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ 1327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(2037);
const fs_1 = __nccwpck_require__(7147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 8974:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _version.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return _parse.default;
  }
}));

var _v = _interopRequireDefault(__nccwpck_require__(1595));

var _v2 = _interopRequireDefault(__nccwpck_require__(6993));

var _v3 = _interopRequireDefault(__nccwpck_require__(1472));

var _v4 = _interopRequireDefault(__nccwpck_require__(6217));

var _nil = _interopRequireDefault(__nccwpck_require__(2381));

var _version = _interopRequireDefault(__nccwpck_require__(427));

var _validate = _interopRequireDefault(__nccwpck_require__(2609));

var _stringify = _interopRequireDefault(__nccwpck_require__(1458));

var _parse = _interopRequireDefault(__nccwpck_require__(6385));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 5842:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 2381:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 6385:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(2609));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 6230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 9784:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ 8844:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 1458:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(2609));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 1595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(9784));

var _stringify = _interopRequireDefault(__nccwpck_require__(1458));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 6993:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(5920));

var _md = _interopRequireDefault(__nccwpck_require__(5842));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 5920:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(__nccwpck_require__(1458));

var _parse = _interopRequireDefault(__nccwpck_require__(6385));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 1472:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(9784));

var _stringify = _interopRequireDefault(__nccwpck_require__(1458));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 6217:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(5920));

var _sha = _interopRequireDefault(__nccwpck_require__(8844));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 2609:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__nccwpck_require__(6230));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 427:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(2609));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 1514:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExecOutput = exports.exec = void 0;
const string_decoder_1 = __nccwpck_require__(1576);
const tr = __importStar(__nccwpck_require__(8159));
/**
 * Exec a command.
 * Output will be streamed to the live console.
 * Returns promise with return code
 *
 * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
 * @param     args               optional arguments for tool. Escaping is handled by the lib.
 * @param     options            optional exec options.  See ExecOptions
 * @returns   Promise<number>    exit code
 */
function exec(commandLine, args, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const commandArgs = tr.argStringToArray(commandLine);
        if (commandArgs.length === 0) {
            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
        }
        // Path to tool to execute should be first arg
        const toolPath = commandArgs[0];
        args = commandArgs.slice(1).concat(args || []);
        const runner = new tr.ToolRunner(toolPath, args, options);
        return runner.exec();
    });
}
exports.exec = exec;
/**
 * Exec a command and get the output.
 * Output will be streamed to the live console.
 * Returns promise with the exit code and collected stdout and stderr
 *
 * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
 * @param     args                  optional arguments for tool. Escaping is handled by the lib.
 * @param     options               optional exec options.  See ExecOptions
 * @returns   Promise<ExecOutput>   exit code, stdout, and stderr
 */
function getExecOutput(commandLine, args, options) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        let stdout = '';
        let stderr = '';
        //Using string decoder covers the case where a mult-byte character is split
        const stdoutDecoder = new string_decoder_1.StringDecoder('utf8');
        const stderrDecoder = new string_decoder_1.StringDecoder('utf8');
        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
        const stdErrListener = (data) => {
            stderr += stderrDecoder.write(data);
            if (originalStdErrListener) {
                originalStdErrListener(data);
            }
        };
        const stdOutListener = (data) => {
            stdout += stdoutDecoder.write(data);
            if (originalStdoutListener) {
                originalStdoutListener(data);
            }
        };
        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
        const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
        //flush any remaining characters
        stdout += stdoutDecoder.end();
        stderr += stderrDecoder.end();
        return {
            exitCode,
            stdout,
            stderr
        };
    });
}
exports.getExecOutput = getExecOutput;
//# sourceMappingURL=exec.js.map

/***/ }),

/***/ 8159:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.argStringToArray = exports.ToolRunner = void 0;
const os = __importStar(__nccwpck_require__(2037));
const events = __importStar(__nccwpck_require__(2361));
const child = __importStar(__nccwpck_require__(2081));
const path = __importStar(__nccwpck_require__(1017));
const io = __importStar(__nccwpck_require__(7436));
const ioUtil = __importStar(__nccwpck_require__(1962));
const timers_1 = __nccwpck_require__(9512);
/* eslint-disable @typescript-eslint/unbound-method */
const IS_WINDOWS = process.platform === 'win32';
/*
 * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.
 */
class ToolRunner extends events.EventEmitter {
    constructor(toolPath, args, options) {
        super();
        if (!toolPath) {
            throw new Error("Parameter 'toolPath' cannot be null or empty.");
        }
        this.toolPath = toolPath;
        this.args = args || [];
        this.options = options || {};
    }
    _debug(message) {
        if (this.options.listeners && this.options.listeners.debug) {
            this.options.listeners.debug(message);
        }
    }
    _getCommandString(options, noPrefix) {
        const toolPath = this._getSpawnFileName();
        const args = this._getSpawnArgs(options);
        let cmd = noPrefix ? '' : '[command]'; // omit prefix when piped to a second tool
        if (IS_WINDOWS) {
            // Windows + cmd file
            if (this._isCmdFile()) {
                cmd += toolPath;
                for (const a of args) {
                    cmd += ` ${a}`;
                }
            }
            // Windows + verbatim
            else if (options.windowsVerbatimArguments) {
                cmd += `"${toolPath}"`;
                for (const a of args) {
                    cmd += ` ${a}`;
                }
            }
            // Windows (regular)
            else {
                cmd += this._windowsQuoteCmdArg(toolPath);
                for (const a of args) {
                    cmd += ` ${this._windowsQuoteCmdArg(a)}`;
                }
            }
        }
        else {
            // OSX/Linux - this can likely be improved with some form of quoting.
            // creating processes on Unix is fundamentally different than Windows.
            // on Unix, execvp() takes an arg array.
            cmd += toolPath;
            for (const a of args) {
                cmd += ` ${a}`;
            }
        }
        return cmd;
    }
    _processLineBuffer(data, strBuffer, onLine) {
        try {
            let s = strBuffer + data.toString();
            let n = s.indexOf(os.EOL);
            while (n > -1) {
                const line = s.substring(0, n);
                onLine(line);
                // the rest of the string ...
                s = s.substring(n + os.EOL.length);
                n = s.indexOf(os.EOL);
            }
            return s;
        }
        catch (err) {
            // streaming lines to console is best effort.  Don't fail a build.
            this._debug(`error processing line. Failed with error ${err}`);
            return '';
        }
    }
    _getSpawnFileName() {
        if (IS_WINDOWS) {
            if (this._isCmdFile()) {
                return process.env['COMSPEC'] || 'cmd.exe';
            }
        }
        return this.toolPath;
    }
    _getSpawnArgs(options) {
        if (IS_WINDOWS) {
            if (this._isCmdFile()) {
                let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
                for (const a of this.args) {
                    argline += ' ';
                    argline += options.windowsVerbatimArguments
                        ? a
                        : this._windowsQuoteCmdArg(a);
                }
                argline += '"';
                return [argline];
            }
        }
        return this.args;
    }
    _endsWith(str, end) {
        return str.endsWith(end);
    }
    _isCmdFile() {
        const upperToolPath = this.toolPath.toUpperCase();
        return (this._endsWith(upperToolPath, '.CMD') ||
            this._endsWith(upperToolPath, '.BAT'));
    }
    _windowsQuoteCmdArg(arg) {
        // for .exe, apply the normal quoting rules that libuv applies
        if (!this._isCmdFile()) {
            return this._uvQuoteCmdArg(arg);
        }
        // otherwise apply quoting rules specific to the cmd.exe command line parser.
        // the libuv rules are generic and are not designed specifically for cmd.exe
        // command line parser.
        //
        // for a detailed description of the cmd.exe command line parser, refer to
        // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912
        // need quotes for empty arg
        if (!arg) {
            return '""';
        }
        // determine whether the arg needs to be quoted
        const cmdSpecialChars = [
            ' ',
            '\t',
            '&',
            '(',
            ')',
            '[',
            ']',
            '{',
            '}',
            '^',
            '=',
            ';',
            '!',
            "'",
            '+',
            ',',
            '`',
            '~',
            '|',
            '<',
            '>',
            '"'
        ];
        let needsQuotes = false;
        for (const char of arg) {
            if (cmdSpecialChars.some(x => x === char)) {
                needsQuotes = true;
                break;
            }
        }
        // short-circuit if quotes not needed
        if (!needsQuotes) {
            return arg;
        }
        // the following quoting rules are very similar to the rules that by libuv applies.
        //
        // 1) wrap the string in quotes
        //
        // 2) double-up quotes - i.e. " => ""
        //
        //    this is different from the libuv quoting rules. libuv replaces " with \", which unfortunately
        //    doesn't work well with a cmd.exe command line.
        //
        //    note, replacing " with "" also works well if the arg is passed to a downstream .NET console app.
        //    for example, the command line:
        //          foo.exe "myarg:""my val"""
        //    is parsed by a .NET console app into an arg array:
        //          [ "myarg:\"my val\"" ]
        //    which is the same end result when applying libuv quoting rules. although the actual
        //    command line from libuv quoting rules would look like:
        //          foo.exe "myarg:\"my val\""
        //
        // 3) double-up slashes that precede a quote,
        //    e.g.  hello \world    => "hello \world"
        //          hello\"world    => "hello\\""world"
        //          hello\\"world   => "hello\\\\""world"
        //          hello world\    => "hello world\\"
        //
        //    technically this is not required for a cmd.exe command line, or the batch argument parser.
        //    the reasons for including this as a .cmd quoting rule are:
        //
        //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an
        //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.
        //
        //    b) it's what we've been doing previously (by deferring to node default behavior) and we
        //       haven't heard any complaints about that aspect.
        //
        // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be
        // escaped when used on the command line directly - even though within a .cmd file % can be escaped
        // by using %%.
        //
        // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts
        // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.
        //
        // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would
        // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the
        // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args
        // to an external program.
        //
        // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.
        // % can be escaped within a .cmd file.
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
            // walk the string in reverse
            reverse += arg[i - 1];
            if (quoteHit && arg[i - 1] === '\\') {
                reverse += '\\'; // double the slash
            }
            else if (arg[i - 1] === '"') {
                quoteHit = true;
                reverse += '"'; // double the quote
            }
            else {
                quoteHit = false;
            }
        }
        reverse += '"';
        return reverse
            .split('')
            .reverse()
            .join('');
    }
    _uvQuoteCmdArg(arg) {
        // Tool runner wraps child_process.spawn() and needs to apply the same quoting as
        // Node in certain cases where the undocumented spawn option windowsVerbatimArguments
        // is used.
        //
        // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,
        // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),
        // pasting copyright notice from Node within this function:
        //
        //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.
        //
        //      Permission is hereby granted, free of charge, to any person obtaining a copy
        //      of this software and associated documentation files (the "Software"), to
        //      deal in the Software without restriction, including without limitation the
        //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
        //      sell copies of the Software, and to permit persons to whom the Software is
        //      furnished to do so, subject to the following conditions:
        //
        //      The above copyright notice and this permission notice shall be included in
        //      all copies or substantial portions of the Software.
        //
        //      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
        //      IN THE SOFTWARE.
        if (!arg) {
            // Need double quotation for empty argument
            return '""';
        }
        if (!arg.includes(' ') && !arg.includes('\t') && !arg.includes('"')) {
            // No quotation needed
            return arg;
        }
        if (!arg.includes('"') && !arg.includes('\\')) {
            // No embedded double quotes or backslashes, so I can just wrap
            // quote marks around the whole thing.
            return `"${arg}"`;
        }
        // Expected input/output:
        //   input : hello"world
        //   output: "hello\"world"
        //   input : hello""world
        //   output: "hello\"\"world"
        //   input : hello\world
        //   output: hello\world
        //   input : hello\\world
        //   output: hello\\world
        //   input : hello\"world
        //   output: "hello\\\"world"
        //   input : hello\\"world
        //   output: "hello\\\\\"world"
        //   input : hello world\
        //   output: "hello world\\" - note the comment in libuv actually reads "hello world\"
        //                             but it appears the comment is wrong, it should be "hello world\\"
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
            // walk the string in reverse
            reverse += arg[i - 1];
            if (quoteHit && arg[i - 1] === '\\') {
                reverse += '\\';
            }
            else if (arg[i - 1] === '"') {
                quoteHit = true;
                reverse += '\\';
            }
            else {
                quoteHit = false;
            }
        }
        reverse += '"';
        return reverse
            .split('')
            .reverse()
            .join('');
    }
    _cloneExecOptions(options) {
        options = options || {};
        const result = {
            cwd: options.cwd || process.cwd(),
            env: options.env || process.env,
            silent: options.silent || false,
            windowsVerbatimArguments: options.windowsVerbatimArguments || false,
            failOnStdErr: options.failOnStdErr || false,
            ignoreReturnCode: options.ignoreReturnCode || false,
            delay: options.delay || 10000
        };
        result.outStream = options.outStream || process.stdout;
        result.errStream = options.errStream || process.stderr;
        return result;
    }
    _getSpawnOptions(options, toolPath) {
        options = options || {};
        const result = {};
        result.cwd = options.cwd;
        result.env = options.env;
        result['windowsVerbatimArguments'] =
            options.windowsVerbatimArguments || this._isCmdFile();
        if (options.windowsVerbatimArguments) {
            result.argv0 = `"${toolPath}"`;
        }
        return result;
    }
    /**
     * Exec a tool.
     * Output will be streamed to the live console.
     * Returns promise with return code
     *
     * @param     tool     path to tool to exec
     * @param     options  optional exec options.  See ExecOptions
     * @returns   number
     */
    exec() {
        return __awaiter(this, void 0, void 0, function* () {
            // root the tool path if it is unrooted and contains relative pathing
            if (!ioUtil.isRooted(this.toolPath) &&
                (this.toolPath.includes('/') ||
                    (IS_WINDOWS && this.toolPath.includes('\\')))) {
                // prefer options.cwd if it is specified, however options.cwd may also need to be rooted
                this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
            }
            // if the tool is only a file name, then resolve it from the PATH
            // otherwise verify it exists (add extension on Windows if necessary)
            this.toolPath = yield io.which(this.toolPath, true);
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                this._debug(`exec tool: ${this.toolPath}`);
                this._debug('arguments:');
                for (const arg of this.args) {
                    this._debug(`   ${arg}`);
                }
                const optionsNonNull = this._cloneExecOptions(this.options);
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                    optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
                }
                const state = new ExecState(optionsNonNull, this.toolPath);
                state.on('debug', (message) => {
                    this._debug(message);
                });
                if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
                    return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
                }
                const fileName = this._getSpawnFileName();
                const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
                let stdbuffer = '';
                if (cp.stdout) {
                    cp.stdout.on('data', (data) => {
                        if (this.options.listeners && this.options.listeners.stdout) {
                            this.options.listeners.stdout(data);
                        }
                        if (!optionsNonNull.silent && optionsNonNull.outStream) {
                            optionsNonNull.outStream.write(data);
                        }
                        stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                            if (this.options.listeners && this.options.listeners.stdline) {
                                this.options.listeners.stdline(line);
                            }
                        });
                    });
                }
                let errbuffer = '';
                if (cp.stderr) {
                    cp.stderr.on('data', (data) => {
                        state.processStderr = true;
                        if (this.options.listeners && this.options.listeners.stderr) {
                            this.options.listeners.stderr(data);
                        }
                        if (!optionsNonNull.silent &&
                            optionsNonNull.errStream &&
                            optionsNonNull.outStream) {
                            const s = optionsNonNull.failOnStdErr
                                ? optionsNonNull.errStream
                                : optionsNonNull.outStream;
                            s.write(data);
                        }
                        errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                            if (this.options.listeners && this.options.listeners.errline) {
                                this.options.listeners.errline(line);
                            }
                        });
                    });
                }
                cp.on('error', (err) => {
                    state.processError = err.message;
                    state.processExited = true;
                    state.processClosed = true;
                    state.CheckComplete();
                });
                cp.on('exit', (code) => {
                    state.processExitCode = code;
                    state.processExited = true;
                    this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
                    state.CheckComplete();
                });
                cp.on('close', (code) => {
                    state.processExitCode = code;
                    state.processExited = true;
                    state.processClosed = true;
                    this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
                    state.CheckComplete();
                });
                state.on('done', (error, exitCode) => {
                    if (stdbuffer.length > 0) {
                        this.emit('stdline', stdbuffer);
                    }
                    if (errbuffer.length > 0) {
                        this.emit('errline', errbuffer);
                    }
                    cp.removeAllListeners();
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(exitCode);
                    }
                });
                if (this.options.input) {
                    if (!cp.stdin) {
                        throw new Error('child process missing stdin');
                    }
                    cp.stdin.end(this.options.input);
                }
            }));
        });
    }
}
exports.ToolRunner = ToolRunner;
/**
 * Convert an arg string to an array of args. Handles escaping
 *
 * @param    argString   string of arguments
 * @returns  string[]    array of arguments
 */
function argStringToArray(argString) {
    const args = [];
    let inQuotes = false;
    let escaped = false;
    let arg = '';
    function append(c) {
        // we only escape double quotes.
        if (escaped && c !== '"') {
            arg += '\\';
        }
        arg += c;
        escaped = false;
    }
    for (let i = 0; i < argString.length; i++) {
        const c = argString.charAt(i);
        if (c === '"') {
            if (!escaped) {
                inQuotes = !inQuotes;
            }
            else {
                append(c);
            }
            continue;
        }
        if (c === '\\' && escaped) {
            append(c);
            continue;
        }
        if (c === '\\' && inQuotes) {
            escaped = true;
            continue;
        }
        if (c === ' ' && !inQuotes) {
            if (arg.length > 0) {
                args.push(arg);
                arg = '';
            }
            continue;
        }
        append(c);
    }
    if (arg.length > 0) {
        args.push(arg.trim());
    }
    return args;
}
exports.argStringToArray = argStringToArray;
class ExecState extends events.EventEmitter {
    constructor(options, toolPath) {
        super();
        this.processClosed = false; // tracks whether the process has exited and stdio is closed
        this.processError = '';
        this.processExitCode = 0;
        this.processExited = false; // tracks whether the process has exited
        this.processStderr = false; // tracks whether stderr was written to
        this.delay = 10000; // 10 seconds
        this.done = false;
        this.timeout = null;
        if (!toolPath) {
            throw new Error('toolPath must not be empty');
        }
        this.options = options;
        this.toolPath = toolPath;
        if (options.delay) {
            this.delay = options.delay;
        }
    }
    CheckComplete() {
        if (this.done) {
            return;
        }
        if (this.processClosed) {
            this._setResult();
        }
        else if (this.processExited) {
            this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
        }
    }
    _debug(message) {
        this.emit('debug', message);
    }
    _setResult() {
        // determine whether there is an error
        let error;
        if (this.processExited) {
            if (this.processError) {
                error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
            }
            else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
                error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
            }
            else if (this.processStderr && this.options.failOnStdErr) {
                error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
            }
        }
        // clear the timeout
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
        this.done = true;
        this.emit('done', error, this.processExitCode);
    }
    static HandleTimeout(state) {
        if (state.done) {
            return;
        }
        if (!state.processClosed && state.processExited) {
            const message = `The STDIO streams did not close within ${state.delay /
                1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
            state._debug(message);
        }
        state._setResult();
    }
}
//# sourceMappingURL=toolrunner.js.map

/***/ }),

/***/ 8090:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.create = void 0;
const internal_globber_1 = __nccwpck_require__(8298);
/**
 * Constructs a globber
 *
 * @param patterns  Patterns separated by newlines
 * @param options   Glob options
 */
function create(patterns, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield internal_globber_1.DefaultGlobber.create(patterns, options);
    });
}
exports.create = create;
//# sourceMappingURL=glob.js.map

/***/ }),

/***/ 1026:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOptions = void 0;
const core = __importStar(__nccwpck_require__(2186));
/**
 * Returns a copy with defaults filled in.
 */
function getOptions(copy) {
    const result = {
        followSymbolicLinks: true,
        implicitDescendants: true,
        omitBrokenSymbolicLinks: true
    };
    if (copy) {
        if (typeof copy.followSymbolicLinks === 'boolean') {
            result.followSymbolicLinks = copy.followSymbolicLinks;
            core.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
        }
        if (typeof copy.implicitDescendants === 'boolean') {
            result.implicitDescendants = copy.implicitDescendants;
            core.debug(`implicitDescendants '${result.implicitDescendants}'`);
        }
        if (typeof copy.omitBrokenSymbolicLinks === 'boolean') {
            result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
            core.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
        }
    }
    return result;
}
exports.getOptions = getOptions;
//# sourceMappingURL=internal-glob-options-helper.js.map

/***/ }),

/***/ 8298:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultGlobber = void 0;
const core = __importStar(__nccwpck_require__(2186));
const fs = __importStar(__nccwpck_require__(7147));
const globOptionsHelper = __importStar(__nccwpck_require__(1026));
const path = __importStar(__nccwpck_require__(1017));
const patternHelper = __importStar(__nccwpck_require__(9005));
const internal_match_kind_1 = __nccwpck_require__(1063);
const internal_pattern_1 = __nccwpck_require__(4536);
const internal_search_state_1 = __nccwpck_require__(9117);
const IS_WINDOWS = process.platform === 'win32';
class DefaultGlobber {
    constructor(options) {
        this.patterns = [];
        this.searchPaths = [];
        this.options = globOptionsHelper.getOptions(options);
    }
    getSearchPaths() {
        // Return a copy
        return this.searchPaths.slice();
    }
    glob() {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            try {
                for (var _b = __asyncValues(this.globGenerator()), _c; _c = yield _b.next(), !_c.done;) {
                    const itemPath = _c.value;
                    result.push(itemPath);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        });
    }
    globGenerator() {
        return __asyncGenerator(this, arguments, function* globGenerator_1() {
            // Fill in defaults options
            const options = globOptionsHelper.getOptions(this.options);
            // Implicit descendants?
            const patterns = [];
            for (const pattern of this.patterns) {
                patterns.push(pattern);
                if (options.implicitDescendants &&
                    (pattern.trailingSeparator ||
                        pattern.segments[pattern.segments.length - 1] !== '**')) {
                    patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat('**')));
                }
            }
            // Push the search paths
            const stack = [];
            for (const searchPath of patternHelper.getSearchPaths(patterns)) {
                core.debug(`Search path '${searchPath}'`);
                // Exists?
                try {
                    // Intentionally using lstat. Detection for broken symlink
                    // will be performed later (if following symlinks).
                    yield __await(fs.promises.lstat(searchPath));
                }
                catch (err) {
                    if (err.code === 'ENOENT') {
                        continue;
                    }
                    throw err;
                }
                stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
            }
            // Search
            const traversalChain = []; // used to detect cycles
            while (stack.length) {
                // Pop
                const item = stack.pop();
                // Match?
                const match = patternHelper.match(patterns, item.path);
                const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
                if (!match && !partialMatch) {
                    continue;
                }
                // Stat
                const stats = yield __await(DefaultGlobber.stat(item, options, traversalChain)
                // Broken symlink, or symlink cycle detected, or no longer exists
                );
                // Broken symlink, or symlink cycle detected, or no longer exists
                if (!stats) {
                    continue;
                }
                // Directory
                if (stats.isDirectory()) {
                    // Matched
                    if (match & internal_match_kind_1.MatchKind.Directory) {
                        yield yield __await(item.path);
                    }
                    // Descend?
                    else if (!partialMatch) {
                        continue;
                    }
                    // Push the child items in reverse
                    const childLevel = item.level + 1;
                    const childItems = (yield __await(fs.promises.readdir(item.path))).map(x => new internal_search_state_1.SearchState(path.join(item.path, x), childLevel));
                    stack.push(...childItems.reverse());
                }
                // File
                else if (match & internal_match_kind_1.MatchKind.File) {
                    yield yield __await(item.path);
                }
            }
        });
    }
    /**
     * Constructs a DefaultGlobber
     */
    static create(patterns, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = new DefaultGlobber(options);
            if (IS_WINDOWS) {
                patterns = patterns.replace(/\r\n/g, '\n');
                patterns = patterns.replace(/\r/g, '\n');
            }
            const lines = patterns.split('\n').map(x => x.trim());
            for (const line of lines) {
                // Empty or comment
                if (!line || line.startsWith('#')) {
                    continue;
                }
                // Pattern
                else {
                    result.patterns.push(new internal_pattern_1.Pattern(line));
                }
            }
            result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
            return result;
        });
    }
    static stat(item, options, traversalChain) {
        return __awaiter(this, void 0, void 0, function* () {
            // Note:
            // `stat` returns info about the target of a symlink (or symlink chain)
            // `lstat` returns info about a symlink itself
            let stats;
            if (options.followSymbolicLinks) {
                try {
                    // Use `stat` (following symlinks)
                    stats = yield fs.promises.stat(item.path);
                }
                catch (err) {
                    if (err.code === 'ENOENT') {
                        if (options.omitBrokenSymbolicLinks) {
                            core.debug(`Broken symlink '${item.path}'`);
                            return undefined;
                        }
                        throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
                    }
                    throw err;
                }
            }
            else {
                // Use `lstat` (not following symlinks)
                stats = yield fs.promises.lstat(item.path);
            }
            // Note, isDirectory() returns false for the lstat of a symlink
            if (stats.isDirectory() && options.followSymbolicLinks) {
                // Get the realpath
                const realPath = yield fs.promises.realpath(item.path);
                // Fixup the traversal chain to match the item level
                while (traversalChain.length >= item.level) {
                    traversalChain.pop();
                }
                // Test for a cycle
                if (traversalChain.some((x) => x === realPath)) {
                    core.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
                    return undefined;
                }
                // Update the traversal chain
                traversalChain.push(realPath);
            }
            return stats;
        });
    }
}
exports.DefaultGlobber = DefaultGlobber;
//# sourceMappingURL=internal-globber.js.map

/***/ }),

/***/ 1063:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MatchKind = void 0;
/**
 * Indicates whether a pattern matches a path
 */
var MatchKind;
(function (MatchKind) {
    /** Not matched */
    MatchKind[MatchKind["None"] = 0] = "None";
    /** Matched if the path is a directory */
    MatchKind[MatchKind["Directory"] = 1] = "Directory";
    /** Matched if the path is a regular file */
    MatchKind[MatchKind["File"] = 2] = "File";
    /** Matched */
    MatchKind[MatchKind["All"] = 3] = "All";
})(MatchKind = exports.MatchKind || (exports.MatchKind = {}));
//# sourceMappingURL=internal-match-kind.js.map

/***/ }),

/***/ 1849:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.safeTrimTrailingSeparator = exports.normalizeSeparators = exports.hasRoot = exports.hasAbsoluteRoot = exports.ensureAbsoluteRoot = exports.dirname = void 0;
const path = __importStar(__nccwpck_require__(1017));
const assert_1 = __importDefault(__nccwpck_require__(9491));
const IS_WINDOWS = process.platform === 'win32';
/**
 * Similar to path.dirname except normalizes the path separators and slightly better handling for Windows UNC paths.
 *
 * For example, on Linux/macOS:
 * - `/               => /`
 * - `/hello          => /`
 *
 * For example, on Windows:
 * - `C:\             => C:\`
 * - `C:\hello        => C:\`
 * - `C:              => C:`
 * - `C:hello         => C:`
 * - `\               => \`
 * - `\hello          => \`
 * - `\\hello         => \\hello`
 * - `\\hello\world   => \\hello\world`
 */
function dirname(p) {
    // Normalize slashes and trim unnecessary trailing slash
    p = safeTrimTrailingSeparator(p);
    // Windows UNC root, e.g. \\hello or \\hello\world
    if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
        return p;
    }
    // Get dirname
    let result = path.dirname(p);
    // Trim trailing slash for Windows UNC root, e.g. \\hello\world\
    if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
        result = safeTrimTrailingSeparator(result);
    }
    return result;
}
exports.dirname = dirname;
/**
 * Roots the path if not already rooted. On Windows, relative roots like `\`
 * or `C:` are expanded based on the current working directory.
 */
function ensureAbsoluteRoot(root, itemPath) {
    assert_1.default(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
    assert_1.default(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
    // Already rooted
    if (hasAbsoluteRoot(itemPath)) {
        return itemPath;
    }
    // Windows
    if (IS_WINDOWS) {
        // Check for itemPath like C: or C:foo
        if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
            let cwd = process.cwd();
            assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
            // Drive letter matches cwd? Expand to cwd
            if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
                // Drive only, e.g. C:
                if (itemPath.length === 2) {
                    // Preserve specified drive letter case (upper or lower)
                    return `${itemPath[0]}:\\${cwd.substr(3)}`;
                }
                // Drive + path, e.g. C:foo
                else {
                    if (!cwd.endsWith('\\')) {
                        cwd += '\\';
                    }
                    // Preserve specified drive letter case (upper or lower)
                    return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
                }
            }
            // Different drive
            else {
                return `${itemPath[0]}:\\${itemPath.substr(2)}`;
            }
        }
        // Check for itemPath like \ or \foo
        else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
            const cwd = process.cwd();
            assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
            return `${cwd[0]}:\\${itemPath.substr(1)}`;
        }
    }
    assert_1.default(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
    // Otherwise ensure root ends with a separator
    if (root.endsWith('/') || (IS_WINDOWS && root.endsWith('\\'))) {
        // Intentionally empty
    }
    else {
        // Append separator
        root += path.sep;
    }
    return root + itemPath;
}
exports.ensureAbsoluteRoot = ensureAbsoluteRoot;
/**
 * On Linux/macOS, true if path starts with `/`. On Windows, true for paths like:
 * `\\hello\share` and `C:\hello` (and using alternate separator).
 */
function hasAbsoluteRoot(itemPath) {
    assert_1.default(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
    // Normalize separators
    itemPath = normalizeSeparators(itemPath);
    // Windows
    if (IS_WINDOWS) {
        // E.g. \\hello\share or C:\hello
        return itemPath.startsWith('\\\\') || /^[A-Z]:\\/i.test(itemPath);
    }
    // E.g. /hello
    return itemPath.startsWith('/');
}
exports.hasAbsoluteRoot = hasAbsoluteRoot;
/**
 * On Linux/macOS, true if path starts with `/`. On Windows, true for paths like:
 * `\`, `\hello`, `\\hello\share`, `C:`, and `C:\hello` (and using alternate separator).
 */
function hasRoot(itemPath) {
    assert_1.default(itemPath, `isRooted parameter 'itemPath' must not be empty`);
    // Normalize separators
    itemPath = normalizeSeparators(itemPath);
    // Windows
    if (IS_WINDOWS) {
        // E.g. \ or \hello or \\hello
        // E.g. C: or C:\hello
        return itemPath.startsWith('\\') || /^[A-Z]:/i.test(itemPath);
    }
    // E.g. /hello
    return itemPath.startsWith('/');
}
exports.hasRoot = hasRoot;
/**
 * Removes redundant slashes and converts `/` to `\` on Windows
 */
function normalizeSeparators(p) {
    p = p || '';
    // Windows
    if (IS_WINDOWS) {
        // Convert slashes on Windows
        p = p.replace(/\//g, '\\');
        // Remove redundant slashes
        const isUnc = /^\\\\+[^\\]/.test(p); // e.g. \\hello
        return (isUnc ? '\\' : '') + p.replace(/\\\\+/g, '\\'); // preserve leading \\ for UNC
    }
    // Remove redundant slashes
    return p.replace(/\/\/+/g, '/');
}
exports.normalizeSeparators = normalizeSeparators;
/**
 * Normalizes the path separators and trims the trailing separator (when safe).
 * For example, `/foo/ => /foo` but `/ => /`
 */
function safeTrimTrailingSeparator(p) {
    // Short-circuit if empty
    if (!p) {
        return '';
    }
    // Normalize separators
    p = normalizeSeparators(p);
    // No trailing slash
    if (!p.endsWith(path.sep)) {
        return p;
    }
    // Check '/' on Linux/macOS and '\' on Windows
    if (p === path.sep) {
        return p;
    }
    // On Windows check if drive root. E.g. C:\
    if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
        return p;
    }
    // Otherwise trim trailing slash
    return p.substr(0, p.length - 1);
}
exports.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
//# sourceMappingURL=internal-path-helper.js.map

/***/ }),

/***/ 6836:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Path = void 0;
const path = __importStar(__nccwpck_require__(1017));
const pathHelper = __importStar(__nccwpck_require__(1849));
const assert_1 = __importDefault(__nccwpck_require__(9491));
const IS_WINDOWS = process.platform === 'win32';
/**
 * Helper class for parsing paths into segments
 */
class Path {
    /**
     * Constructs a Path
     * @param itemPath Path or array of segments
     */
    constructor(itemPath) {
        this.segments = [];
        // String
        if (typeof itemPath === 'string') {
            assert_1.default(itemPath, `Parameter 'itemPath' must not be empty`);
            // Normalize slashes and trim unnecessary trailing slash
            itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
            // Not rooted
            if (!pathHelper.hasRoot(itemPath)) {
                this.segments = itemPath.split(path.sep);
            }
            // Rooted
            else {
                // Add all segments, while not at the root
                let remaining = itemPath;
                let dir = pathHelper.dirname(remaining);
                while (dir !== remaining) {
                    // Add the segment
                    const basename = path.basename(remaining);
                    this.segments.unshift(basename);
                    // Truncate the last segment
                    remaining = dir;
                    dir = pathHelper.dirname(remaining);
                }
                // Remainder is the root
                this.segments.unshift(remaining);
            }
        }
        // Array
        else {
            // Must not be empty
            assert_1.default(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
            // Each segment
            for (let i = 0; i < itemPath.length; i++) {
                let segment = itemPath[i];
                // Must not be empty
                assert_1.default(segment, `Parameter 'itemPath' must not contain any empty segments`);
                // Normalize slashes
                segment = pathHelper.normalizeSeparators(itemPath[i]);
                // Root segment
                if (i === 0 && pathHelper.hasRoot(segment)) {
                    segment = pathHelper.safeTrimTrailingSeparator(segment);
                    assert_1.default(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
                    this.segments.push(segment);
                }
                // All other segments
                else {
                    // Must not contain slash
                    assert_1.default(!segment.includes(path.sep), `Parameter 'itemPath' contains unexpected path separators`);
                    this.segments.push(segment);
                }
            }
        }
    }
    /**
     * Converts the path to it's string representation
     */
    toString() {
        // First segment
        let result = this.segments[0];
        // All others
        let skipSlash = result.endsWith(path.sep) || (IS_WINDOWS && /^[A-Z]:$/i.test(result));
        for (let i = 1; i < this.segments.length; i++) {
            if (skipSlash) {
                skipSlash = false;
            }
            else {
                result += path.sep;
            }
            result += this.segments[i];
        }
        return result;
    }
}
exports.Path = Path;
//# sourceMappingURL=internal-path.js.map

/***/ }),

/***/ 9005:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.partialMatch = exports.match = exports.getSearchPaths = void 0;
const pathHelper = __importStar(__nccwpck_require__(1849));
const internal_match_kind_1 = __nccwpck_require__(1063);
const IS_WINDOWS = process.platform === 'win32';
/**
 * Given an array of patterns, returns an array of paths to search.
 * Duplicates and paths under other included paths are filtered out.
 */
function getSearchPaths(patterns) {
    // Ignore negate patterns
    patterns = patterns.filter(x => !x.negate);
    // Create a map of all search paths
    const searchPathMap = {};
    for (const pattern of patterns) {
        const key = IS_WINDOWS
            ? pattern.searchPath.toUpperCase()
            : pattern.searchPath;
        searchPathMap[key] = 'candidate';
    }
    const result = [];
    for (const pattern of patterns) {
        // Check if already included
        const key = IS_WINDOWS
            ? pattern.searchPath.toUpperCase()
            : pattern.searchPath;
        if (searchPathMap[key] === 'included') {
            continue;
        }
        // Check for an ancestor search path
        let foundAncestor = false;
        let tempKey = key;
        let parent = pathHelper.dirname(tempKey);
        while (parent !== tempKey) {
            if (searchPathMap[parent]) {
                foundAncestor = true;
                break;
            }
            tempKey = parent;
            parent = pathHelper.dirname(tempKey);
        }
        // Include the search pattern in the result
        if (!foundAncestor) {
            result.push(pattern.searchPath);
            searchPathMap[key] = 'included';
        }
    }
    return result;
}
exports.getSearchPaths = getSearchPaths;
/**
 * Matches the patterns against the path
 */
function match(patterns, itemPath) {
    let result = internal_match_kind_1.MatchKind.None;
    for (const pattern of patterns) {
        if (pattern.negate) {
            result &= ~pattern.match(itemPath);
        }
        else {
            result |= pattern.match(itemPath);
        }
    }
    return result;
}
exports.match = match;
/**
 * Checks whether to descend further into the directory
 */
function partialMatch(patterns, itemPath) {
    return patterns.some(x => !x.negate && x.partialMatch(itemPath));
}
exports.partialMatch = partialMatch;
//# sourceMappingURL=internal-pattern-helper.js.map

/***/ }),

/***/ 4536:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pattern = void 0;
const os = __importStar(__nccwpck_require__(2037));
const path = __importStar(__nccwpck_require__(1017));
const pathHelper = __importStar(__nccwpck_require__(1849));
const assert_1 = __importDefault(__nccwpck_require__(9491));
const minimatch_1 = __nccwpck_require__(3973);
const internal_match_kind_1 = __nccwpck_require__(1063);
const internal_path_1 = __nccwpck_require__(6836);
const IS_WINDOWS = process.platform === 'win32';
class Pattern {
    constructor(patternOrNegate, isImplicitPattern = false, segments, homedir) {
        /**
         * Indicates whether matches should be excluded from the result set
         */
        this.negate = false;
        // Pattern overload
        let pattern;
        if (typeof patternOrNegate === 'string') {
            pattern = patternOrNegate.trim();
        }
        // Segments overload
        else {
            // Convert to pattern
            segments = segments || [];
            assert_1.default(segments.length, `Parameter 'segments' must not empty`);
            const root = Pattern.getLiteral(segments[0]);
            assert_1.default(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
            pattern = new internal_path_1.Path(segments).toString().trim();
            if (patternOrNegate) {
                pattern = `!${pattern}`;
            }
        }
        // Negate
        while (pattern.startsWith('!')) {
            this.negate = !this.negate;
            pattern = pattern.substr(1).trim();
        }
        // Normalize slashes and ensures absolute root
        pattern = Pattern.fixupPattern(pattern, homedir);
        // Segments
        this.segments = new internal_path_1.Path(pattern).segments;
        // Trailing slash indicates the pattern should only match directories, not regular files
        this.trailingSeparator = pathHelper
            .normalizeSeparators(pattern)
            .endsWith(path.sep);
        pattern = pathHelper.safeTrimTrailingSeparator(pattern);
        // Search path (literal path prior to the first glob segment)
        let foundGlob = false;
        const searchSegments = this.segments
            .map(x => Pattern.getLiteral(x))
            .filter(x => !foundGlob && !(foundGlob = x === ''));
        this.searchPath = new internal_path_1.Path(searchSegments).toString();
        // Root RegExp (required when determining partial match)
        this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? 'i' : '');
        this.isImplicitPattern = isImplicitPattern;
        // Create minimatch
        const minimatchOptions = {
            dot: true,
            nobrace: true,
            nocase: IS_WINDOWS,
            nocomment: true,
            noext: true,
            nonegate: true
        };
        pattern = IS_WINDOWS ? pattern.replace(/\\/g, '/') : pattern;
        this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
    }
    /**
     * Matches the pattern against the specified path
     */
    match(itemPath) {
        // Last segment is globstar?
        if (this.segments[this.segments.length - 1] === '**') {
            // Normalize slashes
            itemPath = pathHelper.normalizeSeparators(itemPath);
            // Append a trailing slash. Otherwise Minimatch will not match the directory immediately
            // preceding the globstar. For example, given the pattern `/foo/**`, Minimatch returns
            // false for `/foo` but returns true for `/foo/`. Append a trailing slash to handle that quirk.
            if (!itemPath.endsWith(path.sep) && this.isImplicitPattern === false) {
                // Note, this is safe because the constructor ensures the pattern has an absolute root.
                // For example, formats like C: and C:foo on Windows are resolved to an absolute root.
                itemPath = `${itemPath}${path.sep}`;
            }
        }
        else {
            // Normalize slashes and trim unnecessary trailing slash
            itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        }
        // Match
        if (this.minimatch.match(itemPath)) {
            return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
        }
        return internal_match_kind_1.MatchKind.None;
    }
    /**
     * Indicates whether the pattern may match descendants of the specified path
     */
    partialMatch(itemPath) {
        // Normalize slashes and trim unnecessary trailing slash
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        // matchOne does not handle root path correctly
        if (pathHelper.dirname(itemPath) === itemPath) {
            return this.rootRegExp.test(itemPath);
        }
        return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
    }
    /**
     * Escapes glob patterns within a path
     */
    static globEscape(s) {
        return (IS_WINDOWS ? s : s.replace(/\\/g, '\\\\')) // escape '\' on Linux/macOS
            .replace(/(\[)(?=[^/]+\])/g, '[[]') // escape '[' when ']' follows within the path segment
            .replace(/\?/g, '[?]') // escape '?'
            .replace(/\*/g, '[*]'); // escape '*'
    }
    /**
     * Normalizes slashes and ensures absolute root
     */
    static fixupPattern(pattern, homedir) {
        // Empty
        assert_1.default(pattern, 'pattern cannot be empty');
        // Must not contain `.` segment, unless first segment
        // Must not contain `..` segment
        const literalSegments = new internal_path_1.Path(pattern).segments.map(x => Pattern.getLiteral(x));
        assert_1.default(literalSegments.every((x, i) => (x !== '.' || i === 0) && x !== '..'), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
        // Must not contain globs in root, e.g. Windows UNC path \\foo\b*r
        assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
        // Normalize slashes
        pattern = pathHelper.normalizeSeparators(pattern);
        // Replace leading `.` segment
        if (pattern === '.' || pattern.startsWith(`.${path.sep}`)) {
            pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
        }
        // Replace leading `~` segment
        else if (pattern === '~' || pattern.startsWith(`~${path.sep}`)) {
            homedir = homedir || os.homedir();
            assert_1.default(homedir, 'Unable to determine HOME directory');
            assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
            pattern = Pattern.globEscape(homedir) + pattern.substr(1);
        }
        // Replace relative drive root, e.g. pattern is C: or C:foo
        else if (IS_WINDOWS &&
            (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
            let root = pathHelper.ensureAbsoluteRoot('C:\\dummy-root', pattern.substr(0, 2));
            if (pattern.length > 2 && !root.endsWith('\\')) {
                root += '\\';
            }
            pattern = Pattern.globEscape(root) + pattern.substr(2);
        }
        // Replace relative root, e.g. pattern is \ or \foo
        else if (IS_WINDOWS && (pattern === '\\' || pattern.match(/^\\[^\\]/))) {
            let root = pathHelper.ensureAbsoluteRoot('C:\\dummy-root', '\\');
            if (!root.endsWith('\\')) {
                root += '\\';
            }
            pattern = Pattern.globEscape(root) + pattern.substr(1);
        }
        // Otherwise ensure absolute root
        else {
            pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
        }
        return pathHelper.normalizeSeparators(pattern);
    }
    /**
     * Attempts to unescape a pattern segment to create a literal path segment.
     * Otherwise returns empty string.
     */
    static getLiteral(segment) {
        let literal = '';
        for (let i = 0; i < segment.length; i++) {
            const c = segment[i];
            // Escape
            if (c === '\\' && !IS_WINDOWS && i + 1 < segment.length) {
                literal += segment[++i];
                continue;
            }
            // Wildcard
            else if (c === '*' || c === '?') {
                return '';
            }
            // Character set
            else if (c === '[' && i + 1 < segment.length) {
                let set = '';
                let closed = -1;
                for (let i2 = i + 1; i2 < segment.length; i2++) {
                    const c2 = segment[i2];
                    // Escape
                    if (c2 === '\\' && !IS_WINDOWS && i2 + 1 < segment.length) {
                        set += segment[++i2];
                        continue;
                    }
                    // Closed
                    else if (c2 === ']') {
                        closed = i2;
                        break;
                    }
                    // Otherwise
                    else {
                        set += c2;
                    }
                }
                // Closed?
                if (closed >= 0) {
                    // Cannot convert
                    if (set.length > 1) {
                        return '';
                    }
                    // Convert to literal
                    if (set) {
                        literal += set;
                        i = closed;
                        continue;
                    }
                }
                // Otherwise fall thru
            }
            // Append
            literal += c;
        }
        return literal;
    }
    /**
     * Escapes regexp special characters
     * https://javascript.info/regexp-escaping
     */
    static regExpEscape(s) {
        return s.replace(/[[\\^$.|?*+()]/g, '\\$&');
    }
}
exports.Pattern = Pattern;
//# sourceMappingURL=internal-pattern.js.map

/***/ }),

/***/ 9117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchState = void 0;
class SearchState {
    constructor(path, level) {
        this.path = path;
        this.level = level;
    }
}
exports.SearchState = SearchState;
//# sourceMappingURL=internal-search-state.js.map

/***/ }),

/***/ 5526:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 6255:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(3685));
const https = __importStar(__nccwpck_require__(5687));
const pm = __importStar(__nccwpck_require__(9835));
const tunnel = __importStar(__nccwpck_require__(4294));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
    readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const chunks = [];
                this.message.on('data', (chunk) => {
                    chunks.push(chunk);
                });
                this.message.on('end', () => {
                    resolve(Buffer.concat(chunks));
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        try {
            return new URL(proxyVar);
        }
        catch (_a) {
            if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://'))
                return new URL(`http://${proxyVar}`);
        }
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
        return true;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperNoProxyItem === '*' ||
            upperReqHosts.some(x => x === upperNoProxyItem ||
                x.endsWith(`.${upperNoProxyItem}`) ||
                (upperNoProxyItem.startsWith('.') &&
                    x.endsWith(`${upperNoProxyItem}`)))) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return (hostLower === 'localhost' ||
        hostLower.startsWith('127.') ||
        hostLower.startsWith('[::1]') ||
        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));
}
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 1962:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rename = exports.readlink = exports.readdir = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
const fs = __importStar(__nccwpck_require__(7147));
const path = __importStar(__nccwpck_require__(1017));
_a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
exports.IS_WINDOWS = process.platform === 'win32';
function exists(fsPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield exports.stat(fsPath);
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return false;
            }
            throw err;
        }
        return true;
    });
}
exports.exists = exists;
function isDirectory(fsPath, useStat = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
        return stats.isDirectory();
    });
}
exports.isDirectory = isDirectory;
/**
 * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
 * \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
 */
function isRooted(p) {
    p = normalizeSeparators(p);
    if (!p) {
        throw new Error('isRooted() parameter "p" cannot be empty');
    }
    if (exports.IS_WINDOWS) {
        return (p.startsWith('\\') || /^[A-Z]:/i.test(p) // e.g. \ or \hello or \\hello
        ); // e.g. C: or C:\hello
    }
    return p.startsWith('/');
}
exports.isRooted = isRooted;
/**
 * Best effort attempt to determine whether a file exists and is executable.
 * @param filePath    file path to check
 * @param extensions  additional file extensions to try
 * @return if file exists and is executable, returns the file path. otherwise empty string.
 */
function tryGetExecutablePath(filePath, extensions) {
    return __awaiter(this, void 0, void 0, function* () {
        let stats = undefined;
        try {
            // test file exists
            stats = yield exports.stat(filePath);
        }
        catch (err) {
            if (err.code !== 'ENOENT') {
                // eslint-disable-next-line no-console
                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
        }
        if (stats && stats.isFile()) {
            if (exports.IS_WINDOWS) {
                // on Windows, test for valid extension
                const upperExt = path.extname(filePath).toUpperCase();
                if (extensions.some(validExt => validExt.toUpperCase() === upperExt)) {
                    return filePath;
                }
            }
            else {
                if (isUnixExecutable(stats)) {
                    return filePath;
                }
            }
        }
        // try each extension
        const originalFilePath = filePath;
        for (const extension of extensions) {
            filePath = originalFilePath + extension;
            stats = undefined;
            try {
                stats = yield exports.stat(filePath);
            }
            catch (err) {
                if (err.code !== 'ENOENT') {
                    // eslint-disable-next-line no-console
                    console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
                }
            }
            if (stats && stats.isFile()) {
                if (exports.IS_WINDOWS) {
                    // preserve the case of the actual file (since an extension was appended)
                    try {
                        const directory = path.dirname(filePath);
                        const upperName = path.basename(filePath).toUpperCase();
                        for (const actualName of yield exports.readdir(directory)) {
                            if (upperName === actualName.toUpperCase()) {
                                filePath = path.join(directory, actualName);
                                break;
                            }
                        }
                    }
                    catch (err) {
                        // eslint-disable-next-line no-console
                        console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
                    }
                    return filePath;
                }
                else {
                    if (isUnixExecutable(stats)) {
                        return filePath;
                    }
                }
            }
        }
        return '';
    });
}
exports.tryGetExecutablePath = tryGetExecutablePath;
function normalizeSeparators(p) {
    p = p || '';
    if (exports.IS_WINDOWS) {
        // convert slashes on Windows
        p = p.replace(/\//g, '\\');
        // remove redundant slashes
        return p.replace(/\\\\+/g, '\\');
    }
    // remove redundant slashes
    return p.replace(/\/\/+/g, '/');
}
// on Mac/Linux, test the execute bit
//     R   W  X  R  W X R W X
//   256 128 64 32 16 8 4 2 1
function isUnixExecutable(stats) {
    return ((stats.mode & 1) > 0 ||
        ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||
        ((stats.mode & 64) > 0 && stats.uid === process.getuid()));
}
// Get the path of cmd.exe in windows
function getCmdPath() {
    var _a;
    return (_a = process.env['COMSPEC']) !== null && _a !== void 0 ? _a : `cmd.exe`;
}
exports.getCmdPath = getCmdPath;
//# sourceMappingURL=io-util.js.map

/***/ }),

/***/ 7436:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;
const assert_1 = __nccwpck_require__(9491);
const childProcess = __importStar(__nccwpck_require__(2081));
const path = __importStar(__nccwpck_require__(1017));
const util_1 = __nccwpck_require__(3837);
const ioUtil = __importStar(__nccwpck_require__(1962));
const exec = util_1.promisify(childProcess.exec);
const execFile = util_1.promisify(childProcess.execFile);
/**
 * Copies a file or folder.
 * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
 *
 * @param     source    source path
 * @param     dest      destination path
 * @param     options   optional. See CopyOptions.
 */
function cp(source, dest, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        // Dest is an existing file, but not forcing
        if (destStat && destStat.isFile() && !force) {
            return;
        }
        // If dest is an existing directory, should copy inside.
        const newDest = destStat && destStat.isDirectory() && copySourceDirectory
            ? path.join(dest, path.basename(source))
            : dest;
        if (!(yield ioUtil.exists(source))) {
            throw new Error(`no such file or directory: ${source}`);
        }
        const sourceStat = yield ioUtil.stat(source);
        if (sourceStat.isDirectory()) {
            if (!recursive) {
                throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
            }
            else {
                yield cpDirRecursive(source, newDest, 0, force);
            }
        }
        else {
            if (path.relative(source, newDest) === '') {
                // a file cannot be copied to itself
                throw new Error(`'${newDest}' and '${source}' are the same file`);
            }
            yield copyFile(source, newDest, force);
        }
    });
}
exports.cp = cp;
/**
 * Moves a path.
 *
 * @param     source    source path
 * @param     dest      destination path
 * @param     options   optional. See MoveOptions.
 */
function mv(source, dest, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
            let destExists = true;
            if (yield ioUtil.isDirectory(dest)) {
                // If dest is directory copy src into dest
                dest = path.join(dest, path.basename(source));
                destExists = yield ioUtil.exists(dest);
            }
            if (destExists) {
                if (options.force == null || options.force) {
                    yield rmRF(dest);
                }
                else {
                    throw new Error('Destination already exists');
                }
            }
        }
        yield mkdirP(path.dirname(dest));
        yield ioUtil.rename(source, dest);
    });
}
exports.mv = mv;
/**
 * Remove a path recursively with force
 *
 * @param inputPath path to remove
 */
function rmRF(inputPath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS) {
            // Node doesn't provide a delete operation, only an unlink function. This means that if the file is being used by another
            // program (e.g. antivirus), it won't be deleted. To address this, we shell out the work to rd/del.
            // Check for invalid characters
            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file
            if (/[*"<>|]/.test(inputPath)) {
                throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
            }
            try {
                const cmdPath = ioUtil.getCmdPath();
                if (yield ioUtil.isDirectory(inputPath, true)) {
                    yield exec(`${cmdPath} /s /c "rd /s /q "%inputPath%""`, {
                        env: { inputPath }
                    });
                }
                else {
                    yield exec(`${cmdPath} /s /c "del /f /a "%inputPath%""`, {
                        env: { inputPath }
                    });
                }
            }
            catch (err) {
                // if you try to delete a file that doesn't exist, desired result is achieved
                // other errors are valid
                if (err.code !== 'ENOENT')
                    throw err;
            }
            // Shelling out fails to remove a symlink folder with missing source, this unlink catches that
            try {
                yield ioUtil.unlink(inputPath);
            }
            catch (err) {
                // if you try to delete a file that doesn't exist, desired result is achieved
                // other errors are valid
                if (err.code !== 'ENOENT')
                    throw err;
            }
        }
        else {
            let isDir = false;
            try {
                isDir = yield ioUtil.isDirectory(inputPath);
            }
            catch (err) {
                // if you try to delete a file that doesn't exist, desired result is achieved
                // other errors are valid
                if (err.code !== 'ENOENT')
                    throw err;
                return;
            }
            if (isDir) {
                yield execFile(`rm`, [`-rf`, `${inputPath}`]);
            }
            else {
                yield ioUtil.unlink(inputPath);
            }
        }
    });
}
exports.rmRF = rmRF;
/**
 * Make a directory.  Creates the full path with folders in between
 * Will throw if it fails
 *
 * @param   fsPath        path to create
 * @returns Promise<void>
 */
function mkdirP(fsPath) {
    return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, 'a path argument must be provided');
        yield ioUtil.mkdir(fsPath, { recursive: true });
    });
}
exports.mkdirP = mkdirP;
/**
 * Returns path of a tool had the tool actually been invoked.  Resolves via paths.
 * If you check and the tool does not exist, it will throw.
 *
 * @param     tool              name of the tool
 * @param     check             whether to check if tool exists
 * @returns   Promise<string>   path to tool
 */
function which(tool, check) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
            throw new Error("parameter 'tool' is required");
        }
        // recursive when check=true
        if (check) {
            const result = yield which(tool, false);
            if (!result) {
                if (ioUtil.IS_WINDOWS) {
                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
                }
                else {
                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
                }
            }
            return result;
        }
        const matches = yield findInPath(tool);
        if (matches && matches.length > 0) {
            return matches[0];
        }
        return '';
    });
}
exports.which = which;
/**
 * Returns a list of all occurrences of the given tool on the system path.
 *
 * @returns   Promise<string[]>  the paths of the tool
 */
function findInPath(tool) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
            throw new Error("parameter 'tool' is required");
        }
        // build the list of extensions to try
        const extensions = [];
        if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {
            for (const extension of process.env['PATHEXT'].split(path.delimiter)) {
                if (extension) {
                    extensions.push(extension);
                }
            }
        }
        // if it's rooted, return it if exists. otherwise return empty.
        if (ioUtil.isRooted(tool)) {
            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
            if (filePath) {
                return [filePath];
            }
            return [];
        }
        // if any path separators, return empty
        if (tool.includes(path.sep)) {
            return [];
        }
        // build the list of directories
        //
        // Note, technically "where" checks the current directory on Windows. From a toolkit perspective,
        // it feels like we should not do this. Checking the current directory seems like more of a use
        // case of a shell, and the which() function exposed by the toolkit should strive for consistency
        // across platforms.
        const directories = [];
        if (process.env.PATH) {
            for (const p of process.env.PATH.split(path.delimiter)) {
                if (p) {
                    directories.push(p);
                }
            }
        }
        // find all matches
        const matches = [];
        for (const directory of directories) {
            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
            if (filePath) {
                matches.push(filePath);
            }
        }
        return matches;
    });
}
exports.findInPath = findInPath;
function readCopyOptions(options) {
    const force = options.force == null ? true : options.force;
    const recursive = Boolean(options.recursive);
    const copySourceDirectory = options.copySourceDirectory == null
        ? true
        : Boolean(options.copySourceDirectory);
    return { force, recursive, copySourceDirectory };
}
function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
    return __awaiter(this, void 0, void 0, function* () {
        // Ensure there is not a run away recursive copy
        if (currentDepth >= 255)
            return;
        currentDepth++;
        yield mkdirP(destDir);
        const files = yield ioUtil.readdir(sourceDir);
        for (const fileName of files) {
            const srcFile = `${sourceDir}/${fileName}`;
            const destFile = `${destDir}/${fileName}`;
            const srcFileStat = yield ioUtil.lstat(srcFile);
            if (srcFileStat.isDirectory()) {
                // Recurse
                yield cpDirRecursive(srcFile, destFile, currentDepth, force);
            }
            else {
                yield copyFile(srcFile, destFile, force);
            }
        }
        // Change the mode for the newly created directory
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
    });
}
// Buffered file copy
function copyFile(srcFile, destFile, force) {
    return __awaiter(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
            // unlink/re-link it
            try {
                yield ioUtil.lstat(destFile);
                yield ioUtil.unlink(destFile);
            }
            catch (e) {
                // Try to override file permission
                if (e.code === 'EPERM') {
                    yield ioUtil.chmod(destFile, '0666');
                    yield ioUtil.unlink(destFile);
                }
                // other errors = it doesn't exist, no work to do
            }
            // Copy over symlink
            const symlinkFull = yield ioUtil.readlink(srcFile);
            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);
        }
        else if (!(yield ioUtil.exists(destFile)) || force) {
            yield ioUtil.copyFile(srcFile, destFile);
        }
    });
}
//# sourceMappingURL=io.js.map

/***/ }),

/***/ 5235:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";



if (process.env.NODE_ENV === 'production') {
  module.exports = __nccwpck_require__(21)
} else {
  module.exports = __nccwpck_require__(7434)
}


/***/ }),

/***/ 7434:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var cryptoHashMd5 = _interopDefault(__nccwpck_require__(250));
var cryptoEncBase64 = _interopDefault(__nccwpck_require__(8025));
var cryptoEncHex = _interopDefault(__nccwpck_require__(9934));
var cryptoEncUtf8 = _interopDefault(__nccwpck_require__(3098));
var stream = __nccwpck_require__(2781);
var get = _interopDefault(__nccwpck_require__(6908));
var set = _interopDefault(__nccwpck_require__(2900));
var qs = _interopDefault(__nccwpck_require__(2760));
var crypto$1 = _interopDefault(__nccwpck_require__(6113));
var axios = _interopDefault(__nccwpck_require__(6545));
var http = _interopDefault(__nccwpck_require__(3685));
var https = _interopDefault(__nccwpck_require__(5687));
var tosCrc64Js = __nccwpck_require__(5845);
var createDebug = _interopDefault(__nccwpck_require__(8237));
var fs = _interopDefault(__nccwpck_require__(7147));
var util = __nccwpck_require__(3837);
var path = _interopDefault(__nccwpck_require__(1017));
var cloneDeep = _interopDefault(__nccwpck_require__(2187));

class TosClientError extends Error {
  constructor(message) {
    super(message); // https://www.dannyguo.com/blog/how-to-fix-instanceof-not-working-for-custom-errors-in-typescript/

    Object.setPrototypeOf(this, TosClientError.prototype);
  }

}

class CancelError extends Error {
  constructor(message) {
    super(message); // https://www.dannyguo.com/blog/how-to-fix-instanceof-not-working-for-custom-errors-in-typescript/

    Object.setPrototypeOf(this, CancelError.prototype);
  }

}

const makeArrayProp = obj => key => {
  if (obj == null || typeof obj !== 'object') {
    return;
  }

  const value = get(obj, key);

  if (!Array.isArray(value)) {
    set(obj, key, value == null ? [] : [value]);
  }
};

const makeConvertProp = convertMethod => {
  const finalMethod = target => {
    if (Array.isArray(target)) {
      return target.map(it => finalMethod(it));
    }

    if (typeof target === 'string') {
      return convertMethod(target);
    }

    if (typeof target === 'object' && target != null) {
      const ret = Object.keys(target).reduce((acc, key) => {
        const nextKey = finalMethod(key);
        acc[nextKey] = target[key];
        return acc;
      }, {});
      return ret;
    }

    return target;
  };

  return finalMethod;
};

const covertCamelCase2Kebab = /*#__PURE__*/makeConvertProp(camelCase => {
  return camelCase.replace(/[A-Z]/g, '-$&').toLowerCase();
});
const convertNormalCamelCase2Upper = /*#__PURE__*/makeConvertProp(normalCamelCase => {
  return normalCamelCase[0].toUpperCase() + normalCamelCase.slice(1);
});
const getSortedQueryString = query => {
  const searchParts = [];
  Object.keys(query).sort().forEach(key => {
    searchParts.push(`${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`);
  });
  return searchParts.join('&');
};
const normalizeHeadersKey = headers => {
  const headers1 = headers || {};
  const headers2 = {};
  Object.keys(headers1).forEach(key => {
    if (headers1[key] != null) {
      headers2[key] = headers1[key];
    }
  });
  const headers3 = {};
  Object.keys(headers2).forEach(key => {
    const newKey = key.toLowerCase();
    headers3[newKey] = headers2[key];
  });
  return headers3;
};
const encodeHeadersValue = headers => {
  const header2 = {};
  Object.entries(headers).forEach(([key, value]) => {
    header2[key] = `${value}` // reference:
    //  https://stackoverflow.com/questions/38345372/why-is-length-2
    .match(/./gu).map(ch => {
      if (ch.length > 1 || ch.charCodeAt(0) >= 128) {
        return encodeURIComponent(ch);
      }

      return ch;
    }).join('');
  });
  return header2;
}; // TODO: getRegion from endpoint, maybe user passes it is better.
const getEndpoint = region => {
  return `tos-${region}.volces.com`;
};
const normalizeProxy = proxy => {
  var _proxy;

  if (typeof proxy === 'string') {
    proxy = {
      url: proxy
    };
  }

  if (proxy && ((_proxy = proxy) == null ? void 0 : _proxy.needProxyParams) == null && 'node' === 'browser') {}

  return proxy;
};
async function safeAwait(p) {
  try {
    const v = await p;
    return [null, v];
  } catch (err) {
    return [err, null];
  }
}
function safeSync(func) {
  try {
    const ret = func();
    return [null, ret];
  } catch (err) {
    return [err, null];
  }
}
function isBlob(obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob;
}
function isBuffer(obj) {
  return typeof Buffer !== 'undefined' && obj instanceof Buffer;
}
function isReadable(obj) {

  return obj instanceof stream.Readable;
}
function obj2QueryStr(v) {
  if (!v) {
    return '';
  }

  return Object.keys(v).map(key => {
    const vStr = `${v[key]}`;
    return `${encodeURIComponent(key)}=${encodeURIComponent(vStr)}`;
  }).join('&');
}
function isCancelError(err) {
  return err instanceof CancelError;
}
const DEFAULT_PART_SIZE = 20 * 1024 * 1024; // 20 MB

const getGMTDateStr = v => {
  return v.toUTCString();
};

const gmtDateOrStr = v => {
  if (typeof v === 'string') {
    return v;
  }

  return v.toUTCString();
};

const requestHeadersMap = {
  projectName: 'x-tos-project-name',
  encodingType: 'encoding-type',
  cacheControl: 'cache-control',
  contentDisposition: 'content-disposition',
  contentLength: 'content-length',
  contentMD5: 'content-md5',
  contentSHA256: 'x-tos-content-sha256',
  contentEncoding: 'content-encoding',
  contentLanguage: 'content-language',
  contentType: 'content-type',
  expires: ['expires', getGMTDateStr],
  range: 'range',
  ifMatch: 'if-match',
  ifModifiedSince: ['if-modified-since', gmtDateOrStr],
  ifNoneMatch: 'if-none-match',
  ifUnmodifiedSince: ['if-unmodified-since', gmtDateOrStr],
  acl: 'x-tos-acl',
  grantFullControl: 'x-tos-grant-full-control',
  grantRead: 'x-tos-grant-read',
  grantReadAcp: 'x-tos-grant-read-acp',
  grantWrite: 'x-tos-grant-write',
  grantWriteAcp: 'x-tos-grant-write-acp',
  serverSideEncryption: 'x-tos-server-side-encryption',
  ssecAlgorithm: 'x-tos-server-side-encryption-customer-algorithm',
  ssecKey: 'x-tos-server-side-encryption-customer-key',
  ssecKeyMD5: 'x-tos-server-side-encryption-customer-key-md5',
  copySourceRange: 'x-tos-copy-source-range',
  copySourceIfMatch: 'x-tos-copy-source-if-match',
  copySourceIfModifiedSince: ['x-tos-copy-source-if-modified-since', gmtDateOrStr],
  copySourceIfNoneMatch: 'x-tos-copy-source-if-none-match',
  copySourceIfUnmodifiedSince: 'x-tos-copy-source-if-unmodified-since',
  copySourceSSECAlgorithm: 'x-tos-copy-source-server-side-encryption-customer-algorithm',
  copySourceSSECKey: 'x-tos-copy-source-server-side-encryption-customer-key',
  copySourceSSECKeyMD5: 'x-tos-copy-source-server-side-encryption-customer-key-MD5',
  metadataDirective: 'x-tos-metadata-directive',
  meta: v => {
    return Object.keys(v).reduce((prev, key) => {
      prev[`x-tos-meta-${key}`] = `${v[key]}`;
      return prev;
    }, {});
  },
  websiteRedirectLocation: 'x-tos-website-redirect-location',
  storageClass: 'x-tos-storage-class',
  azRedundancy: 'x-tos-az-redundancy',
  trafficLimit: 'x-tos-traffic-limit',
  callback: 'x-tos-callback',
  callbackVar: 'x-tos-callback-var',
  allowSameActionOverlap: ['x-tos-allow-same-action-overlap', v => String(v)]
}; // type RequestHeadersMapKeys = keyof typeof requestHeadersMap;

const requestQueryMap = {
  versionId: 'versionId',
  process: 'x-tos-process',
  saveBucket: 'x-tos-save-bucket',
  saveObject: 'x-tos-save-object',
  responseCacheControl: 'response-cache-control',
  responseContentDisposition: 'response-content-disposition',
  responseContentEncoding: 'response-content-encoding',
  responseContentLanguage: 'response-content-language',
  responseContentType: 'response-content-type',
  responseExpires: ['response-expires', v => v.toUTCString()]
};
function fillRequestHeaders(v, // keys: (keyof T & RequestHeadersMapKeys)[]
keys) {
  if (!keys.length) {
    return;
  }

  const headers = v.headers || {};
  v.headers = headers;

  function setOneHeader(k, v) {
    if (headers[k] == null) {
      headers[k] = v;
    }
  }

  keys.forEach(k => {
    const confV = requestHeadersMap[k];

    if (!confV) {
      // maybe warning
      throw new TosClientError(`\`${k}\` isn't in keys of \`requestHeadersMap\``);
    }

    const oriValue = v[k];

    if (oriValue == null) {
      return;
    }

    const oriValueStr = `${oriValue}`;

    if (typeof confV === 'string') {
      return setOneHeader(confV, oriValueStr);
    }

    if (Array.isArray(confV)) {
      const newKey = confV[0];
      const newValue = confV[1](oriValue);
      return setOneHeader(newKey, newValue);
    }

    const obj = confV(oriValue);
    Object.entries(obj).forEach(([k, v]) => {
      setOneHeader(k, v);
    });
  });
}
function fillRequestQuery(v, query, keys) {
  if (!keys.length) {
    return;
  }

  function setOneKey(k, v) {
    if (query[k] == null) {
      query[k] = v;
    }
  }

  keys.forEach(k => {
    const confV = requestQueryMap[k];

    if (!confV) {
      // maybe warning
      throw new TosClientError(`\`${k}\` isn't in keys of \`requestQueryMap\``);
    }

    const oriValue = v[k];

    if (oriValue == null) {
      return;
    }

    const oriValueStr = `${oriValue}`;

    if (typeof confV === 'string') {
      return setOneKey(confV, oriValueStr);
    }

    if (Array.isArray(confV)) {
      const newKey = confV[0];
      const newValue = confV[1](oriValue);
      return setOneKey(newKey, newValue);
    }

    const obj = confV(oriValue);
    Object.entries(obj).forEach(([k, v]) => {
      setOneKey(k, v);
    });
  });
}
const paramsSerializer = params => {
  return qs.stringify(params);
};
function getNormalDataFromError(data, err) {
  return {
    data,
    statusCode: err.statusCode,
    headers: err.headers,
    requestId: err.requestId,
    id2: err.id2
  };
}
const streamToBuf = async stream => {
  let buf = Buffer.from([]);
  return new Promise((resolve, reject) => {
    stream.on('data', data => {
      buf = Buffer.concat([buf, data]);
    });
    stream.on('end', () => {
      resolve(buf);
    });
    stream.on('error', err => {
      reject(err);
    });
  });
};
function checkCRC64WithHeaders(crc, headers) {
  const serverCRC64 = headers['x-tos-hash-crc64ecma'];

  if (serverCRC64 == null) {

    return;
  }

  const crcStr = typeof crc === 'string' ? crc : crc.getCrc64();

  if (crcStr !== serverCRC64) {
    throw new TosClientError(`expect crc64 ${serverCRC64}, actual crc64 ${crcStr}`);
  }
}

function getEnc(coding) {
  switch (coding) {
    case 'utf-8':
      return cryptoEncUtf8;

    case 'base64':
      return cryptoEncBase64;

    case 'hex':
      return cryptoEncHex;

    default:
      throw new TosClientError('The coding is not supported');
  }
}

function decode(v, decoding) {
  if (!decoding) {
    return v;
  }

  return v.toString(getEnc(decoding));
}
const hashMd5 = function hashMd5(message, decoding) {
  if (isBuffer(message)) {
    throw new TosClientError('not support buffer in browser environment');
  }

  return decode(cryptoHashMd5(message), decoding);
};

function digest(v, decoding) {
  if (!decoding) {
    return v.digest();
  }

  return v.digest(decoding);
}

const hmacSha256 = function hmacSha256(key, message, decoding) {
  return digest(crypto$1.createHmac('sha256', key).update(message), decoding);
};
const hashSha256 = function hashSha256(message, decoding) {
  return digest(crypto$1.createHash('sha256').update(message), decoding);
};
const hashMd5$1 = function hashMd5(message, decoding) {
  return digest(crypto$1.createHash('md5').update(message), decoding);
};
const parse = function parse(str, encoding) {
  return Buffer.from(str, encoding);
};
const stringify = function stringify(str, decoding) {
  return str.toString(decoding);
};

var cryptoNode = {
  __proto__: null,
  hmacSha256: hmacSha256,
  hashSha256: hashSha256,
  hashMd5: hashMd5$1,
  parse: parse,
  stringify: stringify
};

let crypto = null;

{
  crypto = cryptoNode;
}

const {
  hmacSha256: hmacSha256$1,
  hashSha256: hashSha256$1,
  hashMd5: hashMd5$2,
  parse: parse$1,
  stringify: stringify$1
} = crypto;

// @ts-nocheck
const SIG_QUERY = {
  algorithm: 'tos-algorithm',
  expiration: 'tos-expiration',
  signame: 'tos-signame',
  signature: 'tos-signature',
  v4_algorithm: 'X-Tos-Algorithm',
  v4_credential: 'X-Tos-Credential',
  v4_date: 'X-Tos-Date',
  v4_expires: 'X-Tos-Expires',
  v4_signedHeaders: 'X-Tos-SignedHeaders',
  v4_security_token: 'X-Tos-Security-Token',
  v4_signature: 'X-Tos-Signature',
  v4_content_sha: 'X-Tos-Content-Sha256',
  v4_policy: 'X-Tos-Policy'
};
function isDefaultPort(port) {
  if (port && port !== 80 && port !== 443) {
    return false;
  }

  return true;
}
/**
 * @api private
 */

const v4Identifier = 'request';
/**
 * @api private
 */

class SignersV4 {
  constructor(_opt, _credentials) {
    this.options = void 0;
    this.credentials = void 0;

    this.signature = (opt, expiredAt, credentials) => {
      if (!credentials) {
        credentials = this.credentials;
      }

      const parts = [];
      const datatime = opt.datetime;
      const credString = this.credentialString(datatime);
      parts.push(this.options.algorithm + ' Credential=' + credentials.GetAccessKey() + '/' + credString); // console.log(this.algorithm + ' Credential=' +
      //   credentials.accessKeyId + '/' + credString)

      parts.push('SignedHeaders=' + this.signedHeaders(opt));
      parts.push('Signature=' + this.authorization(opt, credentials, 0));
      return parts.join(', ');
    };

    this.signatureHeader = (opt, expiredAt, credentials) => {
      // const datetime = (new Date(new Date().toUTCString())).Format("yyyyMMddTHHmmssZ")
      opt.datetime = this.getDateTime();
      const header = new Map();
      /* istanbul ignore if */

      if (!opt.headers) {
        const h = {};
        opt.headers = h;
      }

      opt.headers.host = `${opt.host}`;
      /* istanbul ignore if */

      if (!isDefaultPort(opt.port)) {
        opt.headers.host += ':' + opt.port;
      }
      /* istanbul ignore if */


      if (opt.endpoints) {
        opt.headers.host = `${this.options.bucket}.${opt.endpoints}`;
      }

      header.set('host', opt.headers.host); // opt.endpoints as string)

      header.set('x-tos-date', opt.datetime); // opt.datetime)

      /* istanbul ignore if
        if (opt.endpoints) {
            let bucket = this.options.bucket;
            if (opt.bucket) {
                bucket = opt.bucket;
            }
            if (!opt.path || opt.path === '/' || opt.path === `/${bucket}`) {
                opt.path = '/' + bucket;
            } else {
                opt.path = '/' + bucket + opt.path;
            }
        }
        */

      header.set('x-tos-content-sha256', this.hexEncodedBodyHash());

      if (this.options.securityToken) {
        header.set('x-tos-security-token', this.options.securityToken);
      } // x-tos- must to be signatured


      header.forEach((value, key) => {
        if (key.startsWith('x-tos')) {
          opt.headers[key] = value;
        }
      });
      opt.path = this.getEncodePath(opt.path);
      const sign = this.signature(opt, 0, credentials);
      header.set('authorization', sign);
      return header;
    };

    this.gnrCopySig = (opt, credentials) => {
      return {
        key: '',
        value: ''
      };
    };

    this.getSignature = (opt, expiredAt) => {
      return {
        key: '',
        value: ''
      };
    };

    this.getSignatureQuery = (opt, expiredAt) => {
      opt.datetime = this.getDateTime();

      if (!opt.headers) {
        const h = {};
        opt.headers = h;
      }

      opt.headers.host = `${opt.host}`;

      if (!isDefaultPort(opt.port)) {
        opt.headers.host += ':' + opt.port;
      }

      opt.path = this.getEncodePath(opt.path);

      if (opt.endpoints) {
        opt.headers.host = `${this.options.bucket}.${opt.endpoints}`; // opt.path = `${opt.path}`;
      }

      opt.headers[SIG_QUERY.v4_date] = opt.datetime;
      const credString = this.credentialString(opt.datetime);
      const res = { ...(opt.query || {}),
        [SIG_QUERY.v4_algorithm]: this.options.algorithm,
        [SIG_QUERY.v4_content_sha]: this.hexEncodedBodyHash(),
        [SIG_QUERY.v4_credential]: this.credentials.GetAccessKey() + '/' + credString,
        [SIG_QUERY.v4_date]: opt.datetime,
        [SIG_QUERY.v4_expires]: '' + expiredAt,
        [SIG_QUERY.v4_signedHeaders]: this.signedHeaders(opt)
      };

      if (this.options.securityToken) {
        res[SIG_QUERY.v4_security_token] = this.options.securityToken;
      }

      opt.query = getSortedQueryString(res);
      res[SIG_QUERY.v4_signature] = this.authorization(opt, this.credentials, expiredAt);
      return res;
    };

    this.getSignaturePolicyQuery = (opt, expiredAt) => {
      opt.datetime = this.getDateTime();
      const credString = this.credentialString(opt.datetime);
      const res = {
        [SIG_QUERY.v4_algorithm]: this.options.algorithm,
        [SIG_QUERY.v4_credential]: this.credentials.GetAccessKey() + '/' + credString,
        [SIG_QUERY.v4_date]: opt.datetime,
        [SIG_QUERY.v4_expires]: '' + expiredAt,
        [SIG_QUERY.v4_policy]: stringify$1(parse$1(JSON.stringify(opt.policy), 'utf-8'), 'base64')
      };

      if (this.options.securityToken) {
        res[SIG_QUERY.v4_security_token] = this.options.securityToken;
      }

      opt.query = getSortedQueryString(res);
      res[SIG_QUERY.v4_signature] = this.authorization(opt, this.credentials, expiredAt);
      return res;
    };

    this.hexEncodedBodyHash = () => {
      return 'UNSIGNED-PAYLOAD'; // return this.hexEncodedHash('');
    };

    this.authorization = (opt, credentials, expiredAt) => {
      /* istanbul ignore if */
      if (!opt.datetime) {
        return '';
      }

      const signingKey = this.getSigningKey(credentials, opt.datetime.substr(0, 8)); // console.log(
      // 'signingKey:',
      //  signingKey,
      //  'sign:',
      //  this.stringToSign(opt.datetime, opt)
      //  );

      return hmacSha256$1(signingKey, this.stringToSign(opt.datetime, opt), 'hex');
    };

    this.getDateTime = () => {
      const date = new Date(new Date().toUTCString());
      const datetime = date.toISOString().replace(/\..+/, '').replace(/-/g, '').replace(/:/g, '') + 'Z';
      return datetime;
    };

    this.credentialString = datetime => {
      return this.createScope(datetime.substr(0, 8), this.options.region, this.options.serviceName);
    };

    this.createScope = (date, region, serviceName) => {
      return [date.substr(0, 8), region, serviceName, v4Identifier].join('/');
    };

    this.getSigningKey = (credentials, date) => {
      const kDate = hmacSha256$1(credentials.GetSecretKey(), date);
      const kRegion = hmacSha256$1(kDate, this.options.region);
      const kService = hmacSha256$1(kRegion, this.options.serviceName);
      const signingKey = hmacSha256$1(kService, v4Identifier);
      return signingKey;
    };

    this.stringToSign = (datetime, opt) => {
      /* istanbul ignore if */
      if (!this.options.algorithm) {
        return '';
      }

      const parts = [];
      parts.push(this.options.algorithm);
      parts.push(datetime);
      parts.push(this.credentialString(datetime));
      const canonicalString = 'policy' in opt ? this.canonicalStringPolicy(opt) : this.canonicalString(opt); // console.log('canonicalString',this.canonicalString(opt),' code:',this.hexEncodedHash(this.canonicalString(opt)));

      parts.push(this.hexEncodedHash(canonicalString));
      return parts.join('\n');
    };

    this.hexEncodedHash = string => {
      return hashSha256$1(string, 'hex');
    };

    this.canonicalString = opt => {
      const parts = [];
      parts.push(opt.method);
      parts.push(opt.path);
      parts.push(this.getEncodePath(opt.query, false));
      parts.push(this.canonicalHeaders(opt) + '\n');
      parts.push(this.signedHeaders(opt));
      parts.push(this.hexEncodedBodyHash());
      return parts.join('\n');
    };

    this.canonicalStringPolicy = opt => {
      const parts = [];
      parts.push(this.getEncodePath(opt.query, false));
      parts.push(this.hexEncodedBodyHash());
      return parts.join('\n');
    };

    this.canonicalHeaders = opt => {
      const parts = [];
      const needSignHeaders = getNeedSignedHeaders(opt.headers);

      for (let key of needSignHeaders) {
        const value = opt.headers[key];
        key = key.toLowerCase();
        parts.push(key + ':' + this.canonicalHeaderValues(value.toString()));
      }

      return parts.join('\n');
    };

    this.canonicalHeaderValues = values => {
      return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
    };

    this.signedHeaders = opt => {
      const keys = [];
      const needSignHeaders = getNeedSignedHeaders(opt.headers);

      for (let key of needSignHeaders) {
        key = key.toLowerCase();
        keys.push(key);
      }

      return keys.sort().join(';');
    };

    this.options = _opt;
    this.credentials = _credentials;
  }
  /*
   * normal v4 signature
   * */


  /**
   * ! * ' () aren't transformed by encodeUrl, so they need be handled
   */
  getEncodePath(path, encodeAll = true) {
    if (!path) {
      return '';
    }

    let tmpPath = path;

    if (encodeAll) {
      tmpPath = path.replace(/%2F/g, '/');
    }

    tmpPath = tmpPath.replace(/\(/g, '%28');
    tmpPath = tmpPath.replace(/\)/g, '%29');
    tmpPath = tmpPath.replace(/!/g, '%21');
    tmpPath = tmpPath.replace(/\*/g, '%2A');
    tmpPath = tmpPath.replace(/\'/g, '%27');
    return tmpPath;
  }

}
class ISigV4Credentials {
  constructor(securityToken, secretAccessKey, accessKeyId) {
    this.securityToken = void 0;
    this.secretAccessKey = void 0;
    this.accessKeyId = void 0;
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.securityToken = securityToken;
  }

  GetAccessKey() {
    return this.accessKeyId;
  }

  GetSecretKey() {
    return this.secretAccessKey;
  }

}

function getNeedSignedHeaders(headers) {
  const needSignHeaders = [];
  Object.keys(headers || {}).forEach(key => {
    if (key === 'host' || key.startsWith('x-tos-')) {
      if (headers[key] != null) {
        needSignHeaders.push(key);
      }
    }
  });
  return needSignHeaders.sort();
}

class TosServerError extends Error {
  /**
   * is original from backend, equals `data.Code`
   */

  /**
   * the body when backend errors
   */

  /**
   * status code
   */

  /**
   * response headers
   */

  /**
   * identifies the errored request, equals to headers['x-tos-request-id'].
   * If you has any question about the request, please send the requestId and id2 to TOS worker.
   */

  /**
   * identifies the errored request, equals to headers['x-tos-id-2'].
   * If you has any question about the request, please send the requestId and id2 to TOS worker.
   */
  constructor(response) {
    const {
      data
    } = response;
    super(data.Message); // https://www.dannyguo.com/blog/how-to-fix-instanceof-not-working-for-custom-errors-in-typescript/

    this.code = void 0;
    this.data = void 0;
    this.statusCode = void 0;
    this.headers = void 0;
    this.requestId = void 0;
    this.id2 = void 0;
    Object.setPrototypeOf(this, TosServerError.prototype);
    this.data = data;
    this.code = data.Code;
    this.statusCode = response.status;
    this.headers = response.headers;
    this.requestId = response.headers['x-tos-request-id'];
    this.id2 = response.headers['x-tos-id-2'];
  }

}

(function (TosServerCode) {
  TosServerCode["NoSuchBucket"] = "NoSuchBucket";
  TosServerCode["NoSuchKey"] = "NoSuchKey";
  TosServerCode["AccessDenied"] = "AccessDenied";
  TosServerCode["MalformedAcl"] = "MalformedAclError";
  TosServerCode["UnexpectedContent"] = "UnexpectedContent";
  TosServerCode["InvalidRequest"] = "InvalidRequest";
  TosServerCode["MissingSecurityHeader"] = "MissingSecurityHeader";
  TosServerCode["InvalidArgument"] = "InvalidArgument";
  TosServerCode["EntityTooSmall"] = "EntityTooSmall";
  TosServerCode["InvalidBucketName"] = "InvalidBucketName";
  TosServerCode["BucketNotEmpty"] = "BucketNotEmpty";
  TosServerCode["TooManyBuckets"] = "TooManyBuckets";
  TosServerCode["BucketAlreadyExists"] = "BucketAlreadyExists";
  TosServerCode["MalformedBody"] = "MalformedBody";
  TosServerCode["NoSuchLifecycleConfiguration"] = "NoSuchLifecycleConfiguration";
  TosServerCode["ReplicationConfigurationNotFound"] = "ReplicationConfigurationNotFoundError";
  TosServerCode["InvalidLocationConstraint"] = "InvalidLocationConstraint";
  TosServerCode["AuthorizationQueryParametersError"] = "AuthorizationQueryParametersError";
  TosServerCode["RequestTimeTooSkewed"] = "RequestTimeTooSkewed";
  TosServerCode["SignatureDoesNotMatch"] = "SignatureDoesNotMatch";
  TosServerCode["RequestedRangeNotSatisfiable"] = "Requested Range Not Satisfiable";
  TosServerCode["PreconditionFailed"] = "PreconditionFailed";
  TosServerCode["BadDigest"] = "BadDigest";
  TosServerCode["InvalidDigest"] = "InvalidDigest";
  TosServerCode["EntityTooLarge"] = "EntityTooLarge";
  TosServerCode["UnImplemented"] = "UnImplemented";
  TosServerCode["MethodNotAllowed"] = "MethodNotAllowed";
  TosServerCode["InvalidAccessKeyId"] = "InvalidAccessKeyId";
  TosServerCode["InvalidSecurityToken"] = "InvalidSecurityToken";
  TosServerCode["ContentSHA256Mismatch"] = "ContentSHA256Mismatch";
  TosServerCode["ExceedQPSLimit"] = "ExceedQPSLimit";
  TosServerCode["ExceedRateLimit"] = "ExceedRateLimit";
  TosServerCode["NoSuchCORSConfiguration"] = "NoSuchCORSConfiguration";
  TosServerCode["NoSuchMirrorConfiguration"] = "NoSuchMirrorConfiguration";
  TosServerCode["NoSuchWebsiteConfiguration"] = "NoSuchWebsiteConfiguration";
  TosServerCode["MissingRequestBody"] = "MissingRequestBodyError";
  TosServerCode["BucketAlreadyOwnedByYou"] = "BucketAlreadyOwnedByYou";
  TosServerCode["NoSuchBucketPolicy"] = "NoSuchBucketPolicy";
  TosServerCode["PolicyTooLarge"] = "PolicyTooLarge";
  TosServerCode["MalformedPolicy"] = "MalformedPolicy";
  TosServerCode["InvalidKey"] = "InvalidKey";
  TosServerCode["MirrorFailed"] = "MirrorFailed";
  TosServerCode["Timeout"] = "Timeout";
  TosServerCode["OffsetNotMatched"] = "OffsetNotMatched";
  TosServerCode["NotAppendable"] = "NotAppendable";
  TosServerCode["ContextCanceled"] = "ContextCanceled";
  TosServerCode["InternalError"] = "InternalError";
  TosServerCode["TooManyRequests"] = "TooManyRequests";
  TosServerCode["TimeOut"] = "TimeOut";
  TosServerCode["ConcurrencyUpdateObjectLimit"] = "ConcurrencyUpdateObjectLimit";
  TosServerCode["DuplicateUpload"] = "DuplicateUpload";
  TosServerCode["DuplicateObject"] = "DuplicateObject";
  TosServerCode["InvalidVersionId"] = "InvalidVersionId";
  TosServerCode["StorageClassNotMatch"] = "StorageClassNotMatch";
  TosServerCode["UploadStatusNotUploading"] = "UploadStatusNotUploading";
  TosServerCode["PartSizeNotMatch"] = "PartSizeNotMatch";
  TosServerCode["NoUploadPart"] = "NoUploadPart";
  TosServerCode["PartsLenInvalid"] = "PartsLenInvalid";
  TosServerCode["PartsIdxSmall"] = "PartsIdxSmall";
  TosServerCode["PartSizeSmall"] = "PartSizeSmall";
  TosServerCode["PrefixNotNextKeyPrefix"] = "PrefixNotNextKeyPrefix";
  TosServerCode["InvalidPart"] = "InvalidPart";
  TosServerCode["InvalidPartOffset"] = "InvalidPartOffset";
  TosServerCode["MismatchObject"] = "MismatchObject";
  TosServerCode["UploadStatusMismatch"] = "UploadStatusMismatch";
  TosServerCode["CompletingStatusNoExpiration"] = "CompletingStatusNoExpiration";
  TosServerCode["Found"] = "Found";
  TosServerCode["InvalidRedirectLocation"] = "InvalidRedirectLocation";
})(exports.TosServerCode || (exports.TosServerCode = {}));

// auto generated by scripts/build.js
var version = '2.7.3';

function TosAgent(opts) {
  const {
    tosOpts,
    ...agentOpts
  } = opts;
  const Agent = tosOpts.isHttps ? https.Agent : http.Agent;
  const agent = new Agent({ ...agentOpts,
    keepAlive: true,
    rejectUnauthorized: tosOpts.enableVerifySSL,
    timeout: tosOpts.idleConnectionTime
  });
  agent.maxFreeSockets = Infinity;
  agent.maxTotalSockets = tosOpts.maxConnections;
  const oriCreateConnection = agent.createConnection;

  agent.createConnection = function (...args) {
    const socket = oriCreateConnection.call(this, ...args);
    let isTimeout = false;
    let isConnected = false;
    let connectTimer = null; // Place `setTimeout` in `process.nextTick` to avoid to
    // trigger "Connect timeout" when debug

    process.nextTick(() => {
      if (isConnected) {
        return;
      }

      connectTimer = setTimeout(() => {
        isTimeout = true;
      }, tosOpts.connectionTimeout);
    });
    socket.on('connect', () => {
      isConnected = true;

      if (connectTimer) {
        clearTimeout(connectTimer);
      }

      if (isTimeout) {
        socket.destroy(new Error('Connect timeout'));
      }
    });
    return socket;
  };

  return agent;
}

// alias with GoSDK
// refer https://github.com/volcengine/ve-tos-golang-sdk/blob/main/tos/mime.go
const mimeTypes = {
  '3gp': 'video/3gpp',
  '7z': 'application/x-7z-compressed',
  abw: 'application/x-abiword',
  ai: 'application/postscript',
  aif: 'audio/x-aiff',
  aifc: 'audio/x-aiff',
  aiff: 'audio/x-aiff',
  alc: 'chemical/x-alchemy',
  amr: 'audio/amr',
  anx: 'application/annodex',
  apk: 'application/vnd.android.package-archive',
  appcache: 'text/cache-manifest',
  art: 'image/x-jg',
  asc: 'text/plain',
  asf: 'video/x-ms-asf',
  aso: 'chemical/x-ncbi-asn1-binary',
  asx: 'video/x-ms-asf',
  atom: 'application/atom+xml',
  atomcat: 'application/atomcat+xml',
  atomsrv: 'application/atomserv+xml',
  au: 'audio/basic',
  avi: 'video/x-msvideo',
  awb: 'audio/amr-wb',
  axa: 'audio/annodex',
  axv: 'video/annodex',
  b: 'chemical/x-molconn-Z',
  bak: 'application/x-trash',
  bat: 'application/x-msdos-program',
  bcpio: 'application/x-bcpio',
  bib: 'text/x-bibtex',
  bin: 'application/octet-stream',
  bmp: 'image/x-ms-bmp',
  boo: 'text/x-boo',
  book: 'application/x-maker',
  brf: 'text/plain',
  bsd: 'chemical/x-crossfire',
  c: 'text/x-csrc',
  'c++': 'text/x-c++src',
  c3d: 'chemical/x-chem3d',
  cab: 'application/x-cab',
  cac: 'chemical/x-cache',
  cache: 'chemical/x-cache',
  cap: 'application/vnd.tcpdump.pcap',
  cascii: 'chemical/x-cactvs-binary',
  cat: 'application/vnd.ms-pki.seccat',
  cbin: 'chemical/x-cactvs-binary',
  cbr: 'application/x-cbr',
  cbz: 'application/x-cbz',
  cc: 'text/x-c++src',
  cda: 'application/x-cdf',
  cdf: 'application/x-cdf',
  cdr: 'image/x-coreldraw',
  cdt: 'image/x-coreldrawtemplate',
  cdx: 'chemical/x-cdx',
  cdy: 'application/vnd.cinderella',
  cef: 'chemical/x-cxf',
  cer: 'chemical/x-cerius',
  chm: 'chemical/x-chemdraw',
  chrt: 'application/x-kchart',
  cif: 'chemical/x-cif',
  class: 'application/java-vm',
  cls: 'text/x-tex',
  cmdf: 'chemical/x-cmdf',
  cml: 'chemical/x-cml',
  cod: 'application/vnd.rim.cod',
  com: 'application/x-msdos-program',
  cpa: 'chemical/x-compass',
  cpio: 'application/x-cpio',
  cpp: 'text/x-c++src',
  cpt: 'application/mac-compactpro',
  cr2: 'image/x-canon-cr2',
  crl: 'application/x-pkcs7-crl',
  crt: 'application/x-x509-ca-cert',
  crw: 'image/x-canon-crw',
  csd: 'audio/csound',
  csf: 'chemical/x-cache-csf',
  csh: 'application/x-csh',
  csm: 'chemical/x-csml',
  csml: 'chemical/x-csml',
  css: 'text/css',
  csv: 'text/csv',
  ctab: 'chemical/x-cactvs-binary',
  ctx: 'chemical/x-ctx',
  cu: 'application/cu-seeme',
  cub: 'chemical/x-gaussian-cube',
  cxf: 'chemical/x-cxf',
  cxx: 'text/x-c++src',
  d: 'text/x-dsrc',
  davmount: 'application/davmount+xml',
  dcm: 'application/dicom',
  dcr: 'application/x-director',
  ddeb: 'application/vnd.debian.binary-package',
  dif: 'video/dv',
  diff: 'text/x-diff',
  dir: 'application/x-director',
  djv: 'image/vnd.djvu',
  djvu: 'image/vnd.djvu',
  dl: 'video/dl',
  dll: 'application/x-msdos-program',
  dmg: 'application/x-apple-diskimage',
  dms: 'application/x-dms',
  doc: 'application/msword',
  docm: 'application/vnd.ms-word.document.macroEnabled.12',
  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  dot: 'application/msword',
  dotm: 'application/vnd.ms-word.template.macroEnabled.12',
  dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
  dv: 'video/dv',
  dvi: 'application/x-dvi',
  dx: 'chemical/x-jcamp-dx',
  dxr: 'application/x-director',
  emb: 'chemical/x-embl-dl-nucleotide',
  embl: 'chemical/x-embl-dl-nucleotide',
  eml: 'message/rfc822',
  eot: 'application/vnd.ms-fontobject',
  eps: 'application/postscript',
  eps2: 'application/postscript',
  eps3: 'application/postscript',
  epsf: 'application/postscript',
  epsi: 'application/postscript',
  erf: 'image/x-epson-erf',
  es: 'application/ecmascript',
  etx: 'text/x-setext',
  exe: 'application/x-msdos-program',
  ez: 'application/andrew-inset',
  fb: 'application/x-maker',
  fbdoc: 'application/x-maker',
  fch: 'chemical/x-gaussian-checkpoint',
  fchk: 'chemical/x-gaussian-checkpoint',
  fig: 'application/x-xfig',
  flac: 'audio/flac',
  fli: 'video/fli',
  flv: 'video/x-flv',
  fm: 'application/x-maker',
  frame: 'application/x-maker',
  frm: 'application/x-maker',
  gal: 'chemical/x-gaussian-log',
  gam: 'chemical/x-gamess-input',
  gamin: 'chemical/x-gamess-input',
  gan: 'application/x-ganttproject',
  gau: 'chemical/x-gaussian-input',
  gcd: 'text/x-pcs-gcd',
  gcf: 'application/x-graphing-calculator',
  gcg: 'chemical/x-gcg8-sequence',
  gen: 'chemical/x-genbank',
  gf: 'application/x-tex-gf',
  gif: 'image/gif',
  gjc: 'chemical/x-gaussian-input',
  gjf: 'chemical/x-gaussian-input',
  gl: 'video/gl',
  gnumeric: 'application/x-gnumeric',
  gpt: 'chemical/x-mopac-graph',
  gsf: 'application/x-font',
  gsm: 'audio/x-gsm',
  gtar: 'application/x-gtar',
  gz: 'application/gzip',
  h: 'text/x-chdr',
  'h++': 'text/x-c++hdr',
  hdf: 'application/x-hdf',
  hh: 'text/x-c++hdr',
  hin: 'chemical/x-hin',
  hpp: 'text/x-c++hdr',
  hqx: 'application/mac-binhex40',
  hs: 'text/x-haskell',
  hta: 'application/hta',
  htc: 'text/x-component',
  htm: 'text/html',
  html: 'text/html',
  hwp: 'application/x-hwp',
  hxx: 'text/x-c++hdr',
  ica: 'application/x-ica',
  ice: 'x-conference/x-cooltalk',
  ico: 'image/vnd.microsoft.icon',
  ics: 'text/calendar',
  icz: 'text/calendar',
  ief: 'image/ief',
  iges: 'model/iges',
  igs: 'model/iges',
  iii: 'application/x-iphone',
  info: 'application/x-info',
  inp: 'chemical/x-gamess-input',
  ins: 'application/x-internet-signup',
  iso: 'application/x-iso9660-image',
  isp: 'application/x-internet-signup',
  ist: 'chemical/x-isostar',
  istr: 'chemical/x-isostar',
  jad: 'text/vnd.sun.j2me.app-descriptor',
  jam: 'application/x-jam',
  jar: 'application/java-archive',
  java: 'text/x-java',
  jdx: 'chemical/x-jcamp-dx',
  jmz: 'application/x-jmol',
  jng: 'image/x-jng',
  jnlp: 'application/x-java-jnlp-file',
  jp2: 'image/jp2',
  jpe: 'image/jpeg',
  jpeg: 'image/jpeg',
  jpf: 'image/jpx',
  jpg: 'image/jpeg',
  jpg2: 'image/jp2',
  jpm: 'image/jpm',
  jpx: 'image/jpx',
  js: 'application/javascript',
  json: 'application/json',
  kar: 'audio/midi',
  key: 'application/pgp-keys',
  kil: 'application/x-killustrator',
  kin: 'chemical/x-kinemage',
  kml: 'application/vnd.google-earth.kml+xml',
  kmz: 'application/vnd.google-earth.kmz',
  kpr: 'application/x-kpresenter',
  kpt: 'application/x-kpresenter',
  ksp: 'application/x-kspread',
  kwd: 'application/x-kword',
  kwt: 'application/x-kword',
  latex: 'application/x-latex',
  lha: 'application/x-lha',
  lhs: 'text/x-literate-haskell',
  lin: 'application/bbolin',
  lsf: 'video/x-la-asf',
  lsx: 'video/x-la-asf',
  ltx: 'text/x-tex',
  ly: 'text/x-lilypond',
  lyx: 'application/x-lyx',
  lzh: 'application/x-lzh',
  lzx: 'application/x-lzx',
  m3g: 'application/m3g',
  m3u: 'audio/x-mpegurl',
  m3u8: 'application/x-mpegURL',
  m4a: 'audio/mpeg',
  maker: 'application/x-maker',
  man: 'application/x-troff-man',
  mbox: 'application/mbox',
  mcif: 'chemical/x-mmcif',
  mcm: 'chemical/x-macmolecule',
  mdb: 'application/msaccess',
  me: 'application/x-troff-me',
  mesh: 'model/mesh',
  mid: 'audio/midi',
  midi: 'audio/midi',
  mif: 'application/x-mif',
  mkv: 'video/x-matroska',
  mm: 'application/x-freemind',
  mmd: 'chemical/x-macromodel-input',
  mmf: 'application/vnd.smaf',
  mml: 'text/mathml',
  mmod: 'chemical/x-macromodel-input',
  mng: 'video/x-mng',
  moc: 'text/x-moc',
  mol: 'chemical/x-mdl-molfile',
  mol2: 'chemical/x-mol2',
  moo: 'chemical/x-mopac-out',
  mop: 'chemical/x-mopac-input',
  mopcrt: 'chemical/x-mopac-input',
  mov: 'video/quicktime',
  movie: 'video/x-sgi-movie',
  mp2: 'audio/mpeg',
  mp3: 'audio/mpeg',
  mp4: 'video/mp4',
  mpc: 'chemical/x-mopac-input',
  mpe: 'video/mpeg',
  mpeg: 'video/mpeg',
  mpega: 'audio/mpeg',
  mpg: 'video/mpeg',
  mpga: 'audio/mpeg',
  mph: 'application/x-comsol',
  mpv: 'video/x-matroska',
  ms: 'application/x-troff-ms',
  msh: 'model/mesh',
  msi: 'application/x-msi',
  mvb: 'chemical/x-mopac-vib',
  mxf: 'application/mxf',
  mxu: 'video/vnd.mpegurl',
  nb: 'application/mathematica',
  nbp: 'application/mathematica',
  nc: 'application/x-netcdf',
  nef: 'image/x-nikon-nef',
  nwc: 'application/x-nwc',
  o: 'application/x-object',
  oda: 'application/oda',
  odb: 'application/vnd.oasis.opendocument.database',
  odc: 'application/vnd.oasis.opendocument.chart',
  odf: 'application/vnd.oasis.opendocument.formula',
  odg: 'application/vnd.oasis.opendocument.graphics',
  odi: 'application/vnd.oasis.opendocument.image',
  odm: 'application/vnd.oasis.opendocument.text-master',
  odp: 'application/vnd.oasis.opendocument.presentation',
  ods: 'application/vnd.oasis.opendocument.spreadsheet',
  odt: 'application/vnd.oasis.opendocument.text',
  oga: 'audio/ogg',
  ogg: 'audio/ogg',
  ogv: 'video/ogg',
  ogx: 'application/ogg',
  old: 'application/x-trash',
  one: 'application/onenote',
  onepkg: 'application/onenote',
  onetmp: 'application/onenote',
  onetoc2: 'application/onenote',
  opf: 'application/oebps-package+xml',
  opus: 'audio/ogg',
  orc: 'audio/csound',
  orf: 'image/x-olympus-orf',
  otf: 'application/font-sfnt',
  otg: 'application/vnd.oasis.opendocument.graphics-template',
  oth: 'application/vnd.oasis.opendocument.text-web',
  otp: 'application/vnd.oasis.opendocument.presentation-template',
  ots: 'application/vnd.oasis.opendocument.spreadsheet-template',
  ott: 'application/vnd.oasis.opendocument.text-template',
  oza: 'application/x-oz-application',
  p: 'text/x-pascal',
  p7r: 'application/x-pkcs7-certreqresp',
  pac: 'application/x-ns-proxy-autoconfig',
  pas: 'text/x-pascal',
  pat: 'image/x-coreldrawpattern',
  patch: 'text/x-diff',
  pbm: 'image/x-portable-bitmap',
  pcap: 'application/vnd.tcpdump.pcap',
  pcf: 'application/x-font-pcf',
  'pcf.Z': 'application/x-font-pcf',
  pcx: 'image/pcx',
  pdb: 'chemical/x-pdb',
  pdf: 'application/pdf',
  pfa: 'application/x-font',
  pfb: 'application/x-font',
  pfr: 'application/font-tdpfr',
  pgm: 'image/x-portable-graymap',
  pgn: 'application/x-chess-pgn',
  pgp: 'application/pgp-encrypted',
  php: '#application/x-httpd-php',
  php3: '#application/x-httpd-php3',
  php3p: '#application/x-httpd-php3-preprocessed',
  php4: '#application/x-httpd-php4',
  php5: '#application/x-httpd-php5',
  phps: '#application/x-httpd-php-source',
  pht: '#application/x-httpd-php',
  phtml: '#application/x-httpd-php',
  pk: 'application/x-tex-pk',
  pl: 'text/x-perl',
  pls: 'audio/x-scpls',
  pm: 'text/x-perl',
  png: 'image/png',
  pnm: 'image/x-portable-anymap',
  pot: 'text/plain',
  potm: 'application/vnd.ms-powerpoint.template.macroEnabled.12',
  potx: 'application/vnd.openxmlformats-officedocument.presentationml.template',
  ppam: 'application/vnd.ms-powerpoint.addin.macroEnabled.12',
  ppm: 'image/x-portable-pixmap',
  pps: 'application/vnd.ms-powerpoint',
  ppsm: 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',
  ppsx: 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
  ppt: 'application/vnd.ms-powerpoint',
  pptm: 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',
  pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
  prf: 'application/pics-rules',
  prt: 'chemical/x-ncbi-asn1-ascii',
  ps: 'application/postscript',
  psd: 'image/x-photoshop',
  py: 'text/x-python',
  pyc: 'application/x-python-code',
  pyo: 'application/x-python-code',
  qgs: 'application/x-qgis',
  qt: 'video/quicktime',
  qtl: 'application/x-quicktimeplayer',
  ra: 'audio/x-pn-realaudio',
  ram: 'audio/x-pn-realaudio',
  rar: 'application/rar',
  ras: 'image/x-cmu-raster',
  rb: 'application/x-ruby',
  rd: 'chemical/x-mdl-rdfile',
  rdf: 'application/rdf+xml',
  rdp: 'application/x-rdp',
  rgb: 'image/x-rgb',
  rhtml: '#application/x-httpd-eruby',
  rm: 'audio/x-pn-realaudio',
  roff: 'application/x-troff',
  ros: 'chemical/x-rosdal',
  rpm: 'application/x-redhat-package-manager',
  rss: 'application/x-rss+xml',
  rtf: 'application/rtf',
  rtx: 'text/richtext',
  rxn: 'chemical/x-mdl-rxnfile',
  scala: 'text/x-scala',
  sce: 'application/x-scilab',
  sci: 'application/x-scilab',
  sco: 'audio/csound',
  scr: 'application/x-silverlight',
  sct: 'text/scriptlet',
  sd: 'chemical/x-mdl-sdfile',
  sd2: 'audio/x-sd2',
  sda: 'application/vnd.stardivision.draw',
  sdc: 'application/vnd.stardivision.calc',
  sdd: 'application/vnd.stardivision.impress',
  sds: 'application/vnd.stardivision.chart',
  sdw: 'application/vnd.stardivision.writer',
  ser: 'application/java-serialized-object',
  sfd: 'application/vnd.font-fontforge-sfd',
  sfv: 'text/x-sfv',
  sgf: 'application/x-go-sgf',
  sgl: 'application/vnd.stardivision.writer-global',
  sh: 'application/x-sh',
  shar: 'application/x-shar',
  shp: 'application/x-qgis',
  shtml: 'text/html',
  shx: 'application/x-qgis',
  sid: 'audio/prs.sid',
  sig: 'application/pgp-signature',
  sik: 'application/x-trash',
  silo: 'model/mesh',
  sis: 'application/vnd.symbian.install',
  sisx: 'x-epoc/x-sisx-app',
  sit: 'application/x-stuffit',
  sitx: 'application/x-stuffit',
  skd: 'application/x-koan',
  skm: 'application/x-koan',
  skp: 'application/x-koan',
  skt: 'application/x-koan',
  sldm: 'application/vnd.ms-powerpoint.slide.macroEnabled.12',
  sldx: 'application/vnd.openxmlformats-officedocument.presentationml.slide',
  smi: 'application/smil+xml',
  smil: 'application/smil+xml',
  snd: 'audio/basic',
  spc: 'chemical/x-galactic-spc',
  spl: 'application/x-futuresplash',
  spx: 'audio/ogg',
  sql: 'application/x-sql',
  src: 'application/x-wais-source',
  srt: 'text/plain',
  stc: 'application/vnd.sun.xml.calc.template',
  std: 'application/vnd.sun.xml.draw.template',
  sti: 'application/vnd.sun.xml.impress.template',
  stw: 'application/vnd.sun.xml.writer.template',
  sty: 'text/x-tex',
  sv4cpio: 'application/x-sv4cpio',
  sv4crc: 'application/x-sv4crc',
  svg: 'image/svg+xml',
  svgz: 'image/svg+xml',
  sw: 'chemical/x-swissprot',
  swf: 'application/x-shockwave-flash',
  swfl: 'application/x-shockwave-flash',
  sxc: 'application/vnd.sun.xml.calc',
  sxd: 'application/vnd.sun.xml.draw',
  sxg: 'application/vnd.sun.xml.writer.global',
  sxi: 'application/vnd.sun.xml.impress',
  sxm: 'application/vnd.sun.xml.math',
  sxw: 'application/vnd.sun.xml.writer',
  t: 'application/x-troff',
  tar: 'application/x-tar',
  taz: 'application/x-gtar-compressed',
  tcl: 'application/x-tcl',
  tex: 'text/x-tex',
  texi: 'application/x-texinfo',
  texinfo: 'application/x-texinfo',
  text: 'text/plain',
  tgf: 'chemical/x-mdl-tgf',
  tgz: 'application/x-gtar-compressed',
  thmx: 'application/vnd.ms-officetheme',
  tif: 'image/tiff',
  tiff: 'image/tiff',
  tk: 'text/x-tcl',
  tm: 'text/texmacs',
  torrent: 'application/x-bittorrent',
  tr: 'application/x-troff',
  ts: 'video/MP2T',
  tsp: 'application/dsptype',
  tsv: 'text/tab-separated-values',
  ttf: 'application/font-sfnt',
  ttl: 'text/turtle',
  txt: 'text/plain',
  uls: 'text/iuls',
  ustar: 'application/x-ustar',
  val: 'chemical/x-ncbi-asn1-binary',
  vcard: 'text/vcard',
  vcd: 'application/x-cdlink',
  vcf: 'text/vcard',
  vcs: 'text/x-vcalendar',
  vmd: 'chemical/x-vmd',
  vms: 'chemical/x-vamas-iso14976',
  vrm: 'x-world/x-vrml',
  vrml: 'model/vrml',
  vsd: 'application/vnd.visio',
  vss: 'application/vnd.visio',
  vst: 'application/vnd.visio',
  vsw: 'application/vnd.visio',
  wad: 'application/x-doom',
  wasm: 'application/wasm',
  wav: 'audio/wav',
  wax: 'audio/x-ms-wax',
  wbmp: 'image/vnd.wap.wbmp',
  wbxml: 'application/vnd.wap.wbxml',
  webm: 'video/webm',
  wk: 'application/x-123',
  wm: 'video/x-ms-wm',
  wma: 'audio/x-ms-wma',
  wmd: 'application/x-ms-wmd',
  wml: 'text/vnd.wap.wml',
  wmlc: 'application/vnd.wap.wmlc',
  wmls: 'text/vnd.wap.wmlscript',
  wmlsc: 'application/vnd.wap.wmlscriptc',
  wmv: 'video/x-ms-wmv',
  wmx: 'video/x-ms-wmx',
  wmz: 'application/x-ms-wmz',
  woff: 'application/font-woff',
  wp5: 'application/vnd.wordperfect5.1',
  wpd: 'application/vnd.wordperfect',
  wrl: 'model/vrml',
  wsc: 'text/scriptlet',
  wvx: 'video/x-ms-wvx',
  wz: 'application/x-wingz',
  x3d: 'model/x3d+xml',
  x3db: 'model/x3d+binary',
  x3dv: 'model/x3d+vrml',
  xbm: 'image/x-xbitmap',
  xcf: 'application/x-xcf',
  xcos: 'application/x-scilab-xcos',
  xht: 'application/xhtml+xml',
  xhtml: 'application/xhtml+xml',
  xlam: 'application/vnd.ms-excel.addin.macroEnabled.12',
  xlb: 'application/vnd.ms-excel',
  xls: 'application/vnd.ms-excel',
  xlsb: 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',
  xlsm: 'application/vnd.ms-excel.sheet.macroEnabled.12',
  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  xlt: 'application/vnd.ms-excel',
  xltm: 'application/vnd.ms-excel.template.macroEnabled.12',
  xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
  xml: 'application/xml',
  xpi: 'application/x-xpinstall',
  xpm: 'image/x-xpixmap',
  xsd: 'application/xml',
  xsl: 'application/xslt+xml',
  xslt: 'application/xslt+xml',
  xspf: 'application/xspf+xml',
  xtel: 'chemical/x-xtel',
  xul: 'application/vnd.mozilla.xul+xml',
  xwd: 'image/x-xwindowdump',
  xyz: 'chemical/x-xyz',
  xz: 'application/x-xz',
  zip: 'application/zip'
};

function createReadNCbTransformer(readCb) {
  return new stream.Transform({
    async transform(chunk, _encoding, callback) {
      const chunkSize = chunk.length;
      readCb(chunkSize);
      this.push(chunk);
      callback();
    }

  });
}

function createReadNReadStream(stream, readCb) {
  const readCbTransformer = createReadNCbTransformer(readCb);
  stream.on('error', err => {
    console.log('stream', stream);
    readCbTransformer.destroy(err);
  });
  return stream.pipe(readCbTransformer);
  /**
   * Don't use the below code.
   *
   * 1. The readable stream will be flowing mode after adding a 'data' event listener to it.
   * 2. The stream will be paused after calling `pause()` method.
   * 3. The stream will not change to flowing mode when adding a 'data' event listener to it.
   */
  // stream.on('data', (d) => {
  //   readCb(d.length);
  // });
  // stream.pause();
}

class CRC {
  constructor() {
    this.value = '0';
  }

  reset() {
    this.value = '0';
  }

  async updateBlob() {
    throw new TosClientError('Not implemented in node.js environment.');
  }

  update(value) {
    this.value = tosCrc64Js.crc64(value, this.value);
    return this.value;
  }

  getCrc64() {
    return this.value;
  }

}

var nodejsCRC = {
  __proto__: null,
  CRC: CRC,
  combineCrc64: tosCrc64Js.combineCrc64
};

let crcModule = null;

{
  crcModule = nodejsCRC;
}

const {
  CRC: CRC$1,
  combineCrc64
} = crcModule;

const minRate = 1024;
const minCapacity = 10 * 1024;
/**
 *
 * @param capacity  minValue 10KB. unit byte
 * @param rate   minValue 1KB. unit byte/s
 * @returns
 */

function createDefaultRateLimiter(capacity, rate) {
  const realCapacity = Math.max(minCapacity, capacity);
  const realRate = Math.max(minRate, rate);
  const d = {
    rate: realRate,
    capacity: realCapacity,
    currentAmount: realCapacity,
    lastConsumeTime: Date.now()
  };
  return {
    Acquire: async want => {
      if (want > d.capacity) {
        want = d.capacity;
      }

      const now = Date.now();
      const increment = Math.floor((now - d.lastConsumeTime) / 1000 * d.rate);

      if (increment + d.currentAmount > d.capacity) {
        d.currentAmount = d.capacity;
      } else {
        d.currentAmount += increment;
      }

      if (want > d.currentAmount) {
        const timeToWaitSec = (want - d.currentAmount) / d.rate;
        return {
          ok: false,
          timeToWait: Math.ceil(timeToWaitSec * 1000)
        };
      }

      d.lastConsumeTime = now;
      d.currentAmount = d.currentAmount - want;
      return {
        ok: true,
        timeToWait: 0
      };
    }
  };
}

function createRateLimiterTransform(rateLimiter) {
  return new stream.Transform({
    async transform(chunk, _encoding, callback) {
      try {
        const chunkSize = chunk.length;
        let finished = false;

        while (!finished) {
          const {
            ok,
            timeToWait
          } = await rateLimiter.Acquire(chunkSize);

          if (!ok) {
            await wait(timeToWait);
          }

          finished = ok;
        }

        this.push(chunk);
        callback();
      } catch (error) {
        callback(error);
      }
    }

  });
}

function createRateLimiterStream(stream, rateLimiter) {
  const pipeRateLimit = createRateLimiterTransform(rateLimiter);
  stream.on('error', err => {
    pipeRateLimit.destroy(err);
  });
  return stream.pipe(pipeRateLimit);
}
function wait(milliseconds) {
  return new Promise(r => {
    setTimeout(() => r(''), milliseconds);
  });
}

class Buffer2Stream extends stream.Readable {
  constructor(buf) {
    super();
    this.buf = void 0;
    this.lastPos = 0;
    this.buf = buf;
  }

  _read(n) {
    const totalSize = this.buf.length;
    let actualN = Math.min(n, totalSize - this.lastPos);

    if (this.lastPos >= totalSize) {
      this.push(null);
      return;
    }

    this.push(this.buf.slice(this.lastPos, this.lastPos + actualN));
    this.lastPos += actualN;
  }

}

function createReadCbTransformer(readCb) {
  return new stream.Transform({
    async transform(chunk, _encoding, callback) {
      readCb(chunk);
      this.push(chunk);
      callback();
    }

  });
}

function createCrcReadStream(stream, crc) {
  const readCbTransformer = createReadCbTransformer(chunk => crc.update(chunk));
  stream.on('error', err => {
    readCbTransformer.destroy(err);
  });
  return stream.pipe(readCbTransformer);
}

var TosHeader;

(function (TosHeader) {
  TosHeader["HeaderRestore"] = "x-tos-restore";
  TosHeader["HeaderRestoreExpiryDays"] = "x-tos-restore-expiry-days";
  TosHeader["HeaderRestoreRequestDate"] = "x-tos-restore-request-date";
  TosHeader["HeaderRestoreTier"] = "x-tos-restore-tier";
  TosHeader["HeaderProjectName"] = "x-tos-project-name";
  TosHeader["HeaderReplicationStatus"] = "x-tos-replication-status";
})(TosHeader || (TosHeader = {}));

const RestoreOngoingRequestTrueStr = 'ongoing-request="true"';

const getObjectInputKey = input => {
  return typeof input === 'string' ? input : input.key;
};
const DEFAULT_CONTENT_TYPE = 'application/octet-stream';
function lookupMimeType(key) {
  const lastDotIndex = key.lastIndexOf('.');

  if (lastDotIndex <= 0) {
    return undefined;
  }

  const extName = key.slice(lastDotIndex + 1).toLowerCase();
  return mimeTypes[extName];
} // for all object methods

function validateObjectName(input) {
  const key = typeof input === 'string' ? input : input.key;

  if (key.length < 1) {
    throw new TosClientError('invalid object name, the length must be greater than 1');
  }
}
function getSize(body, headers) {
  if (isBuffer(body)) {
    return body.length;
  }

  if (isBlob(body)) {
    return body.size;
  }

  if (headers && headers['content-length']) {
    const v = +headers['content-length'];

    if (v >= 0) {
      return v;
    }
  }

  return null;
}
function getEmitReadBodyConfig({
  body,
  dataTransferCallback,
  makeRetryStream,
  rateLimiter
}) {
  let newBody = body;

  const getDefaultRet = () => ({
    body: newBody,
    makeRetryStream: undefined
  });

  if (isBuffer(newBody)) {
    const bodyBuf = newBody;

    makeRetryStream = () => new Buffer2Stream(bodyBuf);

    newBody = new Buffer2Stream(bodyBuf);
  }

  if (isReadable(newBody)) {
    if (rateLimiter && isValidRateLimiter(rateLimiter)) {
      newBody = createRateLimiterStream(newBody, rateLimiter);
    }

    newBody = createReadNReadStream(newBody, dataTransferCallback);

    if (makeRetryStream) {
      const oriMakeRetryStream = makeRetryStream;
      return {
        body: newBody,
        makeRetryStream: () => {
          let stream = oriMakeRetryStream();

          if (!stream) {
            return stream;
          }

          if (rateLimiter && isValidRateLimiter(rateLimiter)) {
            stream = createRateLimiterStream(stream, rateLimiter);
          }

          stream = createReadNReadStream(stream, dataTransferCallback);
          return stream;
        }
      };
    }
  }

  return getDefaultRet();
}
async function getCRCBodyConfig({
  body,
  beforeRetry,
  makeRetryStream,
  enableCRC
}) {
  if ( !enableCRC) {
    return {
      body,
      beforeRetry,
      makeRetryStream
    };
  }

  let newBody = body;
  const crc = new CRC$1();

  if (isReadable(body)) {
    newBody = createCrcReadStream(body, crc);

    if (makeRetryStream) {
      const oriMakeRetryStream = makeRetryStream;

      makeRetryStream = () => {
        const stream = oriMakeRetryStream();

        if (!stream) {
          return stream;
        }

        return createCrcReadStream(stream, crc);
      };
    }
  }

  return {
    body: newBody,
    beforeRetry: () => {
      crc.reset();
      beforeRetry == null ? void 0 : beforeRetry();
    },
    makeRetryStream,
    crc
  };
}
async function getNewBodyConfig(input) {
  const config1 = getEmitReadBodyConfig(input);
  input = { ...input,
    ...config1
  };
  const config2 = getCRCBodyConfig(input);
  return config2;
}
function getCopySourceHeaderValue(srcBucket, srcKey) {
  return `/${srcBucket}/${encodeURIComponent(srcKey)}`;
}
function isValidRateLimiter(rateLimiter) {
  if (!(rateLimiter != null && rateLimiter.Acquire) || !((rateLimiter == null ? void 0 : rateLimiter.Acquire) instanceof Function)) {
    throw new TosClientError(`The rateLimiter is not valid function`);
  }

  return true;
}
function validateCheckpoint(cp) {
  if ( typeof cp === 'object') {
    console.warn(`The \`checkpoint\` parameter should be passed as a string in node.js environment, representing a file or directory.` + `Passing a checkpoint object to it will be removed in the future.`);
  }
}
const getRestoreInfoFromHeaders = headers => {
  if (!headers) return;
  const headerStoreValue = headers == null ? void 0 : headers[TosHeader.HeaderRestore];

  if (headerStoreValue) {
    var _split$1$split$, _split$, _split$$split;

    /**
     * value example:
     * X-Tos-Restore: ongoing-request="false", expiry-date="Fri, 19 Apr 2024 00:00:00 GMT"
     */
    const ExpiryDate = (_split$1$split$ = (_split$ = (headerStoreValue != null ? headerStoreValue : '').split('",')[1]) == null ? void 0 : _split$.split == null ? void 0 : (_split$$split = _split$.split('=')) == null ? void 0 : _split$$split[1]) != null ? _split$1$split$ : '';
    const OngoingRequest = (headerStoreValue == null ? void 0 : headerStoreValue.trim()) === RestoreOngoingRequestTrueStr ? true : false;
    const restoreInfo = {
      RestoreStatus: {
        OngoingRequest,
        ExpiryDate
      }
    };

    if (OngoingRequest) {
      var _headers$TosHeader$He;

      restoreInfo.RestoreParam = {
        ExpiryDays: headers[TosHeader.HeaderRestoreExpiryDays] ? Number(headers[TosHeader.HeaderRestoreExpiryDays]) : 0,
        RequestDate: (_headers$TosHeader$He = headers[TosHeader.HeaderRestoreRequestDate]) != null ? _headers$TosHeader$He : '',
        Tier: headers[TosHeader.HeaderRestoreTier]
      };
    }

    return restoreInfo;
  }

  return;
};

const retryNamespace = '__retryConfig__';

function isNetworkError(error) {
  var _error$response$heade;

  // no response or no requestId, ignore no network(error.code is undefined)
  return !error.response && Boolean(error.code) || error.response && !((_error$response$heade = error.response.headers) != null && _error$response$heade['x-tos-request-id']);
}

function isCanRetryStatusCode(error) {
  if (!error.response) {
    return false;
  }

  const {
    status
  } = error.response;

  if (status === 429 || status >= 500) {
    return true;
  }

  return false;
}
const makeAxiosInst = maxRetryCount => {
  const axiosInst = axios.create(); // set `axiosInst` default values to avoid being affected by the global default values of axios

  axiosInst.defaults.auth = undefined;
  axiosInst.defaults.responseType = 'json';
  axiosInst.defaults.params = undefined;
  axiosInst.defaults.headers = {};
  axiosInst.defaults.withCredentials = false;
  axiosInst.defaults.maxContentLength = -1;
  axiosInst.defaults.maxBodyLength = -1;
  axiosInst.defaults.maxRedirects = 0;

  axiosInst.defaults.validateStatus = function (status) {
    return status >= 200 && status < 300; // default
  };

  axiosInst.defaults.decompress = false;
  axiosInst.defaults.transitional = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  }; // delete browser headers


  const ensureHeaders = v => {
    var _v$response;

    v.headers = v.headers || v.header || (v == null ? void 0 : (_v$response = v.response) == null ? void 0 : _v$response.headers) || {};
    return v;
  };

  axiosInst.interceptors.response.use(ensureHeaders, error => {
    ensureHeaders(error);
    return Promise.reject(error);
  }); // decode header. Encode headers' value by encodeHeadersValue method before calling axios

  function handleResponseHeader(headers) {
    Object.entries(headers).forEach(([key, value]) => {
      const [err, decodedValue] = safeSync(() => decodeURI(value));

      if (err || decodedValue == null || decodedValue === value) {
        return;
      }

      let sArr = [];
      const valueArr = `${value}`.match(/./gu);
      const decodedValueArr = decodedValue.match(/./gu);

      for (let i = 0, j = 0; i < decodedValueArr.length;) {
        const ch = decodedValueArr[i];

        if (ch === valueArr[j]) {
          sArr.push(ch);
          ++i;
          ++j;
          continue;
        }

        const encodedCh = encodeURIComponent(ch);

        if (ch.length > 1 || ch.charCodeAt(0) >= 128) {
          sArr.push(ch);
        } else {
          sArr.push(encodedCh);
        }

        ++i;
        j += encodedCh.length;
      }

      headers[key] = sArr.join('');
    });
  }

  axiosInst.interceptors.response.use(res => {
    if (!res.headers) {
      return res;
    }

    handleResponseHeader(res.headers);
    return res;
  }, async error => {
    var _error$response;

    if (!axios.isAxiosError(error)) {
      return Promise.reject(error);
    }

    const headers = (_error$response = error.response) == null ? void 0 : _error$response.headers;

    if (!headers) {
      return Promise.reject(error);
    }

    handleResponseHeader(headers);
    return Promise.reject(error);
  }); // retry

  axiosInst.interceptors.response.use(undefined, async error => {
    var _retryConfig$retryCou;

    const {
      config
    } = error;

    if (!config) {
      return Promise.reject(error);
    }

    if (!config[retryNamespace]) {
      config[retryNamespace] = {};
    }

    const retryConfig = config[retryNamespace];
    const retryCount = (_retryConfig$retryCou = retryConfig.retryCount) != null ? _retryConfig$retryCou : 0;
    let newData = config.data;

    const canRetryData = (() => {
      {
        if (config.data && config.data instanceof stream.Readable) {
          const v = retryConfig.makeRetryStream == null ? void 0 : retryConfig.makeRetryStream();

          if (!v) {
            return false;
          }

          newData = v;
        }
      }

      return true;
    })();

    const canRetry = (isNetworkError(error) || isCanRetryStatusCode(error)) && retryCount < maxRetryCount && canRetryData;

    if (!canRetry) {
      return Promise.reject(error);
    }

    const nextConfig = { ...config,
      data: newData,
      [retryNamespace]: { ...retryConfig,
        retryCount: retryCount + 1
      }
    };
    retryConfig.beforeRetry == null ? void 0 : retryConfig.beforeRetry();
    return axiosInst(nextConfig);
  });
  return axiosInst;
};

const TOS = /*#__PURE__*/createDebug('TOS');

class TOSBase {
  constructor(_opts) {
    this.opts = void 0;
    this.axiosInst = void 0;
    this.userAgent = void 0;
    this.httpAgent = void 0;
    this.httpsAgent = void 0;

    this.getObjectPath = opts => {
      const actualBucket = typeof opts !== 'string' && opts.bucket || this.opts.bucket;
      const actualKey = typeof opts === 'string' ? opts : opts.key;

      if (!actualBucket) {
        throw new TosClientError('Must provide bucket param');
      }

      return `/${actualBucket}/${encodeURIComponent(actualKey)}`;
    };

    this.setObjectContentTypeHeader = (input, headers) => {
      if (headers['content-type'] != null) {
        return;
      }

      let mimeType = DEFAULT_CONTENT_TYPE;
      const key = getObjectInputKey(input);

      if (this.opts.autoRecognizeContentType) {
        mimeType = lookupMimeType(key) || mimeType;
      }

      if (mimeType) {
        headers['content-type'] = mimeType;
      }
    };

    this.getNormalDataFromError = getNormalDataFromError;
    this.opts = this.normalizeOpts(_opts);

    {
      this.httpAgent = TosAgent({
        tosOpts: { ...this.opts,
          isHttps: false
        }
      }); // fix axios issue, it uses `httpsAgent` although http proxy is enabled.

      const isProxy = !!this.opts.proxyHost;
      this.httpsAgent = TosAgent({
        tosOpts: { ...this.opts,
          isHttps: !isProxy
        }
      });
    }

    this.userAgent = this.getUserAgent();
    this.axiosInst = makeAxiosInst(this.opts.maxRetryCount);
  }

  normalizeOpts(_opts) {
    var _opts$enableCRC, _opts$enableCRC2;

    // 对字符串参数做 trim 操作
    const trimKeys = ['accessKeyId', 'accessKeySecret', 'stsToken', 'region', 'endpoint'];
    trimKeys.forEach(key => {
      const value = _opts[key];

      if (typeof value === 'string') {
        // maybe undefined
        _opts[key] = value.trim();
      }
    });
    const mustKeys = ['accessKeyId', 'accessKeySecret', 'region'];
    const mustKeysErrorStr = mustKeys.filter(key => !_opts[key]).join(', ');

    if (mustKeysErrorStr) {
      throw new TosClientError(`lack params: ${mustKeysErrorStr}.`);
    }

    const endpoint = _opts.endpoint || getEndpoint(_opts.region);

    if (!endpoint) {
      throw new TosClientError(`the value of param region is invalid, correct values are cn-beijing, cn-nantong etc.`);
    }

    if (endpoint.includes('s3')) {
      throw new TosClientError(`do not support s3 endpoint, please use tos endpoint.`);
    }

    const secure = _opts.secure == null ? true : !!_opts.secure;

    const _default = (v, defaultValue) => v == null ? defaultValue : v;

    const enableCRC = (_opts$enableCRC = _opts.enableCRC) != null ? _opts$enableCRC : false;

    if (enableCRC && 'node' === 'browser') {}

    return { ..._opts,
      endpoint,
      secure,
      enableVerifySSL: _default(_opts.enableVerifySSL, true),
      autoRecognizeContentType: _default(_opts.autoRecognizeContentType, true),
      requestTimeout: _default(_opts.requestTimeout, 120000),
      connectionTimeout: _default(_opts.connectionTimeout, 10000),
      maxConnections: _default(_opts.maxConnections, 1024),
      idleConnectionTime: _default(_opts.idleConnectionTime, 30000),
      maxRetryCount: _default(_opts.maxRetryCount, 3),
      enableCRC: (_opts$enableCRC2 = _opts.enableCRC) != null ? _opts$enableCRC2 : false,
      requestAdapter: getAdapter()
    };
  }

  getUserAgent() {
    // tos-{language}-sdk/{version}
    const language =  'nodejs';
    return `tos-${language}-sdk/${version}`;
  }

  async fetch(method, path, query, headers, body, opts) {
    const handleResponse = (opts == null ? void 0 : opts.handleResponse) || (res => res.data);

    const needMd5 = (opts == null ? void 0 : opts.needMd5) || false;

    if (body && needMd5) {
      const md5String = hashMd5$2(JSON.stringify(body), 'base64');
      headers['content-md5'] = md5String;
    }

    const [endpoint, newPath] = (() => {
      if (opts != null && opts.subdomainBucket && this.opts.forcePathStyle) {
        return [this.opts.endpoint, `/${opts.subdomainBucket}${path}`];
      } // if isCustomDomain true, not add subdomainBucket


      if (opts != null && opts.subdomainBucket && !this.opts.isCustomDomain) {
        // endpoint is ip address
        if (/^(\d|:)/.test(this.opts.endpoint)) {
          return [this.opts.endpoint, `/${opts.subdomainBucket}${path}`];
        }

        return [`${opts == null ? void 0 : opts.subdomainBucket}.${this.opts.endpoint}`, path];
      }

      return [this.opts.endpoint, path];
    })();

    path = newPath;
    headers = encodeHeadersValue(headers);
    const signOpt = {
      // TODO: delete endpoints and buckets
      endpoints: undefined,
      bucket: '',
      method,
      headers: { ...headers
      },
      path,
      query: getSortedQueryString(query),
      host: endpoint
    };
    const signv4 = new ISigV4Credentials(this.opts.stsToken, this.opts.accessKeySecret, this.opts.accessKeyId);
    const sig = new SignersV4({
      algorithm: 'TOS4-HMAC-SHA256',
      region: this.opts.region,
      serviceName: 'tos',
      bucket: '',
      securityToken: this.opts.stsToken
    }, signv4);
    const signatureHeaders = sig.signatureHeader(signOpt);
    const reqHeaders = { ...headers
    };
    const reqOpts = {
      method,
      baseURL: `http${this.opts.secure ? 's' : ''}://${endpoint}`,
      url: path,
      params: query,
      headers: reqHeaders,
      data: body
    };
    signatureHeaders.forEach((value, key) => {
      reqOpts.headers[key] = value;
    });
    const normalizedProxy = normalizeProxy(this.opts.proxy);

    if (normalizedProxy != null && normalizedProxy.url && !this.opts.proxyHost) {
      // proxy for nodejs middleware server
      reqOpts.baseURL = normalizedProxy.url;

      if (normalizedProxy != null && normalizedProxy.needProxyParams) {
        reqOpts.params['x-proxy-tos-host'] = endpoint;
        delete reqHeaders['host'];
      }
    } else if (this.opts.proxyHost) {
      if (!this.opts.proxyPort) {
        throw new TosClientError('The `proxyPort` is required if `proxyHost` is truly.');
      } // proxy for general proxy server


      reqOpts.proxy = {
        host: this.opts.proxyHost,
        port: this.opts.proxyPort,
        protocol: 'http'
      };
    }

    reqHeaders['user-agent'] = this.userAgent;

    if (this.opts.requestTimeout > 0 && this.opts.requestTimeout !== Infinity) {
      reqOpts.timeout = this.opts.requestTimeout;
    }

    {
      reqOpts.httpAgent = this.httpAgent;
      reqOpts.httpsAgent = this.httpsAgent;
    }

    try {
      const logReqOpts = { ...reqOpts
      };
      delete logReqOpts.httpAgent;
      delete logReqOpts.httpsAgent;
      TOS('reqOpts: ', logReqOpts);
      const res = await this.axiosInst({ ...{
          maxBodyLength: Infinity,
          maxContentLength: Infinity,
          adapter: this.opts.requestAdapter
        },
        ...reqOpts,
        ...((opts == null ? void 0 : opts.axiosOpts) || {})
      });
      const data = handleResponse(res);
      return {
        data,
        statusCode: res.status,
        headers: res.headers,
        requestId: res.headers['x-tos-request-id'],
        id2: res.headers['x-tos-id-2']
      };
    } catch (err) {
      var _err$response, _err$response$headers;

      if (axios.isAxiosError(err) && (_err$response = err.response) != null && (_err$response$headers = _err$response.headers) != null && _err$response$headers['x-tos-request-id']) {
        // it's ServerError only if `RequestId` exists
        const response = err.response;
        TOS('TosServerError response: ', response);
        const err2 = new TosServerError(response);
        throw err2;
      } // it is neither ServerError nor ClientError, it's other error


      TOS('err: ', err);
      throw err;
    }
  }

  async fetchBucket(bucket, method, query, headers, body, opts) {
    const actualBucket = bucket || this.opts.bucket;

    if (!actualBucket) {
      throw new TosClientError('Must provide bucket param');
    }

    return this.fetch(method, '/', query, headers, body, { ...opts,
      subdomainBucket: actualBucket
    });
  }

  async _fetchObject(input, method, query, headers, body, opts) {
    const actualBucket = typeof input !== 'string' && input.bucket || this.opts.bucket;
    const actualKey = typeof input === 'string' ? input : input.key;

    if (!actualBucket) {
      throw new TosClientError('Must provide bucket param');
    }

    validateObjectName(actualKey);
    return this.fetch(method, `/${encodeURIComponent(actualKey)}`, query, headers, body, { ...opts,
      subdomainBucket: actualBucket
    });
  }

  getSignatureQuery(input) {
    const signv4 = new ISigV4Credentials(this.opts.stsToken, this.opts.accessKeySecret, this.opts.accessKeyId);
    const sig = new SignersV4({
      algorithm: 'TOS4-HMAC-SHA256',
      region: this.opts.endpoint,
      serviceName: 'tos',
      // SignV4 uses this.options.bucket, so set it here
      bucket: input.bucket,
      securityToken: this.opts.stsToken
    }, signv4);

    if ('policy' in input) {
      return sig.getSignaturePolicyQuery({
        policy: input.policy
      }, input.expires);
    } else {
      return sig.getSignatureQuery({
        method: input.method,
        path: input.path,
        endpoints: input.subdomain ? input.endpoint : undefined,
        host: input.endpoint,
        query: input.query
      }, input.expires);
    }
  }

  normalizeBucketInput(input) {
    return typeof input === 'string' ? {
      bucket: input
    } : input;
  }

  normalizeObjectInput(input) {
    return typeof input === 'string' ? {
      key: input
    } : input;
  }

}

function getAdapter() {
  {
    // nodejs env
    return undefined;
  }
}

async function listBuckets(input = {}) {
  const headers = {};
  fillRequestHeaders({ ...input,
    headers
  }, ['projectName']);
  const res = await this.fetch('GET', '/', {}, headers);
  const arrayProp = makeArrayProp(res.data);
  arrayProp('Buckets');
  return res;
}
async function createBucket(input) {
  const actualBucket = input.bucket || this.opts.bucket; // these errors are only for creating bucket

  if (actualBucket) {
    if (actualBucket.length < 3 || actualBucket.length > 63) {
      throw new TosClientError('invalid bucket name, the length must be [3, 63]');
    }

    if (!/^([a-z]|-|\d)+$/.test(actualBucket)) {
      throw new TosClientError('invalid bucket name, the character set is illegal');
    }

    if (/^-/.test(actualBucket) || /-$/.test(actualBucket)) {
      throw new TosClientError(`invalid bucket name, the bucket name can be neither starting with '-' nor ending with '-'`);
    }
  }

  const headers = input.headers = normalizeHeadersKey(input.headers);
  fillRequestHeaders(input, ['acl', 'grantFullControl', 'grantRead', 'grantReadAcp', 'grantWrite', 'grantWriteAcp', 'storageClass', 'azRedundancy', 'projectName']);
  const res = await this.fetchBucket(input.bucket, 'PUT', {}, headers);
  return res;
}
async function deleteBucket(bucket) {
  return this.fetchBucket(bucket, 'DELETE', {}, {});
}
async function headBucket(bucket) {
  return this.fetchBucket(bucket, 'HEAD', {}, {}, undefined, {
    handleResponse: res => {
      return { ...res.headers,
        ProjectName: res.headers[TosHeader.HeaderProjectName]
      };
    }
  });
}
async function putBucketStorageClass(input) {
  const {
    bucket,
    storageClass
  } = input;
  return this.fetchBucket(bucket, 'PUT', {
    storageClass: ''
  }, {
    'x-tos-storage-class': storageClass
  });
}

async function putBucketAcl(input) {
  const headers = {};
  if (input.acl) headers['x-tos-acl'] = input.acl;
  const res = await this.fetchBucket(input.bucket, 'PUT', {
    acl: ''
  }, headers, input.aclBody, {
    needMd5: true
  });
  return res;
}
async function getBucketAcl(bucket) {
  return this.fetchBucket(bucket, 'GET', {
    acl: ''
  }, {});
}

/**
 * since fs/promises exist after nodejs@14, so we make own fs/promises
 */
const createWriteStream = fs.createWriteStream;
const createReadStream = fs.createReadStream;
const rename = /*#__PURE__*/util.promisify(fs.rename);
const stat = /*#__PURE__*/util.promisify(fs.stat);
const mkdir = /*#__PURE__*/util.promisify(fs.mkdir);
const writeFile = /*#__PURE__*/util.promisify(fs.writeFile);

const rm = /*#__PURE__*/util.promisify(fs.unlink);
const readFile = /*#__PURE__*/util.promisify(fs.readFile);

(function (DataTransferType) {
  DataTransferType[DataTransferType["Started"] = 1] = "Started";
  DataTransferType[DataTransferType["Rw"] = 2] = "Rw";
  DataTransferType[DataTransferType["Succeed"] = 3] = "Succeed";
  DataTransferType[DataTransferType["Failed"] = 4] = "Failed";
})(exports.DataTransferType || (exports.DataTransferType = {}));

/**
 * @deprecated use getObjectV2 instead
 * @returns arraybuffer
 */

async function getObject(input) {
  const normalizedInput = typeof input === 'string' ? {
    key: input
  } : input;
  const query = {};

  if (normalizedInput.versionId) {
    query.versionId = normalizedInput.versionId;
  }

  const headers = normalizeHeadersKey(normalizedInput == null ? void 0 : normalizedInput.headers);
  const response = (normalizedInput == null ? void 0 : normalizedInput.response) || {};
  Object.keys(response).forEach(key => {
    const v = response[key];

    if (v != null) {
      query[`response-${key}`] = v;
    }
  }); // TODO: maybe need to return response's headers

  return this._fetchObject(input, 'GET', query, headers, undefined, {
    axiosOpts: {
      responseType: 'arraybuffer'
    }
  });
}
const NODEJS_DATATYPE = ['stream', 'buffer'];

function checkSupportDataType(dataType) {
  let environment = 'node';
  let supportDataTypes = [];

  {
    environment = 'node';
    supportDataTypes = NODEJS_DATATYPE;
  }

  if (!supportDataTypes.includes(dataType)) {
    throw new TosClientError(`The value of \`dataType\` only supports \`${supportDataTypes.join(' | ')}\` in ${environment} environment`);
  }
}

async function getObjectV2(input) {
  const normalizedInput = typeof input === 'string' ? {
    key: input
  } : input;
  const headers = normalizeHeadersKey(normalizedInput.headers);
  normalizedInput.headers = headers;
  const dataType = normalizedInput.dataType || 'stream';
  normalizedInput.dataType = dataType;
  checkSupportDataType(dataType);
  const query = {};
  const response = (normalizedInput == null ? void 0 : normalizedInput.response) || {};
  Object.keys(response).forEach(key => {
    const v = response[key];

    if (v != null) {
      query[`response-${key}`] = v;
    }
  });
  fillRequestQuery(normalizedInput, query, ['versionId', 'process', 'saveBucket', 'saveObject', 'responseCacheControl', 'responseContentDisposition', 'responseContentEncoding', 'responseContentLanguage', 'responseContentType', 'responseExpires']);
  fillRequestHeaders(normalizedInput, ['ifMatch', 'ifModifiedSince', 'ifNoneMatch', 'ifUnmodifiedSince', 'ssecAlgorithm', 'ssecKey', 'ssecKeyMD5', 'range', 'trafficLimit']);

  if (normalizedInput.range == null && (normalizedInput.rangeStart != null || normalizedInput.rangeEnd != null)) {
    var _headers$range;

    const start = normalizedInput.rangeStart != null ? `${normalizedInput.rangeStart}` : '';
    const end = normalizedInput.rangeEnd != null ? `${normalizedInput.rangeEnd}` : '';
    const range = `bytes=${start}-${end}`;
    headers['range'] = (_headers$range = headers['range']) != null ? _headers$range : range;
  }

  const responseType = (() => {
    {
      return 'stream';
    }
  })();

  let consumedBytes = 0; // totalSize is unknown when start download

  let totalSize = -1;
  const {
    dataTransferStatusChange,
    progress
  } = normalizedInput;

  const triggerDataTransfer = (type, rwOnceBytes = 0) => {
    // request cancel will make rwOnceBytes < 0 in browser
    if (rwOnceBytes < 0) {
      return;
    }

    if (!dataTransferStatusChange && !progress) {
      return;
    }

    consumedBytes += rwOnceBytes;
    dataTransferStatusChange == null ? void 0 : dataTransferStatusChange({
      type,
      rwOnceBytes,
      consumedBytes,
      totalBytes: totalSize
    });

    const progressValue = (() => {
      // `totalSize` is unknown if it's in start or fail
      if (totalSize < 0) {
        return 0;
      }

      if (totalSize === 0) {
        if (type === exports.DataTransferType.Succeed) {
          return 1;
        }

        return 0;
      }

      return consumedBytes / totalSize;
    })();

    if (progressValue === 1) {
      if (type === exports.DataTransferType.Succeed) {
        progress == null ? void 0 : progress(progressValue);
      }
    } else {
      progress == null ? void 0 : progress(progressValue);
    }
  };

  triggerDataTransfer(exports.DataTransferType.Started);
  const [err, res] = await safeAwait(this._fetchObject(input, 'GET', query, headers, undefined, {
    axiosOpts: {
      responseType,
      onDownloadProgress: event => {
        totalSize = event.total;
        triggerDataTransfer(exports.DataTransferType.Rw, event.loaded - consumedBytes);
      }
    }
  }));

  if (err || !res) {
    triggerDataTransfer(exports.DataTransferType.Failed);
    throw err;
  }

  let resHeaders = res.headers;
  let newData = res.data;
  totalSize = +(resHeaders['content-length'] || 0);

  {
    // res.data must be a stream in nodejs environment
    if (isReadable(newData)) {
      if (normalizedInput.rateLimiter && isValidRateLimiter(normalizedInput.rateLimiter)) {
        newData = createRateLimiterStream(newData, normalizedInput.rateLimiter);
      }

      newData = createReadNReadStream(newData, n => triggerDataTransfer(exports.DataTransferType.Rw, n));
      newData.on('end', () => triggerDataTransfer(exports.DataTransferType.Succeed));

      if (dataType === 'buffer') {
        // consume stream after `createRateLimiterStream`
        newData = await streamToBuf(newData);
      }
    }
  }

  const actualRes = { ...res,
    data: {
      content: newData,
      etag: resHeaders['etag'] || '',
      lastModified: resHeaders['last-modified'] || '',
      hashCrc64ecma: resHeaders['x-tos-hash-crc64ecma'] || '',
      ReplicationStatus: resHeaders[TosHeader.HeaderReplicationStatus]
    }
  };
  const info = getRestoreInfoFromHeaders(resHeaders);

  if (info) {
    actualRes.data.RestoreInfo = info;
  }

  return actualRes;
}

async function getObjectToFile(input) {

  return new Promise(async (resolve, reject) => {
    const getObjectRes = await getObjectV2.call(this, input);
    const stream = getObjectRes.data.content;
    const fsWriteStream = createWriteStream(input.filePath);
    stream.pipe(fsWriteStream);
    fsWriteStream.on('error', err => reject(err));
    fsWriteStream.on('finish', () => {
      const newData = { ...getObjectRes.data
      };
      delete newData.content;
      resolve({ ...getObjectRes,
        data: { ...newData
        }
      });
    });
  });
}

async function putObject(input) {
  return _putObject.call(this, input);
}
async function _putObject(input) {
  input = this.normalizeObjectInput(input);
  const headers = input.headers = normalizeHeadersKey(input.headers);
  fillRequestHeaders(input, ['contentLength', 'contentMD5', 'contentSHA256', 'cacheControl', 'contentDisposition', 'contentEncoding', 'contentLanguage', 'contentType', 'expires', 'acl', 'grantFullControl', 'grantRead', 'grantReadAcp', 'grantWrite', 'grantWriteAcp', 'ssecAlgorithm', 'ssecKey', 'ssecKeyMD5', 'serverSideEncryption', 'meta', 'websiteRedirectLocation', 'storageClass', 'trafficLimit', 'callback', 'callbackVar']);
  this.setObjectContentTypeHeader(input, headers);
  const totalSize = getSize(input.body, headers);
  const totalSizeValid = totalSize != null;

  if (!totalSizeValid && (input.dataTransferStatusChange || input.progress)) {
    console.warn(`Don't get totalSize of putObject's body, the \`dataTransferStatusChange\` and \`progress\` callback will not trigger. You can use \`putObjectFromFile\` instead`);
  }

  let consumedBytes = 0;
  const {
    dataTransferStatusChange,
    progress
  } = input;

  const triggerDataTransfer = (type, rwOnceBytes = 0) => {
    // request cancel will make rwOnceBytes < 0 in browser
    if (!totalSizeValid || rwOnceBytes < 0) {
      return;
    }

    if (!dataTransferStatusChange && !progress) {
      return;
    }

    consumedBytes += rwOnceBytes;
    dataTransferStatusChange == null ? void 0 : dataTransferStatusChange({
      type,
      rwOnceBytes,
      consumedBytes,
      totalBytes: totalSize
    });

    const progressValue = (() => {
      if (totalSize === 0) {
        if (type === exports.DataTransferType.Succeed) {
          return 1;
        }

        return 0;
      }

      return consumedBytes / totalSize;
    })();

    if (progressValue === 1) {
      if (type === exports.DataTransferType.Succeed) {
        progress == null ? void 0 : progress(progressValue);
      }
    } else {
      progress == null ? void 0 : progress(progressValue);
    }
  };

  const bodyConfig = await getNewBodyConfig({
    body: input.body,
    dataTransferCallback: n => triggerDataTransfer(exports.DataTransferType.Rw, n),
    makeRetryStream: input.makeRetryStream,
    enableCRC: this.opts.enableCRC,
    rateLimiter: input.rateLimiter
  });
  triggerDataTransfer(exports.DataTransferType.Started);

  const task = async () => {
    const res = await this._fetchObject(input, 'PUT', {}, headers, bodyConfig.body || '', {
      handleResponse: res => {
        var _input;

        const result = { ...res.headers
        };

        if ((_input = input) != null && _input.callback && res.data) {
          result.CallbackResult = `${JSON.stringify(res.data)}`;
        }

        return result;
      },
      axiosOpts: {
        [retryNamespace]: {
          beforeRetry: () => {
            consumedBytes = 0;
            bodyConfig.beforeRetry == null ? void 0 : bodyConfig.beforeRetry();
          },
          makeRetryStream: bodyConfig.makeRetryStream
        },
        onUploadProgress: event => {
          triggerDataTransfer(exports.DataTransferType.Rw, event.loaded - consumedBytes);
        }
      }
    });

    if (this.opts.enableCRC && bodyConfig.crc) {
      checkCRC64WithHeaders(bodyConfig.crc, res.headers);
    }

    return res;
  };

  const [err, res] = await safeAwait(task());

  if (err || !res) {
    triggerDataTransfer(exports.DataTransferType.Failed);
    throw err;
  }

  triggerDataTransfer(exports.DataTransferType.Succeed);
  return res;
}
async function putObjectFromFile(input) {
  const normalizedHeaders = normalizeHeadersKey(input.headers);

  if (!normalizedHeaders['content-length']) {
    const stats = await stat(input.filePath);
    normalizedHeaders['content-length'] = `${stats.size}`;
  }

  const makeRetryStream = () => {
    const stream = createReadStream(input.filePath);
    return stream;
  };

  return _putObject.call(this, { ...input,
    body: makeRetryStream(),
    headers: normalizedHeaders,
    makeRetryStream
  });
}

async function fetchObject(input) {
  const headers = input.headers = normalizeHeadersKey(input.headers);
  fillRequestHeaders(input, ['acl', 'grantFullControl', 'grantRead', 'grantReadAcp', 'grantWriteAcp', 'ssecAlgorithm', 'ssecKey', 'ssecKeyMD5', 'meta', 'storageClass']);
  const res = await this._fetchObject(input, 'POST', {
    fetch: ''
  }, headers, {
    URL: input.url,
    IgnoreSameKey: input.ignoreSameKey,
    ContentMD5: input.contentMD5
  }, {
    needMd5: true
  });
  return res;
}
async function putFetchTask(input) {
  const headers = input.headers = normalizeHeadersKey(input.headers);
  fillRequestHeaders(input, ['acl', 'grantFullControl', 'grantRead', 'grantReadAcp', 'grantWriteAcp', 'ssecAlgorithm', 'ssecKey', 'ssecKeyMD5', 'meta', 'storageClass']);
  const res = await this._fetchObject(input, 'POST', {
    fetchTask: ''
  }, headers, {
    URL: input.url,
    IgnoreSameKey: input.ignoreSameKey,
    ContentMD5: input.contentMD5,
    Object: input.key
  }, {
    needMd5: true
  });
  return res;
}

/**
 *
 * @deprecated use listObjectsType2 instead
 * @returns
 */


async function listObjects(input = {}) {
  const {
    bucket,
    ...nextQuery
  } = input;
  const ret = await this.fetchBucket(input.bucket, 'GET', covertCamelCase2Kebab(nextQuery), {});
  const arrayProp = makeArrayProp(ret.data);
  arrayProp('CommonPrefixes');
  arrayProp('Contents');
  arrayProp('Versions');
  arrayProp('DeleteMarkers');
  return ret;
}
async function listObjectVersions(input = {}) {
  return this.listObjects({
    versions: '',
    ...input
  });
}

function getPreSignedUrl(input) {
  validateObjectName(input);
  const normalizedInput = typeof input === 'string' ? {
    key: input
  } : input;
  const endpoint = normalizedInput.alternativeEndpoint || this.opts.endpoint;
  const subdomain = normalizedInput.alternativeEndpoint || normalizedInput.isCustomDomain ? false : true;
  const bucket = normalizedInput.bucket || this.opts.bucket || '';

  if (subdomain && !bucket) {
    throw new TosClientError('Must provide bucket param');
  }

  const [newHost, newPath, signingPath] = (() => {
    const encodedKey = encodeURIComponent(normalizedInput.key);
    const objectKeyPath = normalizedInput.key.split('/').map(it => encodeURIComponent(it)).join('/');

    if (subdomain) {
      return [`${bucket}.${endpoint}`, `/${objectKeyPath}`, `/${encodedKey}`];
    }

    return [endpoint, `/${objectKeyPath}`, `/${encodedKey}`];
  })();

  const nextQuery = normalizedInput.query || {};

  const setOneQuery = (k, v) => {
    if (nextQuery[k] == null && v != null) {
      nextQuery[k] = v;
    }
  };

  const response = normalizedInput.response || {};
  Object.keys(response).forEach(_key => {
    const key = _key;
    const kebabKey = covertCamelCase2Kebab(key);
    setOneQuery(`response-${kebabKey}`, response[key]);
  });

  if (normalizedInput.versionId) {
    setOneQuery('versionId', normalizedInput.versionId);
  }

  const query = this.getSignatureQuery({
    bucket,
    method: normalizedInput.method || 'GET',
    path: signingPath,
    endpoint,
    subdomain,
    expires: normalizedInput.expires || 1800,
    query: nextQuery
  });
  const normalizedProxy = normalizeProxy(this.opts.proxy);
  let baseURL = `http${this.opts.secure ? 's' : ''}://${newHost}`;

  if (normalizedProxy != null && normalizedProxy.url) {
    // if `baseURL` ends with '/'，we filter it.
    // because `newPath` starts with '/'
    baseURL = normalizedProxy.url.replace(/\/+$/g, '');

    if (normalizedProxy != null && normalizedProxy.needProxyParams) {
      query['x-proxy-tos-host'] = newHost;
    }
  }

  const queryStr = Object.keys(query).map(key => {
    return `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`;
  }).join('&');
  return `${baseURL}${newPath}?${queryStr}`;
}

async function headObject(input) {
  const normalizedInput = typeof input === 'string' ? {
    key: input
  } : input;
  const headers = normalizeHeadersKey(normalizedInput.headers);
  normalizedInput.headers = headers;
  const query = {};

  if (normalizedInput.versionId) {
    query.versionId = normalizedInput.versionId;
  }

  fillRequestHeaders(normalizedInput, ['ifMatch', 'ifModifiedSince', 'ifNoneMatch', 'ifUnmodifiedSince', 'ssecAlgorithm', 'ssecKey', 'ssecKeyMD5']);
  return this._fetchObject(input, 'HEAD', query, (normalizedInput == null ? void 0 : normalizedInput.headers) || {}, undefined, {
    handleResponse: res => {
      const result = { ...res.headers,
        ReplicationStatus: res.headers[TosHeader.HeaderReplicationStatus]
      };
      const info = getRestoreInfoFromHeaders(res.headers);

      if (info) {
        result.RestoreInfo = info;
      }

      return result;
    }
  });
}

async function deleteObject(input) {
  const normalizedInput = typeof input === 'string' ? {
    key: input
  } : input;
  const query = {};

  if (normalizedInput.versionId) {
    query.versionId = normalizedInput.versionId;
  }

  const res = await this._fetchObject(input, 'DELETE', query, {}, {}, {
    handleResponse: res => res.headers
  });
  return res;
}

async function renameObject(input) {
  return this._fetchObject(input, 'PUT', {
    rename: '',
    name: input.newKey
  }, {}, '');
}

async function deleteMultiObjects(input) {
  const body = {
    Quiet: input.quiet,
    Objects: input.objects.map(it => ({
      Key: it.key,
      VersionId: it.versionId
    }))
  };
  const res = await this.fetchBucket(input.bucket, 'POST', {
    delete: ''
  }, {}, body);
  const arrayProp = makeArrayProp(res.data);
  arrayProp('Deleted');
  arrayProp('Error');
  return res;
}

async function copyObject(input) {
  const headers = normalizeHeadersKey(input.headers);
  input.headers = headers;
  fillRequestHeaders(input, ['cacheControl', 'contentDisposition', 'contentEncoding', 'contentLanguage', 'contentType', 'expires', 'copySourceIfMatch', 'copySourceIfModifiedSince', 'copySourceIfNoneMatch', 'copySourceIfUnmodifiedSince', 'copySourceSSECAlgorithm', 'copySourceSSECKey', 'copySourceSSECKeyMD5', 'acl', 'grantFullControl', 'grantRead', 'grantReadAcp', 'grantWriteAcp', 'ssecAlgorithm', 'ssecKey', 'ssecKeyMD5', 'serverSideEncryption', 'metadataDirective', 'meta', 'websiteRedirectLocation', 'storageClass', 'trafficLimit']);

  if (input.srcBucket && input.srcKey) {
    var _headers$xTosCopyS;

    let copySource = getCopySourceHeaderValue(input.srcBucket, input.srcKey);

    if (input.srcVersionID) {
      copySource += `?versionId=${input.srcVersionID}`;
    }

    headers['x-tos-copy-source'] = (_headers$xTosCopyS = headers['x-tos-copy-source']) != null ? _headers$xTosCopyS : copySource;
  }

  const [err, res] = await safeAwait(this._fetchObject(input, 'PUT', {}, headers));

  if (err || !res || !res.data.ETag) {
    // TODO: throw TosServerErr
    throw err;
  }

  return res;
}

async function getObjectAcl(input) {
  const normalizedInput = typeof input === 'string' ? {
    key: input
  } : input;
  const query = {
    acl: ''
  };

  if (normalizedInput.versionId) {
    query.versionId = normalizedInput.versionId;
  }

  return this._fetchObject(input, 'GET', query, {});
}
async function putObjectAcl(input) {
  const headers = input.headers = normalizeHeadersKey(input.headers);
  const query = {
    acl: ''
  };

  if (input.versionId) {
    query.versionId = input.versionId;
  }

  fillRequestHeaders(input, ['acl']);
  return this._fetchObject(input, 'PUT', query, headers, input.aclBody);
}

async function abortMultipartUpload(input) {
  return this._fetchObject(input, 'DELETE', {
    uploadId: input.uploadId
  }, {});
}

async function completeMultipartUpload(input) {
  var _input$headers;

  input.headers = (_input$headers = input.headers) != null ? _input$headers : {};
  fillRequestHeaders(input, ['callback', 'callbackVar']);

  const handleResponse = response => {
    const bucket = input.bucket || this.opts.bucket || '';
    const headers = response.headers;
    const result = { ...{
        VersionID: headers['x-tos-version-id'],
        ETag: headers['etag'],
        Bucket: bucket,
        Location: headers['location'],
        HashCrc64ecma: headers['x-tos-hash-crc64ecma'],
        Key: input.key
      },
      ...response.data
    };

    if (input.callback) {
      result.CallbackResult = `${JSON.stringify(response.data)}`;
    }

    return result;
  };

  if (input.completeAll) {
    var _input$parts;

    if (((_input$parts = input.parts) == null ? void 0 : _input$parts.length) > 0) {
      throw new TosClientError(`Should not specify both 'completeAll' and 'parts' params.`);
    }

    return this._fetchObject(input, 'POST', {
      uploadId: input.uploadId
    }, { ...input.headers,
      'x-tos-complete-all': 'yes'
    }, undefined, {
      handleResponse
    });
  }

  return this._fetchObject(input, 'POST', {
    uploadId: input.uploadId
  }, { ...input.headers
  }, {
    Parts: input.parts.map(it => ({
      ETag: it.eTag,
      PartNumber: it.partNumber
    }))
  }, {
    handleResponse
  });
}

async function createMultipartUpload(input) {
  input = this.normalizeObjectInput(input);
  const headers = normalizeHeadersKey(input.headers);
  input.headers = headers;
  fillRequestHeaders(input, ['encodingType', 'cacheControl', 'contentDisposition', 'contentEncoding', 'contentLanguage', 'contentType', 'expires', 'acl', 'grantFullControl', 'grantRead', 'grantReadAcp', 'grantWriteAcp', 'ssecAlgorithm', 'ssecKey', 'ssecKeyMD5', 'serverSideEncryption', 'meta', 'websiteRedirectLocation', 'storageClass']);
  this.setObjectContentTypeHeader(input, headers);
  return this._fetchObject(input, 'POST', {
    uploads: ''
  }, headers, '');
}

// the last part is no size limit

const MIN_PART_SIZE_EXCEPT_LAST_ONE = 5 * 1024 * 1024;
const MAX_PART_NUMBER = 10000;
const calculateSafePartSize = (totalSize, expectPartSize, showWarning = false) => {
  let partSize = expectPartSize;

  if (expectPartSize < MIN_PART_SIZE_EXCEPT_LAST_ONE) {
    partSize = MIN_PART_SIZE_EXCEPT_LAST_ONE;

    if (showWarning) {
      console.warn(`partSize has been set to ${partSize}, because the partSize you provided is less than the minimal size of multipart`);
    }
  }

  const minSize = Math.ceil(totalSize / MAX_PART_NUMBER);

  if (expectPartSize < minSize) {
    partSize = minSize;

    if (showWarning) {
      console.warn(`partSize has been set to ${partSize}, because the partSize you provided causes the number of part excesses 10,000`);
    }
  }

  return partSize;
};
async function listParts(input) {
  const {
    bucket,
    key,
    uploadId,
    ...nextQuery
  } = input;
  const ret = await this._fetchObject(input, 'GET', {
    uploadId,
    ...covertCamelCase2Kebab(nextQuery)
  }, {});
  const arrayProp = makeArrayProp(ret.data);
  arrayProp('Parts');
  return ret;
}

async function _uploadPart(input) {
  const {
    uploadId,
    partNumber,
    body,
    enableContentMD5 = false
  } = input;
  const headers = normalizeHeadersKey(input.headers);
  input.headers = headers;
  fillRequestHeaders(input, ['trafficLimit', 'ssecAlgorithm', 'ssecKey', 'ssecKeyMD5']);
  const size = getSize(body);

  if (size && headers['content-length'] == null) {
    headers['content-length'] = size.toFixed(0);
  }

  if (enableContentMD5 && headers['content-md5'] == null) {
    // current only support in nodejs
    if ( isReadable(body) && input.makeRetryStream) {
      const newStream = input.makeRetryStream();

      if (newStream) {
        let allContent = Buffer.from([]);

        for await (const chunk of newStream) {
          allContent = Buffer.concat([allContent, typeof chunk === 'string' ? Buffer.from(chunk) : chunk]);
        }

        const md5 = hashMd5$2(allContent, 'base64');
        headers['content-md5'] = md5;
      }
    } else {
      console.warn(`current not support enableMD5Checksum`);
    }
  }

  const totalSize = getSize(input.body, headers);
  const totalSizeValid = totalSize != null;

  if (!totalSizeValid && (input.dataTransferStatusChange || input.progress)) {
    console.warn(`Don't get totalSize of uploadPart's body, the \`dataTransferStatusChange\` callback will not trigger. You can use \`uploadPartFromFile\` instead`);
  }

  let consumedBytes = 0;
  const {
    dataTransferStatusChange,
    progress
  } = input;

  const triggerDataTransfer = (type, rwOnceBytes = 0) => {
    // request cancel will make rwOnceBytes < 0 in browser
    if (!totalSizeValid || rwOnceBytes < 0) {
      return;
    }

    if (!dataTransferStatusChange && !progress) {
      return;
    }

    consumedBytes += rwOnceBytes;
    dataTransferStatusChange == null ? void 0 : dataTransferStatusChange({
      type,
      rwOnceBytes,
      consumedBytes,
      totalBytes: totalSize
    });

    const progressValue = (() => {
      if (totalSize === 0) {
        if (type === exports.DataTransferType.Succeed) {
          return 1;
        }

        return 0;
      }

      return consumedBytes / totalSize;
    })();

    if (progressValue === 1) {
      if (type === exports.DataTransferType.Succeed) {
        progress == null ? void 0 : progress(progressValue);
      }
    } else {
      progress == null ? void 0 : progress(progressValue);
    }
  };

  const bodyConfig = await getNewBodyConfig({
    body: input.body,
    dataTransferCallback: n => triggerDataTransfer(exports.DataTransferType.Rw, n),
    beforeRetry: input.beforeRetry,
    makeRetryStream: input.makeRetryStream,
    enableCRC: this.opts.enableCRC,
    rateLimiter: input.rateLimiter
  });
  triggerDataTransfer(exports.DataTransferType.Started);

  const task = async () => {
    const res = await this._fetchObject(input, 'PUT', {
      partNumber,
      uploadId
    }, headers, bodyConfig.body, {
      handleResponse: res => ({
        partNumber,
        ETag: res.headers.etag,
        serverSideEncryption: res.headers['x-tos-server-side-encryption'],
        serverSideEncryptionKeyId: res.headers['x-tos-server-side-encryption-kms-key-id'],
        ssecAlgorithm: res.headers['x-tos-server-side-encryption-customer-algorithm'],
        ssecKeyMD5: res.headers['x-tos-server-side-encryption-customer-key-MD5'],
        hashCrc64ecma: res.headers['x-tos-hash-crc64ecma']
      }),
      axiosOpts: {
        [retryNamespace]: {
          beforeRetry: () => {
            consumedBytes = 0;
            bodyConfig.beforeRetry == null ? void 0 : bodyConfig.beforeRetry();
          },
          makeRetryStream: bodyConfig.makeRetryStream
        },
        onUploadProgress: event => {
          triggerDataTransfer(exports.DataTransferType.Rw, event.loaded - consumedBytes);
        }
      }
    });

    if (this.opts.enableCRC && bodyConfig.crc) {
      checkCRC64WithHeaders(bodyConfig.crc, res.headers);
    }

    return res;
  };

  const [err, res] = await safeAwait(task()); // FAQ: no etag

  if (err || !res) {
    triggerDataTransfer(exports.DataTransferType.Failed);
    throw err;
  }

  triggerDataTransfer(exports.DataTransferType.Succeed);
  return res;
}
async function uploadPart(input) {
  return _uploadPart.call(this, input);
}
async function uploadPartFromFile(input) {
  var _input$offset, _input$partSize;

  const stats = await stat(input.filePath);
  const start = (_input$offset = input.offset) != null ? _input$offset : 0;
  const end = Math.min(stats.size, start + ((_input$partSize = input.partSize) != null ? _input$partSize : stats.size));

  const makeRetryStream = () => {
    const stream = createReadStream(input.filePath, {
      start,
      end: end - 1
    });
    return stream;
  };

  return _uploadPart.call(this, { ...input,
    body: makeRetryStream(),
    headers: { ...(input.headers || {}),
      ['content-length']: `${end - start}`
    },
    makeRetryStream
  });
}

async function listMultipartUploads(input = {}) {
  const {
    bucket,
    ...nextQuery
  } = input;
  const ret = await this.fetchBucket(input.bucket, 'GET', {
    uploads: '',
    ...covertCamelCase2Kebab(nextQuery)
  }, {});
  const arrayProp = makeArrayProp(ret.data);
  arrayProp('Uploads');
  arrayProp('CommonPrefixes');
  return ret;
}

async function appendObject(input) {
  const normalizedInput = input = this.normalizeObjectInput(input);
  const headers = input.headers = normalizeHeadersKey(input.headers);
  fillRequestHeaders(input, ['contentLength', 'cacheControl', 'contentDisposition', 'contentEncoding', 'contentLanguage', 'contentType', 'expires', 'acl', 'grantFullControl', 'grantRead', 'grantReadAcp', 'grantWriteAcp', 'meta', 'websiteRedirectLocation', 'storageClass', 'trafficLimit']);
  this.setObjectContentTypeHeader(input, headers);
  const totalSize = getSize(input.body, headers);
  const totalSizeValid = totalSize != null;

  if (!totalSizeValid) {
    throw new TosClientError(`appendObject needs to know the content length in advance`);
  }

  headers['content-length'] = headers['content-length'] || `${totalSize}`;

  if (this.opts.enableCRC && input.offset !== 0 && !input.preHashCrc64ecma) {
    throw new TosClientError('must provide preHashCrc64ecma if enableCRC is true and offset is non-zero');
  }

  let consumedBytes = 0;
  const {
    dataTransferStatusChange,
    progress
  } = input;

  const triggerDataTransfer = (type, rwOnceBytes = 0) => {
    // request cancel will make rwOnceBytes < 0 in browser
    if (!totalSizeValid || rwOnceBytes < 0) {
      return;
    }

    if (!dataTransferStatusChange && !progress) {
      return;
    }

    consumedBytes += rwOnceBytes;
    dataTransferStatusChange == null ? void 0 : dataTransferStatusChange({
      type,
      rwOnceBytes,
      consumedBytes,
      totalBytes: totalSize
    });

    const progressValue = (() => {
      if (totalSize === 0) {
        if (type === exports.DataTransferType.Succeed) {
          return 1;
        }

        return 0;
      }

      return consumedBytes / totalSize;
    })();

    if (progressValue === 1) {
      if (type === exports.DataTransferType.Succeed) {
        progress == null ? void 0 : progress(progressValue);
      }
    } else {
      progress == null ? void 0 : progress(progressValue);
    }
  };

  const bodyConfig = await getNewBodyConfig({
    body: input.body,
    dataTransferCallback: n => triggerDataTransfer(exports.DataTransferType.Rw, n),
    makeRetryStream: undefined,
    enableCRC: this.opts.enableCRC,
    rateLimiter: input.rateLimiter
  });
  triggerDataTransfer(exports.DataTransferType.Started);

  const task = async () => {
    const res = await this._fetchObject(input, 'POST', {
      append: '',
      offset: normalizedInput.offset
    }, headers, bodyConfig.body || '', {
      handleResponse: res => ({ ...res.headers,
        nextAppendOffset: +res.headers['x-tos-next-append-offset'],
        hashCrc64ecma: res.headers['x-tos-hash-crc64ecma']
      }),
      axiosOpts: {
        [retryNamespace]: {
          beforeRetry: () => {
            consumedBytes = 0;
            bodyConfig.beforeRetry == null ? void 0 : bodyConfig.beforeRetry();
          },
          makeRetryStream: bodyConfig.makeRetryStream
        },
        onUploadProgress: event => {
          triggerDataTransfer(exports.DataTransferType.Rw, event.loaded - consumedBytes);
        }
      }
    });

    if (this.opts.enableCRC && bodyConfig.crc) {
      const appendObjectCrc = combineCrc64(normalizedInput.preHashCrc64ecma || '0', bodyConfig.crc.getCrc64(), totalSize);
      checkCRC64WithHeaders(appendObjectCrc, res.headers);
    }

    return res;
  };

  const [err, res] = await safeAwait(task());

  if (err || !res) {
    triggerDataTransfer(exports.DataTransferType.Failed);
    throw err;
  }

  triggerDataTransfer(exports.DataTransferType.Succeed);
  return res;
}

async function setObjectMeta(input) {
  const normalizedInput = typeof input === 'string' ? {
    key: input
  } : input;
  const headers = normalizedInput.headers = normalizeHeadersKey(normalizedInput.headers);
  fillRequestHeaders(normalizedInput, ['cacheControl', 'contentDisposition', 'contentEncoding', 'contentLanguage', 'contentType', 'expires', 'meta']);
  const query = {
    metadata: ''
  };

  if (normalizedInput.versionId) {
    query.versionId = normalizedInput.versionId;
  }

  return this._fetchObject(input, 'POST', query, headers);
}

async function uploadPartCopy(input) {
  const {
    uploadId,
    partNumber
  } = input;
  const headers = normalizeHeadersKey(input.headers);
  input.headers = headers;
  fillRequestHeaders(input, ['copySourceRange', 'copySourceSSECAlgorithm', 'copySourceSSECKey', 'copySourceSSECKeyMD5', 'ssecAlgorithm', 'ssecKey', 'ssecKeyMD5', 'trafficLimit']);

  if (input.srcBucket && input.srcKey) {
    var _headers$xTosCopyS;

    let copySource = getCopySourceHeaderValue(input.srcBucket, input.srcKey);

    if (input.srcVersionID) {
      copySource += `?versionId=${input.srcVersionID}`;
    }

    headers['x-tos-copy-source'] = (_headers$xTosCopyS = headers['x-tos-copy-source']) != null ? _headers$xTosCopyS : copySource;
  }

  if (input.copySourceRange == null && (input.copySourceRangeStart != null || input.copySourceRangeEnd != null)) {
    var _headers$xTosCopyS2;

    const start = input.copySourceRangeStart != null ? `${input.copySourceRangeStart}` : '';
    const end = input.copySourceRangeEnd != null ? `${input.copySourceRangeEnd}` : '';
    const copyRange = `bytes=${start}-${end}`;
    headers['x-tos-copy-source-range'] = (_headers$xTosCopyS2 = headers['x-tos-copy-source-range']) != null ? _headers$xTosCopyS2 : copyRange;
  }

  const [err, res] = await safeAwait(this._fetchObject(input, 'PUT', {
    partNumber,
    uploadId
  }, headers, undefined, {
    handleResponse(response) {
      return { ...response.data,
        SSECAlgorithm: response.headers[requestHeadersMap['ssecAlgorithm']],
        SSECKeyMD5: response.headers[requestHeadersMap['ssecKeyMD5']]
      };
    }

  }));

  if (err || !res || !res.data.ETag) {
    // TODO: throw TosServerErr
    throw err;
  }

  return res;
}

class EmptyReadStream extends stream.Readable {
  _read() {
    this.push(null);
  }

}

(function (UploadEventType) {
  UploadEventType[UploadEventType["CreateMultipartUploadSucceed"] = 1] = "CreateMultipartUploadSucceed";
  UploadEventType[UploadEventType["CreateMultipartUploadFailed"] = 2] = "CreateMultipartUploadFailed";
  UploadEventType[UploadEventType["UploadPartSucceed"] = 3] = "UploadPartSucceed";
  UploadEventType[UploadEventType["UploadPartFailed"] = 4] = "UploadPartFailed";
  UploadEventType[UploadEventType["UploadPartAborted"] = 5] = "UploadPartAborted";
  UploadEventType[UploadEventType["CompleteMultipartUploadSucceed"] = 6] = "CompleteMultipartUploadSucceed";
  UploadEventType[UploadEventType["CompleteMultipartUploadFailed"] = 7] = "CompleteMultipartUploadFailed";
})(exports.UploadEventType || (exports.UploadEventType = {}));

const CHECKPOINT_FILE_NAME_PLACEHOLDER = '@@checkpoint-file-placeholder@@';
const FILE_PARAM_CHECK_MSG = '`file` must be string, Buffer, File or Blob';
const ABORT_ERROR_STATUS_CODE = [403, 404, 405];
async function uploadFile(input) {
  var _checkpointRichInfo$r3, _checkpointRichInfo$r4, _checkpointRichInfo$r5;

  const {
    cancelToken,
    enableContentMD5 = false
  } = input;
  const headers = normalizeHeadersKey(input.headers);
  input.headers = headers;
  fillRequestHeaders(input, ['encodingType', 'cacheControl', 'contentDisposition', 'contentEncoding', 'contentLanguage', 'contentType', 'expires', 'acl', 'grantFullControl', 'grantRead', 'grantReadAcp', 'grantWriteAcp', 'ssecAlgorithm', 'ssecKey', 'ssecKeyMD5', 'serverSideEncryption', 'meta', 'websiteRedirectLocation', 'storageClass']);

  const isCancel = () => cancelToken && !!cancelToken.reason;

  validateCheckpoint(input.checkpoint);
  const fileStats = await (async () => {
    if ( typeof input.file === 'string') {
      return stat(input.file);
    }

    return null;
  })();
  const fileSize = await (async () => {
    const {
      file
    } = input;

    if (fileStats) {
      return fileStats.size;
    }

    if (isBuffer(file)) {
      return file.length;
    }

    if (isBlob(file)) {
      return file.size;
    }

    throw new TosClientError(FILE_PARAM_CHECK_MSG);
  })();
  const checkpointRichInfo = await (async () => {
    {
      if (typeof input.checkpoint === 'string') {
        const {
          checkpoint
        } = input; // file doesn't exist when stat is null

        let checkpointStat = null;

        try {
          checkpointStat = await stat(checkpoint);
        } catch (_err) {
          // TODO: remove any
          const err = _err;

          if (err.code === 'ENOENT') ; else {
            throw err;
          }
        }

        const isDirectory = (() => {
          if (checkpointStat) {
            return checkpointStat.isDirectory();
          }

          return checkpoint.endsWith('/');
        })(); // TODO: this is not a right decision
        // filePath will generated by uploadId, use placeholder temporarily


        const filePath = isDirectory ? path.resolve(checkpoint, CHECKPOINT_FILE_NAME_PLACEHOLDER) : // ensure relative path require
        path.resolve(checkpoint);
        const dirPath = path.dirname(filePath); // ensure directory exist

        await mkdir(dirPath, {
          recursive: true
        });

        if (isDirectory) {
          return {
            filePath,
            filePathIsPlaceholder: true
          };
        }

        try {
          const record = checkpointStat ? JSON.parse(await readFile(filePath, 'utf-8')) : undefined;
          return {
            filePath,
            filePathIsPlaceholder: false,
            // filePath is json file
            // TODO: validate json schema
            record
          };
        } catch (error) {
          console.warn('the checkpoint file is invalid JSON format. please check checkpoint file');
          throw error;
        }
      }
    }

    if (typeof input.checkpoint === 'object') {
      return {
        record: input.checkpoint
      };
    }

    return {};
  })(); // check if file info is matched

  await (async () => {
    var _checkpointRichInfo$r;

    if (fileStats && (_checkpointRichInfo$r = checkpointRichInfo.record) != null && _checkpointRichInfo$r.file_info) {
      var _checkpointRichInfo$r2;

      const {
        last_modified,
        file_size
      } = (_checkpointRichInfo$r2 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r2.file_info;

      if (fileStats.mtimeMs !== last_modified || fileStats.size !== file_size) {
        console.warn(`The file has been modified since ${new Date(last_modified)}, so the checkpoint file is invalid, and specified file will be uploaded again.`);
        delete checkpointRichInfo.record;
      }
    }
  })();
  const partSize = calculateSafePartSize(fileSize, input.partSize || ((_checkpointRichInfo$r3 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r3.part_size) || DEFAULT_PART_SIZE, true); // check partSize is matched

  if (checkpointRichInfo.record && checkpointRichInfo.record.part_size !== partSize) {
    console.warn('The partSize param does not equal the partSize in checkpoint file, ' + 'so the checkpoint file is invalid, and specified file will be uploaded again.');
    delete checkpointRichInfo.record;
  }

  let bucket = input.bucket || this.opts.bucket || '';
  const key = input.key;
  let uploadId = '';
  let tasks = [];
  const allTasks = getAllTasks(fileSize, partSize);
  const initConsumedBytes = (((_checkpointRichInfo$r4 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r4.parts_info) || []).filter(it => it.is_completed).reduce((prev, it) => prev + it.part_size, 0);
  let consumedBytesForProgress = initConsumedBytes; // recorded tasks

  const recordedTasks = ((_checkpointRichInfo$r5 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r5.parts_info) || [];
  const recordedTaskMap = new Map();
  recordedTasks.forEach(it => recordedTaskMap.set(it.part_number, it));

  const getCheckpointContent = () => {
    const checkpointContent = {
      bucket,
      key,
      part_size: partSize,
      upload_id: uploadId,
      parts_info: recordedTasks
    };

    if (fileStats) {
      checkpointContent.file_info = {
        last_modified: fileStats.mtimeMs,
        file_size: fileStats.size
      };
    }

    return checkpointContent;
  };

  const triggerUploadEvent = e => {
    if (!input.uploadEventChange) {
      return;
    }

    const event = {
      bucket,
      uploadId,
      key,
      ...e
    };

    if (checkpointRichInfo.filePath) {
      event.checkpointFile = checkpointRichInfo.filePath;
    }

    input.uploadEventChange(event);
  };

  let TriggerProgressEventType;

  (function (TriggerProgressEventType) {
    TriggerProgressEventType[TriggerProgressEventType["start"] = 1] = "start";
    TriggerProgressEventType[TriggerProgressEventType["uploadPartSucceed"] = 2] = "uploadPartSucceed";
    TriggerProgressEventType[TriggerProgressEventType["completeMultipartUploadSucceed"] = 3] = "completeMultipartUploadSucceed";
  })(TriggerProgressEventType || (TriggerProgressEventType = {}));

  const triggerProgressEvent = type => {
    if (!input.progress) {
      return;
    }

    const percent = (() => {
      if (type === TriggerProgressEventType.start && fileSize === 0) {
        return 0;
      }

      return !fileSize ? 1 : consumedBytesForProgress / fileSize;
    })();

    if (consumedBytesForProgress === fileSize && type === TriggerProgressEventType.uploadPartSucceed) ; else {
      input.progress(percent, getCheckpointContent());
    }
  };

  let consumedBytes = initConsumedBytes;
  const {
    dataTransferStatusChange
  } = input;

  const triggerDataTransfer = (type, rwOnceBytes = 0) => {
    if (!dataTransferStatusChange) {
      return;
    }

    consumedBytes += rwOnceBytes;
    dataTransferStatusChange == null ? void 0 : dataTransferStatusChange({
      type,
      rwOnceBytes,
      consumedBytes,
      totalBytes: fileSize
    });
  };

  const writeCheckpointFile = async () => {
    if ( checkpointRichInfo.filePath) {
      const content = JSON.stringify(getCheckpointContent(), null, 2);
      const dirPath = path.dirname(checkpointRichInfo.filePath); // ensure directory exist

      await mkdir(dirPath, {
        recursive: true
      });
      await writeFile(checkpointRichInfo.filePath, content, 'utf-8');
    }
  };

  const rmCheckpointFile = async () => {
    if ( checkpointRichInfo.filePath) {
      await rm(checkpointRichInfo.filePath).catch(err => {
        // eat err
        console.warn('remove checkpoint file failure, you can remove it by hand.\n', `checkpoint file path: ${checkpointRichInfo.filePath}\n`, err.message);
      });
    }
  };
  /**
   *
   * @param task one part task
   * @param uploadPartRes upload part failed if `uploadPartRes` is Error
   */


  const updateAfterUploadPart = async (task, uploadPartRes) => {
    let existRecordTask = recordedTaskMap.get(task.partNumber);

    if (!existRecordTask) {
      existRecordTask = {
        part_number: task.partNumber,
        offset: task.offset,
        part_size: task.partSize,
        is_completed: false,
        etag: '',
        hash_crc64ecma: ''
      };
      recordedTasks.push(existRecordTask);
      recordedTaskMap.set(existRecordTask.part_number, existRecordTask);
    }

    if (!uploadPartRes.err) {
      existRecordTask.is_completed = true;
      existRecordTask.etag = uploadPartRes.res.ETag;
      existRecordTask.hash_crc64ecma = uploadPartRes.res.hashCrc64ecma;
    }

    await writeCheckpointFile();
    const uploadPartInfo = {
      partNumber: existRecordTask.part_number,
      partSize: existRecordTask.part_size,
      offset: existRecordTask.offset
    };

    if (uploadPartRes.err) {
      const err = uploadPartRes.err;
      let type = exports.UploadEventType.UploadPartFailed;

      if (err instanceof TosServerError) {
        if (ABORT_ERROR_STATUS_CODE.includes(err.statusCode)) {
          type = exports.UploadEventType.UploadPartAborted;
        }
      }

      triggerUploadEvent({
        type,
        err,
        uploadPartInfo
      });
      return;
    }

    uploadPartInfo.etag = uploadPartRes.res.ETag;
    consumedBytesForProgress += uploadPartInfo.partSize;
    triggerUploadEvent({
      type: exports.UploadEventType.UploadPartSucceed,
      uploadPartInfo
    });
    triggerProgressEvent(TriggerProgressEventType.uploadPartSucceed);
  };

  if (checkpointRichInfo.record) {
    bucket = checkpointRichInfo.record.bucket;
    uploadId = checkpointRichInfo.record.upload_id; // checkpoint info exists, so need to calculate remain tasks

    const uploadedPartSet = new Set((checkpointRichInfo.record.parts_info || []).filter(it => it.is_completed).map(it => it.part_number));
    tasks = allTasks.filter(it => !uploadedPartSet.has(it.partNumber));
  } else {
    // createMultipartUpload will check bucket
    try {
      const {
        data: multipartRes
      } = await createMultipartUpload.call(this, input);

      if (isCancel()) {
        throw new CancelError('cancel uploadFile');
      }

      bucket = multipartRes.Bucket;
      uploadId = multipartRes.UploadId;

      if (checkpointRichInfo.filePathIsPlaceholder) {
        var _checkpointRichInfo$f;

        checkpointRichInfo.filePath = (_checkpointRichInfo$f = checkpointRichInfo.filePath) == null ? void 0 : _checkpointRichInfo$f.replace(`${CHECKPOINT_FILE_NAME_PLACEHOLDER}`, getDefaultCheckpointFilePath(bucket, key));
      }

      triggerUploadEvent({
        type: exports.UploadEventType.CreateMultipartUploadSucceed
      });
    } catch (_err) {
      const err = _err;
      triggerUploadEvent({
        type: exports.UploadEventType.CreateMultipartUploadFailed,
        err
      });
      throw err;
    }

    tasks = allTasks;
  }

  triggerProgressEvent(TriggerProgressEventType.start);

  const handleTasks = async () => {
    let firstErr = null;
    let index = 0; // TODO: how to test parallel does work, measure time is not right

    await Promise.all(Array.from({
      length: input.taskNum || 1
    }).map(async () => {
      while (true) {
        const currentIndex = index++;

        if (currentIndex >= tasks.length) {
          return;
        }

        const curTask = tasks[currentIndex];
        let consumedBytesThisTask = 0;

        try {
          const {
            data: uploadPartRes
          } = await _uploadPart.call(this, {
            bucket,
            key,
            uploadId,
            body: getBody(input.file, curTask),
            enableContentMD5,
            makeRetryStream: getMakeRetryStream(input.file, curTask),
            beforeRetry: () => {
              consumedBytes -= consumedBytesThisTask;
              consumedBytesThisTask = 0;
            },
            partNumber: curTask.partNumber,
            headers: {
              ['content-length']: `${curTask.partSize}`,
              ['x-tos-server-side-encryption-customer-algorithm']: headers['x-tos-server-side-encryption-customer-algorithm'],
              ['x-tos-server-side-encryption-customer-key']: headers['x-tos-server-side-encryption-customer-key'],
              ['x-tos-server-side-encryption-customer-key-md5']: headers['x-tos-server-side-encryption-customer-key-md5']
            },

            dataTransferStatusChange(status) {
              if (status.type !== exports.DataTransferType.Rw) {
                return;
              }

              if (isCancel()) {
                return;
              }

              consumedBytesThisTask += status.rwOnceBytes;
              triggerDataTransfer(status.type, status.rwOnceBytes);
            },

            trafficLimit: input.trafficLimit,
            rateLimiter: input.rateLimiter
          });

          if (isCancel()) {
            throw new CancelError('cancel uploadFile');
          }

          await updateAfterUploadPart(curTask, {
            res: uploadPartRes
          });
        } catch (_err) {
          const err = _err;
          consumedBytes -= consumedBytesThisTask;
          consumedBytesThisTask = 0;

          if (isCancelError(err)) {
            throw err;
          }

          if (isCancel()) {
            throw new CancelError('cancel uploadFile');
          }

          if (!firstErr) {
            firstErr = err;
          }

          await updateAfterUploadPart(curTask, {
            err
          });
        }
      }
    }));

    if (firstErr) {
      throw firstErr;
    }

    const parts = (getCheckpointContent().parts_info || []).map(it => ({
      eTag: it.etag,
      partNumber: it.part_number
    }));
    const [err, res] = await safeAwait(completeMultipartUpload.call(this, {
      bucket,
      key,
      uploadId,
      parts
    }));

    if (err || !res) {
      triggerUploadEvent({
        type: exports.UploadEventType.CompleteMultipartUploadFailed
      });
      throw err;
    }

    triggerUploadEvent({
      type: exports.UploadEventType.CompleteMultipartUploadSucceed
    });
    triggerProgressEvent(TriggerProgressEventType.completeMultipartUploadSucceed);
    await rmCheckpointFile();

    if (this.opts.enableCRC && res.data.HashCrc64ecma && combineCRCInParts(getCheckpointContent()) !== res.data.HashCrc64ecma) {
      throw new TosClientError('crc of entire file mismatch.');
    }

    return res;
  };

  triggerDataTransfer(exports.DataTransferType.Started);
  const [err, res] = await safeAwait(handleTasks());

  if (err || !res) {
    triggerDataTransfer(exports.DataTransferType.Failed);
    throw err;
  }

  triggerDataTransfer(exports.DataTransferType.Succeed);
  return res;
}
/**
 * 即使 totalSize 是 0，也需要一个 Part，否则 Server 端会报错 read request body failed
 */

function getAllTasks(totalSize, partSize) {
  const tasks = [];

  for (let i = 0;; ++i) {
    const offset = i * partSize;
    const currPartSize = Math.min(partSize, totalSize - offset);
    tasks.push({
      offset,
      partSize: currPartSize,
      partNumber: i + 1
    });

    if ((i + 1) * partSize >= totalSize) {
      break;
    }
  }

  return tasks;
}

function getBody(file, task) {
  const {
    offset: start,
    partSize
  } = task;
  const end = start + partSize;
  const makeRetryStream = getMakeRetryStream(file, task);

  if (makeRetryStream) {
    return makeRetryStream();
  }

  if (isBlob(file)) {
    return file.slice(start, end);
  }

  if (isBuffer(file)) {
    return file.slice(start, end);
  }

  throw new TosClientError(FILE_PARAM_CHECK_MSG);
}

function getMakeRetryStream(file, task) {
  const {
    offset: start,
    partSize
  } = task;
  const end = start + partSize;

  if ( typeof file === 'string') {
    return () => {
      if (!partSize) {
        return new EmptyReadStream();
      }

      return createReadStream(file, {
        start,
        end: end - 1
      });
    };
  }

  return undefined;
}

function getDefaultCheckpointFilePath(bucket, key) {
  const originPath = `${key}.${hashMd5$2(`${bucket}.${key}`, 'hex')}.upload`;
  const normalizePath = originPath.replace(/[\\/]/g, '');
  return normalizePath;
}

function combineCRCInParts(cp) {
  var _cp$file_info;

  const size = ((_cp$file_info = cp.file_info) == null ? void 0 : _cp$file_info.file_size) || 0;
  let res = '0';

  for (const part of cp.parts_info || []) {
    res = combineCrc64(res, part.hash_crc64ecma, Math.min(part.part_size, size - part.offset));
  }

  return res;
}

async function calculatePostSignature(input) {
  validateObjectName(input);
  input = this.normalizeObjectInput(input);
  const {
    expiresIn = 3600,
    key
  } = input;
  const bucket = input.bucket || this.opts.bucket;
  const fields = { ...input.fields
  };
  const conditions = [...(input.conditions || [])];

  if (!bucket) {
    throw new TosClientError('Must provide bucket param');
  }

  const accessKeySecret = this.opts.accessKeySecret;
  const date = new Date();
  const expirationDateStr = getDateTimeStr({
    date: new Date(date.valueOf() + expiresIn * 1000),
    type: 'ISO'
  });
  const dateStr = getDateTimeStr();
  const date8Str = dateStr.substring(0, 8);
  const service = 'tos';
  const requestStr = 'request';
  const kDate = hmacSha256$1(accessKeySecret, date8Str);
  const kRegion = hmacSha256$1(kDate, this.opts.region);
  const kService = hmacSha256$1(kRegion, service);
  const signingKey = hmacSha256$1(kService, requestStr);
  const credential = [this.opts.accessKeyId, date8Str, this.opts.region, service, requestStr].join('/');
  const addedInForm = {
    key,
    'x-tos-algorithm': 'TOS4-HMAC-SHA256',
    'x-tos-date': dateStr,
    'x-tos-credential': credential
  };

  if (this.opts.stsToken) {
    addedInForm['x-tos-security-token'] = this.opts.stsToken;
  }

  conditions.push({
    bucket
  });
  Object.entries(addedInForm).forEach(([key, value]) => {
    fields[key] = value;
  });
  Object.entries(fields).forEach(([key, value]) => {
    conditions.push({
      [key]: `${value}`
    });
  });
  const policy = {
    expiration: expirationDateStr,
    conditions
  };
  const policyStr = JSON.stringify(policy);
  const policyBase64 = stringify$1(parse$1(policyStr, 'utf-8'), 'base64');
  const signature = hmacSha256$1(signingKey, policyBase64, 'hex');
  fields.policy = policyBase64;
  fields['x-tos-signature'] = signature;
  return fields;
}
/**
 *
 * Z for 20130728T000000Z
 * ISO for 2007-12-01T12:00:00.000Z
 * @param opt
 * @returns
 */

function getDateTimeStr(opt) {
  const {
    date = new Date(),
    type = 'Z'
  } = opt || {};

  if (type === 'ISO') {
    return date.toISOString();
  }

  const dateTime = date.toISOString().replace(/\..+/, '').replace(/-/g, '').replace(/:/g, '') + 'Z';
  return dateTime;
}

(function (ACLType) {
  ACLType["ACLPrivate"] = "private";
  ACLType["ACLPublicRead"] = "public-read";
  ACLType["ACLPublicReadWrite"] = "public-read-write";
  ACLType["ACLAuthenticatedRead"] = "authenticated-read";
  ACLType["ACLBucketOwnerRead"] = "bucket-owner-read";
  ACLType["ACLBucketOwnerFullControl"] = "bucket-owner-full-control"; // only works for object ACL

  ACLType["ACLBucketOwnerEntrusted"] = "bucket-owner-entrusted";
})(exports.ACLType || (exports.ACLType = {}));

(function (StorageClassType) {
  // storage-class will inherit from bucket if uploading object without `x-tos-storage-class` header
  StorageClassType["StorageClassStandard"] = "STANDARD";
  StorageClassType["StorageClassIa"] = "IA";
  StorageClassType["StorageClassArchiveFr"] = "ARCHIVE_FR";
  StorageClassType["StorageClassColdArchive"] = "COLD_ARCHIVE";
  StorageClassType["StorageClassIntelligentTiering"] = "INTELLIGENT_TIERING";
  StorageClassType["StorageClassArchive"] = "ARCHIVE";
})(exports.StorageClassType || (exports.StorageClassType = {}));

(function (MetadataDirectiveType) {
  MetadataDirectiveType["MetadataDirectiveCopy"] = "COPY";
  MetadataDirectiveType["MetadataDirectiveReplace"] = "REPLACE";
})(exports.MetadataDirectiveType || (exports.MetadataDirectiveType = {}));

(function (AzRedundancyType) {
  AzRedundancyType["AzRedundancySingleAz"] = "single-az";
  AzRedundancyType["AzRedundancyMultiAz"] = "multi-az";
})(exports.AzRedundancyType || (exports.AzRedundancyType = {}));

(function (PermissionType) {
  PermissionType["PermissionRead"] = "READ";
  PermissionType["PermissionWrite"] = "WRITE";
  PermissionType["PermissionReadAcp"] = "READ_ACP";
  PermissionType["PermissionWriteAcp"] = "WRITE_ACP";
  PermissionType["PermissionFullControl"] = "FULL_CONTROL";
})(exports.PermissionType || (exports.PermissionType = {}));

(function (GranteeType) {
  GranteeType["GranteeGroup"] = "Group";
  GranteeType["GranteeUser"] = "CanonicalUser";
})(exports.GranteeType || (exports.GranteeType = {}));

(function (CannedType) {
  CannedType["CannedAllUsers"] = "AllUsers";
  CannedType["CannedAuthenticatedUsers"] = "AuthenticatedUsers";
})(exports.CannedType || (exports.CannedType = {}));

(function (HttpMethodType) {
  HttpMethodType["HttpMethodGet"] = "GET";
  HttpMethodType["HttpMethodPut"] = "PUT";
  HttpMethodType["HttpMethodPost"] = "POST";
  HttpMethodType["HttpMethodDelete"] = "DELETE";
  HttpMethodType["HttpMethodHead"] = "HEAD";
})(exports.HttpMethodType || (exports.HttpMethodType = {}));

(function (StorageClassInheritDirectiveType) {
  StorageClassInheritDirectiveType["StorageClassInheritDirectiveDestinationBucket"] = "DESTINATION_BUCKET";
  StorageClassInheritDirectiveType["StorageClassInheritDirectiveSourceObject"] = "SOURCE_OBJECT";
})(exports.StorageClassInheritDirectiveType || (exports.StorageClassInheritDirectiveType = {}));

(function (ReplicationStatusType) {
  ReplicationStatusType["Complete"] = "COMPLETE";
  ReplicationStatusType["Pending"] = "PENDING";
  ReplicationStatusType["Failed"] = "FAILED";
  ReplicationStatusType["Replica"] = "REPLICA";
})(exports.ReplicationStatusType || (exports.ReplicationStatusType = {}));

(function (LifecycleStatusType) {
  LifecycleStatusType["Enabled"] = "Enabled";
  LifecycleStatusType["Disabled"] = "Disabled";
})(exports.LifecycleStatusType || (exports.LifecycleStatusType = {}));

(function (RedirectType) {
  RedirectType["Mirror"] = "Mirror";
  RedirectType["Async"] = "Async";
})(exports.RedirectType || (exports.RedirectType = {}));

(function (StatusType) {
  StatusType["Enabled"] = "Enabled";
  StatusType["Disabled"] = "Disabled";
})(exports.StatusType || (exports.StatusType = {}));

(function (TierType) {
  TierType["TierStandard"] = "Standard";
  TierType["TierExpedited"] = "Expedited";
  TierType["TierBulk"] = "Bulk";
})(exports.TierType || (exports.TierType = {}));

(function (VersioningStatusType) {
  VersioningStatusType["Enabled"] = "Enabled";
  VersioningStatusType["Suspended"] = "Suspended";
  VersioningStatusType["NotSet"] = "";
  /**
   * @deprecated use `Enabled` instead
   */

  VersioningStatusType["Enable"] = "Enabled";
  /**
   * @deprecated use `NotSet` instead
   */

  VersioningStatusType["Disable"] = "";
})(exports.VersioningStatusType || (exports.VersioningStatusType = {}));

(function (ResumableCopyEventType) {
  ResumableCopyEventType[ResumableCopyEventType["CreateMultipartUploadSucceed"] = 1] = "CreateMultipartUploadSucceed";
  ResumableCopyEventType[ResumableCopyEventType["CreateMultipartUploadFailed"] = 2] = "CreateMultipartUploadFailed";
  ResumableCopyEventType[ResumableCopyEventType["UploadPartCopySucceed"] = 3] = "UploadPartCopySucceed";
  ResumableCopyEventType[ResumableCopyEventType["UploadPartCopyFailed"] = 4] = "UploadPartCopyFailed";
  ResumableCopyEventType[ResumableCopyEventType["UploadPartCopyAborted"] = 5] = "UploadPartCopyAborted";
  ResumableCopyEventType[ResumableCopyEventType["CompleteMultipartUploadSucceed"] = 6] = "CompleteMultipartUploadSucceed";
  ResumableCopyEventType[ResumableCopyEventType["CompleteMultipartUploadFailed"] = 7] = "CompleteMultipartUploadFailed";
})(exports.ResumableCopyEventType || (exports.ResumableCopyEventType = {}));

const CHECKPOINT_FILE_NAME_PLACEHOLDER$1 = '@@checkpoint-file-placeholder@@';
const ABORT_ERROR_STATUS_CODE$1 = [403, 404, 405];
const DEFAULT_PART_SIZE$1 = 20 * 1024 * 1024; // 20 MB

async function resumableCopyObject(input) {
  var _checkpointRichInfo$r3, _checkpointRichInfo$r4, _checkpointRichInfo$r5;

  const {
    cancelToken
  } = input;

  const isCancel = () => cancelToken && !!cancelToken.reason;

  validateCheckpoint(input.checkpoint);
  const {
    data: objectStats
  } = await headObject.call(this, {
    bucket: input.srcBucket,
    key: input.srcKey,
    versionId: input.srcVersionId
  });
  const etag = objectStats['etag'];
  const objectSize = +objectStats['content-length'];
  const checkpointRichInfo = await (async () => {
    {
      if (typeof input.checkpoint === 'string') {
        const {
          checkpoint
        } = input; // file doesn't exist when stat is null

        let checkpointStat = null;

        try {
          checkpointStat = await stat(checkpoint);
        } catch (_err) {
          // TODO: remove any
          const err = _err;

          if (err.code === 'ENOENT') ; else {
            throw err;
          }
        }

        const isDirectory = (() => {
          if (checkpointStat) {
            return checkpointStat.isDirectory();
          }

          return checkpoint.endsWith('/');
        })(); // filePath will generated by uploadId, use placeholder temporarily


        const filePath = isDirectory ? path.resolve(checkpoint, CHECKPOINT_FILE_NAME_PLACEHOLDER$1) : path.resolve(checkpoint);
        const dirPath = path.dirname(filePath); // ensure directory exist

        await mkdir(dirPath, {
          recursive: true
        });

        if (isDirectory) {
          return {
            filePath,
            filePathIsPlaceholder: true
          };
        }

        return {
          filePath,
          filePathIsPlaceholder: false,
          // filePath is json file
          // TODO: validate json schema
          record: checkpointStat ? JSON.parse(await readFile(filePath, 'utf-8')) : undefined
        };
      }
    }

    if (typeof input.checkpoint === 'object') {
      return {
        record: input.checkpoint
      };
    }

    return {};
  })(); // check if file info is matched

  await (async () => {
    var _checkpointRichInfo$r;

    if ((_checkpointRichInfo$r = checkpointRichInfo.record) != null && _checkpointRichInfo$r.copy_source_object_info) {
      var _checkpointRichInfo$r2;

      const {
        last_modified,
        object_size
      } = (_checkpointRichInfo$r2 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r2.copy_source_object_info;

      if ( // TODO: `last-modified` aligns to number
      objectStats['last-modified'] !== last_modified || +objectStats['content-length'] !== object_size) {
        console.warn(`The file has been modified since ${new Date(last_modified)}, so the checkpoint file is invalid, and specified file will be uploaded again.`);
        delete checkpointRichInfo.record;
      }
    }
  })();
  const partSize = calculateSafePartSize(objectSize, input.partSize || ((_checkpointRichInfo$r3 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r3.part_size) || DEFAULT_PART_SIZE$1, true); // check partSize is matched

  if (checkpointRichInfo.record && checkpointRichInfo.record.part_size !== partSize) {
    console.warn('The partSize param does not equal the partSize in checkpoint file, ' + 'so the checkpoint file is invalid, and specified file will be uploaded again.');
    delete checkpointRichInfo.record;
  }

  let bucket = input.bucket || this.opts.bucket || '';
  const key = input.key;
  let uploadId = '';
  let tasks = [];
  const allTasks = getAllTasks$1(objectSize, partSize);
  const initConsumedBytes = (((_checkpointRichInfo$r4 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r4.parts_info) || []).filter(it => it.is_completed).reduce((prev, it) => prev + it.copy_source_range_end - it.copy_source_range_start + 1, 0);
  let consumedBytesForProgress = initConsumedBytes; // recorded tasks

  const recordedTasks = ((_checkpointRichInfo$r5 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r5.parts_info) || [];
  const recordedTaskMap = new Map();
  recordedTasks.forEach(it => recordedTaskMap.set(it.part_number, it));

  const getCheckpointContent = () => {
    const checkpointContent = {
      bucket,
      key,
      part_size: partSize,
      upload_id: uploadId,
      parts_info: recordedTasks,
      copy_source_object_info: {
        last_modified: objectStats['last-modified'],
        etag: objectStats.etag,
        hash_crc64ecma: objectStats['x-tos-hash-crc64ecma'] || '',
        object_size: +objectStats['content-length']
      }
    };
    return checkpointContent;
  };

  const triggerUploadEvent = e => {
    if (!input.copyEventListener) {
      return;
    }

    const event = {
      bucket,
      uploadId,
      key,
      ...e
    };

    if (checkpointRichInfo.filePath) {
      event.checkpointFile = checkpointRichInfo.filePath;
    }

    input.copyEventListener(event);
  };

  let TriggerProgressEventType;

  (function (TriggerProgressEventType) {
    TriggerProgressEventType[TriggerProgressEventType["start"] = 1] = "start";
    TriggerProgressEventType[TriggerProgressEventType["uploadPartSucceed"] = 2] = "uploadPartSucceed";
    TriggerProgressEventType[TriggerProgressEventType["completeMultipartUploadSucceed"] = 3] = "completeMultipartUploadSucceed";
  })(TriggerProgressEventType || (TriggerProgressEventType = {}));

  const triggerProgressEvent = type => {
    if (!input.progress) {
      return;
    }

    const percent = (() => {
      if (type === TriggerProgressEventType.start && objectSize === 0) {
        return 0;
      }

      return !objectSize ? 1 : consumedBytesForProgress / objectSize;
    })();

    if (consumedBytesForProgress === objectSize && type === TriggerProgressEventType.uploadPartSucceed) ; else {
      input.progress(percent, getCheckpointContent());
    }
  };

  const writeCheckpointFile = async () => {
    if ( checkpointRichInfo.filePath) {
      const content = JSON.stringify(getCheckpointContent(), null, 2);
      const dirPath = path.dirname(checkpointRichInfo.filePath); // ensure directory exist

      await mkdir(dirPath, {
        recursive: true
      });
      await writeFile(checkpointRichInfo.filePath, content, 'utf-8');
    }
  };

  const rmCheckpointFile = async () => {
    if ( checkpointRichInfo.filePath) {
      await rm(checkpointRichInfo.filePath).catch(err => {
        // eat err
        console.warn('remove checkpoint file failure, you can remove it by hand.\n', `checkpoint file path: ${checkpointRichInfo.filePath}\n`, err.message);
      });
    }
  };
  /**
   *
   * @param task one part task
   * @param uploadPartRes upload part failed if `uploadPartRes` is Error
   */


  const updateAfterUploadPart = async (task, uploadPartRes) => {
    let existRecordTask = recordedTaskMap.get(task.partNumber);
    const rangeStart = task.offset;
    const rangeEnd = Math.min(task.offset + partSize - 1, objectSize - 1);

    if (!existRecordTask) {
      existRecordTask = {
        part_number: task.partNumber,
        copy_source_range_start: rangeStart,
        copy_source_range_end: rangeEnd,
        is_completed: false,
        etag: ''
      };
      recordedTasks.push(existRecordTask);
      recordedTaskMap.set(existRecordTask.part_number, existRecordTask);
    }

    if (!uploadPartRes.err) {
      existRecordTask.is_completed = true;
      existRecordTask.etag = uploadPartRes.res.ETag;
    }

    await writeCheckpointFile();
    const copyPartInfo = {
      partNumber: existRecordTask.part_number,
      copySourceRangeEnd: existRecordTask.copy_source_range_end,
      copySourceRangeStart: existRecordTask.copy_source_range_start
    };

    if (uploadPartRes.err) {
      const err = uploadPartRes.err;
      let type = exports.ResumableCopyEventType.UploadPartCopyFailed;

      if (err instanceof TosServerError) {
        if (ABORT_ERROR_STATUS_CODE$1.includes(err.statusCode)) {
          type = exports.ResumableCopyEventType.UploadPartCopyAborted;
        }
      }

      triggerUploadEvent({
        type,
        err,
        copyPartInfo
      });
      return;
    }

    copyPartInfo.etag = uploadPartRes.res.ETag;
    consumedBytesForProgress += copyPartInfo.copySourceRangeEnd - copyPartInfo.copySourceRangeStart + 1;
    triggerUploadEvent({
      type: exports.ResumableCopyEventType.UploadPartCopySucceed,
      copyPartInfo
    });
    triggerProgressEvent(TriggerProgressEventType.uploadPartSucceed);
  };

  if (checkpointRichInfo.record) {
    bucket = checkpointRichInfo.record.bucket;
    uploadId = checkpointRichInfo.record.upload_id; // checkpoint info exists, so need to calculate remain tasks

    const uploadedPartSet = new Set((checkpointRichInfo.record.parts_info || []).filter(it => it.is_completed).map(it => it.part_number));
    tasks = allTasks.filter(it => !uploadedPartSet.has(it.partNumber));
  } else {
    // createMultipartUpload will check bucket
    try {
      const {
        data: multipartRes
      } = await createMultipartUpload.call(this, cloneDeep(input));

      if (isCancel()) {
        throw new CancelError('cancel uploadFile');
      }

      bucket = multipartRes.Bucket;
      uploadId = multipartRes.UploadId;

      if (checkpointRichInfo.filePathIsPlaceholder) {
        var _checkpointRichInfo$f;

        checkpointRichInfo.filePath = (_checkpointRichInfo$f = checkpointRichInfo.filePath) == null ? void 0 : _checkpointRichInfo$f.replace(`${CHECKPOINT_FILE_NAME_PLACEHOLDER$1}`, getDefaultCheckpointFilePath$1({ ...input,
          bucket
        }));
      }

      triggerUploadEvent({
        type: exports.ResumableCopyEventType.CreateMultipartUploadSucceed
      });
    } catch (_err) {
      const err = _err;
      triggerUploadEvent({
        type: exports.ResumableCopyEventType.CreateMultipartUploadFailed,
        err
      });
      throw err;
    }

    tasks = allTasks;
  }

  const handleTasks = async () => {
    let firstErr = null;
    let index = 0; // TODO: how to test parallel does work, measure time is not right

    await Promise.all(Array.from({
      length: input.taskNum || 1
    }).map(async () => {
      while (true) {
        const currentIndex = index++;

        if (currentIndex >= tasks.length) {
          return;
        }

        const curTask = tasks[currentIndex];

        try {
          let copySource = getCopySourceHeaderValue(input.srcBucket, input.srcKey);

          if (input.srcVersionId) {
            copySource += `?versionId=${input.srcVersionId}`;
          }

          const copyRange = `bytes=${curTask.offset}-${curTask.offset + curTask.partSize - 1}`;
          const headers = { ...input.headers,
            ['x-tos-copy-source']: copySource,
            ['x-tos-copy-source-if-match']: etag,
            ['x-tos-copy-source-range']: copyRange
          };

          if (!curTask.partSize) {
            delete headers['x-tos-copy-source-range'];
          }

          const {
            data: uploadPartRes
          } = await uploadPartCopy.call(this, {
            bucket,
            key,
            uploadId,
            partNumber: curTask.partNumber,
            headers,
            trafficLimit: input.trafficLimit
          });

          if (isCancel()) {
            throw new CancelError('cancel resumableCopyObject');
          }

          await updateAfterUploadPart(curTask, {
            res: uploadPartRes
          });
        } catch (_err) {
          const err = _err;

          if (isCancelError$1(err)) {
            throw err;
          }

          if (isCancel()) {
            throw new CancelError('cancel resumableCopyObject');
          }

          if (!firstErr) {
            firstErr = err;
          }

          await updateAfterUploadPart(curTask, {
            err
          });
        }
      }
    }));

    if (firstErr) {
      throw firstErr;
    }

    const parts = (getCheckpointContent().parts_info || []).map(it => ({
      eTag: it.etag,
      partNumber: it.part_number
    }));
    const [err, res] = await safeAwait(completeMultipartUpload.call(this, {
      bucket,
      key,
      uploadId,
      parts
    }));

    if (err || !res) {
      triggerUploadEvent({
        type: exports.ResumableCopyEventType.CompleteMultipartUploadFailed
      });
      throw err;
    }

    triggerUploadEvent({
      type: exports.ResumableCopyEventType.CompleteMultipartUploadSucceed
    });
    triggerProgressEvent(TriggerProgressEventType.completeMultipartUploadSucceed);
    await rmCheckpointFile();
    return res;
  };

  const handleEmptyObj = async () => {
    let copySource = getCopySourceHeaderValue(input.srcBucket, input.srcKey);

    if (input.srcVersionId) {
      copySource += `?versionId=${input.srcVersionId}`;
    }

    const headers = { ...input.headers,
      ['x-tos-copy-source']: copySource,
      ['x-tos-copy-source-if-match']: etag
    };
    const [err, res] = await safeAwait(copyObject.call(this, {
      bucket: input.bucket,
      key: input.key,
      headers,
      trafficLimit: input.trafficLimit
    }));

    if (err || !res) {
      triggerUploadEvent({
        type: exports.ResumableCopyEventType.UploadPartCopyFailed
      });
      throw err;
    }

    triggerProgressEvent(TriggerProgressEventType.completeMultipartUploadSucceed);
    triggerUploadEvent({
      type: exports.ResumableCopyEventType.UploadPartCopySucceed,
      copyPartInfo: {
        partNumber: 0,
        copySourceRangeStart: 0,
        copySourceRangeEnd: 0
      }
    });
    triggerUploadEvent({
      type: exports.ResumableCopyEventType.CompleteMultipartUploadSucceed
    });
    return { ...res,
      data: {
        ETag: res.headers['etag'] || '',
        Bucket: bucket,
        Key: key,
        Location: `http${this.opts.secure ? 's' : ''}://${bucket}.${this.opts.endpoint}/${key}`,
        VersionID: res.headers['x-tos-version-id'],
        HashCrc64ecma: res.headers['x-tos-hash-crc64ecma']
      }
    };
  };

  triggerProgressEvent(TriggerProgressEventType.start);
  return objectSize === 0 ? handleEmptyObj() : handleTasks();
}
function isCancelError$1(err) {
  return err instanceof CancelError;
}
/**
 * 即使 totalSize 是 0，也需要一个 Part，否则 Server 端会报错 read request body failed
 */

function getAllTasks$1(totalSize, partSize) {
  const tasks = [];

  for (let i = 0;; ++i) {
    const offset = i * partSize;
    const currPartSize = Math.min(partSize, totalSize - offset);
    tasks.push({
      offset,
      partSize: currPartSize,
      partNumber: i + 1
    });

    if ((i + 1) * partSize >= totalSize) {
      break;
    }
  }

  return tasks;
}

function getDefaultCheckpointFilePath$1(opts) {
  const originPath = [opts.srcBucket, opts.srcKey, opts.srcVersionId, opts.bucket, opts.key, 'copy'].filter(Boolean).join('.');
  const normalizePath = originPath.replace(/[\\/]/g, '');
  return normalizePath;
}

const defaultEmptyMethodMap = {
  getBucketCustomDomain: true,
  getBucketIntelligenttiering: true,
  getBucketInventory: true,
  listBucketInventory: true,
  getBucketMirrorBack: true,
  getBucketNotification: true,
  getBucketPolicy: true,
  getBucketRealTimeLog: true,
  getBucketReplication: true,
  getBucketTagging: true,
  getBucketWebsite: true
};
function handleEmptyServerError(err, opts) {
  const {
    enableCatchEmptyServerError,
    methodKey,
    defaultResponse
  } = opts;

  if (err instanceof TosServerError) {
    if (enableCatchEmptyServerError) {
      if (err.statusCode === 404) {
        return getNormalDataFromError(defaultResponse, err);
      }
    } // 在本次更改前已经有一些接口对404做了catch处理，在不显式声明enableCatchEmptyServerError的情况下，保持原样，不做break change
    else if (enableCatchEmptyServerError === undefined) {
      if (err.statusCode === 404 && defaultEmptyMethodMap[methodKey]) {
        return getNormalDataFromError(defaultResponse, err);
      }
    }
  }

  throw err;
}

async function putBucketPolicy(input) {
  if ((this.opts.enableOptimizeMethodBehavior || this.opts.enableOptimizeMethodBehavior === undefined) && !input.policy.Statement.length) {
    return deleteBucketPolicy.call(this, input.bucket);
  }

  const res = await this.fetchBucket(input.bucket, 'PUT', {
    policy: ''
  }, {}, input.policy, {
    needMd5: true
  });
  return res;
}
async function getBucketPolicy(bucket) {
  try {
    const res = await this.fetchBucket(bucket, 'GET', {
      policy: ''
    }, {});
    res.data.Statement.forEach(it => {
      const arrayProp = makeArrayProp(it);
      Object.keys(it.Condition || {}).forEach(key => {
        Object.keys(it.Condition[key]).forEach(key2 => {
          arrayProp(`Condition["${key}"]["${key2}"]`);
        });
      });
    });
    return res;
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketPolicy',
      defaultResponse: {
        Statement: [],
        Version: '2012-10-17'
      }
    });
  }
}
async function deleteBucketPolicy(bucket) {
  return this.fetchBucket(bucket, 'DELETE', {
    policy: ''
  }, {});
}

async function getBucketVersioning(bucket) {
  return this.fetchBucket(bucket, 'GET', {
    versioning: ''
  }, {});
}
async function putBucketVersioning(input) {
  return this.fetchBucket(input.bucket, 'PUT', {
    versioning: ''
  }, {}, {
    Status: input.status
  });
}

function preSignedPolicyURL(input) {
  const normalizedInput = normalizeInput.call(this, input);
  validateConditions(input.conditions);
  const endpoint = input.alternativeEndpoint || (input.isCustomDomain ? this.opts.endpoint : `${normalizedInput.bucket}.${this.opts.endpoint}`);
  const baseURL = `http${this.opts.secure ? 's' : ''}://${endpoint}`;
  const query = this.getSignatureQuery({
    bucket: normalizedInput.bucket,
    expires: normalizedInput.expires,
    policy: {
      conditions: normalizedInput.conditions
    }
  });
  const queryStr = obj2QueryStr(query);

  const getSignedURLForList = additionalQuery => {
    const str2 = obj2QueryStr(additionalQuery);
    const q = [queryStr, str2].filter(Boolean).join('&');
    return `${baseURL}?${q}`;
  };

  const getSignedURLForGetOrHead = (key, additionalQuery) => {
    const str2 = obj2QueryStr(additionalQuery);
    const q = [queryStr, str2].filter(Boolean).join('&'); // keep   '/'

    const keyPath = key.split('/').map(it => encodeURIComponent(it)).join('/');
    return `${baseURL}/${keyPath}?${q}`;
  };

  return {
    getSignedURLForList,
    getSignedURLForGetOrHead,
    signedQuery: queryStr
  };
}

function normalizeInput(input) {
  const actualBucket = input.bucket || this.opts.bucket;
  const defaultExpires = 3600;

  if (!actualBucket) {
    throw new TosClientError('Must provide bucket param');
  }

  validateConditions(input.conditions);
  const normalizedConditions = input.conditions.map(it => [it.operator || 'eq', '$key', it.value]);
  normalizedConditions.push(['eq', '$bucket', actualBucket]);
  return {
    bucket: actualBucket,
    expires: input.expires || defaultExpires,
    conditions: normalizedConditions
  };
}

function validateConditions(conditions) {
  if (conditions.length < 1) {
    throw new TosClientError('The `conditions` field of `PreSignedPolicyURLInput` must has one item at least');
  }

  for (const it of conditions) {
    if (it.key !== 'key') {
      throw new TosClientError("The `key` field of `PolicySignatureCondition` must be `'key'`");
    }

    if (it.operator && it.operator !== 'eq' && it.operator !== 'starts-with') {
      throw new TosClientError("The `operator` field of `PolicySignatureCondition` must be `'eq'` or `'starts-with'`");
    }
  }
}

(function (DownloadEventType) {
  DownloadEventType[DownloadEventType["CreateTempFileSucceed"] = 1] = "CreateTempFileSucceed";
  DownloadEventType[DownloadEventType["CreateTempFileFailed"] = 2] = "CreateTempFileFailed";
  DownloadEventType[DownloadEventType["DownloadPartSucceed"] = 3] = "DownloadPartSucceed";
  DownloadEventType[DownloadEventType["DownloadPartFailed"] = 4] = "DownloadPartFailed";
  DownloadEventType[DownloadEventType["DownloadPartAborted"] = 5] = "DownloadPartAborted";
  DownloadEventType[DownloadEventType["RenameTempFileSucceed"] = 6] = "RenameTempFileSucceed";
  DownloadEventType[DownloadEventType["RenameTempFileFailed"] = 7] = "RenameTempFileFailed";
})(exports.DownloadEventType || (exports.DownloadEventType = {}));

const CHECKPOINT_FILE_NAME_PLACEHOLDER$2 = '@@checkpoint-file-placeholder@@';
const ABORT_ERROR_STATUS_CODE$2 = [403, 404, 405];
async function downloadFile(input) {
  var _checkpointRichInfo$r3, _checkpointRichInfo$r4, _checkpointRichInfo$r5;

  const {
    cancelToken,
    versionId
  } = input;

  const isCancel = () => cancelToken && !!cancelToken.reason;

  validateCheckpoint(input.checkpoint);
  const headObjectRes = await headObject.call(this, {
    bucket: input.bucket,
    key: input.key,
    versionId
  });
  const {
    data: objectStats
  } = headObjectRes;
  const etag = objectStats['etag'];
  const objectSize = +objectStats['content-length'];
  const checkpointRichInfo = await (async () => {
    {
      if (typeof input.checkpoint === 'string') {
        const {
          checkpoint
        } = input; // file doesn't exist when stat is null

        let checkpointStat = null;

        try {
          checkpointStat = await stat(checkpoint);
        } catch (_err) {
          // TODO: remove any
          const err = _err;

          if (err.code === 'ENOENT') ; else {
            throw err;
          }
        }

        const isDirectory = (() => {
          if (checkpointStat) {
            return checkpointStat.isDirectory();
          }

          return checkpoint.endsWith('/');
        })(); // filePath will generated by uploadId, use placeholder temporarily


        const filePath = isDirectory ? path.resolve(checkpoint, CHECKPOINT_FILE_NAME_PLACEHOLDER$2) : checkpoint;
        const dirPath = path.dirname(filePath); // ensure directory exist

        await mkdir(dirPath, {
          recursive: true
        });

        if (isDirectory) {
          return {
            filePath,
            filePathIsPlaceholder: true
          };
        }

        return {
          filePath,
          filePathIsPlaceholder: false,
          // filePath is json file
          // TODO: validate json schema
          record: checkpointStat ? JSON.parse(await readFile(filePath, 'utf-8')) : undefined
        };
      }
    }

    if (typeof input.checkpoint === 'object') {
      return {
        record: input.checkpoint
      };
    }

    return {};
  })(); // check if file info is matched

  await (async () => {
    var _checkpointRichInfo$r;

    if ((_checkpointRichInfo$r = checkpointRichInfo.record) != null && _checkpointRichInfo$r.object_info) {
      var _checkpointRichInfo$r2;

      const {
        last_modified,
        object_size
      } = (_checkpointRichInfo$r2 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r2.object_info;

      if ( // TODO: `last-modified` aligns to number
      objectStats['last-modified'] !== last_modified || objectSize !== object_size) {
        console.warn(`The file has been modified since ${new Date(last_modified)}, so the checkpoint file is invalid, and specified object will be downloaded again.`);
        delete checkpointRichInfo.record;
      }
    }
  })();
  const partSize = input.partSize || ((_checkpointRichInfo$r3 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r3.part_size) || DEFAULT_PART_SIZE; // check partSize is matched

  if (checkpointRichInfo.record && checkpointRichInfo.record.part_size !== partSize) {
    console.warn('The partSize param does not equal the partSize in checkpoint file, ' + 'so the checkpoint file is invalid, and specified object will be downloaded again.');
    delete checkpointRichInfo.record;
  }

  let bucket = input.bucket || this.opts.bucket || '';
  const key = input.key;
  let tasks = [];
  const allTasks = getAllTasks$2(objectSize, partSize);
  const initConsumedBytes = (((_checkpointRichInfo$r4 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r4.parts_info) || []).filter(it => it.is_completed).reduce((prev, it) => prev + (it.range_end - it.range_start + 1), 0); // recorded tasks

  const recordedTasks = ((_checkpointRichInfo$r5 = checkpointRichInfo.record) == null ? void 0 : _checkpointRichInfo$r5.parts_info) || [];
  const recordedTaskMap = new Map();
  recordedTasks.forEach(it => recordedTaskMap.set(it.part_number, it));
  const filePath = await (async () => {
    let filePathStats = null;

    try {
      filePathStats = await stat(input.filePath);
    } catch (_err) {
      const err = _err;

      if (err.code === 'ENOENT') ; else {
        throw err;
      }
    }

    const isDirectory = (() => {
      if (filePathStats) {
        return filePathStats.isDirectory();
      }

      return input.filePath.endsWith('/');
    })();

    const filePath = isDirectory ? path.resolve(input.filePath, key) : input.filePath;
    const dirPath = path.dirname(filePath);
    await mkdir(dirPath, {
      recursive: true
    });
    return filePath;
  })(); // TODO: there can check temp fileSize

  const [tempFilePath, isExist] = await (async () => {
    const tempFilePath = filePath + '.temp';
    let isExist = true;

    try {
      await stat(input.filePath);
    } catch (_err) {
      const err = _err;

      if (err.code === 'ENOENT') {
        isExist = false; // file doesn't exist
      } else {
        throw err;
      }
    }

    return [tempFilePath, isExist];
  })();

  if (checkpointRichInfo.record) {
    if (!isExist) {
      console.warn("The temp file doesn't not exist " + 'so the checkpoint file is invalid, and specified object will be downloaded again.');
      delete checkpointRichInfo.record;
    }
  }

  const nextEnsureCloseFd = async () => {
    const getCheckpointContent = () => {
      const checkpointContent = {
        bucket,
        key,
        version_id: versionId,
        part_size: partSize,
        parts_info: recordedTasks,
        file_info: {
          file_path: filePath,
          temp_file_path: tempFilePath
        },
        object_info: {
          last_modified: objectStats['last-modified'],
          etag: etag,
          hash_crc64ecma: objectStats['x-tos-hash-crc64ecma'] || '',
          object_size: objectSize
        }
      };
      return checkpointContent;
    };

    const triggerDownloadEvent = e => {
      if (!input.downloadEventChange) {
        return;
      }

      const event = {
        bucket,
        versionId,
        key,
        filePath,
        ...e
      };

      if (checkpointRichInfo.filePath) {
        event.checkpointFile = checkpointRichInfo.filePath;
      }

      input.downloadEventChange(event);
    };

    let consumedBytesForProgress = initConsumedBytes;
    let TriggerProgressEventType;

    (function (TriggerProgressEventType) {
      TriggerProgressEventType[TriggerProgressEventType["start"] = 0] = "start";
      TriggerProgressEventType[TriggerProgressEventType["downloadPartSucceed"] = 1] = "downloadPartSucceed";
      TriggerProgressEventType[TriggerProgressEventType["renameTempFileSucceed"] = 2] = "renameTempFileSucceed";
    })(TriggerProgressEventType || (TriggerProgressEventType = {}));

    const triggerProgressEvent = type => {
      if (!input.progress) {
        return;
      }

      const percent = (() => {
        if (type === TriggerProgressEventType.start && objectSize === 0) {
          return 0;
        }

        return !objectSize ? 1 : consumedBytesForProgress / objectSize;
      })();

      if (consumedBytesForProgress === objectSize && type === TriggerProgressEventType.downloadPartSucceed) ; else {
        input.progress(percent, getCheckpointContent());
      }
    };

    let consumedBytes = initConsumedBytes;
    const {
      dataTransferStatusChange
    } = input;

    const triggerDataTransfer = (type, rwOnceBytes = 0) => {
      if (!dataTransferStatusChange) {
        return;
      }

      consumedBytes += rwOnceBytes;
      dataTransferStatusChange == null ? void 0 : dataTransferStatusChange({
        type,
        rwOnceBytes,
        consumedBytes,
        totalBytes: objectSize
      });
    };

    const writeCheckpointFile = async () => {
      if ( checkpointRichInfo.filePath) {
        const content = JSON.stringify(getCheckpointContent(), null, 2);
        const dirPath = path.dirname(checkpointRichInfo.filePath); // ensure directory exist

        await mkdir(dirPath, {
          recursive: true
        });
        await writeFile(checkpointRichInfo.filePath, content, 'utf-8');
      }
    };

    const rmCheckpointFile = async () => {
      if ( checkpointRichInfo.filePath) {
        await rm(checkpointRichInfo.filePath).catch(err => {
          // eat err
          console.warn('remove checkpoint file failure, you can remove it by hand.\n', `checkpoint file path: ${checkpointRichInfo.filePath}\n`, err.message);
        });
      }
    };
    /**
     *
     * @param task one part task
     * @param downloadPartRes upload part failed if `downloadPartRes` is Error
     */


    const updateAfterDownloadPart = async (task, downloadPartRes) => {
      let existRecordTask = recordedTaskMap.get(task.partNumber);
      const rangeStart = task.offset;
      const rangeEnd = Math.min(task.offset + partSize - 1, objectSize - 1);

      if (!existRecordTask) {
        existRecordTask = {
          part_number: task.partNumber,
          range_start: rangeStart,
          range_end: rangeEnd,
          hash_crc64ecma: '',
          is_completed: false
        };
        recordedTasks.push(existRecordTask);
        recordedTaskMap.set(existRecordTask.part_number, existRecordTask);
      }

      if (!downloadPartRes.err) {
        existRecordTask.is_completed = true;
        existRecordTask.hash_crc64ecma = downloadPartRes.res.rangeHashCrc64ecma;
      }

      await writeCheckpointFile();
      const downloadPartInfo = {
        partNumber: existRecordTask.part_number,
        rangeStart,
        rangeEnd
      };

      if (downloadPartRes.err) {
        const err = downloadPartRes.err;
        let type = exports.DownloadEventType.DownloadPartFailed;

        if (err instanceof TosServerError) {
          if (ABORT_ERROR_STATUS_CODE$2.includes(err.statusCode)) {
            type = exports.DownloadEventType.DownloadPartAborted;
          }
        }

        triggerDownloadEvent({
          type,
          err,
          downloadPartInfo: downloadPartInfo
        });
        return;
      }

      consumedBytesForProgress += downloadPartInfo.rangeEnd - downloadPartInfo.rangeStart + 1;
      triggerDownloadEvent({
        type: exports.DownloadEventType.DownloadPartSucceed,
        downloadPartInfo: downloadPartInfo
      });
      triggerProgressEvent(TriggerProgressEventType.downloadPartSucceed);
    };

    if (checkpointRichInfo.record) {
      bucket = checkpointRichInfo.record.bucket; // checkpoint info exists, so need to calculate remain tasks

      const uploadedPartSet = new Set((checkpointRichInfo.record.parts_info || []).filter(it => it.is_completed).map(it => it.part_number));
      tasks = allTasks.filter(it => !uploadedPartSet.has(it.partNumber));
    } else {
      try {
        // create temp file
        await writeFile(tempFilePath, '', {
          flag: 'w+'
        });
      } catch (_err) {
        const err = _err;
        triggerDownloadEvent({
          type: exports.DownloadEventType.CreateTempFileFailed,
          err
        });
        throw err;
      }

      if (checkpointRichInfo.filePathIsPlaceholder) {
        var _checkpointRichInfo$f;

        checkpointRichInfo.filePath = (_checkpointRichInfo$f = checkpointRichInfo.filePath) == null ? void 0 : _checkpointRichInfo$f.replace(`${CHECKPOINT_FILE_NAME_PLACEHOLDER$2}`, getDefaultCheckpointFilePath$2(bucket, key, versionId));
      }

      triggerDownloadEvent({
        type: exports.DownloadEventType.CreateTempFileSucceed
      });
      triggerDataTransfer(exports.DataTransferType.Started);
      tasks = allTasks;
    }

    const handleTasks = async () => {
      let firstErr = null;
      let index = 0; // TODO: how to test parallel does work, measure time is not right

      await Promise.all(Array.from({
        length: input.taskNum || 1
      }).map(async () => {
        while (true) {
          const currentIndex = index++;

          if (currentIndex >= tasks.length) {
            return;
          }

          const curTask = tasks[currentIndex];
          let consumedBytesThisTask = 0;

          try {
            const res = await getObjectV2.call(this, {
              bucket,
              key,
              versionId,
              headers: {
                'if-match': etag,
                range: `bytes=${curTask.offset}-${Math.min(curTask.offset + curTask.partSize - 1, objectSize - 1)}`
              },
              trafficLimit: input.trafficLimit,
              rateLimiter: input.rateLimiter,

              dataTransferStatusChange(status) {
                if (status.type !== exports.DataTransferType.Rw) {
                  return;
                }

                if (isCancel()) {
                  return;
                }

                consumedBytesThisTask += status.rwOnceBytes;
                triggerDataTransfer(exports.DataTransferType.Rw, status.rwOnceBytes);
              }

            }); // need to handle stream's error event before throw a error
            // if (isCancel()) {
            //   throw new CancelError('cancel downloadFile');
            // }

            let dataStream = res.data.content;
            const crcInst = new CRC$1();

            if ( true && this.opts.enableCRC) {
              dataStream = createCrcReadStream(dataStream, crcInst);
            }

            await new Promise((resolve, reject) => {
              const writeStream = createWriteStream(tempFilePath, {
                start: curTask.offset,
                flags: 'r+'
              });
              writeStream.on('finish', () => {
                resolve(undefined);
              });
              dataStream.on('error', err => {
                reject(err);
              });
              dataStream.pipe(writeStream);

              function handleOnceCancel() {
                if (isCancel()) {
                  reject(new CancelError('cancel downloadFile'));
                  dataStream.unpipe(writeStream);
                  dataStream.off('data', handleOnceCancel);
                }
              }

              dataStream.on('data', handleOnceCancel);
            });

            if (isCancel()) {
              throw new CancelError('cancel downloadFile');
            }

            await updateAfterDownloadPart(curTask, {
              res: { ...res.data,
                rangeHashCrc64ecma: crcInst.getCrc64()
              }
            });
          } catch (_err) {
            const err = _err;
            consumedBytes -= consumedBytesThisTask;
            consumedBytesThisTask = 0;

            if (isCancelError(err)) {
              throw err;
            }

            if (isCancel()) {
              throw new CancelError('cancel downloadFile');
            }

            if (!firstErr) {
              firstErr = err;
            }

            await updateAfterDownloadPart(curTask, {
              err
            });
          }
        }
      }));

      if (firstErr) {
        throw firstErr;
      }

      const serverCRC64 = headObjectRes.data['x-tos-hash-crc64ecma'];

      if (this.opts.enableCRC && serverCRC64) {
        const actualCrc64 = combineCRCInParts$1(getCheckpointContent());

        if (actualCrc64 !== serverCRC64) {
          throw new TosClientError(`expect crc64 ${serverCRC64}, actual crc64 ${actualCrc64}`);
        }
      }
    };

    const handleEmptyObj = async () => {};

    triggerProgressEvent(TriggerProgressEventType.start);
    objectSize === 0 ? await handleEmptyObj() : await handleTasks();

    try {
      await rename(tempFilePath, filePath);
    } catch (_err) {
      const err = _err;
      triggerDownloadEvent({
        type: exports.DownloadEventType.RenameTempFileFailed,
        err
      });
      triggerDataTransfer(exports.DataTransferType.Failed);
      throw err;
    }

    triggerDownloadEvent({
      type: exports.DownloadEventType.RenameTempFileSucceed
    });
    triggerProgressEvent(TriggerProgressEventType.renameTempFileSucceed);
    triggerDataTransfer(exports.DataTransferType.Succeed);
    await rmCheckpointFile();
    return headObjectRes;
  };

  try {
    return await nextEnsureCloseFd();
  } finally {// there is no global fd, don't need to close fd
  }
}
/**
 * 即使 totalSize 是 0，也需要一个 Part，否则 Server 端会报错 read request body failed
 */

function getAllTasks$2(totalSize, partSize) {
  const tasks = [];

  for (let i = 0;; ++i) {
    const offset = i * partSize;
    const currPartSize = Math.min(partSize, totalSize - offset);
    tasks.push({
      offset,
      partSize: currPartSize,
      partNumber: i + 1
    });

    if ((i + 1) * partSize >= totalSize) {
      break;
    }
  }

  return tasks;
}

function getDefaultCheckpointFilePath$2(bucket, key, versionId) {
  const originPath = `${bucket}_${key}.${versionId}.json`;
  const normalizePath = originPath.replace(/[\\/]/g, '');
  return normalizePath;
}

function combineCRCInParts$1(cp) {
  let res = '0';

  for (const part of cp.parts_info || []) {
    res = combineCrc64(res, part.hash_crc64ecma, part.range_end - part.range_start + 1);
  }

  return res;
}

async function getBucketLocation(input) {
  const {
    bucket
  } = input;
  return this.fetchBucket(bucket, 'GET', {
    location: ''
  }, {});
}

async function getBucketCORS(input) {
  try {
    const {
      bucket
    } = input;
    return await this.fetchBucket(bucket, 'GET', {
      cors: ''
    }, {});
  } catch (error) {
    return handleEmptyServerError(error, {
      defaultResponse: {
        CORSRules: []
      },
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketCORS'
    });
  }
}
async function putBucketCORS(input) {
  const {
    bucket,
    CORSRules
  } = input;

  if (this.opts.enableOptimizeMethodBehavior && !CORSRules.length) {
    return deleteBucketCORS.call(this, {
      bucket
    });
  }

  return this.fetchBucket(bucket, 'PUT', {
    cors: ''
  }, {}, {
    CORSRules
  });
}
async function deleteBucketCORS(input) {
  const {
    bucket
  } = input;
  return this.fetchBucket(bucket, 'DELETE', {
    cors: ''
  }, {});
}

const DefaultListMaxKeys = 1000;
async function listObjectsType2(input = {}) {
  const {
    listOnlyOnce = false
  } = input;
  let output;

  if (!input.maxKeys) {
    input.maxKeys = DefaultListMaxKeys;
  }

  if (listOnlyOnce) {
    output = await listObjectsType2Once.call(this, input);
  } else {
    const maxKeys = input.maxKeys;
    let params = { ...input,
      maxKeys
    };

    while (true) {
      const res = await listObjectsType2Once.call(this, params);

      if (output == null) {
        output = res;
      } else {
        output = { ...res,
          data: output.data
        };
        output.data.KeyCount += res.data.KeyCount;
        output.data.IsTruncated = res.data.IsTruncated;
        output.data.NextContinuationToken = res.data.NextContinuationToken;
        output.data.Contents = output.data.Contents.concat(res.data.Contents);
        output.data.CommonPrefixes = output.data.CommonPrefixes.concat(res.data.CommonPrefixes);
      }

      if (!res.data.IsTruncated || output.data.KeyCount >= maxKeys) {
        break;
      }

      params.continuationToken = res.data.NextContinuationToken;
      params.maxKeys = params.maxKeys - res.data.KeyCount;
    }
  }

  return output;
}

async function listObjectsType2Once(input) {
  const {
    bucket,
    ...nextQuery
  } = input;
  const ret = await this.fetchBucket(input.bucket, 'GET', {
    'list-type': 2,
    ...covertCamelCase2Kebab(nextQuery)
  }, {});
  const arrayProp = makeArrayProp(ret.data);
  arrayProp('CommonPrefixes');
  arrayProp('Contents');
  return ret;
}

async function putBucketLifecycle(input) {
  const {
    bucket,
    rules
  } = input;

  if (this.opts.enableOptimizeMethodBehavior && !rules.length) {
    return deleteBucketLifecycle.call(this, {
      bucket
    });
  }

  const headers = {};
  fillRequestHeaders({ ...input,
    headers
  }, ['allowSameActionOverlap']);
  return this.fetchBucket(bucket, 'PUT', {
    lifecycle: ''
  }, headers, {
    Rules: rules
  });
}
async function getBucketLifecycle(input) {
  try {
    const {
      bucket
    } = input;
    return await this.fetchBucket(bucket, 'GET', {
      lifecycle: ''
    }, {}, {}, {
      handleResponse: res => {
        return {
          AllowSameActionOverlap: res.headers['x-tos-allow-same-action-overlap'],
          Rules: res.data.Rules
        };
      }
    });
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketLifecycle',
      defaultResponse: {
        Rules: []
      }
    });
  }
}
async function deleteBucketLifecycle(input) {
  const {
    bucket
  } = input;
  return this.fetchBucket(bucket, 'DELETE', {
    lifecycle: ''
  }, {});
}

async function putBucketEncryption(input) {
  const {
    bucket,
    rule
  } = input;
  return this.fetchBucket(bucket, 'PUT', {
    encryption: ''
  }, {
    'Content-MD5': hashMd5(JSON.stringify({
      Rule: rule
    }), 'base64')
  }, {
    Rule: rule
  });
}
async function getBucketEncryption(input) {
  const {
    bucket
  } = input;
  return this.fetchBucket(bucket, 'GET', {
    encryption: ''
  }, {});
}
async function deleteBucketEncryption(input) {
  const {
    bucket
  } = input;
  return this.fetchBucket(bucket, 'DELETE', {
    encryption: ''
  }, {});
}

const CommonQueryKey = 'mirror';
async function putBucketMirrorBack(input) {
  const {
    bucket,
    rules
  } = input;

  if (this.opts.enableOptimizeMethodBehavior && !rules.length) {
    return deleteBucketMirrorBack.call(this, {
      bucket
    });
  }

  return this.fetchBucket(bucket, 'PUT', {
    [CommonQueryKey]: ''
  }, {}, {
    Rules: rules
  });
}
async function getBucketMirrorBack(input) {
  const {
    bucket
  } = input;

  try {
    return await this.fetchBucket(bucket, 'GET', {
      [CommonQueryKey]: ''
    }, {});
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketMirrorBack',
      defaultResponse: {
        Rules: []
      }
    });
  }
}
async function deleteBucketMirrorBack(input) {
  const {
    bucket
  } = input;
  return this.fetchBucket(bucket, 'DELETE', {
    [CommonQueryKey]: ''
  }, {});
}

const CommonQueryKey$1 = 'tagging';
async function putObjectTagging(input) {
  const {
    tagSet,
    versionId
  } = input;
  const headers = normalizeHeadersKey({
    versionId
  });
  return this._fetchObject(input, 'PUT', {
    [CommonQueryKey$1]: '',
    ...headers
  }, {}, {
    TagSet: tagSet
  });
}
async function getObjectTagging(input) {
  const {
    versionId
  } = input;
  const headers = normalizeHeadersKey({
    versionId
  });
  const res = await this._fetchObject(input, 'GET', {
    [CommonQueryKey$1]: '',
    ...headers
  }, {});
  makeArrayProp(res.data.TagSet)('Tags');
  return res;
}
async function deleteObjectTagging(input) {
  const {
    versionId
  } = input;
  const headers = normalizeHeadersKey({
    versionId
  });
  return this._fetchObject(input, 'DELETE', {
    [CommonQueryKey$1]: '',
    ...headers
  }, {});
}

const CommonQueryKey$2 = 'replication';
async function putBucketReplication(input) {
  const {
    bucket,
    rules,
    role
  } = input;

  if (this.opts.enableOptimizeMethodBehavior && !rules.length) {
    return deleteBucketReplication.call(this, {
      bucket
    });
  }

  return this.fetchBucket(bucket, 'PUT', {
    [CommonQueryKey$2]: ''
  }, {}, {
    Role: role,
    Rules: rules
  });
}
async function getBucketReplication(input) {
  const {
    bucket,
    progress,
    ruleId
  } = input;
  const query = {
    [CommonQueryKey$2]: '',
    progress: progress || ''
  };

  if (ruleId != null) {
    query['rule-id'] = `${ruleId}`;
  }

  try {
    return await this.fetchBucket(bucket, 'GET', query, {});
  } catch (err) {
    return handleEmptyServerError(err, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketReplication',
      defaultResponse: {
        Rules: [],
        Role: ''
      }
    });
  }
}
async function deleteBucketReplication(input) {
  const {
    bucket
  } = input;
  return this.fetchBucket(bucket, 'DELETE', {
    [CommonQueryKey$2]: ''
  }, {});
}

const CommonQueryKey$3 = 'website';
async function putBucketWebsite(input) {
  const {
    bucket,
    ...otherProps
  } = input;
  const body = convertNormalCamelCase2Upper(otherProps);
  return this.fetchBucket(bucket, 'PUT', {
    [CommonQueryKey$3]: ''
  }, {}, { ...body
  });
}
async function getBucketWebsite(input) {
  const {
    bucket
  } = input;

  try {
    return this.fetchBucket(bucket, 'GET', {
      [CommonQueryKey$3]: ''
    }, {});
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketWebsite',
      defaultResponse: {
        RoutingRules: []
      }
    });
  }
}
async function deleteBucketWebsite(input) {
  const {
    bucket
  } = input;
  return this.fetchBucket(bucket, 'DELETE', {
    [CommonQueryKey$3]: ''
  }, {});
}

const CommonQueryKey$4 = 'notification';
/**
 * @deprecated use PutBucketNotificationType2 instead
 */

async function putBucketNotification(input) {
  const {
    bucket,
    ...otherProps
  } = input;
  const body = convertNormalCamelCase2Upper(otherProps);
  return this.fetchBucket(bucket, 'PUT', {
    [CommonQueryKey$4]: ''
  }, {}, { ...body
  });
}
/**
 * @deprecated use GetBucketNotificationType2 instead
 */

async function getBucketNotification(input) {
  const {
    bucket
  } = input;

  try {
    return await this.fetchBucket(bucket, 'GET', {
      [CommonQueryKey$4]: ''
    }, {});
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketNotification',
      defaultResponse: {
        CloudFunctionConfigurations: [],
        RocketMQConfigurations: []
      }
    });
  }
}

const CommonQueryKey$5 = 'customdomain';
async function putBucketCustomDomain(input) {
  const {
    bucket,
    ...otherProps
  } = input;
  const body = convertNormalCamelCase2Upper(otherProps);
  return this.fetchBucket(bucket, 'PUT', {
    [CommonQueryKey$5]: ''
  }, {}, { ...body
  });
}
async function getBucketCustomDomain(input) {
  try {
    const {
      bucket
    } = input;
    return await this.fetchBucket(bucket, 'GET', {
      [CommonQueryKey$5]: ''
    }, {});
  } catch (error) {
    return handleEmptyServerError(error, {
      defaultResponse: {
        CustomDomainRules: []
      },
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketCustomDomain'
    });
  }
}
async function deleteBucketCustomDomain(input) {
  const {
    bucket,
    customDomain
  } = input;
  return this.fetchBucket(bucket, 'DELETE', {
    customdomain: customDomain
  }, {});
}

const CommonQueryKey$6 = 'realtimeLog';
async function putBucketRealTimeLog(input) {
  const {
    bucket,
    ...otherProps
  } = input;
  const body = convertNormalCamelCase2Upper(otherProps);
  return this.fetchBucket(bucket, 'PUT', {
    [CommonQueryKey$6]: ''
  }, {}, { ...body
  });
}
async function getBucketRealTimeLog(input) {
  const {
    bucket
  } = input;

  try {
    return await this.fetchBucket(bucket, 'GET', {
      [CommonQueryKey$6]: ''
    }, {});
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketRealTimeLog',
      defaultResponse: {}
    });
  }
}
async function deleteBucketRealTimeLog(input) {
  const {
    bucket
  } = input;
  return this.fetchBucket(bucket, 'DELETE', {
    [CommonQueryKey$6]: ''
  }, {});
}

/**
 * 清单文件导出周期
 */

var ScheduleFrequency;

(function (ScheduleFrequency) {
  /** 按天 */
  ScheduleFrequency["Daily"] = "Daily";
  /** 按周 */

  ScheduleFrequency["Weekly"] = "Weekly";
})(ScheduleFrequency || (ScheduleFrequency = {}));
/**
 * 清单包含Object版本信息值
 */


var IncludedObjectVersions;

(function (IncludedObjectVersions) {
  /** 全部 */
  IncludedObjectVersions["All"] = "All";
  /** 当前版本 */

  IncludedObjectVersions["Current"] = "Current";
})(IncludedObjectVersions || (IncludedObjectVersions = {}));
/**
 * 清单配置项
 */


var InventoryOptionalFields;

(function (InventoryOptionalFields) {
  /** Object的大小 */
  InventoryOptionalFields["Size"] = "Size";
  /** Object的最后修改时间 */

  InventoryOptionalFields["LastModifiedDat"] = "LastModifiedDate";
  /** 标识Object的内容 */

  InventoryOptionalFields["ETag"] = "ETag";
  /** Object的存储类型 */

  InventoryOptionalFields["StorageClass"] = "StorageClass";
  /** 是否为通过分片上传的Object */

  InventoryOptionalFields["IsMultipartUploaded"] = "IsMultipartUploaded";
  /** Object是否加密 */

  InventoryOptionalFields["EncryptionStatus"] = "EncryptionStatus";
  InventoryOptionalFields["CRC64"] = "CRC64";
  /** crr复制状态 */

  InventoryOptionalFields["ReplicationStatus"] = "ReplicationStatus";
})(InventoryOptionalFields || (InventoryOptionalFields = {}));
/**
 * 获取桶清单详情信息
 */


async function getBucketInventory(req) {
  try {
    const res = await this.fetchBucket(req.bucket, 'GET', {
      inventory: '',
      id: req.id
    }, {});
    return res;
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketInventory',
      defaultResponse: undefined
    });
  }
}
/**
 * 分页获取桶清单信息
 */

async function listBucketInventory(req) {
  const params = {
    inventory: '',
    ...(req.continuationToken ? {
      'continuation-token': req.continuationToken
    } : null)
  };

  try {
    const res = await this.fetchBucket(req.bucket, 'GET', params, {});
    return res;
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'listBucketInventory',
      defaultResponse: {
        InventoryConfigurations: []
      }
    });
  }
}
/**
 * 删除桶清单
 */

async function deleteBucketInventory(req) {
  return this.fetchBucket(req.bucket, 'DELETE', {
    inventory: '',
    id: req.id
  }, {});
}
/**
 * 更新桶清单
 */

function putBucketInventory(req) {
  return this.fetchBucket(req.bucket, 'PUT', {
    inventory: '',
    id: req.inventoryConfiguration.Id
  }, {}, req.inventoryConfiguration);
}

/**
 *
 * @private unstable method
 * @description 创建批量任务
 * @param params
 * @returns
 */

async function createJob(params) {
  const {
    accountId,
    ...reset
  } = params;
  const data = convertNormalCamelCase2Upper(reset);
  const res = await this.fetch('POST', '/jobs', {}, {
    'x-tos-account-id': accountId
  }, { ...data
  });
  return res;
}
/**
 * @private unstable method
 * @description  获取批量任务列表
 * @param params
 * @returns
 */

async function listJobs(params) {
  const {
    accountId,
    maxResults = 1000,
    ...others
  } = params;
  const res = await this.fetch('GET', '/jobs', {
    maxResults,
    ...others
  }, {
    'x-tos-account-id': accountId
  }, {}, {
    axiosOpts: {
      paramsSerializer
    }
  });
  return res;
}
/**
 *
 * @private unstable method
 * @description 更新批量任务优先级
 * @param params
 * @returns
 */

async function updateJobPriority(params) {
  const {
    accountId,
    jobId: JobId,
    priority
  } = params;
  const res = await this.fetch('POST', `/jobs/${JobId}/priority`, {
    priority
  }, {
    'x-tos-account-id': accountId
  }, {}, {
    needMd5: true
  });
  return res;
}
/**
 *
 * @private unstable method
 * @description 更新批量任务优先级
 * @param params
 * @returns
 */

async function updateJobStatus(params) {
  const {
    accountId,
    jobId: JobId,
    requestedJobStatus,
    statusUpdateReason
  } = params;
  const res = await this.fetch('POST', `/jobs/${JobId}/status`, {
    requestedJobStatus,
    statusUpdateReason
  }, {
    'x-tos-account-id': accountId
  }, {}, {
    needMd5: true
  });
  return res;
}
/**
 *
 * @private unstable method
 * @description 删除批量任务
 * @param params
 * @returns
 */

async function deleteJob(params) {
  const {
    accountId,
    JobId
  } = params;
  const res = await this.fetch('DELETE', `/jobs/${JobId}`, {}, {
    'x-tos-account-id': accountId
  }, {});
  return res;
}
/**
 *
 * @private unstable method
 * @description 获取批量任务详情
 * @param params
 * @returns
 */

async function describeJob(params) {
  const {
    accountId,
    JobId
  } = params;
  const res = await this.fetch('GET', `/jobs/${JobId}`, {}, {
    'x-tos-account-id': accountId
  }, {});
  return res;
}

/**
 * @private unstable method
 */

async function putBucketTagging(input) {
  const res = await this.fetchBucket(input.bucket, 'PUT', {
    tagging: ''
  }, {}, input.tagging, {
    needMd5: true
  });
  return res;
}
/**
 * @private unstable method
 */

async function getBucketTagging({
  bucket
}) {
  try {
    const res = await this.fetchBucket(bucket, 'GET', {
      tagging: ''
    }, {});
    return res;
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketTagging',
      defaultResponse: {
        TagSet: {
          Tags: []
        }
      }
    });
  }
}
/**
 * @private unstable method
 */

async function deleteBucketTagging({
  bucket
}) {
  return this.fetchBucket(bucket, 'DELETE', {
    tagging: ''
  }, {});
}

/**
 * @private unstable method
 */
async function putBucketPayByTraffic(input) {
  const res = await this.fetchBucket(input.bucket, 'PUT', {
    payByTraffic: ''
  }, {}, input.payByTraffic);
  return res;
}
/**
 * @private unstable method
 */

async function getBucketPayByTraffic({
  bucket
}) {
  const res = await this.fetchBucket(bucket, 'GET', {
    payByTraffic: ''
  }, {});
  return res;
}

/**
 * @private unstable method
 */

async function getImageStyleBriefInfo(req) {
  const {
    bucket
  } = req;

  try {
    const res = await this.fetchBucket(bucket, 'GET', {
      imageStyleBriefInfo: ''
    }, {});
    return res;
  } catch (err) {
    if (err instanceof TosServerError) {
      if (err.statusCode === 404) {
        return this.getNormalDataFromError({
          BucketName: bucket,
          ImageStyleBriefInfo: []
        }, err);
      }
    }

    throw err;
  }
}
/**
 * @private unstable method
 */

async function getBucketImageStyleList(bucket) {
  try {
    const res = await this.fetchBucket(bucket, 'GET', {
      imageStyle: ''
    }, {});
    return res;
  } catch (err) {
    if (err instanceof TosServerError) {
      if (err.statusCode === 404) {
        return this.getNormalDataFromError({
          ImageStyles: []
        }, err);
      }
    }

    throw err;
  }
}
/**
 * @private unstable method
 */

async function getBucketImageStyleListByName(req) {
  try {
    const {
      bucket,
      styleName
    } = req;
    const res = await this.fetchBucket(bucket, 'GET', {
      imageStyleContent: '',
      styleName
    }, {});
    return res;
  } catch (err) {
    if (err instanceof TosServerError) {
      if (err.statusCode === 404) {
        return this.getNormalDataFromError({
          ImageStyles: []
        }, err);
      }
    }

    throw err;
  }
}
/**
 * @private unstable method
 */

async function getBucketImageStyle(bucket, styleName) {
  try {
    const res = await this.fetchBucket(bucket, 'GET', {
      imageStyle: '',
      styleName
    }, {});
    return res;
  } catch (err) {
    if (err instanceof TosServerError) {
      if (err.statusCode === 404) {
        return this.getNormalDataFromError(null, err);
      }
    }

    throw err;
  }
}
/**
 * @private unstable method
 */

async function putBucketImageStyle(req) {
  const {
    bucket,
    styleName,
    content,
    styleObjectPrefix
  } = req;

  try {
    const res = await this.fetchBucket(bucket, 'PUT', {
      imageStyle: '',
      styleName,
      styleObjectPrefix
    }, {}, {
      Content: content
    });
    return res;
  } catch (err) {
    if (err instanceof TosServerError) {
      if (err.statusCode === 404) {
        return this.getNormalDataFromError(null, err);
      }
    }

    throw err;
  }
}
/**
 * @private unstable method
 */

async function deleteBucketImageStyle(req) {
  const {
    styleName,
    styleObjectPrefix,
    bucket
  } = req;

  try {
    const res = await this.fetchBucket(bucket, 'DELETE', {
      imageStyle: '',
      styleName,
      styleObjectPrefix
    }, {});
    return res;
  } catch (err) {
    if (err instanceof TosServerError) {
      if (err.statusCode === 404) {
        return this.getNormalDataFromError(null, err);
      }
    }

    throw err;
  }
}
/**
 * @private unstable method
 */

async function putBucketImageProtect(bucket, data) {
  try {
    const res = await this.fetchBucket(bucket, 'PUT', {
      originalImageProtect: ''
    }, {}, data);
    return res;
  } catch (err) {
    if (err instanceof TosServerError) {
      if (err.statusCode === 404) {
        return this.getNormalDataFromError(null, err);
      }
    }

    throw err;
  }
}
/**
 * @private unstable method
 */

async function getBucketImageProtect(bucket) {
  try {
    const res = await this.fetchBucket(bucket, 'GET', {
      originalImageProtect: ''
    }, {});
    return res;
  } catch (err) {
    if (err instanceof TosServerError) {
      if (err.statusCode === 404) {
        return this.getNormalDataFromError(null, err);
      }
    }

    throw err;
  }
}
/**
 * @private unstable method
 */

async function putBucketImageStyleSeparator(req) {
  const {
    bucket,
    Separator,
    SeparatorSuffix
  } = req;

  try {
    const res = await this.fetchBucket(bucket, 'PUT', {
      imageStyleSeparator: ''
    }, {}, {
      Separator,
      SeparatorSuffix
    });
    return res;
  } catch (err) {
    if (err instanceof TosServerError) {
      if (err.statusCode === 404) {
        return this.getNormalDataFromError(null, err);
      }
    }

    throw err;
  }
}
/**
 * @private unstable method
 */

async function getBucketImageStyleSeparator(bucket) {
  try {
    const res = await this.fetchBucket(bucket, 'GET', {
      imageStyleSeparator: ''
    }, {});
    return res;
  } catch (err) {
    if (err instanceof TosServerError) {
      if (err.statusCode === 404) {
        return this.getNormalDataFromError(null, err);
      }
    }

    throw err;
  }
}

async function getBucketIntelligenttiering(bucket) {
  try {
    const res = await this.fetchBucket(bucket, 'GET', {
      intelligenttiering: ''
    }, {});
    return res;
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketIntelligenttiering',
      defaultResponse: {}
    });
  }
}

const CommonQueryKey$7 = 'rename';
async function putBucketRename(input) {
  const {
    bucket,
    ...otherProps
  } = input;
  const body = convertNormalCamelCase2Upper(otherProps);
  return this.fetchBucket(bucket, 'PUT', {
    [CommonQueryKey$7]: ''
  }, {}, { ...body
  });
}
async function getBucketRename(input) {
  const {
    bucket
  } = input;
  return await this.fetchBucket(bucket, 'GET', {
    [CommonQueryKey$7]: ''
  }, {});
}
async function deleteBucketRename(input) {
  const {
    bucket
  } = input;
  return this.fetchBucket(bucket, 'DELETE', {
    [CommonQueryKey$7]: ''
  }, {});
}

async function restoreObject(input) {
  const {
    bucket,
    key,
    versionId,
    ...otherProps
  } = input;
  const query = {
    restore: ''
  };

  if (versionId) {
    query.versionId = versionId;
  }

  const body = convertNormalCamelCase2Upper(otherProps);
  return this._fetchObject(input, 'POST', query, {}, body);
}

/**
 * @private unstable method
 * @description 获取数据透视列表
 * @param params
 * @returns
 */

async function listStorageLens(params) {
  const {
    accountId
  } = params;
  const res = await this.fetch('GET', '/storagelens', {}, {
    'x-tos-account-id': accountId
  }, {}, {
    axiosOpts: {
      paramsSerializer
    }
  });
  return res;
}
/**
 * @private unstable method
 * @description 删除数据透视记录
 * @param params
 * @returns
 */

async function deleteStorageLens(params) {
  const {
    accountId,
    Id
  } = params;
  const res = await this.fetch('DELETE', `/storagelens`, {
    id: Id
  }, {
    'x-tos-account-id': accountId
  }, {}, {
    needMd5: true
  });
  return res;
}
/**
 * @private unstable method
 * @description 获取数据透视详情
 * @param params
 * @returns
 */

async function getStorageLens(params) {
  const {
    accountId,
    Id
  } = params;
  const res = await this.fetch('GET', `/storagelens`, {
    id: Id
  }, {
    'x-tos-account-id': accountId
  }, {}, {
    needMd5: true
  });
  return res;
}
/**
 * @private unstable method
 * @description 提交数据透视记录
 * @param params
 * @returns
 */

async function putStorageLens(params) {
  const {
    accountId,
    Id,
    ...rest
  } = params;
  const res = await this.fetch('PUT', `/storagelens`, {
    id: Id
  }, {
    'x-tos-account-id': accountId
  }, { ...rest,
    Id
  }, {
    needMd5: true
  });
  return res;
}

const CommonQueryKey$8 = 'notification_v2';
async function putBucketNotificationType2(input) {
  const {
    bucket,
    ...otherProps
  } = input;
  const body = convertNormalCamelCase2Upper(otherProps);
  return this.fetchBucket(bucket, 'PUT', {
    [CommonQueryKey$8]: ''
  }, {}, { ...body
  });
}
async function getBucketNotificationType2(input) {
  const {
    bucket
  } = input;

  try {
    return await this.fetchBucket(bucket, 'GET', {
      [CommonQueryKey$8]: ''
    }, {});
  } catch (error) {
    return handleEmptyServerError(error, {
      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,
      methodKey: 'getBucketNotificationType2',
      defaultResponse: {
        Rules: []
      }
    });
  }
}

const CancelToken = axios.CancelToken; // refer https://stackoverflow.com/questions/23876782/how-do-i-split-a-typescript-class-into-multiple-files

class TosClient extends TOSBase {
  constructor(...args) {
    super(...args);
    this.createBucket = createBucket;
    this.headBucket = headBucket;
    this.deleteBucket = deleteBucket;
    this.listBuckets = listBuckets;
    this.getBucketLocation = getBucketLocation;
    this.putBucketStorageClass = putBucketStorageClass;
    this.getBucketAcl = getBucketAcl;
    this.putBucketAcl = putBucketAcl;
    this.getBucketPolicy = getBucketPolicy;
    this.putBucketPolicy = putBucketPolicy;
    this.deleteBucketPolicy = deleteBucketPolicy;
    this.getBucketVersioning = getBucketVersioning;
    this.putBucketVersioning = putBucketVersioning;
    this.getBucketCORS = getBucketCORS;
    this.putBucketCORS = putBucketCORS;
    this.deleteBucketCORS = deleteBucketCORS;
    this.putBucketLifecycle = putBucketLifecycle;
    this.getBucketLifecycle = getBucketLifecycle;
    this.deleteBucketLifecycle = deleteBucketLifecycle;
    this.putBucketEncryption = putBucketEncryption;
    this.getBucketEncryption = getBucketEncryption;
    this.deleteBucketEncryption = deleteBucketEncryption;
    this.putBucketMirrorBack = putBucketMirrorBack;
    this.getBucketMirrorBack = getBucketMirrorBack;
    this.deleteBucketMirrorBack = deleteBucketMirrorBack;
    this.putBucketReplication = putBucketReplication;
    this.getBucketReplication = getBucketReplication;
    this.deleteBucketReplication = deleteBucketReplication;
    this.putBucketWebsite = putBucketWebsite;
    this.getBucketWebsite = getBucketWebsite;
    this.deleteBucketWebsite = deleteBucketWebsite;
    this.putBucketNotification = putBucketNotification;
    this.getBucketNotification = getBucketNotification;
    this.putBucketCustomDomain = putBucketCustomDomain;
    this.getBucketCustomDomain = getBucketCustomDomain;
    this.deleteBucketCustomDomain = deleteBucketCustomDomain;
    this.putBucketRealTimeLog = putBucketRealTimeLog;
    this.getBucketRealTimeLog = getBucketRealTimeLog;
    this.deleteBucketRealTimeLog = deleteBucketRealTimeLog;
    this.getBucketInventory = getBucketInventory;
    this.listBucketInventory = listBucketInventory;
    this.putBucketInventory = putBucketInventory;
    this.deleteBucketInventory = deleteBucketInventory;
    this.putBucketTagging = putBucketTagging;
    this.getBucketTagging = getBucketTagging;
    this.deleteBucketTagging = deleteBucketTagging;
    this.putBucketPayByTraffic = putBucketPayByTraffic;
    this.getBucketPayByTraffic = getBucketPayByTraffic;
    this.getBucketImageStyle = getBucketImageStyle;
    this.getBucketImageStyleList = getBucketImageStyleList;
    this.getBucketImageStyleListByName = getBucketImageStyleListByName;
    this.getImageStyleBriefInfo = getImageStyleBriefInfo;
    this.deleteBucketImageStyle = deleteBucketImageStyle;
    this.putBucketImageStyle = putBucketImageStyle;
    this.putBucketImageStyleSeparator = putBucketImageStyleSeparator;
    this.putBucketImageProtect = putBucketImageProtect;
    this.getBucketImageProtect = getBucketImageProtect;
    this.getBucketImageStyleSeparator = getBucketImageStyleSeparator;
    this.putBucketRename = putBucketRename;
    this.getBucketRename = getBucketRename;
    this.deleteBucketRename = deleteBucketRename;
    this.copyObject = copyObject;
    this.resumableCopyObject = resumableCopyObject;
    this.deleteObject = deleteObject;
    this.deleteMultiObjects = deleteMultiObjects;
    this.getObject = getObject;
    this.getObjectV2 = getObjectV2;
    this.getObjectToFile = getObjectToFile;
    this.getObjectAcl = getObjectAcl;
    this.headObject = headObject;
    this.appendObject = appendObject;
    this.listObjects = listObjects;
    this.renameObject = renameObject;
    this.fetchObject = fetchObject;
    this.putFetchTask = putFetchTask;
    this.listObjectsType2 = listObjectsType2;
    this.listObjectVersions = listObjectVersions;
    this.putObject = putObject;
    this.putObjectFromFile = putObjectFromFile;
    this.putObjectAcl = putObjectAcl;
    this.setObjectMeta = setObjectMeta;
    this.createMultipartUpload = createMultipartUpload;
    this.uploadPart = uploadPart;
    this.uploadPartFromFile = uploadPartFromFile;
    this.completeMultipartUpload = completeMultipartUpload;
    this.abortMultipartUpload = abortMultipartUpload;
    this.uploadPartCopy = uploadPartCopy;
    this.listMultipartUploads = listMultipartUploads;
    this.listParts = listParts;
    this.downloadFile = downloadFile;
    this.putObjectTagging = putObjectTagging;
    this.getObjectTagging = getObjectTagging;
    this.deleteObjectTagging = deleteObjectTagging;
    this.listJobs = listJobs;
    this.createJob = createJob;
    this.deleteJob = deleteJob;
    this.describeJob = describeJob;
    this.updateJobStatus = updateJobStatus;
    this.updateJobPriority = updateJobPriority;
    this.restoreObject = restoreObject;
    this.uploadFile = uploadFile;
    this.getPreSignedUrl = getPreSignedUrl;
    this.calculatePostSignature = calculatePostSignature;
    this.preSignedPostSignature = calculatePostSignature;
    this.preSignedPolicyURL = preSignedPolicyURL;
    this.getBucketIntelligenttiering = getBucketIntelligenttiering;
    this.listStorageLens = listStorageLens;
    this.deleteStorageLens = deleteStorageLens;
    this.getStorageLens = getStorageLens;
    this.putStorageLens = putStorageLens;
    this.putBucketNotificationType2 = putBucketNotificationType2;
    this.getBucketNotificationType2 = getBucketNotificationType2;
  }

}

TosClient.TosServerError = TosServerError;
TosClient.isCancel = isCancelError;
TosClient.CancelError = CancelError;
TosClient.TosServerCode = exports.TosServerCode;
TosClient.TosClientError = TosClientError;
TosClient.CancelToken = CancelToken;
TosClient.ACLType = exports.ACLType;
TosClient.StorageClassType = exports.StorageClassType;
TosClient.MetadataDirectiveType = exports.MetadataDirectiveType;
TosClient.AzRedundancyType = exports.AzRedundancyType;
TosClient.PermissionType = exports.PermissionType;
TosClient.GranteeType = exports.GranteeType;
TosClient.CannedType = exports.CannedType;
TosClient.HttpMethodType = exports.HttpMethodType;
TosClient.LifecycleStatusType = exports.LifecycleStatusType;
TosClient.StatusType = exports.StatusType;
TosClient.RedirectType = exports.RedirectType;
TosClient.StorageClassInheritDirectiveType = exports.StorageClassInheritDirectiveType;
TosClient.TierType = exports.TierType;
TosClient.VersioningStatusType = exports.VersioningStatusType;
TosClient.createDefaultRateLimiter = createDefaultRateLimiter;
TosClient.DataTransferType = exports.DataTransferType;
TosClient.UploadEventType = exports.UploadEventType;
TosClient.DownloadEventType = exports.DownloadEventType;
TosClient.ResumableCopyEventType = exports.ResumableCopyEventType;
TosClient.ReplicationStatusType = exports.ReplicationStatusType;

exports.CancelError = CancelError;
exports.CancelToken = CancelToken;
exports.TOS = TosClient;
exports.TosClient = TosClient;
exports.TosClientError = TosClientError;
exports.TosServerError = TosServerError;
exports.createDefaultRateLimiter = createDefaultRateLimiter;
exports["default"] = TosClient;
exports.isCancel = isCancelError;
//# sourceMappingURL=tos.cjs.development.js.map


/***/ }),

/***/ 21:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports, "__esModule", ({value:!0}));var t=e(__nccwpck_require__(250)),a=e(__nccwpck_require__(8025)),o=e(__nccwpck_require__(9934)),n=e(__nccwpck_require__(3098)),i=__nccwpck_require__(2781),r=e(__nccwpck_require__(6908)),s=e(__nccwpck_require__(2900)),c=e(__nccwpck_require__(2760)),p=e(__nccwpck_require__(6113)),l=e(__nccwpck_require__(6545)),d=e(__nccwpck_require__(3685)),u=e(__nccwpck_require__(5687)),h=__nccwpck_require__(5845),m=e(__nccwpck_require__(8237)),f=e(__nccwpck_require__(7147)),y=__nccwpck_require__(3837),g=e(__nccwpck_require__(1017)),x=e(__nccwpck_require__(2187));class b extends Error{constructor(e){super(e),Object.setPrototypeOf(this,b.prototype)}}class k extends Error{constructor(e){super(e),Object.setPrototypeOf(this,k.prototype)}}const v=e=>t=>{if(null==e||"object"!=typeof e)return;const a=r(e,t);Array.isArray(a)||s(e,t,null==a?[]:[a])},T=e=>{const t=a=>Array.isArray(a)?a.map(e=>t(e)):"string"==typeof a?e(a):"object"==typeof a&&null!=a?Object.keys(a).reduce((e,o)=>(e[t(o)]=a[o],e),{}):a;return t},w=T(e=>e.replace(/[A-Z]/g,"-$&").toLowerCase()),S=T(e=>e[0].toUpperCase()+e.slice(1)),C=e=>{const t=[];return Object.keys(e).sort().forEach(a=>{t.push(`${encodeURIComponent(a)}=${encodeURIComponent(e[a])}`)}),t.join("&")},E=e=>{const t=e||{},a={};Object.keys(t).forEach(e=>{null!=t[e]&&(a[e]=t[e])});const o={};return Object.keys(a).forEach(e=>{const t=e.toLowerCase();o[t]=a[e]}),o},R=e=>("string"==typeof e&&(e={url:e}),e);async function P(e){try{return[null,await e]}catch(e){return[e,null]}}function B(e){return"undefined"!=typeof Blob&&e instanceof Blob}function I(e){return"undefined"!=typeof Buffer&&e instanceof Buffer}function D(e){return e instanceof i.Readable}function j(e){return e?Object.keys(e).map(t=>{const a=""+e[t];return`${encodeURIComponent(t)}=${encodeURIComponent(a)}`}).join("&"):""}function O(e){return e instanceof k}const M=e=>"string"==typeof e?e:e.toUTCString(),_={projectName:"x-tos-project-name",encodingType:"encoding-type",cacheControl:"cache-control",contentDisposition:"content-disposition",contentLength:"content-length",contentMD5:"content-md5",contentSHA256:"x-tos-content-sha256",contentEncoding:"content-encoding",contentLanguage:"content-language",contentType:"content-type",expires:["expires",e=>e.toUTCString()],range:"range",ifMatch:"if-match",ifModifiedSince:["if-modified-since",M],ifNoneMatch:"if-none-match",ifUnmodifiedSince:["if-unmodified-since",M],acl:"x-tos-acl",grantFullControl:"x-tos-grant-full-control",grantRead:"x-tos-grant-read",grantReadAcp:"x-tos-grant-read-acp",grantWrite:"x-tos-grant-write",grantWriteAcp:"x-tos-grant-write-acp",serverSideEncryption:"x-tos-server-side-encryption",ssecAlgorithm:"x-tos-server-side-encryption-customer-algorithm",ssecKey:"x-tos-server-side-encryption-customer-key",ssecKeyMD5:"x-tos-server-side-encryption-customer-key-md5",copySourceRange:"x-tos-copy-source-range",copySourceIfMatch:"x-tos-copy-source-if-match",copySourceIfModifiedSince:["x-tos-copy-source-if-modified-since",M],copySourceIfNoneMatch:"x-tos-copy-source-if-none-match",copySourceIfUnmodifiedSince:"x-tos-copy-source-if-unmodified-since",copySourceSSECAlgorithm:"x-tos-copy-source-server-side-encryption-customer-algorithm",copySourceSSECKey:"x-tos-copy-source-server-side-encryption-customer-key",copySourceSSECKeyMD5:"x-tos-copy-source-server-side-encryption-customer-key-MD5",metadataDirective:"x-tos-metadata-directive",meta:e=>Object.keys(e).reduce((t,a)=>(t["x-tos-meta-"+a]=""+e[a],t),{}),websiteRedirectLocation:"x-tos-website-redirect-location",storageClass:"x-tos-storage-class",azRedundancy:"x-tos-az-redundancy",trafficLimit:"x-tos-traffic-limit",callback:"x-tos-callback",callbackVar:"x-tos-callback-var",allowSameActionOverlap:["x-tos-allow-same-action-overlap",e=>String(e)]},A={versionId:"versionId",process:"x-tos-process",saveBucket:"x-tos-save-bucket",saveObject:"x-tos-save-object",responseCacheControl:"response-cache-control",responseContentDisposition:"response-content-disposition",responseContentEncoding:"response-content-encoding",responseContentLanguage:"response-content-language",responseContentType:"response-content-type",responseExpires:["response-expires",e=>e.toUTCString()]};function U(e,t){if(!t.length)return;const a=e.headers||{};function o(e,t){null==a[e]&&(a[e]=t)}e.headers=a,t.forEach(t=>{const a=_[t];if(!a)throw new b(`\`${t}\` isn't in keys of \`requestHeadersMap\``);const n=e[t];if(null==n)return;if("string"==typeof a)return o(a,""+n);if(Array.isArray(a))return o(a[0],a[1](n));const i=a(n);Object.entries(i).forEach(([e,t])=>{o(e,t)})})}const L=e=>c.stringify(e);function N(e,t){return{data:e,statusCode:t.statusCode,headers:t.headers,requestId:t.requestId,id2:t.id2}}function z(e,t){const a=t["x-tos-hash-crc64ecma"];if(null==a)return;const o="string"==typeof e?e:e.getCrc64();if(o!==a)throw new b(`expect crc64 ${a}, actual crc64 ${o}`)}const F=function(e,i){if(I(e))throw new b("not support buffer in browser environment");return function(e,t){return t?e.toString(function(e){switch(e){case"utf-8":return n;case"base64":return a;case"hex":return o;default:throw new b("The coding is not supported")}}(t)):e}(t(e),i)};function K(e,t){return t?e.digest(t):e.digest()}let q=null;q={__proto__:null,hmacSha256:function(e,t,a){return K(p.createHmac("sha256",e).update(t),a)},hashSha256:function(e,t){return K(p.createHash("sha256").update(e),t)},hashMd5:function(e,t){return K(p.createHash("md5").update(e),t)},parse:function(e,t){return Buffer.from(e,t)},stringify:function(e,t){return e.toString(t)}};const{hmacSha256:H,hashSha256:$,hashMd5:G,parse:V,stringify:W}=q;function J(e){return!e||80===e||443===e}const X="request";class Q{constructor(e,t){this.options=void 0,this.credentials=void 0,this.signature=(e,t,a)=>{a||(a=this.credentials);const o=[],n=this.credentialString(e.datetime);return o.push(this.options.algorithm+" Credential="+a.GetAccessKey()+"/"+n),o.push("SignedHeaders="+this.signedHeaders(e)),o.push("Signature="+this.authorization(e,a,0)),o.join(", ")},this.signatureHeader=(e,t,a)=>{e.datetime=this.getDateTime();const o=new Map;e.headers||(e.headers={}),e.headers.host=""+e.host,J(e.port)||(e.headers.host+=":"+e.port),e.endpoints&&(e.headers.host=`${this.options.bucket}.${e.endpoints}`),o.set("host",e.headers.host),o.set("x-tos-date",e.datetime),o.set("x-tos-content-sha256",this.hexEncodedBodyHash()),this.options.securityToken&&o.set("x-tos-security-token",this.options.securityToken),o.forEach((t,a)=>{a.startsWith("x-tos")&&(e.headers[a]=t)}),e.path=this.getEncodePath(e.path);const n=this.signature(e,0,a);return o.set("authorization",n),o},this.gnrCopySig=(e,t)=>({key:"",value:""}),this.getSignature=(e,t)=>({key:"",value:""}),this.getSignatureQuery=(e,t)=>{e.datetime=this.getDateTime(),e.headers||(e.headers={}),e.headers.host=""+e.host,J(e.port)||(e.headers.host+=":"+e.port),e.path=this.getEncodePath(e.path),e.endpoints&&(e.headers.host=`${this.options.bucket}.${e.endpoints}`),e.headers["X-Tos-Date"]=e.datetime;const a=this.credentialString(e.datetime),o={...e.query||{},"X-Tos-Algorithm":this.options.algorithm,"X-Tos-Content-Sha256":this.hexEncodedBodyHash(),"X-Tos-Credential":this.credentials.GetAccessKey()+"/"+a,"X-Tos-Date":e.datetime,"X-Tos-Expires":""+t,"X-Tos-SignedHeaders":this.signedHeaders(e)};return this.options.securityToken&&(o["X-Tos-Security-Token"]=this.options.securityToken),e.query=C(o),o["X-Tos-Signature"]=this.authorization(e,this.credentials,t),o},this.getSignaturePolicyQuery=(e,t)=>{e.datetime=this.getDateTime();const a=this.credentialString(e.datetime),o={"X-Tos-Algorithm":this.options.algorithm,"X-Tos-Credential":this.credentials.GetAccessKey()+"/"+a,"X-Tos-Date":e.datetime,"X-Tos-Expires":""+t,"X-Tos-Policy":W(V(JSON.stringify(e.policy),"utf-8"),"base64")};return this.options.securityToken&&(o["X-Tos-Security-Token"]=this.options.securityToken),e.query=C(o),o["X-Tos-Signature"]=this.authorization(e,this.credentials,t),o},this.hexEncodedBodyHash=()=>"UNSIGNED-PAYLOAD",this.authorization=(e,t,a)=>{if(!e.datetime)return"";const o=this.getSigningKey(t,e.datetime.substr(0,8));return H(o,this.stringToSign(e.datetime,e),"hex")},this.getDateTime=()=>new Date((new Date).toUTCString()).toISOString().replace(/\..+/,"").replace(/-/g,"").replace(/:/g,"")+"Z",this.credentialString=e=>this.createScope(e.substr(0,8),this.options.region,this.options.serviceName),this.createScope=(e,t,a)=>[e.substr(0,8),t,a,X].join("/"),this.getSigningKey=(e,t)=>{const a=H(e.GetSecretKey(),t),o=H(a,this.options.region),n=H(o,this.options.serviceName);return H(n,X)},this.stringToSign=(e,t)=>{if(!this.options.algorithm)return"";const a=[];a.push(this.options.algorithm),a.push(e),a.push(this.credentialString(e));const o="policy"in t?this.canonicalStringPolicy(t):this.canonicalString(t);return a.push(this.hexEncodedHash(o)),a.join("\n")},this.hexEncodedHash=e=>$(e,"hex"),this.canonicalString=e=>{const t=[];return t.push(e.method),t.push(e.path),t.push(this.getEncodePath(e.query,!1)),t.push(this.canonicalHeaders(e)+"\n"),t.push(this.signedHeaders(e)),t.push(this.hexEncodedBodyHash()),t.join("\n")},this.canonicalStringPolicy=e=>{const t=[];return t.push(this.getEncodePath(e.query,!1)),t.push(this.hexEncodedBodyHash()),t.join("\n")},this.canonicalHeaders=e=>{const t=[],a=Z(e.headers);for(let o of a){const a=e.headers[o];o=o.toLowerCase(),t.push(o+":"+this.canonicalHeaderValues(a.toString()))}return t.join("\n")},this.canonicalHeaderValues=e=>e.replace(/\s+/g," ").replace(/^\s+|\s+$/g,""),this.signedHeaders=e=>{const t=[],a=Z(e.headers);for(let e of a)e=e.toLowerCase(),t.push(e);return t.sort().join(";")},this.options=e,this.credentials=t}getEncodePath(e,t=!0){if(!e)return"";let a=e;return t&&(a=e.replace(/%2F/g,"/")),a=a.replace(/\(/g,"%28"),a=a.replace(/\)/g,"%29"),a=a.replace(/!/g,"%21"),a=a.replace(/\*/g,"%2A"),a=a.replace(/\'/g,"%27"),a}}class Y{constructor(e,t,a){this.securityToken=void 0,this.secretAccessKey=void 0,this.accessKeyId=void 0,this.accessKeyId=a,this.secretAccessKey=t,this.securityToken=e}GetAccessKey(){return this.accessKeyId}GetSecretKey(){return this.secretAccessKey}}function Z(e){const t=[];return Object.keys(e||{}).forEach(a=>{("host"===a||a.startsWith("x-tos-"))&&null!=e[a]&&t.push(a)}),t.sort()}class ee extends Error{constructor(e){const{data:t}=e;super(t.Message),this.code=void 0,this.data=void 0,this.statusCode=void 0,this.headers=void 0,this.requestId=void 0,this.id2=void 0,Object.setPrototypeOf(this,ee.prototype),this.data=t,this.code=t.Code,this.statusCode=e.status,this.headers=e.headers,this.requestId=e.headers["x-tos-request-id"],this.id2=e.headers["x-tos-id-2"]}}var te;function ae(e){const{tosOpts:t,...a}=e,o=new(t.isHttps?u.Agent:d.Agent)({...a,keepAlive:!0,rejectUnauthorized:t.enableVerifySSL,timeout:t.idleConnectionTime});o.maxFreeSockets=Infinity,o.maxTotalSockets=t.maxConnections;const n=o.createConnection;return o.createConnection=function(...e){const a=n.call(this,...e);let o=!1,i=!1,r=null;return process.nextTick(()=>{i||(r=setTimeout(()=>{o=!0},t.connectionTimeout))}),a.on("connect",()=>{i=!0,r&&clearTimeout(r),o&&a.destroy(new Error("Connect timeout"))}),a},o}(te=exports.TosServerCode||(exports.TosServerCode={})).NoSuchBucket="NoSuchBucket",te.NoSuchKey="NoSuchKey",te.AccessDenied="AccessDenied",te.MalformedAcl="MalformedAclError",te.UnexpectedContent="UnexpectedContent",te.InvalidRequest="InvalidRequest",te.MissingSecurityHeader="MissingSecurityHeader",te.InvalidArgument="InvalidArgument",te.EntityTooSmall="EntityTooSmall",te.InvalidBucketName="InvalidBucketName",te.BucketNotEmpty="BucketNotEmpty",te.TooManyBuckets="TooManyBuckets",te.BucketAlreadyExists="BucketAlreadyExists",te.MalformedBody="MalformedBody",te.NoSuchLifecycleConfiguration="NoSuchLifecycleConfiguration",te.ReplicationConfigurationNotFound="ReplicationConfigurationNotFoundError",te.InvalidLocationConstraint="InvalidLocationConstraint",te.AuthorizationQueryParametersError="AuthorizationQueryParametersError",te.RequestTimeTooSkewed="RequestTimeTooSkewed",te.SignatureDoesNotMatch="SignatureDoesNotMatch",te.RequestedRangeNotSatisfiable="Requested Range Not Satisfiable",te.PreconditionFailed="PreconditionFailed",te.BadDigest="BadDigest",te.InvalidDigest="InvalidDigest",te.EntityTooLarge="EntityTooLarge",te.UnImplemented="UnImplemented",te.MethodNotAllowed="MethodNotAllowed",te.InvalidAccessKeyId="InvalidAccessKeyId",te.InvalidSecurityToken="InvalidSecurityToken",te.ContentSHA256Mismatch="ContentSHA256Mismatch",te.ExceedQPSLimit="ExceedQPSLimit",te.ExceedRateLimit="ExceedRateLimit",te.NoSuchCORSConfiguration="NoSuchCORSConfiguration",te.NoSuchMirrorConfiguration="NoSuchMirrorConfiguration",te.NoSuchWebsiteConfiguration="NoSuchWebsiteConfiguration",te.MissingRequestBody="MissingRequestBodyError",te.BucketAlreadyOwnedByYou="BucketAlreadyOwnedByYou",te.NoSuchBucketPolicy="NoSuchBucketPolicy",te.PolicyTooLarge="PolicyTooLarge",te.MalformedPolicy="MalformedPolicy",te.InvalidKey="InvalidKey",te.MirrorFailed="MirrorFailed",te.Timeout="Timeout",te.OffsetNotMatched="OffsetNotMatched",te.NotAppendable="NotAppendable",te.ContextCanceled="ContextCanceled",te.InternalError="InternalError",te.TooManyRequests="TooManyRequests",te.TimeOut="TimeOut",te.ConcurrencyUpdateObjectLimit="ConcurrencyUpdateObjectLimit",te.DuplicateUpload="DuplicateUpload",te.DuplicateObject="DuplicateObject",te.InvalidVersionId="InvalidVersionId",te.StorageClassNotMatch="StorageClassNotMatch",te.UploadStatusNotUploading="UploadStatusNotUploading",te.PartSizeNotMatch="PartSizeNotMatch",te.NoUploadPart="NoUploadPart",te.PartsLenInvalid="PartsLenInvalid",te.PartsIdxSmall="PartsIdxSmall",te.PartSizeSmall="PartSizeSmall",te.PrefixNotNextKeyPrefix="PrefixNotNextKeyPrefix",te.InvalidPart="InvalidPart",te.InvalidPartOffset="InvalidPartOffset",te.MismatchObject="MismatchObject",te.UploadStatusMismatch="UploadStatusMismatch",te.CompletingStatusNoExpiration="CompletingStatusNoExpiration",te.Found="Found",te.InvalidRedirectLocation="InvalidRedirectLocation";const oe={"3gp":"video/3gpp","7z":"application/x-7z-compressed",abw:"application/x-abiword",ai:"application/postscript",aif:"audio/x-aiff",aifc:"audio/x-aiff",aiff:"audio/x-aiff",alc:"chemical/x-alchemy",amr:"audio/amr",anx:"application/annodex",apk:"application/vnd.android.package-archive",appcache:"text/cache-manifest",art:"image/x-jg",asc:"text/plain",asf:"video/x-ms-asf",aso:"chemical/x-ncbi-asn1-binary",asx:"video/x-ms-asf",atom:"application/atom+xml",atomcat:"application/atomcat+xml",atomsrv:"application/atomserv+xml",au:"audio/basic",avi:"video/x-msvideo",awb:"audio/amr-wb",axa:"audio/annodex",axv:"video/annodex",b:"chemical/x-molconn-Z",bak:"application/x-trash",bat:"application/x-msdos-program",bcpio:"application/x-bcpio",bib:"text/x-bibtex",bin:"application/octet-stream",bmp:"image/x-ms-bmp",boo:"text/x-boo",book:"application/x-maker",brf:"text/plain",bsd:"chemical/x-crossfire",c:"text/x-csrc","c++":"text/x-c++src",c3d:"chemical/x-chem3d",cab:"application/x-cab",cac:"chemical/x-cache",cache:"chemical/x-cache",cap:"application/vnd.tcpdump.pcap",cascii:"chemical/x-cactvs-binary",cat:"application/vnd.ms-pki.seccat",cbin:"chemical/x-cactvs-binary",cbr:"application/x-cbr",cbz:"application/x-cbz",cc:"text/x-c++src",cda:"application/x-cdf",cdf:"application/x-cdf",cdr:"image/x-coreldraw",cdt:"image/x-coreldrawtemplate",cdx:"chemical/x-cdx",cdy:"application/vnd.cinderella",cef:"chemical/x-cxf",cer:"chemical/x-cerius",chm:"chemical/x-chemdraw",chrt:"application/x-kchart",cif:"chemical/x-cif",class:"application/java-vm",cls:"text/x-tex",cmdf:"chemical/x-cmdf",cml:"chemical/x-cml",cod:"application/vnd.rim.cod",com:"application/x-msdos-program",cpa:"chemical/x-compass",cpio:"application/x-cpio",cpp:"text/x-c++src",cpt:"application/mac-compactpro",cr2:"image/x-canon-cr2",crl:"application/x-pkcs7-crl",crt:"application/x-x509-ca-cert",crw:"image/x-canon-crw",csd:"audio/csound",csf:"chemical/x-cache-csf",csh:"application/x-csh",csm:"chemical/x-csml",csml:"chemical/x-csml",css:"text/css",csv:"text/csv",ctab:"chemical/x-cactvs-binary",ctx:"chemical/x-ctx",cu:"application/cu-seeme",cub:"chemical/x-gaussian-cube",cxf:"chemical/x-cxf",cxx:"text/x-c++src",d:"text/x-dsrc",davmount:"application/davmount+xml",dcm:"application/dicom",dcr:"application/x-director",ddeb:"application/vnd.debian.binary-package",dif:"video/dv",diff:"text/x-diff",dir:"application/x-director",djv:"image/vnd.djvu",djvu:"image/vnd.djvu",dl:"video/dl",dll:"application/x-msdos-program",dmg:"application/x-apple-diskimage",dms:"application/x-dms",doc:"application/msword",docm:"application/vnd.ms-word.document.macroEnabled.12",docx:"application/vnd.openxmlformats-officedocument.wordprocessingml.document",dot:"application/msword",dotm:"application/vnd.ms-word.template.macroEnabled.12",dotx:"application/vnd.openxmlformats-officedocument.wordprocessingml.template",dv:"video/dv",dvi:"application/x-dvi",dx:"chemical/x-jcamp-dx",dxr:"application/x-director",emb:"chemical/x-embl-dl-nucleotide",embl:"chemical/x-embl-dl-nucleotide",eml:"message/rfc822",eot:"application/vnd.ms-fontobject",eps:"application/postscript",eps2:"application/postscript",eps3:"application/postscript",epsf:"application/postscript",epsi:"application/postscript",erf:"image/x-epson-erf",es:"application/ecmascript",etx:"text/x-setext",exe:"application/x-msdos-program",ez:"application/andrew-inset",fb:"application/x-maker",fbdoc:"application/x-maker",fch:"chemical/x-gaussian-checkpoint",fchk:"chemical/x-gaussian-checkpoint",fig:"application/x-xfig",flac:"audio/flac",fli:"video/fli",flv:"video/x-flv",fm:"application/x-maker",frame:"application/x-maker",frm:"application/x-maker",gal:"chemical/x-gaussian-log",gam:"chemical/x-gamess-input",gamin:"chemical/x-gamess-input",gan:"application/x-ganttproject",gau:"chemical/x-gaussian-input",gcd:"text/x-pcs-gcd",gcf:"application/x-graphing-calculator",gcg:"chemical/x-gcg8-sequence",gen:"chemical/x-genbank",gf:"application/x-tex-gf",gif:"image/gif",gjc:"chemical/x-gaussian-input",gjf:"chemical/x-gaussian-input",gl:"video/gl",gnumeric:"application/x-gnumeric",gpt:"chemical/x-mopac-graph",gsf:"application/x-font",gsm:"audio/x-gsm",gtar:"application/x-gtar",gz:"application/gzip",h:"text/x-chdr","h++":"text/x-c++hdr",hdf:"application/x-hdf",hh:"text/x-c++hdr",hin:"chemical/x-hin",hpp:"text/x-c++hdr",hqx:"application/mac-binhex40",hs:"text/x-haskell",hta:"application/hta",htc:"text/x-component",htm:"text/html",html:"text/html",hwp:"application/x-hwp",hxx:"text/x-c++hdr",ica:"application/x-ica",ice:"x-conference/x-cooltalk",ico:"image/vnd.microsoft.icon",ics:"text/calendar",icz:"text/calendar",ief:"image/ief",iges:"model/iges",igs:"model/iges",iii:"application/x-iphone",info:"application/x-info",inp:"chemical/x-gamess-input",ins:"application/x-internet-signup",iso:"application/x-iso9660-image",isp:"application/x-internet-signup",ist:"chemical/x-isostar",istr:"chemical/x-isostar",jad:"text/vnd.sun.j2me.app-descriptor",jam:"application/x-jam",jar:"application/java-archive",java:"text/x-java",jdx:"chemical/x-jcamp-dx",jmz:"application/x-jmol",jng:"image/x-jng",jnlp:"application/x-java-jnlp-file",jp2:"image/jp2",jpe:"image/jpeg",jpeg:"image/jpeg",jpf:"image/jpx",jpg:"image/jpeg",jpg2:"image/jp2",jpm:"image/jpm",jpx:"image/jpx",js:"application/javascript",json:"application/json",kar:"audio/midi",key:"application/pgp-keys",kil:"application/x-killustrator",kin:"chemical/x-kinemage",kml:"application/vnd.google-earth.kml+xml",kmz:"application/vnd.google-earth.kmz",kpr:"application/x-kpresenter",kpt:"application/x-kpresenter",ksp:"application/x-kspread",kwd:"application/x-kword",kwt:"application/x-kword",latex:"application/x-latex",lha:"application/x-lha",lhs:"text/x-literate-haskell",lin:"application/bbolin",lsf:"video/x-la-asf",lsx:"video/x-la-asf",ltx:"text/x-tex",ly:"text/x-lilypond",lyx:"application/x-lyx",lzh:"application/x-lzh",lzx:"application/x-lzx",m3g:"application/m3g",m3u:"audio/x-mpegurl",m3u8:"application/x-mpegURL",m4a:"audio/mpeg",maker:"application/x-maker",man:"application/x-troff-man",mbox:"application/mbox",mcif:"chemical/x-mmcif",mcm:"chemical/x-macmolecule",mdb:"application/msaccess",me:"application/x-troff-me",mesh:"model/mesh",mid:"audio/midi",midi:"audio/midi",mif:"application/x-mif",mkv:"video/x-matroska",mm:"application/x-freemind",mmd:"chemical/x-macromodel-input",mmf:"application/vnd.smaf",mml:"text/mathml",mmod:"chemical/x-macromodel-input",mng:"video/x-mng",moc:"text/x-moc",mol:"chemical/x-mdl-molfile",mol2:"chemical/x-mol2",moo:"chemical/x-mopac-out",mop:"chemical/x-mopac-input",mopcrt:"chemical/x-mopac-input",mov:"video/quicktime",movie:"video/x-sgi-movie",mp2:"audio/mpeg",mp3:"audio/mpeg",mp4:"video/mp4",mpc:"chemical/x-mopac-input",mpe:"video/mpeg",mpeg:"video/mpeg",mpega:"audio/mpeg",mpg:"video/mpeg",mpga:"audio/mpeg",mph:"application/x-comsol",mpv:"video/x-matroska",ms:"application/x-troff-ms",msh:"model/mesh",msi:"application/x-msi",mvb:"chemical/x-mopac-vib",mxf:"application/mxf",mxu:"video/vnd.mpegurl",nb:"application/mathematica",nbp:"application/mathematica",nc:"application/x-netcdf",nef:"image/x-nikon-nef",nwc:"application/x-nwc",o:"application/x-object",oda:"application/oda",odb:"application/vnd.oasis.opendocument.database",odc:"application/vnd.oasis.opendocument.chart",odf:"application/vnd.oasis.opendocument.formula",odg:"application/vnd.oasis.opendocument.graphics",odi:"application/vnd.oasis.opendocument.image",odm:"application/vnd.oasis.opendocument.text-master",odp:"application/vnd.oasis.opendocument.presentation",ods:"application/vnd.oasis.opendocument.spreadsheet",odt:"application/vnd.oasis.opendocument.text",oga:"audio/ogg",ogg:"audio/ogg",ogv:"video/ogg",ogx:"application/ogg",old:"application/x-trash",one:"application/onenote",onepkg:"application/onenote",onetmp:"application/onenote",onetoc2:"application/onenote",opf:"application/oebps-package+xml",opus:"audio/ogg",orc:"audio/csound",orf:"image/x-olympus-orf",otf:"application/font-sfnt",otg:"application/vnd.oasis.opendocument.graphics-template",oth:"application/vnd.oasis.opendocument.text-web",otp:"application/vnd.oasis.opendocument.presentation-template",ots:"application/vnd.oasis.opendocument.spreadsheet-template",ott:"application/vnd.oasis.opendocument.text-template",oza:"application/x-oz-application",p:"text/x-pascal",p7r:"application/x-pkcs7-certreqresp",pac:"application/x-ns-proxy-autoconfig",pas:"text/x-pascal",pat:"image/x-coreldrawpattern",patch:"text/x-diff",pbm:"image/x-portable-bitmap",pcap:"application/vnd.tcpdump.pcap",pcf:"application/x-font-pcf","pcf.Z":"application/x-font-pcf",pcx:"image/pcx",pdb:"chemical/x-pdb",pdf:"application/pdf",pfa:"application/x-font",pfb:"application/x-font",pfr:"application/font-tdpfr",pgm:"image/x-portable-graymap",pgn:"application/x-chess-pgn",pgp:"application/pgp-encrypted",php:"#application/x-httpd-php",php3:"#application/x-httpd-php3",php3p:"#application/x-httpd-php3-preprocessed",php4:"#application/x-httpd-php4",php5:"#application/x-httpd-php5",phps:"#application/x-httpd-php-source",pht:"#application/x-httpd-php",phtml:"#application/x-httpd-php",pk:"application/x-tex-pk",pl:"text/x-perl",pls:"audio/x-scpls",pm:"text/x-perl",png:"image/png",pnm:"image/x-portable-anymap",pot:"text/plain",potm:"application/vnd.ms-powerpoint.template.macroEnabled.12",potx:"application/vnd.openxmlformats-officedocument.presentationml.template",ppam:"application/vnd.ms-powerpoint.addin.macroEnabled.12",ppm:"image/x-portable-pixmap",pps:"application/vnd.ms-powerpoint",ppsm:"application/vnd.ms-powerpoint.slideshow.macroEnabled.12",ppsx:"application/vnd.openxmlformats-officedocument.presentationml.slideshow",ppt:"application/vnd.ms-powerpoint",pptm:"application/vnd.ms-powerpoint.presentation.macroEnabled.12",pptx:"application/vnd.openxmlformats-officedocument.presentationml.presentation",prf:"application/pics-rules",prt:"chemical/x-ncbi-asn1-ascii",ps:"application/postscript",psd:"image/x-photoshop",py:"text/x-python",pyc:"application/x-python-code",pyo:"application/x-python-code",qgs:"application/x-qgis",qt:"video/quicktime",qtl:"application/x-quicktimeplayer",ra:"audio/x-pn-realaudio",ram:"audio/x-pn-realaudio",rar:"application/rar",ras:"image/x-cmu-raster",rb:"application/x-ruby",rd:"chemical/x-mdl-rdfile",rdf:"application/rdf+xml",rdp:"application/x-rdp",rgb:"image/x-rgb",rhtml:"#application/x-httpd-eruby",rm:"audio/x-pn-realaudio",roff:"application/x-troff",ros:"chemical/x-rosdal",rpm:"application/x-redhat-package-manager",rss:"application/x-rss+xml",rtf:"application/rtf",rtx:"text/richtext",rxn:"chemical/x-mdl-rxnfile",scala:"text/x-scala",sce:"application/x-scilab",sci:"application/x-scilab",sco:"audio/csound",scr:"application/x-silverlight",sct:"text/scriptlet",sd:"chemical/x-mdl-sdfile",sd2:"audio/x-sd2",sda:"application/vnd.stardivision.draw",sdc:"application/vnd.stardivision.calc",sdd:"application/vnd.stardivision.impress",sds:"application/vnd.stardivision.chart",sdw:"application/vnd.stardivision.writer",ser:"application/java-serialized-object",sfd:"application/vnd.font-fontforge-sfd",sfv:"text/x-sfv",sgf:"application/x-go-sgf",sgl:"application/vnd.stardivision.writer-global",sh:"application/x-sh",shar:"application/x-shar",shp:"application/x-qgis",shtml:"text/html",shx:"application/x-qgis",sid:"audio/prs.sid",sig:"application/pgp-signature",sik:"application/x-trash",silo:"model/mesh",sis:"application/vnd.symbian.install",sisx:"x-epoc/x-sisx-app",sit:"application/x-stuffit",sitx:"application/x-stuffit",skd:"application/x-koan",skm:"application/x-koan",skp:"application/x-koan",skt:"application/x-koan",sldm:"application/vnd.ms-powerpoint.slide.macroEnabled.12",sldx:"application/vnd.openxmlformats-officedocument.presentationml.slide",smi:"application/smil+xml",smil:"application/smil+xml",snd:"audio/basic",spc:"chemical/x-galactic-spc",spl:"application/x-futuresplash",spx:"audio/ogg",sql:"application/x-sql",src:"application/x-wais-source",srt:"text/plain",stc:"application/vnd.sun.xml.calc.template",std:"application/vnd.sun.xml.draw.template",sti:"application/vnd.sun.xml.impress.template",stw:"application/vnd.sun.xml.writer.template",sty:"text/x-tex",sv4cpio:"application/x-sv4cpio",sv4crc:"application/x-sv4crc",svg:"image/svg+xml",svgz:"image/svg+xml",sw:"chemical/x-swissprot",swf:"application/x-shockwave-flash",swfl:"application/x-shockwave-flash",sxc:"application/vnd.sun.xml.calc",sxd:"application/vnd.sun.xml.draw",sxg:"application/vnd.sun.xml.writer.global",sxi:"application/vnd.sun.xml.impress",sxm:"application/vnd.sun.xml.math",sxw:"application/vnd.sun.xml.writer",t:"application/x-troff",tar:"application/x-tar",taz:"application/x-gtar-compressed",tcl:"application/x-tcl",tex:"text/x-tex",texi:"application/x-texinfo",texinfo:"application/x-texinfo",text:"text/plain",tgf:"chemical/x-mdl-tgf",tgz:"application/x-gtar-compressed",thmx:"application/vnd.ms-officetheme",tif:"image/tiff",tiff:"image/tiff",tk:"text/x-tcl",tm:"text/texmacs",torrent:"application/x-bittorrent",tr:"application/x-troff",ts:"video/MP2T",tsp:"application/dsptype",tsv:"text/tab-separated-values",ttf:"application/font-sfnt",ttl:"text/turtle",txt:"text/plain",uls:"text/iuls",ustar:"application/x-ustar",val:"chemical/x-ncbi-asn1-binary",vcard:"text/vcard",vcd:"application/x-cdlink",vcf:"text/vcard",vcs:"text/x-vcalendar",vmd:"chemical/x-vmd",vms:"chemical/x-vamas-iso14976",vrm:"x-world/x-vrml",vrml:"model/vrml",vsd:"application/vnd.visio",vss:"application/vnd.visio",vst:"application/vnd.visio",vsw:"application/vnd.visio",wad:"application/x-doom",wasm:"application/wasm",wav:"audio/wav",wax:"audio/x-ms-wax",wbmp:"image/vnd.wap.wbmp",wbxml:"application/vnd.wap.wbxml",webm:"video/webm",wk:"application/x-123",wm:"video/x-ms-wm",wma:"audio/x-ms-wma",wmd:"application/x-ms-wmd",wml:"text/vnd.wap.wml",wmlc:"application/vnd.wap.wmlc",wmls:"text/vnd.wap.wmlscript",wmlsc:"application/vnd.wap.wmlscriptc",wmv:"video/x-ms-wmv",wmx:"video/x-ms-wmx",wmz:"application/x-ms-wmz",woff:"application/font-woff",wp5:"application/vnd.wordperfect5.1",wpd:"application/vnd.wordperfect",wrl:"model/vrml",wsc:"text/scriptlet",wvx:"video/x-ms-wvx",wz:"application/x-wingz",x3d:"model/x3d+xml",x3db:"model/x3d+binary",x3dv:"model/x3d+vrml",xbm:"image/x-xbitmap",xcf:"application/x-xcf",xcos:"application/x-scilab-xcos",xht:"application/xhtml+xml",xhtml:"application/xhtml+xml",xlam:"application/vnd.ms-excel.addin.macroEnabled.12",xlb:"application/vnd.ms-excel",xls:"application/vnd.ms-excel",xlsb:"application/vnd.ms-excel.sheet.binary.macroEnabled.12",xlsm:"application/vnd.ms-excel.sheet.macroEnabled.12",xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",xlt:"application/vnd.ms-excel",xltm:"application/vnd.ms-excel.template.macroEnabled.12",xltx:"application/vnd.openxmlformats-officedocument.spreadsheetml.template",xml:"application/xml",xpi:"application/x-xpinstall",xpm:"image/x-xpixmap",xsd:"application/xml",xsl:"application/xslt+xml",xslt:"application/xslt+xml",xspf:"application/xspf+xml",xtel:"chemical/x-xtel",xul:"application/vnd.mozilla.xul+xml",xwd:"image/x-xwindowdump",xyz:"chemical/x-xyz",xz:"application/x-xz",zip:"application/zip"};function ne(e){return new i.Transform({async transform(t,a,o){e(t.length),this.push(t),o()}})}function ie(e,t){const a=ne(t);return e.on("error",t=>{console.log("stream",e),a.destroy(t)}),e.pipe(a)}let re=null;re={__proto__:null,CRC:class{constructor(){this.value="0"}reset(){this.value="0"}async updateBlob(){throw new b("Not implemented in node.js environment.")}update(e){return this.value=h.crc64(e,this.value),this.value}getCrc64(){return this.value}},combineCrc64:h.combineCrc64};const{CRC:se,combineCrc64:ce}=re;function pe(e,t){const a=Math.max(10240,e),o={rate:Math.max(1024,t),capacity:a,currentAmount:a,lastConsumeTime:Date.now()};return{Acquire:async e=>{e>o.capacity&&(e=o.capacity);const t=Date.now(),a=Math.floor((t-o.lastConsumeTime)/1e3*o.rate);return a+o.currentAmount>o.capacity?o.currentAmount=o.capacity:o.currentAmount+=a,e>o.currentAmount?{ok:!1,timeToWait:Math.ceil((e-o.currentAmount)/o.rate*1e3)}:(o.lastConsumeTime=t,o.currentAmount=o.currentAmount-e,{ok:!0,timeToWait:0})}}}function le(e){return new i.Transform({async transform(t,a,o){try{const a=t.length;let n=!1;for(;!n;){const{ok:t,timeToWait:o}=await e.Acquire(a);t||await ue(o),n=t}this.push(t),o()}catch(e){o(e)}}})}function de(e,t){const a=le(t);return e.on("error",e=>{a.destroy(e)}),e.pipe(a)}function ue(e){return new Promise(t=>{setTimeout(()=>t(""),e)})}class he extends i.Readable{constructor(e){super(),this.buf=void 0,this.lastPos=0,this.buf=e}_read(e){const t=this.buf.length;let a=Math.min(e,t-this.lastPos);this.lastPos>=t?this.push(null):(this.push(this.buf.slice(this.lastPos,this.lastPos+a)),this.lastPos+=a)}}function me(e){return new i.Transform({async transform(t,a,o){e(t),this.push(t),o()}})}function fe(e,t){const a=me(e=>t.update(e));return e.on("error",e=>{a.destroy(e)}),e.pipe(a)}var ye;function ge(e){if(("string"==typeof e?e:e.key).length<1)throw new b("invalid object name, the length must be greater than 1")}function xe(e,t){if(I(e))return e.length;if(B(e))return e.size;if(t&&t["content-length"]){const e=+t["content-length"];if(e>=0)return e}return null}async function be(e){const t=function({body:e,dataTransferCallback:t,makeRetryStream:a,rateLimiter:o}){let n=e;if(I(n)){const e=n;a=()=>new he(e),n=new he(e)}if(D(n)&&(o&&ve(o)&&(n=de(n,o)),n=ie(n,t),a)){const e=a;return{body:n,makeRetryStream:()=>{let a=e();return a?(o&&ve(o)&&(a=de(a,o)),a=ie(a,t),a):a}}}return{body:n,makeRetryStream:void 0}}(e);return async function({body:e,beforeRetry:t,makeRetryStream:a,enableCRC:o}){if(!o)return{body:e,beforeRetry:t,makeRetryStream:a};let n=e;const i=new se;if(D(e)&&(n=fe(e,i),a)){const e=a;a=()=>{const t=e();return t?fe(t,i):t}}return{body:n,beforeRetry:()=>{i.reset(),null==t||t()},makeRetryStream:a,crc:i}}(e={...e,...t})}function ke(e,t){return`/${e}/${encodeURIComponent(t)}`}function ve(e){if(!(null!=e&&e.Acquire&&(null==e?void 0:e.Acquire)instanceof Function))throw new b("The rateLimiter is not valid function");return!0}function Te(e){"object"==typeof e&&console.warn("The `checkpoint` parameter should be passed as a string in node.js environment, representing a file or directory.Passing a checkpoint object to it will be removed in the future.")}!function(e){e.HeaderRestore="x-tos-restore",e.HeaderRestoreExpiryDays="x-tos-restore-expiry-days",e.HeaderRestoreRequestDate="x-tos-restore-request-date",e.HeaderRestoreTier="x-tos-restore-tier",e.HeaderProjectName="x-tos-project-name",e.HeaderReplicationStatus="x-tos-replication-status"}(ye||(ye={}));const we=e=>{if(!e)return;const t=null==e?void 0:e[ye.HeaderRestore];if(t){var a,o,n;const r=null!=(a=null==(o=(null!=t?t:"").split('",')[1])||null==o.split||null==(n=o.split("="))?void 0:n[1])?a:"",s='ongoing-request="true"'===(null==t?void 0:t.trim()),c={RestoreStatus:{OngoingRequest:s,ExpiryDate:r}};var i;return s&&(c.RestoreParam={ExpiryDays:e[ye.HeaderRestoreExpiryDays]?Number(e[ye.HeaderRestoreExpiryDays]):0,RequestDate:null!=(i=e[ye.HeaderRestoreRequestDate])?i:"",Tier:e[ye.HeaderRestoreTier]}),c}},Se=m("TOS");async function Ce(e={}){const t={};U({...e,headers:t},["projectName"]);const a=await this.fetch("GET","/",{},t);return v(a.data)("Buckets"),a}async function Ee(e){const t=e.bucket||this.opts.bucket;if(t){if(t.length<3||t.length>63)throw new b("invalid bucket name, the length must be [3, 63]");if(!/^([a-z]|-|\d)+$/.test(t))throw new b("invalid bucket name, the character set is illegal");if(/^-/.test(t)||/-$/.test(t))throw new b("invalid bucket name, the bucket name can be neither starting with '-' nor ending with '-'")}const a=e.headers=E(e.headers);return U(e,["acl","grantFullControl","grantRead","grantReadAcp","grantWrite","grantWriteAcp","storageClass","azRedundancy","projectName"]),await this.fetchBucket(e.bucket,"PUT",{},a)}async function Re(e){return this.fetchBucket(e,"DELETE",{},{})}async function Pe(e){return this.fetchBucket(e,"HEAD",{},{},void 0,{handleResponse:e=>({...e.headers,ProjectName:e.headers[ye.HeaderProjectName]})})}async function Be(e){const{bucket:t,storageClass:a}=e;return this.fetchBucket(t,"PUT",{storageClass:""},{"x-tos-storage-class":a})}async function Ie(e){const t={};return e.acl&&(t["x-tos-acl"]=e.acl),await this.fetchBucket(e.bucket,"PUT",{acl:""},t,e.aclBody,{needMd5:!0})}async function De(e){return this.fetchBucket(e,"GET",{acl:""},{})}const je=f.createWriteStream,Oe=f.createReadStream,Me=y.promisify(f.rename),_e=y.promisify(f.stat),Ae=y.promisify(f.mkdir),Ue=y.promisify(f.writeFile),Le=y.promisify(f.unlink),Ne=y.promisify(f.readFile);var ze;async function Fe(e){const t="string"==typeof e?{key:e}:e,a={};t.versionId&&(a.versionId=t.versionId);const o=E(null==t?void 0:t.headers),n=(null==t?void 0:t.response)||{};return Object.keys(n).forEach(e=>{const t=n[e];null!=t&&(a["response-"+e]=t)}),this._fetchObject(e,"GET",a,o,void 0,{axiosOpts:{responseType:"arraybuffer"}})}(ze=exports.DataTransferType||(exports.DataTransferType={}))[ze.Started=1]="Started",ze[ze.Rw=2]="Rw",ze[ze.Succeed=3]="Succeed",ze[ze.Failed=4]="Failed";const Ke=["stream","buffer"];async function qe(e){const t="string"==typeof e?{key:e}:e,a=E(t.headers);t.headers=a;const o=t.dataType||"stream";t.dataType=o,function(e){let t="node",a=[];if(t="node",a=Ke,!a.includes(e))throw new b(`The value of \`dataType\` only supports \`${a.join(" | ")}\` in node environment`)}(o);const n={},i=(null==t?void 0:t.response)||{};if(Object.keys(i).forEach(e=>{const t=i[e];null!=t&&(n["response-"+e]=t)}),function(e,t,a){function o(e,a){null==t[e]&&(t[e]=a)}a.length&&a.forEach(t=>{const a=A[t];if(!a)throw new b(`\`${t}\` isn't in keys of \`requestQueryMap\``);const n=e[t];if(null==n)return;if("string"==typeof a)return o(a,""+n);if(Array.isArray(a))return o(a[0],a[1](n));const i=a(n);Object.entries(i).forEach(([e,t])=>{o(e,t)})})}(t,n,["versionId","process","saveBucket","saveObject","responseCacheControl","responseContentDisposition","responseContentEncoding","responseContentLanguage","responseContentType","responseExpires"]),U(t,["ifMatch","ifModifiedSince","ifNoneMatch","ifUnmodifiedSince","ssecAlgorithm","ssecKey","ssecKeyMD5","range","trafficLimit"]),null==t.range&&(null!=t.rangeStart||null!=t.rangeEnd)){var r;const e=`bytes=${null!=t.rangeStart?""+t.rangeStart:""}-${null!=t.rangeEnd?""+t.rangeEnd:""}`;a.range=null!=(r=a.range)?r:e}let s=0,c=-1;const{dataTransferStatusChange:p,progress:l}=t,d=(e,t=0)=>{if(t<0)return;if(!p&&!l)return;s+=t,null==p||p({type:e,rwOnceBytes:t,consumedBytes:s,totalBytes:c});const a=c<0?0:0===c?e===exports.DataTransferType.Succeed?1:0:s/c;1===a?e===exports.DataTransferType.Succeed&&(null==l||l(a)):null==l||l(a)};d(exports.DataTransferType.Started);const[u,h]=await P(this._fetchObject(e,"GET",n,a,void 0,{axiosOpts:{responseType:"stream",onDownloadProgress:e=>{c=e.total,d(exports.DataTransferType.Rw,e.loaded-s)}}}));if(u||!h)throw d(exports.DataTransferType.Failed),u;let m=h.headers,f=h.data;c=+(m["content-length"]||0),D(f)&&(t.rateLimiter&&ve(t.rateLimiter)&&(f=de(f,t.rateLimiter)),f=ie(f,e=>d(exports.DataTransferType.Rw,e)),f.on("end",()=>d(exports.DataTransferType.Succeed)),"buffer"===o&&(f=await(async e=>{let t=Buffer.from([]);return new Promise((a,o)=>{e.on("data",e=>{t=Buffer.concat([t,e])}),e.on("end",()=>{a(t)}),e.on("error",e=>{o(e)})})})(f)));const y={...h,data:{content:f,etag:m.etag||"",lastModified:m["last-modified"]||"",hashCrc64ecma:m["x-tos-hash-crc64ecma"]||"",ReplicationStatus:m[ye.HeaderReplicationStatus]}},g=we(m);return g&&(y.data.RestoreInfo=g),y}async function He(e){return new Promise(async(t,a)=>{const o=await qe.call(this,e),n=o.data.content,i=je(e.filePath);n.pipe(i),i.on("error",e=>a(e)),i.on("finish",()=>{const e={...o.data};delete e.content,t({...o,data:{...e}})})})}async function $e(e){return Ge.call(this,e)}async function Ge(e){const t=(e=this.normalizeObjectInput(e)).headers=E(e.headers);U(e,["contentLength","contentMD5","contentSHA256","cacheControl","contentDisposition","contentEncoding","contentLanguage","contentType","expires","acl","grantFullControl","grantRead","grantReadAcp","grantWrite","grantWriteAcp","ssecAlgorithm","ssecKey","ssecKeyMD5","serverSideEncryption","meta","websiteRedirectLocation","storageClass","trafficLimit","callback","callbackVar"]),this.setObjectContentTypeHeader(e,t);const a=xe(e.body,t),o=null!=a;o||!e.dataTransferStatusChange&&!e.progress||console.warn("Don't get totalSize of putObject's body, the `dataTransferStatusChange` and `progress` callback will not trigger. You can use `putObjectFromFile` instead");let n=0;const{dataTransferStatusChange:i,progress:r}=e,s=(e,t=0)=>{if(!o||t<0)return;if(!i&&!r)return;n+=t,null==i||i({type:e,rwOnceBytes:t,consumedBytes:n,totalBytes:a});const s=0===a?e===exports.DataTransferType.Succeed?1:0:n/a;1===s?e===exports.DataTransferType.Succeed&&(null==r||r(s)):null==r||r(s)},c=await be({body:e.body,dataTransferCallback:e=>s(exports.DataTransferType.Rw,e),makeRetryStream:e.makeRetryStream,enableCRC:this.opts.enableCRC,rateLimiter:e.rateLimiter});s(exports.DataTransferType.Started);const[p,l]=await P((async()=>{const a=await this._fetchObject(e,"PUT",{},t,c.body||"",{handleResponse:t=>{var a;const o={...t.headers};return null!=(a=e)&&a.callback&&t.data&&(o.CallbackResult=""+JSON.stringify(t.data)),o},axiosOpts:{__retryConfig__:{beforeRetry:()=>{n=0,null==c.beforeRetry||c.beforeRetry()},makeRetryStream:c.makeRetryStream},onUploadProgress:e=>{s(exports.DataTransferType.Rw,e.loaded-n)}}});return this.opts.enableCRC&&c.crc&&z(c.crc,a.headers),a})());if(p||!l)throw s(exports.DataTransferType.Failed),p;return s(exports.DataTransferType.Succeed),l}async function Ve(e){const t=E(e.headers);if(!t["content-length"]){const a=await _e(e.filePath);t["content-length"]=""+a.size}const a=()=>Oe(e.filePath);return Ge.call(this,{...e,body:a(),headers:t,makeRetryStream:a})}async function We(e){const t=e.headers=E(e.headers);return U(e,["acl","grantFullControl","grantRead","grantReadAcp","grantWriteAcp","ssecAlgorithm","ssecKey","ssecKeyMD5","meta","storageClass"]),await this._fetchObject(e,"POST",{fetch:""},t,{URL:e.url,IgnoreSameKey:e.ignoreSameKey,ContentMD5:e.contentMD5},{needMd5:!0})}async function Je(e){const t=e.headers=E(e.headers);return U(e,["acl","grantFullControl","grantRead","grantReadAcp","grantWriteAcp","ssecAlgorithm","ssecKey","ssecKeyMD5","meta","storageClass"]),await this._fetchObject(e,"POST",{fetchTask:""},t,{URL:e.url,IgnoreSameKey:e.ignoreSameKey,ContentMD5:e.contentMD5,Object:e.key},{needMd5:!0})}async function Xe(e={}){const{...t}=e,a=await this.fetchBucket(e.bucket,"GET",w(t),{}),o=v(a.data);return o("CommonPrefixes"),o("Contents"),o("Versions"),o("DeleteMarkers"),a}async function Qe(e={}){return this.listObjects({versions:"",...e})}function Ye(e){ge(e);const t="string"==typeof e?{key:e}:e,a=t.alternativeEndpoint||this.opts.endpoint,o=!t.alternativeEndpoint&&!t.isCustomDomain,n=t.bucket||this.opts.bucket||"";if(o&&!n)throw new b("Must provide bucket param");const[i,r,s]=(()=>{const e=encodeURIComponent(t.key),i=t.key.split("/").map(e=>encodeURIComponent(e)).join("/");return o?[`${n}.${a}`,"/"+i,"/"+e]:[a,"/"+i,"/"+e]})(),c=t.query||{},p=(e,t)=>{null==c[e]&&null!=t&&(c[e]=t)},l=t.response||{};Object.keys(l).forEach(e=>{const t=e,a=w(t);p("response-"+a,l[t])}),t.versionId&&p("versionId",t.versionId);const d=this.getSignatureQuery({bucket:n,method:t.method||"GET",path:s,endpoint:a,subdomain:o,expires:t.expires||1800,query:c}),u=R(this.opts.proxy);let h=`http${this.opts.secure?"s":""}://${i}`;return null!=u&&u.url&&(h=u.url.replace(/\/+$/g,""),null!=u&&u.needProxyParams&&(d["x-proxy-tos-host"]=i)),`${h}${r}?${Object.keys(d).map(e=>`${encodeURIComponent(e)}=${encodeURIComponent(d[e])}`).join("&")}`}async function Ze(e){const t="string"==typeof e?{key:e}:e,a=E(t.headers);t.headers=a;const o={};return t.versionId&&(o.versionId=t.versionId),U(t,["ifMatch","ifModifiedSince","ifNoneMatch","ifUnmodifiedSince","ssecAlgorithm","ssecKey","ssecKeyMD5"]),this._fetchObject(e,"HEAD",o,(null==t?void 0:t.headers)||{},void 0,{handleResponse:e=>{const t={...e.headers,ReplicationStatus:e.headers[ye.HeaderReplicationStatus]},a=we(e.headers);return a&&(t.RestoreInfo=a),t}})}async function et(e){const t="string"==typeof e?{key:e}:e,a={};return t.versionId&&(a.versionId=t.versionId),await this._fetchObject(e,"DELETE",a,{},{},{handleResponse:e=>e.headers})}async function tt(e){return this._fetchObject(e,"PUT",{rename:"",name:e.newKey},{},"")}async function at(e){const t={Quiet:e.quiet,Objects:e.objects.map(e=>({Key:e.key,VersionId:e.versionId}))},a=await this.fetchBucket(e.bucket,"POST",{delete:""},{},t),o=v(a.data);return o("Deleted"),o("Error"),a}async function ot(e){const t=E(e.headers);if(e.headers=t,U(e,["cacheControl","contentDisposition","contentEncoding","contentLanguage","contentType","expires","copySourceIfMatch","copySourceIfModifiedSince","copySourceIfNoneMatch","copySourceIfUnmodifiedSince","copySourceSSECAlgorithm","copySourceSSECKey","copySourceSSECKeyMD5","acl","grantFullControl","grantRead","grantReadAcp","grantWriteAcp","ssecAlgorithm","ssecKey","ssecKeyMD5","serverSideEncryption","metadataDirective","meta","websiteRedirectLocation","storageClass","trafficLimit"]),e.srcBucket&&e.srcKey){var a;let o=ke(e.srcBucket,e.srcKey);e.srcVersionID&&(o+="?versionId="+e.srcVersionID),t["x-tos-copy-source"]=null!=(a=t["x-tos-copy-source"])?a:o}const[o,n]=await P(this._fetchObject(e,"PUT",{},t));if(o||!n||!n.data.ETag)throw o;return n}async function nt(e){const t="string"==typeof e?{key:e}:e,a={acl:""};return t.versionId&&(a.versionId=t.versionId),this._fetchObject(e,"GET",a,{})}async function it(e){const t=e.headers=E(e.headers),a={acl:""};return e.versionId&&(a.versionId=e.versionId),U(e,["acl"]),this._fetchObject(e,"PUT",a,t,e.aclBody)}async function rt(e){return this._fetchObject(e,"DELETE",{uploadId:e.uploadId},{})}async function st(e){var t;e.headers=null!=(t=e.headers)?t:{},U(e,["callback","callbackVar"]);const a=t=>{const a=t.headers,o={VersionID:a["x-tos-version-id"],ETag:a.etag,Bucket:e.bucket||this.opts.bucket||"",Location:a.location,HashCrc64ecma:a["x-tos-hash-crc64ecma"],Key:e.key,...t.data};return e.callback&&(o.CallbackResult=""+JSON.stringify(t.data)),o};if(e.completeAll){var o;if((null==(o=e.parts)?void 0:o.length)>0)throw new b("Should not specify both 'completeAll' and 'parts' params.");return this._fetchObject(e,"POST",{uploadId:e.uploadId},{...e.headers,"x-tos-complete-all":"yes"},void 0,{handleResponse:a})}return this._fetchObject(e,"POST",{uploadId:e.uploadId},{...e.headers},{Parts:e.parts.map(e=>({ETag:e.eTag,PartNumber:e.partNumber}))},{handleResponse:a})}async function ct(e){e=this.normalizeObjectInput(e);const t=E(e.headers);return e.headers=t,U(e,["encodingType","cacheControl","contentDisposition","contentEncoding","contentLanguage","contentType","expires","acl","grantFullControl","grantRead","grantReadAcp","grantWriteAcp","ssecAlgorithm","ssecKey","ssecKeyMD5","serverSideEncryption","meta","websiteRedirectLocation","storageClass"]),this.setObjectContentTypeHeader(e,t),this._fetchObject(e,"POST",{uploads:""},t,"")}const pt=(e,t,a=!1)=>{let o=t;t<5242880&&(o=5242880,a&&console.warn(`partSize has been set to ${o}, because the partSize you provided is less than the minimal size of multipart`));const n=Math.ceil(e/1e4);return t<n&&(o=n,a&&console.warn(`partSize has been set to ${o}, because the partSize you provided causes the number of part excesses 10,000`)),o};async function lt(e){const{uploadId:t,...a}=e,o=await this._fetchObject(e,"GET",{uploadId:t,...w(a)},{});return v(o.data)("Parts"),o}async function dt(e){const{uploadId:t,partNumber:a,body:o,enableContentMD5:n=!1}=e,i=E(e.headers);e.headers=i,U(e,["trafficLimit","ssecAlgorithm","ssecKey","ssecKeyMD5"]);const r=xe(o);if(r&&null==i["content-length"]&&(i["content-length"]=r.toFixed(0)),n&&null==i["content-md5"])if(D(o)&&e.makeRetryStream){const t=e.makeRetryStream();if(t){let e=Buffer.from([]);for await(const a of t)e=Buffer.concat([e,"string"==typeof a?Buffer.from(a):a]);const a=G(e,"base64");i["content-md5"]=a}}else console.warn("current not support enableMD5Checksum");const s=xe(e.body,i),c=null!=s;c||!e.dataTransferStatusChange&&!e.progress||console.warn("Don't get totalSize of uploadPart's body, the `dataTransferStatusChange` callback will not trigger. You can use `uploadPartFromFile` instead");let p=0;const{dataTransferStatusChange:l,progress:d}=e,u=(e,t=0)=>{if(!c||t<0)return;if(!l&&!d)return;p+=t,null==l||l({type:e,rwOnceBytes:t,consumedBytes:p,totalBytes:s});const a=0===s?e===exports.DataTransferType.Succeed?1:0:p/s;1===a?e===exports.DataTransferType.Succeed&&(null==d||d(a)):null==d||d(a)},h=await be({body:e.body,dataTransferCallback:e=>u(exports.DataTransferType.Rw,e),beforeRetry:e.beforeRetry,makeRetryStream:e.makeRetryStream,enableCRC:this.opts.enableCRC,rateLimiter:e.rateLimiter});u(exports.DataTransferType.Started);const[m,f]=await P((async()=>{const o=await this._fetchObject(e,"PUT",{partNumber:a,uploadId:t},i,h.body,{handleResponse:e=>({partNumber:a,ETag:e.headers.etag,serverSideEncryption:e.headers["x-tos-server-side-encryption"],serverSideEncryptionKeyId:e.headers["x-tos-server-side-encryption-kms-key-id"],ssecAlgorithm:e.headers["x-tos-server-side-encryption-customer-algorithm"],ssecKeyMD5:e.headers["x-tos-server-side-encryption-customer-key-MD5"],hashCrc64ecma:e.headers["x-tos-hash-crc64ecma"]}),axiosOpts:{__retryConfig__:{beforeRetry:()=>{p=0,null==h.beforeRetry||h.beforeRetry()},makeRetryStream:h.makeRetryStream},onUploadProgress:e=>{u(exports.DataTransferType.Rw,e.loaded-p)}}});return this.opts.enableCRC&&h.crc&&z(h.crc,o.headers),o})());if(m||!f)throw u(exports.DataTransferType.Failed),m;return u(exports.DataTransferType.Succeed),f}async function ut(e){return dt.call(this,e)}async function ht(e){var t,a;const o=await _e(e.filePath),n=null!=(t=e.offset)?t:0,i=Math.min(o.size,n+(null!=(a=e.partSize)?a:o.size)),r=()=>Oe(e.filePath,{start:n,end:i-1});return dt.call(this,{...e,body:r(),headers:{...e.headers||{},"content-length":""+(i-n)},makeRetryStream:r})}async function mt(e={}){const{...t}=e,a=await this.fetchBucket(e.bucket,"GET",{uploads:"",...w(t)},{}),o=v(a.data);return o("Uploads"),o("CommonPrefixes"),a}async function ft(e){const t=e=this.normalizeObjectInput(e),a=e.headers=E(e.headers);U(e,["contentLength","cacheControl","contentDisposition","contentEncoding","contentLanguage","contentType","expires","acl","grantFullControl","grantRead","grantReadAcp","grantWriteAcp","meta","websiteRedirectLocation","storageClass","trafficLimit"]),this.setObjectContentTypeHeader(e,a);const o=xe(e.body,a),n=null!=o;if(!n)throw new b("appendObject needs to know the content length in advance");if(a["content-length"]=a["content-length"]||""+o,this.opts.enableCRC&&0!==e.offset&&!e.preHashCrc64ecma)throw new b("must provide preHashCrc64ecma if enableCRC is true and offset is non-zero");let i=0;const{dataTransferStatusChange:r,progress:s}=e,c=(e,t=0)=>{if(!n||t<0)return;if(!r&&!s)return;i+=t,null==r||r({type:e,rwOnceBytes:t,consumedBytes:i,totalBytes:o});const a=0===o?e===exports.DataTransferType.Succeed?1:0:i/o;1===a?e===exports.DataTransferType.Succeed&&(null==s||s(a)):null==s||s(a)},p=await be({body:e.body,dataTransferCallback:e=>c(exports.DataTransferType.Rw,e),makeRetryStream:void 0,enableCRC:this.opts.enableCRC,rateLimiter:e.rateLimiter});c(exports.DataTransferType.Started);const[l,d]=await P((async()=>{const n=await this._fetchObject(e,"POST",{append:"",offset:t.offset},a,p.body||"",{handleResponse:e=>({...e.headers,nextAppendOffset:+e.headers["x-tos-next-append-offset"],hashCrc64ecma:e.headers["x-tos-hash-crc64ecma"]}),axiosOpts:{__retryConfig__:{beforeRetry:()=>{i=0,null==p.beforeRetry||p.beforeRetry()},makeRetryStream:p.makeRetryStream},onUploadProgress:e=>{c(exports.DataTransferType.Rw,e.loaded-i)}}});return this.opts.enableCRC&&p.crc&&z(ce(t.preHashCrc64ecma||"0",p.crc.getCrc64(),o),n.headers),n})());if(l||!d)throw c(exports.DataTransferType.Failed),l;return c(exports.DataTransferType.Succeed),d}async function yt(e){const t="string"==typeof e?{key:e}:e,a=t.headers=E(t.headers);U(t,["cacheControl","contentDisposition","contentEncoding","contentLanguage","contentType","expires","meta"]);const o={metadata:""};return t.versionId&&(o.versionId=t.versionId),this._fetchObject(e,"POST",o,a)}async function gt(e){const{uploadId:t,partNumber:a}=e,o=E(e.headers);if(e.headers=o,U(e,["copySourceRange","copySourceSSECAlgorithm","copySourceSSECKey","copySourceSSECKeyMD5","ssecAlgorithm","ssecKey","ssecKeyMD5","trafficLimit"]),e.srcBucket&&e.srcKey){var n;let t=ke(e.srcBucket,e.srcKey);e.srcVersionID&&(t+="?versionId="+e.srcVersionID),o["x-tos-copy-source"]=null!=(n=o["x-tos-copy-source"])?n:t}if(null==e.copySourceRange&&(null!=e.copySourceRangeStart||null!=e.copySourceRangeEnd)){var i;const t=`bytes=${null!=e.copySourceRangeStart?""+e.copySourceRangeStart:""}-${null!=e.copySourceRangeEnd?""+e.copySourceRangeEnd:""}`;o["x-tos-copy-source-range"]=null!=(i=o["x-tos-copy-source-range"])?i:t}const[r,s]=await P(this._fetchObject(e,"PUT",{partNumber:a,uploadId:t},o,void 0,{handleResponse:e=>({...e.data,SSECAlgorithm:e.headers[_.ssecAlgorithm],SSECKeyMD5:e.headers[_.ssecKeyMD5]})}));if(r||!s||!s.data.ETag)throw r;return s}class xt extends i.Readable{_read(){this.push(null)}}var bt;(bt=exports.UploadEventType||(exports.UploadEventType={}))[bt.CreateMultipartUploadSucceed=1]="CreateMultipartUploadSucceed",bt[bt.CreateMultipartUploadFailed=2]="CreateMultipartUploadFailed",bt[bt.UploadPartSucceed=3]="UploadPartSucceed",bt[bt.UploadPartFailed=4]="UploadPartFailed",bt[bt.UploadPartAborted=5]="UploadPartAborted",bt[bt.CompleteMultipartUploadSucceed=6]="CompleteMultipartUploadSucceed",bt[bt.CompleteMultipartUploadFailed=7]="CompleteMultipartUploadFailed";const kt=[403,404,405];async function vt(e){var t,a,o;const{cancelToken:n,enableContentMD5:i=!1}=e,r=E(e.headers);e.headers=r,U(e,["encodingType","cacheControl","contentDisposition","contentEncoding","contentLanguage","contentType","expires","acl","grantFullControl","grantRead","grantReadAcp","grantWriteAcp","ssecAlgorithm","ssecKey","ssecKeyMD5","serverSideEncryption","meta","websiteRedirectLocation","storageClass"]);const s=()=>n&&!!n.reason;Te(e.checkpoint);const c=await(async()=>"string"==typeof e.file?_e(e.file):null)(),p=await(async()=>{const{file:t}=e;if(c)return c.size;if(I(t))return t.length;if(B(t))return t.size;throw new b("`file` must be string, Buffer, File or Blob")})(),l=await(async()=>{if("string"==typeof e.checkpoint){const{checkpoint:t}=e;let a=null;try{a=await _e(t)}catch(e){const t=e;if("ENOENT"!==t.code)throw t}const o=a?a.isDirectory():t.endsWith("/"),n=o?g.resolve(t,"@@checkpoint-file-placeholder@@"):g.resolve(t),i=g.dirname(n);if(await Ae(i,{recursive:!0}),o)return{filePath:n,filePathIsPlaceholder:!0};try{return{filePath:n,filePathIsPlaceholder:!1,record:a?JSON.parse(await Ne(n,"utf-8")):void 0}}catch(e){throw console.warn("the checkpoint file is invalid JSON format. please check checkpoint file"),e}}return"object"==typeof e.checkpoint?{record:e.checkpoint}:{}})();await(async()=>{var e;if(c&&null!=(e=l.record)&&e.file_info){var t;const{last_modified:e,file_size:a}=null==(t=l.record)?void 0:t.file_info;c.mtimeMs===e&&c.size===a||(console.warn(`The file has been modified since ${new Date(e)}, so the checkpoint file is invalid, and specified file will be uploaded again.`),delete l.record)}})();const d=pt(p,e.partSize||(null==(t=l.record)?void 0:t.part_size)||20971520,!0);l.record&&l.record.part_size!==d&&(console.warn("The partSize param does not equal the partSize in checkpoint file, so the checkpoint file is invalid, and specified file will be uploaded again."),delete l.record);let u=e.bucket||this.opts.bucket||"";const h=e.key;let m="",f=[];const y=function(e,t){const a=[];for(let o=0;;++o){const n=o*t,i=Math.min(t,e-n);if(a.push({offset:n,partSize:i,partNumber:o+1}),(o+1)*t>=e)break}return a}(p,d),x=((null==(a=l.record)?void 0:a.parts_info)||[]).filter(e=>e.is_completed).reduce((e,t)=>e+t.part_size,0);let v=x;const T=(null==(o=l.record)?void 0:o.parts_info)||[],w=new Map;T.forEach(e=>w.set(e.part_number,e));const S=()=>{const e={bucket:u,key:h,part_size:d,upload_id:m,parts_info:T};return c&&(e.file_info={last_modified:c.mtimeMs,file_size:c.size}),e},C=t=>{if(!e.uploadEventChange)return;const a={bucket:u,uploadId:m,key:h,...t};l.filePath&&(a.checkpointFile=l.filePath),e.uploadEventChange(a)};let R;!function(e){e[e.start=1]="start",e[e.uploadPartSucceed=2]="uploadPartSucceed",e[e.completeMultipartUploadSucceed=3]="completeMultipartUploadSucceed"}(R||(R={}));const D=t=>{e.progress&&(v===p&&t===R.uploadPartSucceed||e.progress(t===R.start&&0===p?0:p?v/p:1,S()))};let j=x;const{dataTransferStatusChange:M}=e,_=(e,t=0)=>{M&&(j+=t,null==M||M({type:e,rwOnceBytes:t,consumedBytes:j,totalBytes:p}))},A=async(e,t)=>{let a=w.get(e.partNumber);a||(a={part_number:e.partNumber,offset:e.offset,part_size:e.partSize,is_completed:!1,etag:"",hash_crc64ecma:""},T.push(a),w.set(a.part_number,a)),t.err||(a.is_completed=!0,a.etag=t.res.ETag,a.hash_crc64ecma=t.res.hashCrc64ecma),await(async()=>{if(l.filePath){const e=JSON.stringify(S(),null,2),t=g.dirname(l.filePath);await Ae(t,{recursive:!0}),await Ue(l.filePath,e,"utf-8")}})();const o={partNumber:a.part_number,partSize:a.part_size,offset:a.offset};if(t.err){const e=t.err;let a=exports.UploadEventType.UploadPartFailed;return e instanceof ee&&kt.includes(e.statusCode)&&(a=exports.UploadEventType.UploadPartAborted),void C({type:a,err:e,uploadPartInfo:o})}o.etag=t.res.ETag,v+=o.partSize,C({type:exports.UploadEventType.UploadPartSucceed,uploadPartInfo:o}),D(R.uploadPartSucceed)};if(l.record){u=l.record.bucket,m=l.record.upload_id;const e=new Set((l.record.parts_info||[]).filter(e=>e.is_completed).map(e=>e.part_number));f=y.filter(t=>!e.has(t.partNumber))}else{try{const{data:t}=await ct.call(this,e);if(s())throw new k("cancel uploadFile");var L;u=t.Bucket,m=t.UploadId,l.filePathIsPlaceholder&&(l.filePath=null==(L=l.filePath)?void 0:L.replace("@@checkpoint-file-placeholder@@",function(e,t){return`${t}.${G(`${e}.${t}`,"hex")}.upload`.replace(/[\\/]/g,"")}(u,h))),C({type:exports.UploadEventType.CreateMultipartUploadSucceed})}catch(e){const t=e;throw C({type:exports.UploadEventType.CreateMultipartUploadFailed,err:t}),t}f=y}D(R.start),_(exports.DataTransferType.Started);const[N,z]=await P((async()=>{let t=null,a=0;if(await Promise.all(Array.from({length:e.taskNum||1}).map(async()=>{for(;;){const o=a++;if(o>=f.length)return;const n=f[o];let c=0;try{const{data:t}=await dt.call(this,{bucket:u,key:h,uploadId:m,body:Tt(e.file,n),enableContentMD5:i,makeRetryStream:wt(e.file,n),beforeRetry:()=>{j-=c,c=0},partNumber:n.partNumber,headers:{"content-length":""+n.partSize,"x-tos-server-side-encryption-customer-algorithm":r["x-tos-server-side-encryption-customer-algorithm"],"x-tos-server-side-encryption-customer-key":r["x-tos-server-side-encryption-customer-key"],"x-tos-server-side-encryption-customer-key-md5":r["x-tos-server-side-encryption-customer-key-md5"]},dataTransferStatusChange(e){e.type===exports.DataTransferType.Rw&&(s()||(c+=e.rwOnceBytes,_(e.type,e.rwOnceBytes)))},trafficLimit:e.trafficLimit,rateLimiter:e.rateLimiter});if(s())throw new k("cancel uploadFile");await A(n,{res:t})}catch(e){const a=e;if(j-=c,c=0,O(a))throw a;if(s())throw new k("cancel uploadFile");t||(t=a),await A(n,{err:a})}}})),t)throw t;const o=(S().parts_info||[]).map(e=>({eTag:e.etag,partNumber:e.part_number})),[n,c]=await P(st.call(this,{bucket:u,key:h,uploadId:m,parts:o}));if(n||!c)throw C({type:exports.UploadEventType.CompleteMultipartUploadFailed}),n;if(C({type:exports.UploadEventType.CompleteMultipartUploadSucceed}),D(R.completeMultipartUploadSucceed),await(async()=>{l.filePath&&await Le(l.filePath).catch(e=>{console.warn("remove checkpoint file failure, you can remove it by hand.\n",`checkpoint file path: ${l.filePath}\n`,e.message)})})(),this.opts.enableCRC&&c.data.HashCrc64ecma&&function(e){var t;const a=(null==(t=e.file_info)?void 0:t.file_size)||0;let o="0";for(const t of e.parts_info||[])o=ce(o,t.hash_crc64ecma,Math.min(t.part_size,a-t.offset));return o}(S())!==c.data.HashCrc64ecma)throw new b("crc of entire file mismatch.");return c})());if(N||!z)throw _(exports.DataTransferType.Failed),N;return _(exports.DataTransferType.Succeed),z}function Tt(e,t){const{offset:a,partSize:o}=t,n=a+o,i=wt(e,t);if(i)return i();if(B(e))return e.slice(a,n);if(I(e))return e.slice(a,n);throw new b("`file` must be string, Buffer, File or Blob")}function wt(e,t){const{offset:a,partSize:o}=t,n=a+o;if("string"==typeof e)return()=>o?Oe(e,{start:a,end:n-1}):new xt}async function St(e){ge(e),e=this.normalizeObjectInput(e);const{expiresIn:t=3600,key:a}=e,o=e.bucket||this.opts.bucket,n={...e.fields},i=[...e.conditions||[]];if(!o)throw new b("Must provide bucket param");const r=this.opts.accessKeySecret,s=new Date,c=Ct({date:new Date(s.valueOf()+1e3*t),type:"ISO"}),p=Ct(),l=p.substring(0,8),d="tos",u="request",h=H(r,l),m=H(h,this.opts.region),f=H(m,d),y=H(f,u),g={key:a,"x-tos-algorithm":"TOS4-HMAC-SHA256","x-tos-date":p,"x-tos-credential":[this.opts.accessKeyId,l,this.opts.region,d,u].join("/")};this.opts.stsToken&&(g["x-tos-security-token"]=this.opts.stsToken),i.push({bucket:o}),Object.entries(g).forEach(([e,t])=>{n[e]=t}),Object.entries(n).forEach(([e,t])=>{i.push({[e]:""+t})});const x=JSON.stringify({expiration:c,conditions:i}),k=W(V(x,"utf-8"),"base64"),v=H(y,k,"hex");return n.policy=k,n["x-tos-signature"]=v,n}function Ct(e){const{date:t=new Date,type:a="Z"}=e||{};return"ISO"===a?t.toISOString():t.toISOString().replace(/\..+/,"").replace(/-/g,"").replace(/:/g,"")+"Z"}var Et,Rt,Pt,Bt,It,Dt,jt,Ot,Mt,_t,At,Ut,Lt,Nt,zt,Ft;(Et=exports.ACLType||(exports.ACLType={})).ACLPrivate="private",Et.ACLPublicRead="public-read",Et.ACLPublicReadWrite="public-read-write",Et.ACLAuthenticatedRead="authenticated-read",Et.ACLBucketOwnerRead="bucket-owner-read",Et.ACLBucketOwnerFullControl="bucket-owner-full-control",Et.ACLBucketOwnerEntrusted="bucket-owner-entrusted",(Rt=exports.StorageClassType||(exports.StorageClassType={})).StorageClassStandard="STANDARD",Rt.StorageClassIa="IA",Rt.StorageClassArchiveFr="ARCHIVE_FR",Rt.StorageClassColdArchive="COLD_ARCHIVE",Rt.StorageClassIntelligentTiering="INTELLIGENT_TIERING",Rt.StorageClassArchive="ARCHIVE",(Pt=exports.MetadataDirectiveType||(exports.MetadataDirectiveType={})).MetadataDirectiveCopy="COPY",Pt.MetadataDirectiveReplace="REPLACE",(Bt=exports.AzRedundancyType||(exports.AzRedundancyType={})).AzRedundancySingleAz="single-az",Bt.AzRedundancyMultiAz="multi-az",(It=exports.PermissionType||(exports.PermissionType={})).PermissionRead="READ",It.PermissionWrite="WRITE",It.PermissionReadAcp="READ_ACP",It.PermissionWriteAcp="WRITE_ACP",It.PermissionFullControl="FULL_CONTROL",(Dt=exports.GranteeType||(exports.GranteeType={})).GranteeGroup="Group",Dt.GranteeUser="CanonicalUser",(jt=exports.CannedType||(exports.CannedType={})).CannedAllUsers="AllUsers",jt.CannedAuthenticatedUsers="AuthenticatedUsers",(Ot=exports.HttpMethodType||(exports.HttpMethodType={})).HttpMethodGet="GET",Ot.HttpMethodPut="PUT",Ot.HttpMethodPost="POST",Ot.HttpMethodDelete="DELETE",Ot.HttpMethodHead="HEAD",(Mt=exports.StorageClassInheritDirectiveType||(exports.StorageClassInheritDirectiveType={})).StorageClassInheritDirectiveDestinationBucket="DESTINATION_BUCKET",Mt.StorageClassInheritDirectiveSourceObject="SOURCE_OBJECT",(_t=exports.ReplicationStatusType||(exports.ReplicationStatusType={})).Complete="COMPLETE",_t.Pending="PENDING",_t.Failed="FAILED",_t.Replica="REPLICA",(At=exports.LifecycleStatusType||(exports.LifecycleStatusType={})).Enabled="Enabled",At.Disabled="Disabled",(Ut=exports.RedirectType||(exports.RedirectType={})).Mirror="Mirror",Ut.Async="Async",(Lt=exports.StatusType||(exports.StatusType={})).Enabled="Enabled",Lt.Disabled="Disabled",(Nt=exports.TierType||(exports.TierType={})).TierStandard="Standard",Nt.TierExpedited="Expedited",Nt.TierBulk="Bulk",(zt=exports.VersioningStatusType||(exports.VersioningStatusType={})).Enabled="Enabled",zt.Suspended="Suspended",zt.NotSet="",zt.Enable="Enabled",zt.Disable="",(Ft=exports.ResumableCopyEventType||(exports.ResumableCopyEventType={}))[Ft.CreateMultipartUploadSucceed=1]="CreateMultipartUploadSucceed",Ft[Ft.CreateMultipartUploadFailed=2]="CreateMultipartUploadFailed",Ft[Ft.UploadPartCopySucceed=3]="UploadPartCopySucceed",Ft[Ft.UploadPartCopyFailed=4]="UploadPartCopyFailed",Ft[Ft.UploadPartCopyAborted=5]="UploadPartCopyAborted",Ft[Ft.CompleteMultipartUploadSucceed=6]="CompleteMultipartUploadSucceed",Ft[Ft.CompleteMultipartUploadFailed=7]="CompleteMultipartUploadFailed";const Kt=[403,404,405];async function qt(e){var t,a,o;const{cancelToken:n}=e,i=()=>n&&!!n.reason;Te(e.checkpoint);const{data:r}=await Ze.call(this,{bucket:e.srcBucket,key:e.srcKey,versionId:e.srcVersionId}),s=r.etag,c=+r["content-length"],p=await(async()=>{if("string"==typeof e.checkpoint){const{checkpoint:t}=e;let a=null;try{a=await _e(t)}catch(e){const t=e;if("ENOENT"!==t.code)throw t}const o=a?a.isDirectory():t.endsWith("/"),n=o?g.resolve(t,"@@checkpoint-file-placeholder@@"):g.resolve(t),i=g.dirname(n);return await Ae(i,{recursive:!0}),o?{filePath:n,filePathIsPlaceholder:!0}:{filePath:n,filePathIsPlaceholder:!1,record:a?JSON.parse(await Ne(n,"utf-8")):void 0}}return"object"==typeof e.checkpoint?{record:e.checkpoint}:{}})();await(async()=>{var e;if(null!=(e=p.record)&&e.copy_source_object_info){var t;const{last_modified:e,object_size:a}=null==(t=p.record)?void 0:t.copy_source_object_info;r["last-modified"]===e&&+r["content-length"]===a||(console.warn(`The file has been modified since ${new Date(e)}, so the checkpoint file is invalid, and specified file will be uploaded again.`),delete p.record)}})();const l=pt(c,e.partSize||(null==(t=p.record)?void 0:t.part_size)||20971520,!0);p.record&&p.record.part_size!==l&&(console.warn("The partSize param does not equal the partSize in checkpoint file, so the checkpoint file is invalid, and specified file will be uploaded again."),delete p.record);let d=e.bucket||this.opts.bucket||"";const u=e.key;let h="",m=[];const f=function(e,t){const a=[];for(let o=0;;++o){const n=o*t,i=Math.min(t,e-n);if(a.push({offset:n,partSize:i,partNumber:o+1}),(o+1)*t>=e)break}return a}(c,l);let y=((null==(a=p.record)?void 0:a.parts_info)||[]).filter(e=>e.is_completed).reduce((e,t)=>e+t.copy_source_range_end-t.copy_source_range_start+1,0);const b=(null==(o=p.record)?void 0:o.parts_info)||[],v=new Map;b.forEach(e=>v.set(e.part_number,e));const T=()=>({bucket:d,key:u,part_size:l,upload_id:h,parts_info:b,copy_source_object_info:{last_modified:r["last-modified"],etag:r.etag,hash_crc64ecma:r["x-tos-hash-crc64ecma"]||"",object_size:+r["content-length"]}}),w=t=>{if(!e.copyEventListener)return;const a={bucket:d,uploadId:h,key:u,...t};p.filePath&&(a.checkpointFile=p.filePath),e.copyEventListener(a)};let S;!function(e){e[e.start=1]="start",e[e.uploadPartSucceed=2]="uploadPartSucceed",e[e.completeMultipartUploadSucceed=3]="completeMultipartUploadSucceed"}(S||(S={}));const C=t=>{e.progress&&(y===c&&t===S.uploadPartSucceed||e.progress(t===S.start&&0===c?0:c?y/c:1,T()))},E=async(e,t)=>{let a=v.get(e.partNumber);const o=e.offset,n=Math.min(e.offset+l-1,c-1);a||(a={part_number:e.partNumber,copy_source_range_start:o,copy_source_range_end:n,is_completed:!1,etag:""},b.push(a),v.set(a.part_number,a)),t.err||(a.is_completed=!0,a.etag=t.res.ETag),await(async()=>{if(p.filePath){const e=JSON.stringify(T(),null,2),t=g.dirname(p.filePath);await Ae(t,{recursive:!0}),await Ue(p.filePath,e,"utf-8")}})();const i={partNumber:a.part_number,copySourceRangeEnd:a.copy_source_range_end,copySourceRangeStart:a.copy_source_range_start};if(t.err){const e=t.err;let a=exports.ResumableCopyEventType.UploadPartCopyFailed;return e instanceof ee&&Kt.includes(e.statusCode)&&(a=exports.ResumableCopyEventType.UploadPartCopyAborted),void w({type:a,err:e,copyPartInfo:i})}i.etag=t.res.ETag,y+=i.copySourceRangeEnd-i.copySourceRangeStart+1,w({type:exports.ResumableCopyEventType.UploadPartCopySucceed,copyPartInfo:i}),C(S.uploadPartSucceed)};if(p.record){d=p.record.bucket,h=p.record.upload_id;const e=new Set((p.record.parts_info||[]).filter(e=>e.is_completed).map(e=>e.part_number));m=f.filter(t=>!e.has(t.partNumber))}else{try{const{data:t}=await ct.call(this,x(e));if(i())throw new k("cancel uploadFile");var R;d=t.Bucket,h=t.UploadId,p.filePathIsPlaceholder&&(p.filePath=null==(R=p.filePath)?void 0:R.replace("@@checkpoint-file-placeholder@@",[(B={...e,bucket:d}).srcBucket,B.srcKey,B.srcVersionId,B.bucket,B.key,"copy"].filter(Boolean).join(".").replace(/[\\/]/g,""))),w({type:exports.ResumableCopyEventType.CreateMultipartUploadSucceed})}catch(e){const t=e;throw w({type:exports.ResumableCopyEventType.CreateMultipartUploadFailed,err:t}),t}m=f}var B;return C(S.start),0===c?(async()=>{let t=ke(e.srcBucket,e.srcKey);e.srcVersionId&&(t+="?versionId="+e.srcVersionId);const a={...e.headers,"x-tos-copy-source":t,"x-tos-copy-source-if-match":s},[o,n]=await P(ot.call(this,{bucket:e.bucket,key:e.key,headers:a,trafficLimit:e.trafficLimit}));if(o||!n)throw w({type:exports.ResumableCopyEventType.UploadPartCopyFailed}),o;return C(S.completeMultipartUploadSucceed),w({type:exports.ResumableCopyEventType.UploadPartCopySucceed,copyPartInfo:{partNumber:0,copySourceRangeStart:0,copySourceRangeEnd:0}}),w({type:exports.ResumableCopyEventType.CompleteMultipartUploadSucceed}),{...n,data:{ETag:n.headers.etag||"",Bucket:d,Key:u,Location:`http${this.opts.secure?"s":""}://${d}.${this.opts.endpoint}/${u}`,VersionID:n.headers["x-tos-version-id"],HashCrc64ecma:n.headers["x-tos-hash-crc64ecma"]}}})():(async()=>{let t=null,a=0;if(await Promise.all(Array.from({length:e.taskNum||1}).map(async()=>{for(;;){const o=a++;if(o>=m.length)return;const n=m[o];try{let t=ke(e.srcBucket,e.srcKey);e.srcVersionId&&(t+="?versionId="+e.srcVersionId);const a=`bytes=${n.offset}-${n.offset+n.partSize-1}`,o={...e.headers,"x-tos-copy-source":t,"x-tos-copy-source-if-match":s,"x-tos-copy-source-range":a};n.partSize||delete o["x-tos-copy-source-range"];const{data:r}=await gt.call(this,{bucket:d,key:u,uploadId:h,partNumber:n.partNumber,headers:o,trafficLimit:e.trafficLimit});if(i())throw new k("cancel resumableCopyObject");await E(n,{res:r})}catch(e){const a=e;if(Ht(a))throw a;if(i())throw new k("cancel resumableCopyObject");t||(t=a),await E(n,{err:a})}}})),t)throw t;const o=(T().parts_info||[]).map(e=>({eTag:e.etag,partNumber:e.part_number})),[n,r]=await P(st.call(this,{bucket:d,key:u,uploadId:h,parts:o}));if(n||!r)throw w({type:exports.ResumableCopyEventType.CompleteMultipartUploadFailed}),n;return w({type:exports.ResumableCopyEventType.CompleteMultipartUploadSucceed}),C(S.completeMultipartUploadSucceed),await(async()=>{p.filePath&&await Le(p.filePath).catch(e=>{console.warn("remove checkpoint file failure, you can remove it by hand.\n",`checkpoint file path: ${p.filePath}\n`,e.message)})})(),r})()}function Ht(e){return e instanceof k}const $t={getBucketCustomDomain:!0,getBucketIntelligenttiering:!0,getBucketInventory:!0,listBucketInventory:!0,getBucketMirrorBack:!0,getBucketNotification:!0,getBucketPolicy:!0,getBucketRealTimeLog:!0,getBucketReplication:!0,getBucketTagging:!0,getBucketWebsite:!0};function Gt(e,t){const{enableCatchEmptyServerError:a,methodKey:o,defaultResponse:n}=t;if(e instanceof ee)if(a){if(404===e.statusCode)return N(n,e)}else if(void 0===a&&404===e.statusCode&&$t[o])return N(n,e);throw e}async function Vt(e){return!this.opts.enableOptimizeMethodBehavior&&void 0!==this.opts.enableOptimizeMethodBehavior||e.policy.Statement.length?await this.fetchBucket(e.bucket,"PUT",{policy:""},{},e.policy,{needMd5:!0}):Jt.call(this,e.bucket)}async function Wt(e){try{const t=await this.fetchBucket(e,"GET",{policy:""},{});return t.data.Statement.forEach(e=>{const t=v(e);Object.keys(e.Condition||{}).forEach(a=>{Object.keys(e.Condition[a]).forEach(e=>{t(`Condition["${a}"]["${e}"]`)})})}),t}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketPolicy",defaultResponse:{Statement:[],Version:"2012-10-17"}})}}async function Jt(e){return this.fetchBucket(e,"DELETE",{policy:""},{})}async function Xt(e){return this.fetchBucket(e,"GET",{versioning:""},{})}async function Qt(e){return this.fetchBucket(e.bucket,"PUT",{versioning:""},{},{Status:e.status})}function Yt(e){const t=Zt.call(this,e);ea(e.conditions);const a=`http${this.opts.secure?"s":""}://${e.alternativeEndpoint||(e.isCustomDomain?this.opts.endpoint:`${t.bucket}.${this.opts.endpoint}`)}`,o=j(this.getSignatureQuery({bucket:t.bucket,expires:t.expires,policy:{conditions:t.conditions}}));return{getSignedURLForList:e=>{const t=j(e),n=[o,t].filter(Boolean).join("&");return`${a}?${n}`},getSignedURLForGetOrHead:(e,t)=>{const n=j(t),i=[o,n].filter(Boolean).join("&"),r=e.split("/").map(e=>encodeURIComponent(e)).join("/");return`${a}/${r}?${i}`},signedQuery:o}}function Zt(e){const t=e.bucket||this.opts.bucket;if(!t)throw new b("Must provide bucket param");ea(e.conditions);const a=e.conditions.map(e=>[e.operator||"eq","$key",e.value]);return a.push(["eq","$bucket",t]),{bucket:t,expires:e.expires||3600,conditions:a}}function ea(e){if(e.length<1)throw new b("The `conditions` field of `PreSignedPolicyURLInput` must has one item at least");for(const t of e){if("key"!==t.key)throw new b("The `key` field of `PolicySignatureCondition` must be `'key'`");if(t.operator&&"eq"!==t.operator&&"starts-with"!==t.operator)throw new b("The `operator` field of `PolicySignatureCondition` must be `'eq'` or `'starts-with'`")}}var ta;(ta=exports.DownloadEventType||(exports.DownloadEventType={}))[ta.CreateTempFileSucceed=1]="CreateTempFileSucceed",ta[ta.CreateTempFileFailed=2]="CreateTempFileFailed",ta[ta.DownloadPartSucceed=3]="DownloadPartSucceed",ta[ta.DownloadPartFailed=4]="DownloadPartFailed",ta[ta.DownloadPartAborted=5]="DownloadPartAborted",ta[ta.RenameTempFileSucceed=6]="RenameTempFileSucceed",ta[ta.RenameTempFileFailed=7]="RenameTempFileFailed";const aa=[403,404,405];async function oa(e){var t,a,o;const{cancelToken:n,versionId:i}=e,r=()=>n&&!!n.reason;Te(e.checkpoint);const s=await Ze.call(this,{bucket:e.bucket,key:e.key,versionId:i}),{data:c}=s,p=c.etag,l=+c["content-length"],d=await(async()=>{if("string"==typeof e.checkpoint){const{checkpoint:t}=e;let a=null;try{a=await _e(t)}catch(e){const t=e;if("ENOENT"!==t.code)throw t}const o=a?a.isDirectory():t.endsWith("/"),n=o?g.resolve(t,"@@checkpoint-file-placeholder@@"):t,i=g.dirname(n);return await Ae(i,{recursive:!0}),o?{filePath:n,filePathIsPlaceholder:!0}:{filePath:n,filePathIsPlaceholder:!1,record:a?JSON.parse(await Ne(n,"utf-8")):void 0}}return"object"==typeof e.checkpoint?{record:e.checkpoint}:{}})();await(async()=>{var e;if(null!=(e=d.record)&&e.object_info){var t;const{last_modified:e,object_size:a}=null==(t=d.record)?void 0:t.object_info;c["last-modified"]===e&&l===a||(console.warn(`The file has been modified since ${new Date(e)}, so the checkpoint file is invalid, and specified object will be downloaded again.`),delete d.record)}})();const u=e.partSize||(null==(t=d.record)?void 0:t.part_size)||20971520;d.record&&d.record.part_size!==u&&(console.warn("The partSize param does not equal the partSize in checkpoint file, so the checkpoint file is invalid, and specified object will be downloaded again."),delete d.record);let h=e.bucket||this.opts.bucket||"";const m=e.key;let f=[];const y=function(e,t){const a=[];for(let o=0;;++o){const n=o*t,i=Math.min(t,e-n);if(a.push({offset:n,partSize:i,partNumber:o+1}),(o+1)*t>=e)break}return a}(l,u),x=((null==(a=d.record)?void 0:a.parts_info)||[]).filter(e=>e.is_completed).reduce((e,t)=>e+(t.range_end-t.range_start+1),0),v=(null==(o=d.record)?void 0:o.parts_info)||[],T=new Map;v.forEach(e=>T.set(e.part_number,e));const w=await(async()=>{let t=null;try{t=await _e(e.filePath)}catch(e){const t=e;if("ENOENT"!==t.code)throw t}const a=(t?t.isDirectory():e.filePath.endsWith("/"))?g.resolve(e.filePath,m):e.filePath,o=g.dirname(a);return await Ae(o,{recursive:!0}),a})(),[S,C]=await(async()=>{const t=w+".temp";let a=!0;try{await _e(e.filePath)}catch(e){const t=e;if("ENOENT"!==t.code)throw t;a=!1}return[t,a]})();d.record&&(C||(console.warn("The temp file doesn't not exist so the checkpoint file is invalid, and specified object will be downloaded again."),delete d.record));const E=async()=>{const t=()=>({bucket:h,key:m,version_id:i,part_size:u,parts_info:v,file_info:{file_path:w,temp_file_path:S},object_info:{last_modified:c["last-modified"],etag:p,hash_crc64ecma:c["x-tos-hash-crc64ecma"]||"",object_size:l}}),a=t=>{if(!e.downloadEventChange)return;const a={bucket:h,versionId:i,key:m,filePath:w,...t};d.filePath&&(a.checkpointFile=d.filePath),e.downloadEventChange(a)};let o,n=x;!function(e){e[e.start=0]="start",e[e.downloadPartSucceed=1]="downloadPartSucceed",e[e.renameTempFileSucceed=2]="renameTempFileSucceed"}(o||(o={}));const C=a=>{e.progress&&(n===l&&a===o.downloadPartSucceed||e.progress(a===o.start&&0===l?0:l?n/l:1,t()))};let E=x;const{dataTransferStatusChange:R}=e,P=(e,t=0)=>{R&&(E+=t,null==R||R({type:e,rwOnceBytes:t,consumedBytes:E,totalBytes:l}))},B=async(e,i)=>{let r=T.get(e.partNumber);const s=e.offset,c=Math.min(e.offset+u-1,l-1);r||(r={part_number:e.partNumber,range_start:s,range_end:c,hash_crc64ecma:"",is_completed:!1},v.push(r),T.set(r.part_number,r)),i.err||(r.is_completed=!0,r.hash_crc64ecma=i.res.rangeHashCrc64ecma),await(async()=>{if(d.filePath){const e=JSON.stringify(t(),null,2),a=g.dirname(d.filePath);await Ae(a,{recursive:!0}),await Ue(d.filePath,e,"utf-8")}})();const p={partNumber:r.part_number,rangeStart:s,rangeEnd:c};if(i.err){const e=i.err;let t=exports.DownloadEventType.DownloadPartFailed;return e instanceof ee&&aa.includes(e.statusCode)&&(t=exports.DownloadEventType.DownloadPartAborted),void a({type:t,err:e,downloadPartInfo:p})}n+=p.rangeEnd-p.rangeStart+1,a({type:exports.DownloadEventType.DownloadPartSucceed,downloadPartInfo:p}),C(o.downloadPartSucceed)};if(d.record){h=d.record.bucket;const e=new Set((d.record.parts_info||[]).filter(e=>e.is_completed).map(e=>e.part_number));f=y.filter(t=>!e.has(t.partNumber))}else{try{await Ue(S,"",{flag:"w+"})}catch(e){const t=e;throw a({type:exports.DownloadEventType.CreateTempFileFailed,err:t}),t}var I;d.filePathIsPlaceholder&&(d.filePath=null==(I=d.filePath)?void 0:I.replace("@@checkpoint-file-placeholder@@",function(e,t,a){return`${e}_${t}.${a}.json`.replace(/[\\/]/g,"")}(h,m,i))),a({type:exports.DownloadEventType.CreateTempFileSucceed}),P(exports.DataTransferType.Started),f=y}C(o.start),0===l?await(async()=>{})():await(async()=>{let a=null,o=0;if(await Promise.all(Array.from({length:e.taskNum||1}).map(async()=>{for(;;){const t=o++;if(t>=f.length)return;const n=f[t];let s=0;try{const t=await qe.call(this,{bucket:h,key:m,versionId:i,headers:{"if-match":p,range:`bytes=${n.offset}-${Math.min(n.offset+n.partSize-1,l-1)}`},trafficLimit:e.trafficLimit,rateLimiter:e.rateLimiter,dataTransferStatusChange(e){e.type===exports.DataTransferType.Rw&&(r()||(s+=e.rwOnceBytes,P(exports.DataTransferType.Rw,e.rwOnceBytes)))}});let a=t.data.content;const o=new se;if(this.opts.enableCRC&&(a=fe(a,o)),await new Promise((e,t)=>{const o=je(S,{start:n.offset,flags:"r+"});o.on("finish",()=>{e(void 0)}),a.on("error",e=>{t(e)}),a.pipe(o),a.on("data",(function e(){r()&&(t(new k("cancel downloadFile")),a.unpipe(o),a.off("data",e))}))}),r())throw new k("cancel downloadFile");await B(n,{res:{...t.data,rangeHashCrc64ecma:o.getCrc64()}})}catch(e){const t=e;if(E-=s,s=0,O(t))throw t;if(r())throw new k("cancel downloadFile");a||(a=t),await B(n,{err:t})}}})),a)throw a;const n=s.data["x-tos-hash-crc64ecma"];if(this.opts.enableCRC&&n){const e=function(e){let t="0";for(const a of e.parts_info||[])t=ce(t,a.hash_crc64ecma,a.range_end-a.range_start+1);return t}(t());if(e!==n)throw new b(`expect crc64 ${n}, actual crc64 ${e}`)}})();try{await Me(S,w)}catch(e){const t=e;throw a({type:exports.DownloadEventType.RenameTempFileFailed,err:t}),P(exports.DataTransferType.Failed),t}return a({type:exports.DownloadEventType.RenameTempFileSucceed}),C(o.renameTempFileSucceed),P(exports.DataTransferType.Succeed),await(async()=>{d.filePath&&await Le(d.filePath).catch(e=>{console.warn("remove checkpoint file failure, you can remove it by hand.\n",`checkpoint file path: ${d.filePath}\n`,e.message)})})(),s};try{return await E()}finally{}}async function na(e){const{bucket:t}=e;return this.fetchBucket(t,"GET",{location:""},{})}async function ia(e){try{const{bucket:t}=e;return await this.fetchBucket(t,"GET",{cors:""},{})}catch(e){return Gt(e,{defaultResponse:{CORSRules:[]},enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketCORS"})}}async function ra(e){const{bucket:t,CORSRules:a}=e;return this.opts.enableOptimizeMethodBehavior&&!a.length?sa.call(this,{bucket:t}):this.fetchBucket(t,"PUT",{cors:""},{},{CORSRules:a})}async function sa(e){const{bucket:t}=e;return this.fetchBucket(t,"DELETE",{cors:""},{})}async function ca(e={}){const{listOnlyOnce:t=!1}=e;let a;if(e.maxKeys||(e.maxKeys=1e3),t)a=await pa.call(this,e);else{const t=e.maxKeys;let o={...e,maxKeys:t};for(;;){const e=await pa.call(this,o);if(null==a?a=e:(a={...e,data:a.data},a.data.KeyCount+=e.data.KeyCount,a.data.IsTruncated=e.data.IsTruncated,a.data.NextContinuationToken=e.data.NextContinuationToken,a.data.Contents=a.data.Contents.concat(e.data.Contents),a.data.CommonPrefixes=a.data.CommonPrefixes.concat(e.data.CommonPrefixes)),!e.data.IsTruncated||a.data.KeyCount>=t)break;o.continuationToken=e.data.NextContinuationToken,o.maxKeys=o.maxKeys-e.data.KeyCount}}return a}async function pa(e){const{...t}=e,a=await this.fetchBucket(e.bucket,"GET",{"list-type":2,...w(t)},{}),o=v(a.data);return o("CommonPrefixes"),o("Contents"),a}async function la(e){const{bucket:t,rules:a}=e;if(this.opts.enableOptimizeMethodBehavior&&!a.length)return ua.call(this,{bucket:t});const o={};return U({...e,headers:o},["allowSameActionOverlap"]),this.fetchBucket(t,"PUT",{lifecycle:""},o,{Rules:a})}async function da(e){try{const{bucket:t}=e;return await this.fetchBucket(t,"GET",{lifecycle:""},{},{},{handleResponse:e=>({AllowSameActionOverlap:e.headers["x-tos-allow-same-action-overlap"],Rules:e.data.Rules})})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketLifecycle",defaultResponse:{Rules:[]}})}}async function ua(e){const{bucket:t}=e;return this.fetchBucket(t,"DELETE",{lifecycle:""},{})}async function ha(e){const{bucket:t,rule:a}=e;return this.fetchBucket(t,"PUT",{encryption:""},{"Content-MD5":F(JSON.stringify({Rule:a}),"base64")},{Rule:a})}async function ma(e){const{bucket:t}=e;return this.fetchBucket(t,"GET",{encryption:""},{})}async function fa(e){const{bucket:t}=e;return this.fetchBucket(t,"DELETE",{encryption:""},{})}async function ya(e){const{bucket:t,rules:a}=e;return this.opts.enableOptimizeMethodBehavior&&!a.length?xa.call(this,{bucket:t}):this.fetchBucket(t,"PUT",{mirror:""},{},{Rules:a})}async function ga(e){const{bucket:t}=e;try{return await this.fetchBucket(t,"GET",{mirror:""},{})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketMirrorBack",defaultResponse:{Rules:[]}})}}async function xa(e){const{bucket:t}=e;return this.fetchBucket(t,"DELETE",{mirror:""},{})}async function ba(e){const{tagSet:t,versionId:a}=e,o=E({versionId:a});return this._fetchObject(e,"PUT",{tagging:"",...o},{},{TagSet:t})}async function ka(e){const{versionId:t}=e,a=E({versionId:t}),o=await this._fetchObject(e,"GET",{tagging:"",...a},{});return v(o.data.TagSet)("Tags"),o}async function va(e){const{versionId:t}=e,a=E({versionId:t});return this._fetchObject(e,"DELETE",{tagging:"",...a},{})}async function Ta(e){const{bucket:t,rules:a,role:o}=e;return this.opts.enableOptimizeMethodBehavior&&!a.length?Sa.call(this,{bucket:t}):this.fetchBucket(t,"PUT",{replication:""},{},{Role:o,Rules:a})}async function wa(e){const{bucket:t,progress:a,ruleId:o}=e,n={replication:"",progress:a||""};null!=o&&(n["rule-id"]=""+o);try{return await this.fetchBucket(t,"GET",n,{})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketReplication",defaultResponse:{Rules:[],Role:""}})}}async function Sa(e){const{bucket:t}=e;return this.fetchBucket(t,"DELETE",{replication:""},{})}async function Ca(e){const{bucket:t,...a}=e,o=S(a);return this.fetchBucket(t,"PUT",{website:""},{},{...o})}async function Ea(e){const{bucket:t}=e;try{return this.fetchBucket(t,"GET",{website:""},{})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketWebsite",defaultResponse:{RoutingRules:[]}})}}async function Ra(e){const{bucket:t}=e;return this.fetchBucket(t,"DELETE",{website:""},{})}async function Pa(e){const{bucket:t,...a}=e,o=S(a);return this.fetchBucket(t,"PUT",{notification:""},{},{...o})}async function Ba(e){const{bucket:t}=e;try{return await this.fetchBucket(t,"GET",{notification:""},{})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketNotification",defaultResponse:{CloudFunctionConfigurations:[],RocketMQConfigurations:[]}})}}async function Ia(e){const{bucket:t,...a}=e,o=S(a);return this.fetchBucket(t,"PUT",{customdomain:""},{},{...o})}async function Da(e){try{const{bucket:t}=e;return await this.fetchBucket(t,"GET",{customdomain:""},{})}catch(e){return Gt(e,{defaultResponse:{CustomDomainRules:[]},enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketCustomDomain"})}}async function ja(e){const{bucket:t,customDomain:a}=e;return this.fetchBucket(t,"DELETE",{customdomain:a},{})}async function Oa(e){const{bucket:t,...a}=e,o=S(a);return this.fetchBucket(t,"PUT",{realtimeLog:""},{},{...o})}async function Ma(e){const{bucket:t}=e;try{return await this.fetchBucket(t,"GET",{realtimeLog:""},{})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketRealTimeLog",defaultResponse:{}})}}async function _a(e){const{bucket:t}=e;return this.fetchBucket(t,"DELETE",{realtimeLog:""},{})}var Aa,Ua,La;async function Na(e){try{return await this.fetchBucket(e.bucket,"GET",{inventory:"",id:e.id},{})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketInventory",defaultResponse:void 0})}}async function za(e){const t={inventory:"",...e.continuationToken?{"continuation-token":e.continuationToken}:null};try{return await this.fetchBucket(e.bucket,"GET",t,{})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"listBucketInventory",defaultResponse:{InventoryConfigurations:[]}})}}async function Fa(e){return this.fetchBucket(e.bucket,"DELETE",{inventory:"",id:e.id},{})}function Ka(e){return this.fetchBucket(e.bucket,"PUT",{inventory:"",id:e.inventoryConfiguration.Id},{},e.inventoryConfiguration)}async function qa(e){const{accountId:t,...a}=e,o=S(a);return await this.fetch("POST","/jobs",{},{"x-tos-account-id":t},{...o})}async function Ha(e){const{accountId:t,maxResults:a=1e3,...o}=e;return await this.fetch("GET","/jobs",{maxResults:a,...o},{"x-tos-account-id":t},{},{axiosOpts:{paramsSerializer:L}})}async function $a(e){const{accountId:t,jobId:a,priority:o}=e;return await this.fetch("POST",`/jobs/${a}/priority`,{priority:o},{"x-tos-account-id":t},{},{needMd5:!0})}async function Ga(e){const{accountId:t,jobId:a,requestedJobStatus:o,statusUpdateReason:n}=e;return await this.fetch("POST",`/jobs/${a}/status`,{requestedJobStatus:o,statusUpdateReason:n},{"x-tos-account-id":t},{},{needMd5:!0})}async function Va(e){const{accountId:t,JobId:a}=e;return await this.fetch("DELETE","/jobs/"+a,{},{"x-tos-account-id":t},{})}async function Wa(e){const{accountId:t,JobId:a}=e;return await this.fetch("GET","/jobs/"+a,{},{"x-tos-account-id":t},{})}async function Ja(e){return await this.fetchBucket(e.bucket,"PUT",{tagging:""},{},e.tagging,{needMd5:!0})}async function Xa({bucket:e}){try{return await this.fetchBucket(e,"GET",{tagging:""},{})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketTagging",defaultResponse:{TagSet:{Tags:[]}}})}}async function Qa({bucket:e}){return this.fetchBucket(e,"DELETE",{tagging:""},{})}async function Ya(e){return await this.fetchBucket(e.bucket,"PUT",{payByTraffic:""},{},e.payByTraffic)}async function Za({bucket:e}){return await this.fetchBucket(e,"GET",{payByTraffic:""},{})}async function eo(e){const{bucket:t}=e;try{return await this.fetchBucket(t,"GET",{imageStyleBriefInfo:""},{})}catch(e){if(e instanceof ee&&404===e.statusCode)return this.getNormalDataFromError({BucketName:t,ImageStyleBriefInfo:[]},e);throw e}}async function to(e){try{return await this.fetchBucket(e,"GET",{imageStyle:""},{})}catch(e){if(e instanceof ee&&404===e.statusCode)return this.getNormalDataFromError({ImageStyles:[]},e);throw e}}async function ao(e){try{const{bucket:t,styleName:a}=e;return await this.fetchBucket(t,"GET",{imageStyleContent:"",styleName:a},{})}catch(e){if(e instanceof ee&&404===e.statusCode)return this.getNormalDataFromError({ImageStyles:[]},e);throw e}}async function oo(e,t){try{return await this.fetchBucket(e,"GET",{imageStyle:"",styleName:t},{})}catch(e){if(e instanceof ee&&404===e.statusCode)return this.getNormalDataFromError(null,e);throw e}}async function no(e){const{bucket:t,styleName:a,content:o,styleObjectPrefix:n}=e;try{return await this.fetchBucket(t,"PUT",{imageStyle:"",styleName:a,styleObjectPrefix:n},{},{Content:o})}catch(e){if(e instanceof ee&&404===e.statusCode)return this.getNormalDataFromError(null,e);throw e}}async function io(e){const{styleName:t,styleObjectPrefix:a,bucket:o}=e;try{return await this.fetchBucket(o,"DELETE",{imageStyle:"",styleName:t,styleObjectPrefix:a},{})}catch(e){if(e instanceof ee&&404===e.statusCode)return this.getNormalDataFromError(null,e);throw e}}async function ro(e,t){try{return await this.fetchBucket(e,"PUT",{originalImageProtect:""},{},t)}catch(e){if(e instanceof ee&&404===e.statusCode)return this.getNormalDataFromError(null,e);throw e}}async function so(e){try{return await this.fetchBucket(e,"GET",{originalImageProtect:""},{})}catch(e){if(e instanceof ee&&404===e.statusCode)return this.getNormalDataFromError(null,e);throw e}}async function co(e){const{bucket:t,Separator:a,SeparatorSuffix:o}=e;try{return await this.fetchBucket(t,"PUT",{imageStyleSeparator:""},{},{Separator:a,SeparatorSuffix:o})}catch(e){if(e instanceof ee&&404===e.statusCode)return this.getNormalDataFromError(null,e);throw e}}async function po(e){try{return await this.fetchBucket(e,"GET",{imageStyleSeparator:""},{})}catch(e){if(e instanceof ee&&404===e.statusCode)return this.getNormalDataFromError(null,e);throw e}}async function lo(e){try{return await this.fetchBucket(e,"GET",{intelligenttiering:""},{})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketIntelligenttiering",defaultResponse:{}})}}async function uo(e){const{bucket:t,...a}=e,o=S(a);return this.fetchBucket(t,"PUT",{rename:""},{},{...o})}async function ho(e){const{bucket:t}=e;return await this.fetchBucket(t,"GET",{rename:""},{})}async function mo(e){const{bucket:t}=e;return this.fetchBucket(t,"DELETE",{rename:""},{})}async function fo(e){const{versionId:t,...a}=e,o={restore:""};t&&(o.versionId=t);const n=S(a);return this._fetchObject(e,"POST",o,{},n)}async function yo(e){const{accountId:t}=e;return await this.fetch("GET","/storagelens",{},{"x-tos-account-id":t},{},{axiosOpts:{paramsSerializer:L}})}async function go(e){const{accountId:t,Id:a}=e;return await this.fetch("DELETE","/storagelens",{id:a},{"x-tos-account-id":t},{},{needMd5:!0})}async function xo(e){const{accountId:t,Id:a}=e;return await this.fetch("GET","/storagelens",{id:a},{"x-tos-account-id":t},{},{needMd5:!0})}async function bo(e){const{accountId:t,Id:a,...o}=e;return await this.fetch("PUT","/storagelens",{id:a},{"x-tos-account-id":t},{...o,Id:a},{needMd5:!0})}async function ko(e){const{bucket:t,...a}=e,o=S(a);return this.fetchBucket(t,"PUT",{notification_v2:""},{},{...o})}async function vo(e){const{bucket:t}=e;try{return await this.fetchBucket(t,"GET",{notification_v2:""},{})}catch(e){return Gt(e,{enableCatchEmptyServerError:this.opts.enableOptimizeMethodBehavior,methodKey:"getBucketNotificationType2",defaultResponse:{Rules:[]}})}}!function(e){e.Daily="Daily",e.Weekly="Weekly"}(Aa||(Aa={})),function(e){e.All="All",e.Current="Current"}(Ua||(Ua={})),function(e){e.Size="Size",e.LastModifiedDat="LastModifiedDate",e.ETag="ETag",e.StorageClass="StorageClass",e.IsMultipartUploaded="IsMultipartUploaded",e.EncryptionStatus="EncryptionStatus",e.CRC64="CRC64",e.ReplicationStatus="ReplicationStatus"}(La||(La={}));const To=l.CancelToken;class wo extends class{constructor(e){this.opts=void 0,this.axiosInst=void 0,this.userAgent=void 0,this.httpAgent=void 0,this.httpsAgent=void 0,this.getObjectPath=e=>{const t="string"!=typeof e&&e.bucket||this.opts.bucket,a="string"==typeof e?e:e.key;if(!t)throw new b("Must provide bucket param");return`/${t}/${encodeURIComponent(a)}`},this.setObjectContentTypeHeader=(e,t)=>{if(null!=t["content-type"])return;let a="application/octet-stream";const o=(e=>"string"==typeof e?e:e.key)(e);this.opts.autoRecognizeContentType&&(a=function(e){const t=e.lastIndexOf(".");if(t<=0)return;const a=e.slice(t+1).toLowerCase();return oe[a]}(o)||a),a&&(t["content-type"]=a)},this.getNormalDataFromError=N,this.opts=this.normalizeOpts(e),this.httpAgent=ae({tosOpts:{...this.opts,isHttps:!1}}),this.httpsAgent=ae({tosOpts:{...this.opts,isHttps:!this.opts.proxyHost}}),this.userAgent=this.getUserAgent(),this.axiosInst=(e=>{const t=l.create();t.defaults.auth=void 0,t.defaults.responseType="json",t.defaults.params=void 0,t.defaults.headers={},t.defaults.withCredentials=!1,t.defaults.maxContentLength=-1,t.defaults.maxBodyLength=-1,t.defaults.maxRedirects=0,t.defaults.validateStatus=function(e){return e>=200&&e<300},t.defaults.decompress=!1,t.defaults.transitional={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1};const a=e=>{var t;return e.headers=e.headers||e.header||(null==e||null==(t=e.response)?void 0:t.headers)||{},e};function o(e){Object.entries(e).forEach(([t,a])=>{const[o,n]=function(e){try{return[null,decodeURI(a)]}catch(e){return[e,null]}}();if(o||null==n||n===a)return;let i=[];const r=(""+a).match(/./gu),s=n.match(/./gu);for(let e=0,t=0;e<s.length;){const a=s[e];if(a===r[t]){i.push(a),++e,++t;continue}const o=encodeURIComponent(a);a.length>1||a.charCodeAt(0)>=128?i.push(a):i.push(o),++e,t+=o.length}e[t]=i.join("")})}return t.interceptors.response.use(a,e=>(a(e),Promise.reject(e))),t.interceptors.response.use(e=>e.headers?(o(e.headers),e):e,async e=>{var t;if(!l.isAxiosError(e))return Promise.reject(e);const a=null==(t=e.response)?void 0:t.headers;return a?(o(a),Promise.reject(e)):Promise.reject(e)}),t.interceptors.response.use(void 0,async a=>{var o;const{config:n}=a;if(!n)return Promise.reject(a);n.__retryConfig__||(n.__retryConfig__={});const r=n.__retryConfig__,s=null!=(o=r.retryCount)?o:0;let c=n.data;const p=(()=>{if(n.data&&n.data instanceof i.Readable){const e=null==r.makeRetryStream?void 0:r.makeRetryStream();if(!e)return!1;c=e}return!0})();if(!((function(e){var t;return!e.response&&Boolean(e.code)||e.response&&!(null!=(t=e.response.headers)&&t["x-tos-request-id"])}(a)||function(e){if(!e.response)return!1;const{status:t}=e.response;return 429===t||t>=500}(a))&&s<e&&p))return Promise.reject(a);const l={...n,data:c,__retryConfig__:{...r,retryCount:s+1}};return null==r.beforeRetry||r.beforeRetry(),t(l)}),t})(this.opts.maxRetryCount)}normalizeOpts(e){var t;["accessKeyId","accessKeySecret","stsToken","region","endpoint"].forEach(t=>{const a=e[t];"string"==typeof a&&(e[t]=a.trim())});const a=["accessKeyId","accessKeySecret","region"].filter(t=>!e[t]).join(", ");if(a)throw new b(`lack params: ${a}.`);const o=e.endpoint||`tos-${e.region}.volces.com`;if(!o)throw new b("the value of param region is invalid, correct values are cn-beijing, cn-nantong etc.");if(o.includes("s3"))throw new b("do not support s3 endpoint, please use tos endpoint.");const n=null==e.secure||!!e.secure,i=(e,t)=>null==e?t:e;return{...e,endpoint:o,secure:n,enableVerifySSL:i(e.enableVerifySSL,!0),autoRecognizeContentType:i(e.autoRecognizeContentType,!0),requestTimeout:i(e.requestTimeout,12e4),connectionTimeout:i(e.connectionTimeout,1e4),maxConnections:i(e.maxConnections,1024),idleConnectionTime:i(e.idleConnectionTime,3e4),maxRetryCount:i(e.maxRetryCount,3),enableCRC:null!=(t=e.enableCRC)&&t,requestAdapter:void 0}}getUserAgent(){return"tos-nodejs-sdk/2.7.3"}async fetch(e,t,a,o,n,i){const r=(null==i?void 0:i.handleResponse)||(e=>e.data);if(n&&(null==i?void 0:i.needMd5)){const e=G(JSON.stringify(n),"base64");o["content-md5"]=e}const[s,c]=(()=>null!=i&&i.subdomainBucket&&this.opts.forcePathStyle?[this.opts.endpoint,`/${i.subdomainBucket}${t}`]:null!=i&&i.subdomainBucket&&!this.opts.isCustomDomain?/^(\d|:)/.test(this.opts.endpoint)?[this.opts.endpoint,`/${i.subdomainBucket}${t}`]:[`${null==i?void 0:i.subdomainBucket}.${this.opts.endpoint}`,t]:[this.opts.endpoint,t])();t=c,o=(e=>{const t={};return Object.entries(e).forEach(([e,a])=>{t[e]=(""+a).match(/./gu).map(e=>e.length>1||e.charCodeAt(0)>=128?encodeURIComponent(e):e).join("")}),t})(o);const p={endpoints:void 0,bucket:"",method:e,headers:{...o},path:t,query:C(a),host:s},d=new Y(this.opts.stsToken,this.opts.accessKeySecret,this.opts.accessKeyId),u=new Q({algorithm:"TOS4-HMAC-SHA256",region:this.opts.region,serviceName:"tos",bucket:"",securityToken:this.opts.stsToken},d).signatureHeader(p),h={...o},m={method:e,baseURL:`http${this.opts.secure?"s":""}://${s}`,url:t,params:a,headers:h,data:n};u.forEach((e,t)=>{m.headers[t]=e});const f=R(this.opts.proxy);if(null!=f&&f.url&&!this.opts.proxyHost)m.baseURL=f.url,null!=f&&f.needProxyParams&&(m.params["x-proxy-tos-host"]=s,delete h.host);else if(this.opts.proxyHost){if(!this.opts.proxyPort)throw new b("The `proxyPort` is required if `proxyHost` is truly.");m.proxy={host:this.opts.proxyHost,port:this.opts.proxyPort,protocol:"http"}}h["user-agent"]=this.userAgent,this.opts.requestTimeout>0&&Infinity!==this.opts.requestTimeout&&(m.timeout=this.opts.requestTimeout),m.httpAgent=this.httpAgent,m.httpsAgent=this.httpsAgent;try{const e={...m};delete e.httpAgent,delete e.httpsAgent,Se("reqOpts: ",e);const t=await this.axiosInst({maxBodyLength:Infinity,maxContentLength:Infinity,adapter:this.opts.requestAdapter,...m,...(null==i?void 0:i.axiosOpts)||{}});return{data:r(t),statusCode:t.status,headers:t.headers,requestId:t.headers["x-tos-request-id"],id2:t.headers["x-tos-id-2"]}}catch(e){var y,g;if(l.isAxiosError(e)&&null!=(y=e.response)&&null!=(g=y.headers)&&g["x-tos-request-id"]){const t=e.response;throw Se("TosServerError response: ",t),new ee(t)}throw Se("err: ",e),e}}async fetchBucket(e,t,a,o,n,i){const r=e||this.opts.bucket;if(!r)throw new b("Must provide bucket param");return this.fetch(t,"/",a,o,n,{...i,subdomainBucket:r})}async _fetchObject(e,t,a,o,n,i){const r="string"!=typeof e&&e.bucket||this.opts.bucket,s="string"==typeof e?e:e.key;if(!r)throw new b("Must provide bucket param");return ge(s),this.fetch(t,"/"+encodeURIComponent(s),a,o,n,{...i,subdomainBucket:r})}getSignatureQuery(e){const t=new Y(this.opts.stsToken,this.opts.accessKeySecret,this.opts.accessKeyId),a=new Q({algorithm:"TOS4-HMAC-SHA256",region:this.opts.endpoint,serviceName:"tos",bucket:e.bucket,securityToken:this.opts.stsToken},t);return"policy"in e?a.getSignaturePolicyQuery({policy:e.policy},e.expires):a.getSignatureQuery({method:e.method,path:e.path,endpoints:e.subdomain?e.endpoint:void 0,host:e.endpoint,query:e.query},e.expires)}normalizeBucketInput(e){return"string"==typeof e?{bucket:e}:e}normalizeObjectInput(e){return"string"==typeof e?{key:e}:e}}{constructor(...e){super(...e),this.createBucket=Ee,this.headBucket=Pe,this.deleteBucket=Re,this.listBuckets=Ce,this.getBucketLocation=na,this.putBucketStorageClass=Be,this.getBucketAcl=De,this.putBucketAcl=Ie,this.getBucketPolicy=Wt,this.putBucketPolicy=Vt,this.deleteBucketPolicy=Jt,this.getBucketVersioning=Xt,this.putBucketVersioning=Qt,this.getBucketCORS=ia,this.putBucketCORS=ra,this.deleteBucketCORS=sa,this.putBucketLifecycle=la,this.getBucketLifecycle=da,this.deleteBucketLifecycle=ua,this.putBucketEncryption=ha,this.getBucketEncryption=ma,this.deleteBucketEncryption=fa,this.putBucketMirrorBack=ya,this.getBucketMirrorBack=ga,this.deleteBucketMirrorBack=xa,this.putBucketReplication=Ta,this.getBucketReplication=wa,this.deleteBucketReplication=Sa,this.putBucketWebsite=Ca,this.getBucketWebsite=Ea,this.deleteBucketWebsite=Ra,this.putBucketNotification=Pa,this.getBucketNotification=Ba,this.putBucketCustomDomain=Ia,this.getBucketCustomDomain=Da,this.deleteBucketCustomDomain=ja,this.putBucketRealTimeLog=Oa,this.getBucketRealTimeLog=Ma,this.deleteBucketRealTimeLog=_a,this.getBucketInventory=Na,this.listBucketInventory=za,this.putBucketInventory=Ka,this.deleteBucketInventory=Fa,this.putBucketTagging=Ja,this.getBucketTagging=Xa,this.deleteBucketTagging=Qa,this.putBucketPayByTraffic=Ya,this.getBucketPayByTraffic=Za,this.getBucketImageStyle=oo,this.getBucketImageStyleList=to,this.getBucketImageStyleListByName=ao,this.getImageStyleBriefInfo=eo,this.deleteBucketImageStyle=io,this.putBucketImageStyle=no,this.putBucketImageStyleSeparator=co,this.putBucketImageProtect=ro,this.getBucketImageProtect=so,this.getBucketImageStyleSeparator=po,this.putBucketRename=uo,this.getBucketRename=ho,this.deleteBucketRename=mo,this.copyObject=ot,this.resumableCopyObject=qt,this.deleteObject=et,this.deleteMultiObjects=at,this.getObject=Fe,this.getObjectV2=qe,this.getObjectToFile=He,this.getObjectAcl=nt,this.headObject=Ze,this.appendObject=ft,this.listObjects=Xe,this.renameObject=tt,this.fetchObject=We,this.putFetchTask=Je,this.listObjectsType2=ca,this.listObjectVersions=Qe,this.putObject=$e,this.putObjectFromFile=Ve,this.putObjectAcl=it,this.setObjectMeta=yt,this.createMultipartUpload=ct,this.uploadPart=ut,this.uploadPartFromFile=ht,this.completeMultipartUpload=st,this.abortMultipartUpload=rt,this.uploadPartCopy=gt,this.listMultipartUploads=mt,this.listParts=lt,this.downloadFile=oa,this.putObjectTagging=ba,this.getObjectTagging=ka,this.deleteObjectTagging=va,this.listJobs=Ha,this.createJob=qa,this.deleteJob=Va,this.describeJob=Wa,this.updateJobStatus=Ga,this.updateJobPriority=$a,this.restoreObject=fo,this.uploadFile=vt,this.getPreSignedUrl=Ye,this.calculatePostSignature=St,this.preSignedPostSignature=St,this.preSignedPolicyURL=Yt,this.getBucketIntelligenttiering=lo,this.listStorageLens=yo,this.deleteStorageLens=go,this.getStorageLens=xo,this.putStorageLens=bo,this.putBucketNotificationType2=ko,this.getBucketNotificationType2=vo}}wo.TosServerError=ee,wo.isCancel=O,wo.CancelError=k,wo.TosServerCode=exports.TosServerCode,wo.TosClientError=b,wo.CancelToken=To,wo.ACLType=exports.ACLType,wo.StorageClassType=exports.StorageClassType,wo.MetadataDirectiveType=exports.MetadataDirectiveType,wo.AzRedundancyType=exports.AzRedundancyType,wo.PermissionType=exports.PermissionType,wo.GranteeType=exports.GranteeType,wo.CannedType=exports.CannedType,wo.HttpMethodType=exports.HttpMethodType,wo.LifecycleStatusType=exports.LifecycleStatusType,wo.StatusType=exports.StatusType,wo.RedirectType=exports.RedirectType,wo.StorageClassInheritDirectiveType=exports.StorageClassInheritDirectiveType,wo.TierType=exports.TierType,wo.VersioningStatusType=exports.VersioningStatusType,wo.createDefaultRateLimiter=pe,wo.DataTransferType=exports.DataTransferType,wo.UploadEventType=exports.UploadEventType,wo.DownloadEventType=exports.DownloadEventType,wo.ResumableCopyEventType=exports.ResumableCopyEventType,wo.ReplicationStatusType=exports.ReplicationStatusType,exports.CancelError=k,exports.CancelToken=To,exports.TOS=wo,exports.TosClient=wo,exports.TosClientError=b,exports.TosServerError=ee,exports.createDefaultRateLimiter=pe,exports["default"]=wo,exports.isCancel=O;
//# sourceMappingURL=tos.cjs.production.min.js.map


/***/ }),

/***/ 6545:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(2618);

/***/ }),

/***/ 8104:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);
var settle = __nccwpck_require__(3211);
var buildFullPath = __nccwpck_require__(1934);
var buildURL = __nccwpck_require__(646);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var httpFollow = (__nccwpck_require__(7707).http);
var httpsFollow = (__nccwpck_require__(7707).https);
var url = __nccwpck_require__(7310);
var zlib = __nccwpck_require__(9796);
var pkg = __nccwpck_require__(8593);
var createError = __nccwpck_require__(5226);
var enhanceError = __nccwpck_require__(1516);

var isHttps = /https:?/;

/**
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} proxy
 * @param {string} location
 */
function setProxy(options, proxy, location) {
  options.hostname = proxy.host;
  options.host = proxy.host;
  options.port = proxy.port;
  options.path = location;

  // Basic proxy authorization
  if (proxy.auth) {
    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
    options.headers['Proxy-Authorization'] = 'Basic ' + base64;
  }

  // If a proxy is used, any redirects must also pass through the proxy
  options.beforeRedirect = function beforeRedirect(redirection) {
    redirection.headers.host = redirection.host;
    setProxy(redirection, proxy, redirection.href);
  };
}

/*eslint consistent-return:0*/
module.exports = function httpAdapter(config) {
  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
    var resolve = function resolve(value) {
      resolvePromise(value);
    };
    var reject = function reject(value) {
      rejectPromise(value);
    };
    var data = config.data;
    var headers = config.headers;

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    if ('User-Agent' in headers || 'user-agent' in headers) {
      // User-Agent is specified; handle case where no UA header is desired
      if (!headers['User-Agent'] && !headers['user-agent']) {
        delete headers['User-Agent'];
        delete headers['user-agent'];
      }
      // Otherwise, use specified value
    } else {
      // Only set header if it hasn't been set in config
      headers['User-Agent'] = 'axios/' + pkg.version;
    }

    if (data && !utils.isStream(data)) {
      if (Buffer.isBuffer(data)) {
        // Nothing to do...
      } else if (utils.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(createError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          config
        ));
      }

      // Add Content-Length header if data exists
      headers['Content-Length'] = data.length;
    }

    // HTTP basic authentication
    var auth = undefined;
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      auth = username + ':' + password;
    }

    // Parse url
    var fullPath = buildFullPath(config.baseURL, config.url);
    var parsed = url.parse(fullPath);
    var protocol = parsed.protocol || 'http:';

    if (!auth && parsed.auth) {
      var urlAuth = parsed.auth.split(':');
      var urlUsername = urlAuth[0] || '';
      var urlPassword = urlAuth[1] || '';
      auth = urlUsername + ':' + urlPassword;
    }

    if (auth) {
      delete headers.Authorization;
    }

    var isHttpsRequest = isHttps.test(protocol);
    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

    var options = {
      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
      method: config.method.toUpperCase(),
      headers: headers,
      agent: agent,
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth: auth
    };

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
    }

    var proxy = config.proxy;
    if (!proxy && proxy !== false) {
      var proxyEnv = protocol.slice(0, -1) + '_proxy';
      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
      if (proxyUrl) {
        var parsedProxyUrl = url.parse(proxyUrl);
        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
        var shouldProxy = true;

        if (noProxyEnv) {
          var noProxy = noProxyEnv.split(',').map(function trim(s) {
            return s.trim();
          });

          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
            if (!proxyElement) {
              return false;
            }
            if (proxyElement === '*') {
              return true;
            }
            if (proxyElement[0] === '.' &&
                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
              return true;
            }

            return parsed.hostname === proxyElement;
          });
        }

        if (shouldProxy) {
          proxy = {
            host: parsedProxyUrl.hostname,
            port: parsedProxyUrl.port,
            protocol: parsedProxyUrl.protocol
          };

          if (parsedProxyUrl.auth) {
            var proxyUrlAuth = parsedProxyUrl.auth.split(':');
            proxy.auth = {
              username: proxyUrlAuth[0],
              password: proxyUrlAuth[1]
            };
          }
        }
      }
    }

    if (proxy) {
      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    var transport;
    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsProxy ? https : http;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      transport = isHttpsProxy ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    }

    // Create the request
    var req = transport.request(options, function handleResponse(res) {
      if (req.aborted) return;

      // uncompress the response body transparently if required
      var stream = res;

      // return the last request in case of redirects
      var lastRequest = res.req || req;


      // if no content, is HEAD request or decompress disabled we should not decompress
      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
        switch (res.headers['content-encoding']) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'compress':
        case 'deflate':
        // add the unzipper to the body stream processing pipeline
          stream = stream.pipe(zlib.createUnzip());

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        }
      }

      var response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: res.headers,
        config: config,
        request: lastRequest
      };

      if (config.responseType === 'stream') {
        response.data = stream;
        settle(resolve, reject, response);
      } else {
        var responseBuffer = [];
        var totalResponseBytes = 0;
        stream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            stream.destroy();
            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              config, null, lastRequest));
          }
        });

        stream.on('error', function handleStreamError(err) {
          if (req.aborted) return;
          reject(enhanceError(err, config, null, lastRequest));
        });

        stream.on('end', function handleStreamEnd() {
          var responseData = Buffer.concat(responseBuffer);
          if (config.responseType !== 'arraybuffer') {
            responseData = responseData.toString(config.responseEncoding);
            if (!config.responseEncoding || config.responseEncoding === 'utf8') {
              responseData = utils.stripBOM(responseData);
            }
          }

          response.data = responseData;
          settle(resolve, reject, response);
        });
      }
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;
      reject(enhanceError(err, config, null, req));
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      var timeout = parseInt(config.timeout, 10);

      if (isNaN(timeout)) {
        reject(createError(
          'error trying to parse `config.timeout` to int',
          config,
          'ERR_PARSE_TIMEOUT',
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devoring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        req.abort();
        reject(createError(
          'timeout of ' + timeout + 'ms exceeded',
          config,
          config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
          req
        ));
      });
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (req.aborted) return;

        req.abort();
        reject(cancel);
      });
    }

    // Send the request
    if (utils.isStream(data)) {
      data.on('error', function handleStreamError(err) {
        reject(enhanceError(err, config, null, req));
      }).pipe(req);
    } else {
      req.end(data);
    }
  });
};


/***/ }),

/***/ 3454:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);
var settle = __nccwpck_require__(3211);
var cookies = __nccwpck_require__(1545);
var buildURL = __nccwpck_require__(646);
var buildFullPath = __nccwpck_require__(1934);
var parseHeaders = __nccwpck_require__(6455);
var isURLSameOrigin = __nccwpck_require__(3608);
var createError = __nccwpck_require__(5226);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ 2618:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);
var bind = __nccwpck_require__(7065);
var Axios = __nccwpck_require__(8178);
var mergeConfig = __nccwpck_require__(4831);
var defaults = __nccwpck_require__(8190);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __nccwpck_require__(8875);
axios.CancelToken = __nccwpck_require__(1587);
axios.isCancel = __nccwpck_require__(4057);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __nccwpck_require__(4850);

// Expose isAxiosError
axios.isAxiosError = __nccwpck_require__(650);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ 8875:
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ 1587:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Cancel = __nccwpck_require__(8875);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ 4057:
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ 8178:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);
var buildURL = __nccwpck_require__(646);
var InterceptorManager = __nccwpck_require__(3214);
var dispatchRequest = __nccwpck_require__(5062);
var mergeConfig = __nccwpck_require__(4831);
var validator = __nccwpck_require__(1632);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ 3214:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ 1934:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var isAbsoluteURL = __nccwpck_require__(1301);
var combineURLs = __nccwpck_require__(7189);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ 5226:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var enhanceError = __nccwpck_require__(1516);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ 5062:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);
var transformData = __nccwpck_require__(9812);
var isCancel = __nccwpck_require__(4057);
var defaults = __nccwpck_require__(8190);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ 1516:
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ 4831:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ 3211:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var createError = __nccwpck_require__(5226);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ 9812:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);
var defaults = __nccwpck_require__(8190);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ 8190:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);
var normalizeHeaderName = __nccwpck_require__(6240);
var enhanceError = __nccwpck_require__(1516);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __nccwpck_require__(3454);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __nccwpck_require__(8104);
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ 7065:
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ 646:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ 7189:
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ 1545:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ 1301:
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ 650:
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ 3608:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ 6240:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ 6455:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(328);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ 4850:
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ 1632:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var pkg = __nccwpck_require__(8593);

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ 328:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var bind = __nccwpck_require__(7065);

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ 9417:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 3717:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var concatMap = __nccwpck_require__(6891);
var balanced = __nccwpck_require__(9417);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 8803:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(4538);

var callBind = __nccwpck_require__(2977);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ 2977:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var bind = __nccwpck_require__(8334);
var GetIntrinsic = __nccwpck_require__(4538);
var setFunctionLength = __nccwpck_require__(4056);

var $TypeError = __nccwpck_require__(6361);
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = __nccwpck_require__(6123);
var $max = GetIntrinsic('%Math.max%');

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ 6891:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 425:
/***/ (function(module, exports, __nccwpck_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nccwpck_require__(6113);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ 8025:
/***/ (function(module, exports, __nccwpck_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nccwpck_require__(425));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),

/***/ 9934:
/***/ (function(module, exports, __nccwpck_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nccwpck_require__(425));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),

/***/ 3098:
/***/ (function(module, exports, __nccwpck_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nccwpck_require__(425));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),

/***/ 250:
/***/ (function(module, exports, __nccwpck_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nccwpck_require__(425));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ 8222:
/***/ ((module, exports, __nccwpck_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __nccwpck_require__(6243)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 6243:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __nccwpck_require__(900);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 8237:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __nccwpck_require__(8222);
} else {
	module.exports = __nccwpck_require__(5332);
}


/***/ }),

/***/ 5332:
/***/ ((module, exports, __nccwpck_require__) => {

/**
 * Module dependencies.
 */

const tty = __nccwpck_require__(6224);
const util = __nccwpck_require__(3837);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __nccwpck_require__(9318);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __nccwpck_require__(6243)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 4564:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var $defineProperty = __nccwpck_require__(6123);

var $SyntaxError = __nccwpck_require__(5474);
var $TypeError = __nccwpck_require__(6361);

var gopd = __nccwpck_require__(8501);

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),

/***/ 6123:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(4538);

/** @type {import('.')} */
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ 1933:
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ 8015:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ 4415:
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ 6279:
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ 5474:
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ 6361:
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ 5065:
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ 1133:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var debug;

module.exports = function () {
  if (!debug) {
    try {
      /* eslint global-require: off */
      debug = __nccwpck_require__(8237)("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug !== "function") {
      debug = function () { /* */ };
    }
  }
  debug.apply(null, arguments);
};


/***/ }),

/***/ 7707:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var url = __nccwpck_require__(7310);
var URL = url.URL;
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var Writable = (__nccwpck_require__(2781).Writable);
var assert = __nccwpck_require__(9491);
var debug = __nccwpck_require__(1133);

// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
  assert(new URL());
}
catch (error) {
  useNativeURL = error.code === "ERR_INVALID_URL";
}

// URL fields to preserve in copy operations
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash",
];

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    try {
      self._processResponse(response);
    }
    catch (cause) {
      self.emit("error", cause instanceof RedirectionError ?
        cause : new RedirectionError({ cause: cause }));
    }
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};

RedirectableRequest.prototype.destroy = function (error) {
  destroyRequest(this._currentRequest, error);
  destroy.call(this, error);
  return this;
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  }
  else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    self.removeListener("close", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request and set up its event handlers
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }

  // RFC7230§5.3.1: When making a request directly to an origin server, […]
  // a client MUST send only the absolute path […] as the request-target.
  this._currentUrl = /^\//.test(this._options.path) ?
    url.format(this._options) :
    // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path;

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      /* istanbul ignore else */
      if (request === self._currentRequest) {
        // Report any write errors
        /* istanbul ignore if */
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          /* istanbul ignore else */
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.

  // If the response is not a redirect; return it as-is
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false ||
      statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
    return;
  }

  // The response is a redirect, so abort the current request
  destroyRequest(this._currentRequest);
  // Discard the remainder of the response to avoid waiting for data
  response.destroy();

  // RFC7231§6.4: A client SHOULD detect and intervene
  // in cyclical redirections (i.e., "infinite" redirection loops).
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }

  // Store the request headers if applicable
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host"),
    }, this._options.headers);
  }

  // RFC7231§6.4: Automatic redirection needs to done with
  // care for methods not known to be safe, […]
  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
  // the request method from POST to GET for the subsequent request.
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
      // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    // Drop a possible entity and headers related to it
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }

  // Drop the Host header, as the redirect might lead to a different host
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

  // If the redirect is relative, carry over the host of the last request
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
    url.format(Object.assign(currentUrlParts, { host: currentHost }));

  // Create the redirected request
  var redirectUrl = resolveUrl(location, currentUrl);
  debug("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);

  // Drop confidential headers when redirecting to a less secure protocol
  // or to a different domain that is not a superdomain
  if (redirectUrl.protocol !== currentUrlParts.protocol &&
     redirectUrl.protocol !== "https:" ||
     redirectUrl.host !== currentHost &&
     !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }

  // Evaluate the beforeRedirect callback
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode: statusCode,
    };
    var requestDetails = {
      url: currentUrl,
      method: method,
      headers: requestHeaders,
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }

  // Perform the redirected request
  this._performRequest();
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters, ensuring that input is an object
      if (isURL(input)) {
        input = spreadUrlObject(input);
      }
      else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      }
      else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

function noop() { /* empty */ }

function parseUrl(input) {
  var parsed;
  /* istanbul ignore else */
  if (useNativeURL) {
    parsed = new URL(input);
  }
  else {
    // Ensure the URL is valid and absolute
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}

function resolveUrl(relative, base) {
  /* istanbul ignore next */
  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}

function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}

function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }

  // Fix IPv6 hostname
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  // Ensure port is a number
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  // Concatenate path
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

  return spread;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, message, baseClass) {
  // Create constructor
  function CustomError(properties) {
    Error.captureStackTrace(this, this.constructor);
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }

  // Attach constructor and set default properties
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false,
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false,
    },
  });
  return CustomError;
}

function destroyRequest(request, error) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop);
  request.destroy(error);
}

function isSubdomain(subdomain, domain) {
  assert(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

function isString(value) {
  return typeof value === "string" || value instanceof String;
}

function isFunction(value) {
  return typeof value === "function";
}

function isBuffer(value) {
  return typeof value === "object" && ("length" in value);
}

function isURL(value) {
  return URL && value instanceof URL;
}

// Exports
module.exports = wrap({ http: http, https: https });
module.exports.wrap = wrap;


/***/ }),

/***/ 9320:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 8334:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var implementation = __nccwpck_require__(9320);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 4538:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var undefined;

var $Error = __nccwpck_require__(8015);
var $EvalError = __nccwpck_require__(1933);
var $RangeError = __nccwpck_require__(4415);
var $ReferenceError = __nccwpck_require__(6279);
var $SyntaxError = __nccwpck_require__(5474);
var $TypeError = __nccwpck_require__(6361);
var $URIError = __nccwpck_require__(5065);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __nccwpck_require__(587)();
var hasProto = __nccwpck_require__(5894)();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __nccwpck_require__(8334);
var hasOwn = __nccwpck_require__(2157);
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 8501:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(4538);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 1621:
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ 176:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var $defineProperty = __nccwpck_require__(6123);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ 5894:
/***/ ((module) => {

"use strict";


var test = {
	__proto__: null,
	foo: {}
};

var $Object = Object;

/** @type {import('.')} */
module.exports = function hasProto() {
	// @ts-expect-error: TS errors on an inherited property for some reason
	return { __proto__: test }.foo === test.foo
		&& !(test instanceof $Object);
};


/***/ }),

/***/ 587:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __nccwpck_require__(7747);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 7747:
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 2157:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __nccwpck_require__(8334);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ 1857:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479),
    root = __nccwpck_require__(9882);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ 5902:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var hashClear = __nccwpck_require__(1789),
    hashDelete = __nccwpck_require__(712),
    hashGet = __nccwpck_require__(5395),
    hashHas = __nccwpck_require__(5232),
    hashSet = __nccwpck_require__(7320);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ 6608:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var listCacheClear = __nccwpck_require__(9792),
    listCacheDelete = __nccwpck_require__(7716),
    listCacheGet = __nccwpck_require__(5789),
    listCacheHas = __nccwpck_require__(9386),
    listCacheSet = __nccwpck_require__(7399);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ 881:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479),
    root = __nccwpck_require__(9882);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ 938:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var mapCacheClear = __nccwpck_require__(1610),
    mapCacheDelete = __nccwpck_require__(6657),
    mapCacheGet = __nccwpck_require__(1372),
    mapCacheHas = __nccwpck_require__(609),
    mapCacheSet = __nccwpck_require__(5582);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ 4671:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479),
    root = __nccwpck_require__(9882);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ 5793:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479),
    root = __nccwpck_require__(9882);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ 5323:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var ListCache = __nccwpck_require__(6608),
    stackClear = __nccwpck_require__(2843),
    stackDelete = __nccwpck_require__(4717),
    stackGet = __nccwpck_require__(4141),
    stackHas = __nccwpck_require__(3910),
    stackSet = __nccwpck_require__(9955);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ 9213:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var root = __nccwpck_require__(9882);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ 3261:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var root = __nccwpck_require__(9882);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ 3915:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479),
    root = __nccwpck_require__(9882);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ 8403:
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ 8388:
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ 2237:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseTimes = __nccwpck_require__(7765),
    isArguments = __nccwpck_require__(8495),
    isArray = __nccwpck_require__(4869),
    isBuffer = __nccwpck_require__(4190),
    isIndex = __nccwpck_require__(2936),
    isTypedArray = __nccwpck_require__(2496);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ 4356:
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ 82:
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ 9725:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseAssignValue = __nccwpck_require__(3868),
    eq = __nccwpck_require__(1901);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ 6752:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var eq = __nccwpck_require__(1901);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ 1368:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var copyObject = __nccwpck_require__(6388),
    keys = __nccwpck_require__(7645);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ 428:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var copyObject = __nccwpck_require__(6388),
    keysIn = __nccwpck_require__(9109);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ 3868:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var defineProperty = __nccwpck_require__(416);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ 3040:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Stack = __nccwpck_require__(5323),
    arrayEach = __nccwpck_require__(8403),
    assignValue = __nccwpck_require__(9725),
    baseAssign = __nccwpck_require__(1368),
    baseAssignIn = __nccwpck_require__(428),
    cloneBuffer = __nccwpck_require__(2974),
    copyArray = __nccwpck_require__(5157),
    copySymbols = __nccwpck_require__(6631),
    copySymbolsIn = __nccwpck_require__(1136),
    getAllKeys = __nccwpck_require__(8009),
    getAllKeysIn = __nccwpck_require__(4291),
    getTag = __nccwpck_require__(941),
    initCloneArray = __nccwpck_require__(9763),
    initCloneByTag = __nccwpck_require__(6501),
    initCloneObject = __nccwpck_require__(1532),
    isArray = __nccwpck_require__(4869),
    isBuffer = __nccwpck_require__(4190),
    isMap = __nccwpck_require__(9718),
    isObject = __nccwpck_require__(3334),
    isSet = __nccwpck_require__(8371),
    keys = __nccwpck_require__(7645),
    keysIn = __nccwpck_require__(9109);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ 6706:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isObject = __nccwpck_require__(3334);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ 5758:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var castPath = __nccwpck_require__(2688),
    toKey = __nccwpck_require__(9071);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ 5951:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var arrayPush = __nccwpck_require__(82),
    isArray = __nccwpck_require__(4869);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ 7497:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Symbol = __nccwpck_require__(9213),
    getRawTag = __nccwpck_require__(923),
    objectToString = __nccwpck_require__(4200);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ 2177:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetTag = __nccwpck_require__(7497),
    isObjectLike = __nccwpck_require__(5926);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ 6372:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getTag = __nccwpck_require__(941),
    isObjectLike = __nccwpck_require__(5926);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ 411:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isFunction = __nccwpck_require__(7799),
    isMasked = __nccwpck_require__(9058),
    isObject = __nccwpck_require__(3334),
    toSource = __nccwpck_require__(6928);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ 3688:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getTag = __nccwpck_require__(941),
    isObjectLike = __nccwpck_require__(5926);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ 1528:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetTag = __nccwpck_require__(7497),
    isLength = __nccwpck_require__(4530),
    isObjectLike = __nccwpck_require__(5926);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ 7164:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isPrototype = __nccwpck_require__(10),
    nativeKeys = __nccwpck_require__(5778);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ 297:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isObject = __nccwpck_require__(3334),
    isPrototype = __nccwpck_require__(10),
    nativeKeysIn = __nccwpck_require__(5383);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ 8580:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var assignValue = __nccwpck_require__(9725),
    castPath = __nccwpck_require__(2688),
    isIndex = __nccwpck_require__(2936),
    isObject = __nccwpck_require__(3334),
    toKey = __nccwpck_require__(9071);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),

/***/ 7765:
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ 6792:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Symbol = __nccwpck_require__(9213),
    arrayMap = __nccwpck_require__(4356),
    isArray = __nccwpck_require__(4869),
    isSymbol = __nccwpck_require__(6403);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ 9258:
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ 2688:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isArray = __nccwpck_require__(4869),
    isKey = __nccwpck_require__(9084),
    stringToPath = __nccwpck_require__(1853),
    toString = __nccwpck_require__(2931);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ 1094:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Uint8Array = __nccwpck_require__(3261);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ 2974:
/***/ ((module, exports, __nccwpck_require__) => {

/* module decorator */ module = __nccwpck_require__.nmd(module);
var root = __nccwpck_require__(9882);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ 4524:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var cloneArrayBuffer = __nccwpck_require__(1094);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ 6497:
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ 8035:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Symbol = __nccwpck_require__(9213);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ 7764:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var cloneArrayBuffer = __nccwpck_require__(1094);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ 5157:
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ 6388:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var assignValue = __nccwpck_require__(9725),
    baseAssignValue = __nccwpck_require__(3868);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ 6631:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var copyObject = __nccwpck_require__(6388),
    getSymbols = __nccwpck_require__(6802);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ 1136:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var copyObject = __nccwpck_require__(6388),
    getSymbolsIn = __nccwpck_require__(443);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ 8380:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var root = __nccwpck_require__(9882);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ 416:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ 2085:
/***/ ((module) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;


/***/ }),

/***/ 8009:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetAllKeys = __nccwpck_require__(5951),
    getSymbols = __nccwpck_require__(6802),
    keys = __nccwpck_require__(7645);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ 4291:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetAllKeys = __nccwpck_require__(5951),
    getSymbolsIn = __nccwpck_require__(443),
    keysIn = __nccwpck_require__(9109);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ 9980:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isKeyable = __nccwpck_require__(3308);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ 4479:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsNative = __nccwpck_require__(411),
    getValue = __nccwpck_require__(3542);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ 6271:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var overArg = __nccwpck_require__(6320);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ 923:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Symbol = __nccwpck_require__(9213);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ 6802:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var arrayFilter = __nccwpck_require__(8388),
    stubArray = __nccwpck_require__(8634);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ 443:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var arrayPush = __nccwpck_require__(82),
    getPrototype = __nccwpck_require__(6271),
    getSymbols = __nccwpck_require__(6802),
    stubArray = __nccwpck_require__(8634);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ 941:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var DataView = __nccwpck_require__(1857),
    Map = __nccwpck_require__(881),
    Promise = __nccwpck_require__(4671),
    Set = __nccwpck_require__(5793),
    WeakMap = __nccwpck_require__(3915),
    baseGetTag = __nccwpck_require__(7497),
    toSource = __nccwpck_require__(6928);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ 3542:
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ 1789:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var nativeCreate = __nccwpck_require__(3041);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ 712:
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ 5395:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var nativeCreate = __nccwpck_require__(3041);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ 5232:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var nativeCreate = __nccwpck_require__(3041);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ 7320:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var nativeCreate = __nccwpck_require__(3041);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ 9763:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ 6501:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var cloneArrayBuffer = __nccwpck_require__(1094),
    cloneDataView = __nccwpck_require__(4524),
    cloneRegExp = __nccwpck_require__(6497),
    cloneSymbol = __nccwpck_require__(8035),
    cloneTypedArray = __nccwpck_require__(7764);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ 1532:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseCreate = __nccwpck_require__(6706),
    getPrototype = __nccwpck_require__(6271),
    isPrototype = __nccwpck_require__(10);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ 2936:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ 9084:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isArray = __nccwpck_require__(4869),
    isSymbol = __nccwpck_require__(6403);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ 3308:
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ 9058:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var coreJsData = __nccwpck_require__(8380);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ 10:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ 9792:
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ 7716:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var assocIndexOf = __nccwpck_require__(6752);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ 5789:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var assocIndexOf = __nccwpck_require__(6752);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ 9386:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var assocIndexOf = __nccwpck_require__(6752);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ 7399:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var assocIndexOf = __nccwpck_require__(6752);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ 1610:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Hash = __nccwpck_require__(5902),
    ListCache = __nccwpck_require__(6608),
    Map = __nccwpck_require__(881);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ 6657:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getMapData = __nccwpck_require__(9980);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ 1372:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getMapData = __nccwpck_require__(9980);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ 609:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getMapData = __nccwpck_require__(9980);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ 5582:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getMapData = __nccwpck_require__(9980);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ 9422:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var memoize = __nccwpck_require__(9885);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ 3041:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ 5778:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var overArg = __nccwpck_require__(6320);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ 5383:
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ 4643:
/***/ ((module, exports, __nccwpck_require__) => {

/* module decorator */ module = __nccwpck_require__.nmd(module);
var freeGlobal = __nccwpck_require__(2085);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ 4200:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ 6320:
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ 9882:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var freeGlobal = __nccwpck_require__(2085);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ 2843:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var ListCache = __nccwpck_require__(6608);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ 4717:
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ 4141:
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ 3910:
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ 9955:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var ListCache = __nccwpck_require__(6608),
    Map = __nccwpck_require__(881),
    MapCache = __nccwpck_require__(938);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ 1853:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var memoizeCapped = __nccwpck_require__(9422);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ 9071:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isSymbol = __nccwpck_require__(6403);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ 6928:
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ 2187:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseClone = __nccwpck_require__(3040);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ 1901:
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ 6908:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGet = __nccwpck_require__(5758);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ 8495:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsArguments = __nccwpck_require__(2177),
    isObjectLike = __nccwpck_require__(5926);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ 4869:
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ 8017:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isFunction = __nccwpck_require__(7799),
    isLength = __nccwpck_require__(4530);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ 4190:
/***/ ((module, exports, __nccwpck_require__) => {

/* module decorator */ module = __nccwpck_require__.nmd(module);
var root = __nccwpck_require__(9882),
    stubFalse = __nccwpck_require__(7744);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ 7799:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetTag = __nccwpck_require__(7497),
    isObject = __nccwpck_require__(3334);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ 4530:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ 9718:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsMap = __nccwpck_require__(6372),
    baseUnary = __nccwpck_require__(9258),
    nodeUtil = __nccwpck_require__(4643);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ 3334:
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ 5926:
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ 8371:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsSet = __nccwpck_require__(3688),
    baseUnary = __nccwpck_require__(9258),
    nodeUtil = __nccwpck_require__(4643);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ 6403:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetTag = __nccwpck_require__(7497),
    isObjectLike = __nccwpck_require__(5926);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ 2496:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsTypedArray = __nccwpck_require__(1528),
    baseUnary = __nccwpck_require__(9258),
    nodeUtil = __nccwpck_require__(4643);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ 7645:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var arrayLikeKeys = __nccwpck_require__(2237),
    baseKeys = __nccwpck_require__(7164),
    isArrayLike = __nccwpck_require__(8017);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ 9109:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var arrayLikeKeys = __nccwpck_require__(2237),
    baseKeysIn = __nccwpck_require__(297),
    isArrayLike = __nccwpck_require__(8017);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ 9885:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var MapCache = __nccwpck_require__(938);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ 2900:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseSet = __nccwpck_require__(8580);

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;


/***/ }),

/***/ 8634:
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ 7744:
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ 2931:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseToString = __nccwpck_require__(6792);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ 3973:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return __nccwpck_require__(1017) } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __nccwpck_require__(3717)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 900:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 504:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __nccwpck_require__(7265);
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (
        (typeof globalThis !== 'undefined' && obj === globalThis)
        || (typeof global !== 'undefined' && obj === global)
    ) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ 7265:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(3837).inspect;


/***/ }),

/***/ 4907:
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ 2760:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var stringify = __nccwpck_require__(9954);
var parse = __nccwpck_require__(3912);
var formats = __nccwpck_require__(4907);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ 3912:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(2360);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ 9954:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var getSideChannel = __nccwpck_require__(4334);
var utils = __nccwpck_require__(2360);
var formats = __nccwpck_require__(4907);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ 2360:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var formats = __nccwpck_require__(4907);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ 5911:
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

// The actual regexps go on exports.re
var re = exports.re = []
var safeRe = exports.safeRe = []
var src = exports.src = []
var t = exports.tokens = {}
var R = 0

function tok (n) {
  t[n] = R++
}

var LETTERDASHNUMBER = '[a-zA-Z0-9-]'

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
var safeRegexReplacements = [
  ['\\s', 1],
  ['\\d', MAX_LENGTH],
  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
]

function makeSafeRe (value) {
  for (var i = 0; i < safeRegexReplacements.length; i++) {
    var token = safeRegexReplacements[i][0]
    var max = safeRegexReplacements[i][1]
    value = value
      .split(token + '*').join(token + '{0,' + max + '}')
      .split(token + '+').join(token + '{1,' + max + '}')
  }
  return value
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

tok('NUMERICIDENTIFIER')
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*'
tok('NUMERICIDENTIFIERLOOSE')
src[t.NUMERICIDENTIFIERLOOSE] = '\\d+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER')
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-]' + LETTERDASHNUMBER + '*'

// ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION')
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')'

tok('MAINVERSIONLOOSE')
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER')
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] +
                            '|' + src[t.NONNUMERICIDENTIFIER] + ')'

tok('PRERELEASEIDENTIFIERLOOSE')
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[t.NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE')
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))'

tok('PRERELEASELOOSE')
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER')
src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + '+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD')
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] +
             '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL')
tok('FULLPLAIN')
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] +
                  src[t.PRERELEASE] + '?' +
                  src[t.BUILD] + '?'

src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
tok('LOOSEPLAIN')
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] +
                  src[t.PRERELEASELOOSE] + '?' +
                  src[t.BUILD] + '?'

tok('LOOSE')
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$'

tok('GTLT')
src[t.GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
tok('XRANGEIDENTIFIERLOOSE')
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
tok('XRANGEIDENTIFIER')
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*'

tok('XRANGEPLAIN')
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[t.PRERELEASE] + ')?' +
                   src[t.BUILD] + '?' +
                   ')?)?'

tok('XRANGEPLAINLOOSE')
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[t.PRERELEASELOOSE] + ')?' +
                        src[t.BUILD] + '?' +
                        ')?)?'

tok('XRANGE')
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$'
tok('XRANGELOOSE')
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
tok('COERCE')
src[t.COERCE] = '(^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'
tok('COERCERTL')
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g')
safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), 'g')

// Tilde ranges.
// Meaning is "reasonably at or greater than"
tok('LONETILDE')
src[t.LONETILDE] = '(?:~>?)'

tok('TILDETRIM')
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+'
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g')
safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), 'g')
var tildeTrimReplace = '$1~'

tok('TILDE')
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$'
tok('TILDELOOSE')
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
tok('LONECARET')
src[t.LONECARET] = '(?:\\^)'

tok('CARETTRIM')
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+'
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g')
safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), 'g')
var caretTrimReplace = '$1^'

tok('CARET')
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$'
tok('CARETLOOSE')
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
tok('COMPARATORLOOSE')
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$'
tok('COMPARATOR')
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
tok('COMPARATORTRIM')
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] +
                      '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g')
safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
tok('HYPHENRANGE')
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s*$'

tok('HYPHENRANGELOOSE')
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
tok('STAR')
src[t.STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])

    // Replace all greedy whitespace to prevent regex dos issues. These regex are
    // used internally via the safeRe object since all inputs in this library get
    // normalized first to trim and collapse all extra whitespace. The original
    // regexes are exported for userland consumption and lower level usage. A
    // future breaking change could export the safer regex only with a note that
    // all input should have extra whitespace removed.
    safeRe[i] = new RegExp(makeSafeRe(src[i]))
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  var i = 0
  do {
    var a = this.build[i]
    var b = other.build[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.compareBuild = compareBuild
function compareBuild (a, b, loose) {
  var versionA = new SemVer(a, loose)
  var versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  comp = comp.trim().split(/\s+/).join(' ')
  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1] !== undefined ? m[1] : ''
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY || version === ANY) {
    return true
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    if (this.value === '') {
      return true
    }
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true
    }
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First reduce all whitespace as much as possible so we do not have to rely
  // on potentially slow regexes like \s*. This is then stored and used for
  // future error messages as well.
  this.raw = range
    .trim()
    .split(/\s+/)
    .join(' ')

  // First, split based on boolean or ||
  this.set = this.raw.split('||').map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + this.raw)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, safeRe[t.COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return (
      isSatisfiable(thisComparators, options) &&
      range.set.some(function (rangeComparators) {
        return (
          isSatisfiable(rangeComparators, options) &&
          thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options)
            })
          })
        )
      })
    )
  })
}

// take a set of comparators and determine whether there
// exists a version which can satisfy it
function isSatisfiable (comparators, options) {
  var result = true
  var remainingComparators = comparators.slice()
  var testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr +
        ' <' + M + '.' + (+m + 1) + '.0' + pr
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(safeRe[t.STAR], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version, options) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  var match = null
  if (!options.rtl) {
    match = version.match(safeRe[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next
    while ((next = safeRe[t.COERCERTL].exec(version)) &&
      (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
          next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    safeRe[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(match[2] +
    '.' + (match[3] || '0') +
    '.' + (match[4] || '0'), options)
}


/***/ }),

/***/ 4056:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(4538);
var define = __nccwpck_require__(4564);
var hasDescriptors = __nccwpck_require__(176)();
var gOPD = __nccwpck_require__(8501);

var $TypeError = __nccwpck_require__(6361);
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


/***/ }),

/***/ 4334:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var GetIntrinsic = __nccwpck_require__(4538);
var callBound = __nccwpck_require__(8803);
var inspect = __nccwpck_require__(504);

var $TypeError = __nccwpck_require__(6361);
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('.').listGetNode} */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	for (; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			// eslint-disable-next-line no-extra-parens
			curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

/** @type {import('.').listGet} */
var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('.').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('.').ListNode<typeof value>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('.').listHas} */
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @type {WeakMap<object, unknown>} */ var $wm;
	/** @type {Map<object, unknown>} */ var $m;
	/** @type {import('.').RootNode<unknown>} */ var $o;

	/** @type {import('.').Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ 9318:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const os = __nccwpck_require__(2037);
const tty = __nccwpck_require__(6224);
const hasFlag = __nccwpck_require__(1621);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ 5845:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const fs = __nccwpck_require__(7147);

const binding = __nccwpck_require__(6642);

const raw = {
  crc64: binding._crc64,
  combineCrc64: binding._combine_crc64,
  strToUint64Ptr: binding._str_to_uint64,
  uint64PtrToStr: binding._uint64_to_str,
};

binding._crc64_init();

function strToUint64Ptr(str) {
  const strPtr = binding._malloc(str.length + 1);
  binding.stringToUTF8(str, strPtr, str.length + 1);

  const uint64Ptr = binding._malloc(8);
  raw.strToUint64Ptr(strPtr, uint64Ptr);
  binding._free(strPtr);

  return uint64Ptr;
}

function uint64PtrToStr(uint64Ptr) {
  const strPtr = binding._malloc(32);
  raw.uint64PtrToStr(strPtr, uint64Ptr);
  const str = binding.UTF8ToString(strPtr);
  binding._free(strPtr);
  return str;
}

function isBuffer(v) { return typeof Buffer !== 'undefined' && Buffer.isBuffer(v); }

function buffToPtr(buff) {
  if (!isBuffer(buff)) {
    throw new Error('Invalid buffer type.');
  }

  const buffPtr = binding._malloc(buff.length);
  binding.writeArrayToMemory(buff, buffPtr);

  return buffPtr;
}

module.exports.crc64 = function(buff, prev) {
  if (!prev) prev = '0';
  if (typeof prev !== 'string' || !/\d+/.test(prev)) {
    throw new Error('Invlid previous value.');
  }

  const prevPtr = strToUint64Ptr(prev);
  const buffPtr = buffToPtr(buff);

  raw.crc64(prevPtr, buffPtr, buff.length);
  const ret = uint64PtrToStr(prevPtr);

  binding._free(prevPtr);
  binding._free(buffPtr);

  return ret;
};

/**
 * Calculate the CRC-64 of two sequential blocks
 * @param {string} crc1 the CRC-64 of the first block
 * @param {string} crc2 crc2 is the CRC-64 of the second block
 * @param {number} crc2BytesLen the length of the second block
 * @returns {string} the CRC-64 of two sequential blocks
 */
module.exports.combineCrc64 = function(crc1, crc2, crc2BytesLen) {
  if (
    typeof crc1 !== 'string' || !/\d+/.test(crc1) ||
    typeof crc2 !== 'string' || !/\d+/.test(crc2)
  ) {
    throw new Error('Invlid crc1 or crc2 value.');
  }
  const crc1Ptr = strToUint64Ptr(crc1);
  const crc2Ptr = strToUint64Ptr(crc2);
  raw.combineCrc64(crc1Ptr, crc2Ptr, crc2BytesLen);
  const retCrc = uint64PtrToStr(crc1Ptr);

  binding._free(crc1Ptr);
  binding._free(crc2Ptr);

  return retCrc;
};

module.exports.crc64File = function(filename, callback) {
  let errored = false;
  const stream = fs.createReadStream(filename);
  const crcPtr = strToUint64Ptr('0');
  let crcPtrFreed = false;
  stream.on('error', function(err) {
    errored = true;
    stream.destroy();
    if (!crcPtrFreed) {
      binding._free(crcPtr);
      crcPtrFreed = true;
    }
    return callback(err);
  });

  stream.on('data', function(chunk) {
    const buffPtr = buffToPtr(chunk);
    raw.crc64(crcPtr, buffPtr, chunk.length);
    binding._free(buffPtr);
  });
  stream.on('end', function() {
    if (errored) return;

    const ret = uint64PtrToStr(crcPtr);
    if (!crcPtrFreed) {
      binding._free(crcPtr);
      crcPtrFreed = true;
    }

    return callback(undefined, ret);
  });
};


/***/ }),

/***/ 6642:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = (/* unused pure expression or super */ null && ([]));
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');
}

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
  readAsync,
  readBinary;

if (ENVIRONMENT_IS_NODE) {
  if (typeof process == 'undefined' || !process.release || process.release.name !== 'node') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  var nodeVersion = process.versions.node;
  var numericVersion = nodeVersion.split('.').slice(0, 3);
  numericVersion = numericVersion[0] * 10000 + numericVersion[1] * 100 + numericVersion[2].split('-')[0] * 1;
  var minVersion = 160000;
  if (numericVersion < 160000) {
    // throw new Error('This emscripten-generated code requires node v16.0.0 (detected v' + nodeVersion + ')');
  }

  // `require()` is no-op in an ESM module, use `createRequire()` to construct
  // the require()` function.  This is only necessary for multi-environment
  // builds, `-sENVIRONMENT=node` emits a static import declaration instead.
  // TODO: Swap all `require()`'s with `import()`'s?
  // These modules will usually be used on Node.js. Load them eagerly to avoid
  // the complexity of lazy-loading.
  var fs = __nccwpck_require__(7147);
  var nodePath = __nccwpck_require__(1017);

  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = nodePath.dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }

  // include: node_shell_read.js
  read_ = (filename, binary) => {
    // We need to re-wrap `file://` strings to URLs. Normalizing isn't
    // necessary in that case, the path should already be absolute.
    filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
    return fs.readFileSync(filename, binary ? undefined : 'utf8');
  };

  readBinary = (filename) => {
    var ret = read_(filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };

  readAsync = (filename, onload, onerror, binary = true) => {
    // See the comment in the `read_` function.
    filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
    fs.readFile(filename, binary ? undefined : 'utf8', (err, data) => {
      if (err) onerror(err);else
      onload(binary ? data.buffer : data);
    });
  };
  // end include: node_shell_read.js
  if (!Module['thisProgram'] && process.argv.length > 1) {
    thisProgram = process.argv[1].replace(/\\/g, '/');
  }

  arguments_ = process.argv.slice(2);

  if (true) {
    module['exports'] = Module;
  }

  quit_ = (status, toThrow) => {
    process.exitCode = status;
    throw toThrow;
  };

} else
if (ENVIRONMENT_IS_SHELL) {

  if (typeof process == 'object' && "function" === 'function' || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  if (typeof read != 'undefined') {
    read_ = read;
  }

  readBinary = (f) => {
    if (typeof readbuffer == 'function') {
      return new Uint8Array(readbuffer(f));
    }
    let data = read(f, 'binary');
    assert(typeof data == 'object');
    return data;
  };

  readAsync = (f, onload, onerror) => {
    setTimeout(() => onload(readBinary(f)));
  };

  if (typeof clearTimeout == 'undefined') {
    globalThis.clearTimeout = (id) => {};
  }

  if (typeof setTimeout == 'undefined') {
    // spidermonkey lacks setTimeout but we use it above in readAsync.
    globalThis.setTimeout = (f) => typeof f == 'function' ? f() : abort();
  }

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit == 'function') {
    quit_ = (status, toThrow) => {
      // Unlike node which has process.exitCode, d8 has no such mechanism. So we
      // have no way to set the exit code and then let the program exit with
      // that code when it naturally stops running (say, when all setTimeouts
      // have completed). For that reason, we must call `quit` - the only way to
      // set the exit code - but quit also halts immediately.  To increase
      // consistency with node (and the web) we schedule the actual quit call
      // using a setTimeout to give the current stack and any exception handlers
      // a chance to run.  This enables features such as addOnPostRun (which
      // expected to be able to run code after main returns).
      setTimeout(() => {
        if (!(toThrow instanceof ExitStatus)) {
          let toLog = toThrow;
          if (toThrow && typeof toThrow == 'object' && toThrow.stack) {
            toLog = [toThrow, toThrow.stack];
          }
          err(`exiting due to exception: ${toLog}`);
        }
        quit(status);
      });
      throw toThrow;
    };
  }

  if (typeof print != 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console == 'undefined') console = /** @type{!Console} */{};
    console.log = /** @type{!function(this:Console, ...*): undefined} */print;
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */typeof printErr != 'undefined' ? printErr : print;
  }

} else

  // Note that this includes Node.js workers when relevant (pthreads is enabled).
  // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
  // ENVIRONMENT_IS_NODE.
  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    if (ENVIRONMENT_IS_WORKER) {// Check worker, not web, since window could be polyfilled
      scriptDirectory = self.location.href;
    } else if (typeof document != 'undefined' && document.currentScript) {// web
      scriptDirectory = document.currentScript.src;
    }
    // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
    // otherwise, slice off the final part of the url to find the script directory.
    // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
    // and scriptDirectory will correctly be replaced with an empty string.
    // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
    // they are removed because they could contain a slash.
    if (scriptDirectory.startsWith('blob:')) {
      scriptDirectory = '';
    } else {
      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1);
    }

    if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

    // Differentiate the Web Worker from the Node Worker case, as reading must
    // be done differently.
    {
      // include: web_or_worker_shell_read.js
      read_ = (url) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.send(null);
        return xhr.responseText;
      };

      if (ENVIRONMENT_IS_WORKER) {
        readBinary = (url) => {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, false);
          xhr.responseType = 'arraybuffer';
          xhr.send(null);
          return new Uint8Array( /** @type{!ArrayBuffer} */xhr.response);
        };
      }

      readAsync = (url, onload, onerror) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = () => {
          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {// file URLs can return 0
            onload(xhr.response);
            return;
          }
          onerror();
        };
        xhr.onerror = onerror;
        xhr.send(null);
      };

      // end include: web_or_worker_shell_read.js
    }
  } else
  {
    throw new Error('environment detection error');
  }

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.error.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;
checkIncomingModuleAPI();

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');

if (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');

if (Module['quit']) quit_ = Module['quit'];legacyModuleProp('quit', 'quit_');

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');
assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');
assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
legacyModuleProp('asm', 'wasmExports');
legacyModuleProp('read', 'read_');
legacyModuleProp('readAsync', 'readAsync');
legacyModuleProp('readBinary', 'readBinary');
legacyModuleProp('setWindowTitle', 'setWindowTitle');
var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';
var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';
var FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';
var ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';
var JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';
var OPFS = 'OPFS is no longer included by default; build with -lopfs.js';

var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';

assert(!ENVIRONMENT_IS_SHELL, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');


// end include: shell.js
// include: preamble.js
// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');

// include: wasm2js.js
// wasm2js.js - enough of a polyfill for the WebAssembly object so that we can load
// wasm2js code that way.

// Emit "var WebAssembly" if definitely using wasm2js. Otherwise, in MAYBE_WASM2JS
// mode, we can't use a "var" since it would prevent normal wasm from working.
/** @suppress{duplicate, const} */
var
WebAssembly = {
  // Note that we do not use closure quoting (this['buffer'], etc.) on these
  // functions, as they are just meant for internal use. In other words, this is
  // not a fully general polyfill.
  /** @constructor */
  Memory: function (opts) {
    this.buffer = new ArrayBuffer(opts['initial'] * 65536);
  },

  Module: function (binary) {




    // TODO: use the binary and info somehow - right now the wasm2js output is embedded in
    // the main JS
  }, /** @constructor */Instance: function (module, info) {// TODO: use the module somehow - right now the wasm2js output is embedded in
    // the main JS
    // This will be replaced by the actual wasm2js code.
    this.exports =
    function instantiate(info) {
      function Table(ret) {
        // grow method not included; table is not growable
        ret.set = function (i, func) {
          this[i] = func;
        };
        ret.get = function (i) {
          return this[i];
        };
        return ret;
      }

      var bufferView;
      var base64ReverseLookup = new Uint8Array(123 /*'z'+1*/);
      for (var i = 25; i >= 0; --i) {
        base64ReverseLookup[48 + i] = 52 + i; // '0-9'
        base64ReverseLookup[65 + i] = i; // 'A-Z'
        base64ReverseLookup[97 + i] = 26 + i; // 'a-z'
      }
      base64ReverseLookup[43] = 62; // '+'
      base64ReverseLookup[47] = 63; // '/'
      /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */
      function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
        var b1,b2,i = 0,j = offset,bLength = b64.length,end = offset + (bLength * 3 >> 2) - (b64[bLength - 2] == '=') - (b64[bLength - 1] == '=');
        for (; i < bLength; i += 4) {
          b1 = base64ReverseLookup[b64.charCodeAt(i + 1)];
          b2 = base64ReverseLookup[b64.charCodeAt(i + 2)];
          uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
          if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
          if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i + 3)];
        }
      }
      function initActiveSegments(imports) {
        base64DecodeToExistingUint8Array(bufferView, 65536, "aW5maW5pdHkALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAAlbGx1AG5hbgBpbmYATkFOAElORgAuAChudWxsKQAAAAAAAAAAAAAAAAAZAAoAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkAEQoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAZAAoNGRkZAA0AAAIACQ4AAAAJAA4AAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAEwAAAAATAAAAAAkMAAAAAAAMAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAA8AAAAEDwAAAAAJEAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAARAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGgAAABoaGgAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAABcAAAAAFwAAAAAJFAAAAAAAFAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAAAAAAAAAAAAAAVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUbRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUYAAAANQAAAHEAAABr////zvv//5K///8AAAAAAAAAAP////////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAECBAcDBgUAAAAAAAAAAgAAwAMAAMAEAADABQAAwAYAAMAHAADACAAAwAkAAMAKAADACwAAwAwAAMANAADADgAAwA8AAMAQAADAEQAAwBIAAMATAADAFAAAwBUAAMAWAADAFwAAwBgAAMAZAADAGgAAwBsAAMAcAADAHQAAwB4AAMAfAADAAAAAswEAAMMCAADDAwAAwwQAAMMFAADDBgAAwwcAAMMIAADDCQAAwwoAAMMLAADDDAAAww0AANMOAADDDwAAwwAADLsBAAzDAgAMwwMADMMEAAzb");
        base64DecodeToExistingUint8Array(bufferView, 66652, "IIcBAA==");
      }

      var scratchBuffer = new ArrayBuffer(16);
      var i32ScratchView = new Int32Array(scratchBuffer);
      var f32ScratchView = new Float32Array(scratchBuffer);
      var f64ScratchView = new Float64Array(scratchBuffer);

      function wasm2js_scratch_load_i32(index) {
        return i32ScratchView[index];
      }

      function wasm2js_scratch_store_i32(index, value) {
        i32ScratchView[index] = value;
      }

      function wasm2js_scratch_load_f64() {
        return f64ScratchView[0];
      }

      function wasm2js_scratch_store_f64(value) {
        f64ScratchView[0] = value;
      }

      function wasm2js_scratch_store_f32(value) {
        f32ScratchView[2] = value;
      }

      function wasm2js_scratch_load_f32() {
        return f32ScratchView[2];
      }

      function asmFunc(imports) {
        var buffer = new ArrayBuffer(16777216);
        var HEAP8 = new Int8Array(buffer);
        var HEAP16 = new Int16Array(buffer);
        var HEAP32 = new Int32Array(buffer);
        var HEAPU8 = new Uint8Array(buffer);
        var HEAPU16 = new Uint16Array(buffer);
        var HEAPU32 = new Uint32Array(buffer);
        var HEAPF32 = new Float32Array(buffer);
        var HEAPF64 = new Float64Array(buffer);
        var Math_imul = Math.imul;
        var Math_fround = Math.fround;
        var Math_abs = Math.abs;
        var Math_clz32 = Math.clz32;
        var Math_min = Math.min;
        var Math_max = Math.max;
        var Math_floor = Math.floor;
        var Math_ceil = Math.ceil;
        var Math_trunc = Math.trunc;
        var Math_sqrt = Math.sqrt;
        var env = imports.env;
        var fimport$0 = env.emscripten_memcpy_js;
        var fimport$1 = env.emscripten_resize_heap;
        var global$0 = 65536;
        var global$2 = 0;
        var global$3 = 0;
        var __wasm_intrinsics_temp_i64 = 0;
        var __wasm_intrinsics_temp_i64$hi = 0;
        var i64toi32_i32$HIGH_BITS = 0;
        // EMSCRIPTEN_START_FUNCS
        ;
        function $0() {
          $104();
          $66();
        }

        function $1() {
          var $2_1 = 0,i64toi32_i32$0 = 0;
          $2_1 = global$0 - 16 | 0;
          global$0 = $2_1;
          i64toi32_i32$0 = 0;
          HEAP32[($2_1 + 8 | 0) >> 2] = 1;
          HEAP32[($2_1 + 12 | 0) >> 2] = i64toi32_i32$0;
          label$1: {
            label$2: {
              if (!(((HEAPU8[($2_1 + 8 | 0) >> 0] | 0) & 255 | 0 | 0) != (0 & 255 | 0 | 0) & 1 | 0)) {
                break label$2;
              }
              $2();
              break label$1;
            }
            $3();
          }
          global$0 = $2_1 + 16 | 0;
          return;
        }

        function $2() {
          $4(66656 | 0);
          return;
        }

        function $3() {
          var $2_1 = 0,i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,$111_1 = 0;
          $2_1 = global$0 - 16 | 0;
          global$0 = $2_1;
          $4(83040 | 0);
          HEAP32[($2_1 + 12 | 0) >> 2] = 0;
          label$1: {
            label$2: while (1) {
              if (!((HEAP32[($2_1 + 12 | 0) >> 2] | 0) >>> 0 < 8 >>> 0 & 1 | 0)) {
                break label$1;
              }
              HEAP32[($2_1 + 8 | 0) >> 2] = 0;
              label$3: {
                label$4: while (1) {
                  if (!((HEAP32[($2_1 + 8 | 0) >> 2] | 0) >>> 0 < 256 >>> 0 & 1 | 0)) {
                    break label$3;
                  }
                  i64toi32_i32$2 = (83040 + ((HEAP32[($2_1 + 12 | 0) >> 2] | 0) << 11 | 0) | 0) + ((HEAP32[($2_1 + 8 | 0) >> 2] | 0) << 3 | 0) | 0;
                  i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                  i64toi32_i32$1 = $5(i64toi32_i32$0 | 0, i64toi32_i32$1 | 0) | 0;
                  i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
                  $111_1 = i64toi32_i32$1;
                  i64toi32_i32$1 = (83040 + ((HEAP32[($2_1 + 12 | 0) >> 2] | 0) << 11 | 0) | 0) + ((HEAP32[($2_1 + 8 | 0) >> 2] | 0) << 3 | 0) | 0;
                  HEAP32[i64toi32_i32$1 >> 2] = $111_1;
                  HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
                  HEAP32[($2_1 + 8 | 0) >> 2] = (HEAP32[($2_1 + 8 | 0) >> 2] | 0) + 1 | 0;
                  continue label$4;
                };
              }
              HEAP32[($2_1 + 12 | 0) >> 2] = (HEAP32[($2_1 + 12 | 0) >> 2] | 0) + 1 | 0;
              continue label$2;
            };
          }
          global$0 = $2_1 + 16 | 0;
          return;
        }

        function $4($0_1) {
          $0_1 = $0_1 | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,i64toi32_i32$3 = 0,$3_1 = 0,i64toi32_i32$2 = 0,i64toi32_i32$4 = 0,$70$hi = 0,$71$hi = 0,$72$hi = 0,$73$hi = 0,$74$hi = 0,$75$hi = 0,$30_1 = 0,$76$hi = 0,$77$hi = 0,$79_1 = 0,$79$hi = 0,$80$hi = 0,$81$hi = 0,$31_1 = 0,$86$hi = 0,$87$hi = 0,$89$hi = 0,$90$hi = 0,$91$hi = 0,$32_1 = 0,$92$hi = 0,$183 = 0,$216 = 0,$89_1 = 0,$255 = 0,$277 = 0;
          $3_1 = global$0 - 32 | 0;
          HEAP32[($3_1 + 28 | 0) >> 2] = $0_1;
          HEAP32[($3_1 + 24 | 0) >> 2] = 0;
          label$1: {
            label$2: while (1) {
              if (!((HEAP32[($3_1 + 24 | 0) >> 2] | 0) >>> 0 < 256 >>> 0 & 1 | 0)) {
                break label$1;
              }
              i64toi32_i32$0 = 0;
              i64toi32_i32$1 = $3_1;
              HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
              HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = i64toi32_i32$0;
              HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] = 0;
              label$3: {
                label$4: while (1) {
                  if (!((HEAP32[($3_1 + 20 | 0) >> 2] | 0) >>> 0 < 8 >>> 0 & 1 | 0)) {
                    break label$3;
                  }
                  i64toi32_i32$2 = $3_1;
                  i64toi32_i32$0 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;
                  i64toi32_i32$1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;
                  $70$hi = i64toi32_i32$1;
                  i64toi32_i32$1 = 0;
                  $71$hi = i64toi32_i32$1;
                  i64toi32_i32$1 = $70$hi;
                  i64toi32_i32$1 = $71$hi;
                  i64toi32_i32$1 = $70$hi;
                  i64toi32_i32$2 = i64toi32_i32$0;
                  i64toi32_i32$0 = $71$hi;
                  i64toi32_i32$3 = 1;
                  i64toi32_i32$0 = i64toi32_i32$1 & i64toi32_i32$0 | 0;
                  $72$hi = i64toi32_i32$0;
                  i64toi32_i32$0 = 0;
                  $73$hi = i64toi32_i32$0;
                  i64toi32_i32$0 = $72$hi;
                  i64toi32_i32$0 = $73$hi;
                  i64toi32_i32$0 = $72$hi;
                  i64toi32_i32$1 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
                  i64toi32_i32$2 = $73$hi;
                  i64toi32_i32$3 = 0;
                  label$5: {
                    label$6: {
                      if (!(((i64toi32_i32$1 | 0) != (i64toi32_i32$3 | 0) | (i64toi32_i32$0 | 0) != (i64toi32_i32$2 | 0) | 0) & 1 | 0)) {
                        break label$6;
                      }
                      i64toi32_i32$3 = $3_1;
                      i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 8 | 0) >> 2] | 0;
                      i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 12 | 0) >> 2] | 0;
                      $74$hi = i64toi32_i32$0;
                      i64toi32_i32$0 = 0;
                      $75$hi = i64toi32_i32$0;
                      i64toi32_i32$0 = $74$hi;
                      i64toi32_i32$0 = $75$hi;
                      i64toi32_i32$0 = $74$hi;
                      i64toi32_i32$3 = i64toi32_i32$1;
                      i64toi32_i32$1 = $75$hi;
                      i64toi32_i32$2 = 1;
                      i64toi32_i32$4 = i64toi32_i32$2 & 31 | 0;
                      if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                        i64toi32_i32$1 = 0;
                        $30_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                      } else {
                        i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                        $30_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$4 | 0) | 0;
                      }
                      $76$hi = i64toi32_i32$1;
                      i64toi32_i32$1 = -915646571;
                      $77$hi = i64toi32_i32$1;
                      i64toi32_i32$1 = $76$hi;
                      i64toi32_i32$1 = $77$hi;
                      i64toi32_i32$1 = $76$hi;
                      i64toi32_i32$0 = $30_1;
                      i64toi32_i32$3 = $77$hi;
                      i64toi32_i32$2 = -679014590;
                      i64toi32_i32$3 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
                      $79_1 = i64toi32_i32$0 ^ i64toi32_i32$2 | 0;
                      $79$hi = i64toi32_i32$3;
                      break label$5;
                    }
                    i64toi32_i32$1 = $3_1;
                    i64toi32_i32$3 = HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] | 0;
                    i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] | 0;
                    $80$hi = i64toi32_i32$0;
                    i64toi32_i32$0 = 0;
                    $81$hi = i64toi32_i32$0;
                    i64toi32_i32$0 = $80$hi;
                    i64toi32_i32$0 = $81$hi;
                    i64toi32_i32$0 = $80$hi;
                    i64toi32_i32$1 = i64toi32_i32$3;
                    i64toi32_i32$3 = $81$hi;
                    i64toi32_i32$2 = 1;
                    i64toi32_i32$4 = i64toi32_i32$2 & 31 | 0;
                    if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                      i64toi32_i32$3 = 0;
                      $31_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                    } else {
                      i64toi32_i32$3 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                      $31_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
                    }
                    $79_1 = $31_1;
                    $79$hi = i64toi32_i32$3;
                  }
                  i64toi32_i32$3 = $79$hi;
                  i64toi32_i32$1 = $3_1;
                  HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] = $79_1;
                  HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = i64toi32_i32$3;
                  HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] = (HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] | 0) + 1 | 0;
                  continue label$4;
                };
              }
              i64toi32_i32$0 = $3_1;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 8 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] | 0;
              $183 = i64toi32_i32$3;
              i64toi32_i32$3 = (HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0) + ((HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0) << 3 | 0) | 0;
              HEAP32[i64toi32_i32$3 >> 2] = $183;
              HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] = i64toi32_i32$1;
              HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] = (HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0) + 1 | 0;
              continue label$2;
            };
          }
          HEAP32[($3_1 + 24 | 0) >> 2] = 0;
          label$7: {
            label$8: while (1) {
              if (!((HEAP32[($3_1 + 24 | 0) >> 2] | 0) >>> 0 < 256 >>> 0 & 1 | 0)) {
                break label$7;
              }
              i64toi32_i32$0 = (HEAP32[($3_1 + 28 | 0) >> 2] | 0) + ((HEAP32[($3_1 + 24 | 0) >> 2] | 0) << 3 | 0) | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $216 = i64toi32_i32$1;
              i64toi32_i32$1 = $3_1;
              HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] = $216;
              HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = i64toi32_i32$3;
              HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] = 1;
              label$9: {
                label$10: while (1) {
                  if (!((HEAP32[($3_1 + 20 | 0) >> 2] | 0) >>> 0 < 8 >>> 0 & 1 | 0)) {
                    break label$9;
                  }
                  i64toi32_i32$0 = $3_1;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 8 | 0) >> 2] | 0;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] | 0;
                  $86$hi = i64toi32_i32$1;
                  i64toi32_i32$1 = 0;
                  $87$hi = i64toi32_i32$1;
                  i64toi32_i32$1 = $86$hi;
                  i64toi32_i32$1 = $87$hi;
                  i64toi32_i32$1 = $86$hi;
                  i64toi32_i32$0 = i64toi32_i32$3;
                  i64toi32_i32$3 = $87$hi;
                  i64toi32_i32$2 = 255;
                  i64toi32_i32$3 = i64toi32_i32$1 & i64toi32_i32$3 | 0;
                  i64toi32_i32$1 = (HEAP32[($3_1 + 28 | 0) >> 2] | 0) + ((i64toi32_i32$0 & i64toi32_i32$2 | 0) << 3 | 0) | 0;
                  i64toi32_i32$3 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                  i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                  $89_1 = i64toi32_i32$3;
                  $89$hi = i64toi32_i32$0;
                  i64toi32_i32$1 = $3_1;
                  i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] | 0;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] | 0;
                  $90$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = 0;
                  $91$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = $90$hi;
                  i64toi32_i32$3 = $91$hi;
                  i64toi32_i32$3 = $90$hi;
                  i64toi32_i32$1 = i64toi32_i32$0;
                  i64toi32_i32$0 = $91$hi;
                  i64toi32_i32$2 = 8;
                  i64toi32_i32$4 = i64toi32_i32$2 & 31 | 0;
                  if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                    i64toi32_i32$0 = 0;
                    $32_1 = i64toi32_i32$3 >>> i64toi32_i32$4 | 0;
                  } else {
                    i64toi32_i32$0 = i64toi32_i32$3 >>> i64toi32_i32$4 | 0;
                    $32_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$3 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
                  }
                  $92$hi = i64toi32_i32$0;
                  i64toi32_i32$0 = $89$hi;
                  i64toi32_i32$0 = $92$hi;
                  i64toi32_i32$0 = $89$hi;
                  i64toi32_i32$3 = $89_1;
                  i64toi32_i32$1 = $92$hi;
                  i64toi32_i32$2 = $32_1;
                  i64toi32_i32$1 = i64toi32_i32$0 ^ i64toi32_i32$1 | 0;
                  $255 = i64toi32_i32$3 ^ i64toi32_i32$2 | 0;
                  i64toi32_i32$3 = $3_1;
                  HEAP32[(i64toi32_i32$3 + 8 | 0) >> 2] = $255;
                  HEAP32[(i64toi32_i32$3 + 12 | 0) >> 2] = i64toi32_i32$1;
                  i64toi32_i32$0 = i64toi32_i32$3;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 8 | 0) >> 2] | 0;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] | 0;
                  $277 = i64toi32_i32$1;
                  i64toi32_i32$1 = ((HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0) + ((HEAP32[(i64toi32_i32$0 + 20 | 0) >> 2] | 0) << 11 | 0) | 0) + ((HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0) << 3 | 0) | 0;
                  HEAP32[i64toi32_i32$1 >> 2] = $277;
                  HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$3;
                  HEAP32[(i64toi32_i32$0 + 20 | 0) >> 2] = (HEAP32[(i64toi32_i32$0 + 20 | 0) >> 2] | 0) + 1 | 0;
                  continue label$10;
                };
              }
              HEAP32[($3_1 + 24 | 0) >> 2] = (HEAP32[($3_1 + 24 | 0) >> 2] | 0) + 1 | 0;
              continue label$8;
            };
          }
          return;
        }

        function $5($0_1, $0$hi) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          var i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$4 = 0,i64toi32_i32$3 = 0,$3_1 = 0,$5$hi = 0,$6$hi = 0,$45_1 = 0,$7$hi = 0,$8$hi = 0,$9$hi = 0,$10$hi = 0,$11$hi = 0,$12$hi = 0,$13$hi = 0,$46_1 = 0,$14$hi = 0,$17$hi = 0,$18$hi = 0,$47_1 = 0,$19$hi = 0,$20$hi = 0,$21$hi = 0,$22$hi = 0,$23$hi = 0,$24$hi = 0,$25$hi = 0,$48_1 = 0,$26$hi = 0,$28$hi = 0,$29$hi = 0,$49_1 = 0,$30$hi = 0,$31$hi = 0,$32$hi = 0,$50_1 = 0,$33$hi = 0,$51_1 = 0,$9_1 = 0,$10_1 = 0,$58_1 = 0,$67_1 = 0,$78_1 = 0,$21_1 = 0,$22_1 = 0,$85_1 = 0,$94_1 = 0,$30_1 = 0;
          $3_1 = global$0 - 16 | 0;
          i64toi32_i32$0 = $0$hi;
          i64toi32_i32$1 = $3_1;
          HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] = $0_1;
          HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = i64toi32_i32$0;
          i64toi32_i32$0 = 16711935;
          HEAP32[i64toi32_i32$1 >> 2] = 16711935;
          HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
          i64toi32_i32$2 = i64toi32_i32$1;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] | 0;
          $5$hi = i64toi32_i32$1;
          i64toi32_i32$1 = 0;
          $6$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $5$hi;
          i64toi32_i32$1 = $6$hi;
          i64toi32_i32$1 = $5$hi;
          i64toi32_i32$2 = i64toi32_i32$0;
          i64toi32_i32$0 = $6$hi;
          i64toi32_i32$3 = 8;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$0 = 0;
            $45_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
          } else {
            i64toi32_i32$0 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
            $45_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
          }
          $7$hi = i64toi32_i32$0;
          i64toi32_i32$1 = $3_1;
          i64toi32_i32$0 = HEAP32[i64toi32_i32$1 >> 2] | 0;
          i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
          $8$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $7$hi;
          i64toi32_i32$2 = $8$hi;
          $51_1 = i64toi32_i32$0;
          i64toi32_i32$2 = $7$hi;
          i64toi32_i32$1 = $45_1;
          i64toi32_i32$0 = $8$hi;
          i64toi32_i32$3 = $51_1;
          i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
          $9_1 = i64toi32_i32$1 & i64toi32_i32$3 | 0;
          $9$hi = i64toi32_i32$0;
          i64toi32_i32$2 = $3_1;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 8 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 12 | 0) >> 2] | 0;
          $10_1 = i64toi32_i32$0;
          $10$hi = i64toi32_i32$1;
          i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $11$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $10$hi;
          i64toi32_i32$0 = $11$hi;
          $58_1 = i64toi32_i32$1;
          i64toi32_i32$0 = $10$hi;
          i64toi32_i32$2 = $10_1;
          i64toi32_i32$1 = $11$hi;
          i64toi32_i32$3 = $58_1;
          i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
          $12$hi = i64toi32_i32$1;
          i64toi32_i32$1 = 0;
          $13$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $12$hi;
          i64toi32_i32$1 = $13$hi;
          i64toi32_i32$1 = $12$hi;
          i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
          i64toi32_i32$2 = $13$hi;
          i64toi32_i32$3 = 8;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$2 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
            $46_1 = 0;
          } else {
            i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
            $46_1 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
          }
          $14$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $9$hi;
          i64toi32_i32$2 = $14$hi;
          i64toi32_i32$2 = $9$hi;
          i64toi32_i32$1 = $9_1;
          i64toi32_i32$0 = $14$hi;
          i64toi32_i32$3 = $46_1;
          i64toi32_i32$0 = i64toi32_i32$2 | i64toi32_i32$0 | 0;
          $67_1 = i64toi32_i32$1 | i64toi32_i32$3 | 0;
          i64toi32_i32$1 = $3_1;
          HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] = $67_1;
          HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = i64toi32_i32$0;
          i64toi32_i32$0 = 65535;
          HEAP32[i64toi32_i32$1 >> 2] = 65535;
          HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
          i64toi32_i32$2 = i64toi32_i32$1;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] | 0;
          $17$hi = i64toi32_i32$1;
          i64toi32_i32$1 = 0;
          $18$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $17$hi;
          i64toi32_i32$1 = $18$hi;
          i64toi32_i32$1 = $17$hi;
          i64toi32_i32$2 = i64toi32_i32$0;
          i64toi32_i32$0 = $18$hi;
          i64toi32_i32$3 = 16;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$0 = 0;
            $47_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
          } else {
            i64toi32_i32$0 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
            $47_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
          }
          $19$hi = i64toi32_i32$0;
          i64toi32_i32$1 = $3_1;
          i64toi32_i32$0 = HEAP32[i64toi32_i32$1 >> 2] | 0;
          i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
          $20$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $19$hi;
          i64toi32_i32$2 = $20$hi;
          $78_1 = i64toi32_i32$0;
          i64toi32_i32$2 = $19$hi;
          i64toi32_i32$1 = $47_1;
          i64toi32_i32$0 = $20$hi;
          i64toi32_i32$3 = $78_1;
          i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
          $21_1 = i64toi32_i32$1 & i64toi32_i32$3 | 0;
          $21$hi = i64toi32_i32$0;
          i64toi32_i32$2 = $3_1;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 8 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 12 | 0) >> 2] | 0;
          $22_1 = i64toi32_i32$0;
          $22$hi = i64toi32_i32$1;
          i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $23$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $22$hi;
          i64toi32_i32$0 = $23$hi;
          $85_1 = i64toi32_i32$1;
          i64toi32_i32$0 = $22$hi;
          i64toi32_i32$2 = $22_1;
          i64toi32_i32$1 = $23$hi;
          i64toi32_i32$3 = $85_1;
          i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
          $24$hi = i64toi32_i32$1;
          i64toi32_i32$1 = 0;
          $25$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $24$hi;
          i64toi32_i32$1 = $25$hi;
          i64toi32_i32$1 = $24$hi;
          i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
          i64toi32_i32$2 = $25$hi;
          i64toi32_i32$3 = 16;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$2 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
            $48_1 = 0;
          } else {
            i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
            $48_1 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
          }
          $26$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $21$hi;
          i64toi32_i32$2 = $26$hi;
          i64toi32_i32$2 = $21$hi;
          i64toi32_i32$1 = $21_1;
          i64toi32_i32$0 = $26$hi;
          i64toi32_i32$3 = $48_1;
          i64toi32_i32$0 = i64toi32_i32$2 | i64toi32_i32$0 | 0;
          $94_1 = i64toi32_i32$1 | i64toi32_i32$3 | 0;
          i64toi32_i32$1 = $3_1;
          HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] = $94_1;
          HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = i64toi32_i32$0;
          i64toi32_i32$2 = i64toi32_i32$1;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] | 0;
          $28$hi = i64toi32_i32$1;
          i64toi32_i32$1 = 0;
          $29$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $28$hi;
          i64toi32_i32$1 = $29$hi;
          i64toi32_i32$1 = $28$hi;
          i64toi32_i32$2 = i64toi32_i32$0;
          i64toi32_i32$0 = $29$hi;
          i64toi32_i32$3 = 32;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$0 = 0;
            $49_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
          } else {
            i64toi32_i32$0 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
            $49_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
          }
          $30_1 = $49_1;
          $30$hi = i64toi32_i32$0;
          i64toi32_i32$1 = $3_1;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] | 0;
          i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] | 0;
          $31$hi = i64toi32_i32$2;
          i64toi32_i32$2 = 0;
          $32$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $31$hi;
          i64toi32_i32$2 = $32$hi;
          i64toi32_i32$2 = $31$hi;
          i64toi32_i32$1 = i64toi32_i32$0;
          i64toi32_i32$0 = $32$hi;
          i64toi32_i32$3 = 32;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$0 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
            $50_1 = 0;
          } else {
            i64toi32_i32$0 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$4 | 0) | 0;
            $50_1 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
          }
          $33$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $30$hi;
          i64toi32_i32$0 = $33$hi;
          i64toi32_i32$0 = $30$hi;
          i64toi32_i32$2 = $30_1;
          i64toi32_i32$1 = $33$hi;
          i64toi32_i32$3 = $50_1;
          i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
          i64toi32_i32$2 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$1;
          return i64toi32_i32$2 | 0;
        }

        function $6($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $5_1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,i64toi32_i32$2 = 0,$27_1 = 0,$27$hi = 0;
          $5_1 = global$0 - 32 | 0;
          global$0 = $5_1;
          HEAP32[($5_1 + 28 | 0) >> 2] = $0_1;
          HEAP32[($5_1 + 24 | 0) >> 2] = $1_1;
          HEAP32[($5_1 + 20 | 0) >> 2] = $2_1;
          i64toi32_i32$0 = 0;
          i64toi32_i32$1 = $5_1;
          HEAP32[($5_1 + 8 | 0) >> 2] = 1;
          HEAP32[($5_1 + 12 | 0) >> 2] = i64toi32_i32$0;
          label$1: {
            label$2: {
              if (!(((HEAPU8[($5_1 + 8 | 0) >> 0] | 0) & 255 | 0 | 0) != (0 & 255 | 0 | 0) & 1 | 0)) {
                break label$2;
              }
              i64toi32_i32$2 = HEAP32[($5_1 + 28 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              i64toi32_i32$1 = $7(i64toi32_i32$0 | 0, i64toi32_i32$1 | 0, HEAP32[($5_1 + 24 | 0) >> 2] | 0 | 0, HEAP32[($5_1 + 20 | 0) >> 2] | 0 | 0) | 0;
              i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
              $27_1 = i64toi32_i32$1;
              $27$hi = i64toi32_i32$0;
              break label$1;
            }
            i64toi32_i32$2 = HEAP32[($5_1 + 28 | 0) >> 2] | 0;
            i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
            i64toi32_i32$1 = $8(i64toi32_i32$0 | 0, i64toi32_i32$1 | 0, HEAP32[($5_1 + 24 | 0) >> 2] | 0 | 0, HEAP32[($5_1 + 20 | 0) >> 2] | 0 | 0) | 0;
            i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
            $27_1 = i64toi32_i32$1;
            $27$hi = i64toi32_i32$0;
          }
          i64toi32_i32$0 = $27$hi;
          i64toi32_i32$1 = HEAP32[($5_1 + 28 | 0) >> 2] | 0;
          HEAP32[i64toi32_i32$1 >> 2] = $27_1;
          HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
          global$0 = $5_1 + 32 | 0;
          return;
        }

        function $7($0_1, $0$hi, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var i64toi32_i32$1 = 0,i64toi32_i32$2 = 0,i64toi32_i32$0 = 0,i64toi32_i32$3 = 0,i64toi32_i32$4 = 0,$5_1 = 0,$113$hi = 0,$114$hi = 0,$9_1 = 0,$116$hi = 0,$18_1 = 0,$117$hi = 0,$118$hi = 0,$119$hi = 0,$121$hi = 0,$122$hi = 0,$123$hi = 0,$100_1 = 0,$124$hi = 0,$126$hi = 0,$129$hi = 0,$130$hi = 0,$132$hi = 0,$133$hi = 0,$134$hi = 0,$101_1 = 0,$135$hi = 0,$136$hi = 0,$138$hi = 0,$139$hi = 0,$140$hi = 0,$141$hi = 0,$102 = 0,$142$hi = 0,$143$hi = 0,$145$hi = 0,$146$hi = 0,$147$hi = 0,$148$hi = 0,$103 = 0,$149$hi = 0,$150$hi = 0,$152$hi = 0,$153$hi = 0,$154$hi = 0,$155$hi = 0,$104_1 = 0,$156$hi = 0,$157$hi = 0,$159$hi = 0,$160$hi = 0,$161$hi = 0,$162$hi = 0,$105_1 = 0,$163$hi = 0,$164$hi = 0,$166$hi = 0,$167$hi = 0,$168$hi = 0,$169$hi = 0,$106_1 = 0,$170$hi = 0,$171$hi = 0,$173$hi = 0,$174$hi = 0,$175$hi = 0,$176$hi = 0,$107_1 = 0,$178$hi = 0,$180$hi = 0,$99_1 = 0,$181$hi = 0,$182$hi = 0,$183$hi = 0,$185$hi = 0,$186$hi = 0,$187$hi = 0,$108_1 = 0,$188$hi = 0,$190$hi = 0,$191$hi = 0,$213 = 0,$121 = 0,$275 = 0,$126 = 0,$299$hi = 0,$303 = 0,$132 = 0,$344 = 0,$139 = 0,$368 = 0,$146 = 0,$392 = 0,$153 = 0,$416 = 0,$160 = 0,$440 = 0,$167 = 0,$464 = 0,$174 = 0,$482 = 0,$485 = 0,$185 = 0,$545 = 0;
          $5_1 = global$0 - 32 | 0;
          i64toi32_i32$0 = $0$hi;
          i64toi32_i32$1 = $5_1;
          HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] = $0_1;
          HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] = i64toi32_i32$0;
          HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] = $1_1;
          HEAP32[(i64toi32_i32$1 + 16 | 0) >> 2] = $2_1;
          HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] | 0;
          i64toi32_i32$2 = i64toi32_i32$1;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
          $113$hi = i64toi32_i32$1;
          i64toi32_i32$1 = -1;
          $114$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $113$hi;
          i64toi32_i32$1 = $114$hi;
          i64toi32_i32$1 = $113$hi;
          i64toi32_i32$2 = i64toi32_i32$0;
          i64toi32_i32$0 = $114$hi;
          i64toi32_i32$3 = -1;
          i64toi32_i32$0 = i64toi32_i32$1 ^ i64toi32_i32$0 | 0;
          $213 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
          i64toi32_i32$2 = $5_1;
          HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] = $213;
          HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] = i64toi32_i32$0;
          label$1: while (1) {
            $9_1 = 0;
            label$2: {
              if (!(HEAP32[($5_1 + 16 | 0) >> 2] | 0)) {
                break label$2;
              }
              $9_1 = ((HEAP32[($5_1 + 12 | 0) >> 2] | 0) & 7 | 0 | 0) != (0 | 0);
            }
            label$3: {
              if (!($9_1 & 1 | 0)) {
                break label$3;
              }
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
              $116$hi = i64toi32_i32$2;
              $18_1 = HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] | 0;
              HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = $18_1 + 1 | 0;
              i64toi32_i32$2 = 0;
              $117$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $116$hi;
              i64toi32_i32$2 = $117$hi;
              i64toi32_i32$2 = $116$hi;
              i64toi32_i32$1 = i64toi32_i32$0;
              i64toi32_i32$0 = $117$hi;
              i64toi32_i32$3 = (HEAPU8[$18_1 >> 0] | 0) & 255 | 0;
              i64toi32_i32$0 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
              $118$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $119$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $118$hi;
              i64toi32_i32$0 = $119$hi;
              i64toi32_i32$0 = $118$hi;
              i64toi32_i32$2 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
              i64toi32_i32$1 = $119$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
              i64toi32_i32$0 = 66656 + ((i64toi32_i32$2 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $121 = i64toi32_i32$1;
              $121$hi = i64toi32_i32$2;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0;
              $122$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $123$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $122$hi;
              i64toi32_i32$1 = $123$hi;
              i64toi32_i32$1 = $122$hi;
              i64toi32_i32$0 = i64toi32_i32$2;
              i64toi32_i32$2 = $123$hi;
              i64toi32_i32$3 = 8;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = 0;
                $100_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                $100_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
              }
              $124$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $121$hi;
              i64toi32_i32$2 = $124$hi;
              i64toi32_i32$2 = $121$hi;
              i64toi32_i32$1 = $121;
              i64toi32_i32$0 = $124$hi;
              i64toi32_i32$3 = $100_1;
              i64toi32_i32$0 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
              $275 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
              i64toi32_i32$1 = $5_1;
              HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] = $275;
              HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] = i64toi32_i32$0;
              HEAP32[(i64toi32_i32$1 + 16 | 0) >> 2] = (HEAP32[(i64toi32_i32$1 + 16 | 0) >> 2] | 0) + -1 | 0;
              continue label$1;
            }
            break label$1;
          };
          label$4: {
            label$5: while (1) {
              if (!((HEAP32[($5_1 + 16 | 0) >> 2] | 0) >>> 0 >= 8 >>> 0 & 1 | 0)) {
                break label$4;
              }
              i64toi32_i32$2 = HEAP32[($5_1 + 12 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $126 = i64toi32_i32$0;
              $126$hi = i64toi32_i32$1;
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] | 0;
              $299$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $126$hi;
              i64toi32_i32$0 = $299$hi;
              i64toi32_i32$2 = i64toi32_i32$1;
              i64toi32_i32$1 = $126$hi;
              i64toi32_i32$3 = $126;
              i64toi32_i32$1 = i64toi32_i32$0 ^ i64toi32_i32$1 | 0;
              $303 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
              i64toi32_i32$2 = $5_1;
              HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] = $303;
              HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] = i64toi32_i32$1;
              i64toi32_i32$0 = i64toi32_i32$2;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0;
              $129$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $130$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $129$hi;
              i64toi32_i32$2 = $130$hi;
              i64toi32_i32$2 = $129$hi;
              i64toi32_i32$0 = i64toi32_i32$1;
              i64toi32_i32$1 = $130$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$1 = i64toi32_i32$2 & i64toi32_i32$1 | 0;
              i64toi32_i32$2 = (66656 + 14336 | 0) + ((i64toi32_i32$0 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $132 = i64toi32_i32$1;
              $132$hi = i64toi32_i32$0;
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] | 0;
              $133$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $134$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $133$hi;
              i64toi32_i32$1 = $134$hi;
              i64toi32_i32$1 = $133$hi;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$0 = $134$hi;
              i64toi32_i32$3 = 8;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $101_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                $101_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
              }
              $135$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $136$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $135$hi;
              i64toi32_i32$0 = $136$hi;
              i64toi32_i32$0 = $135$hi;
              i64toi32_i32$1 = $101_1;
              i64toi32_i32$2 = $136$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$2 = i64toi32_i32$0 & i64toi32_i32$2 | 0;
              i64toi32_i32$0 = (66656 + 12288 | 0) + ((i64toi32_i32$1 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $138$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $132$hi;
              i64toi32_i32$1 = $138$hi;
              $344 = i64toi32_i32$2;
              i64toi32_i32$1 = $132$hi;
              i64toi32_i32$0 = $132;
              i64toi32_i32$2 = $138$hi;
              i64toi32_i32$3 = $344;
              i64toi32_i32$2 = i64toi32_i32$1 ^ i64toi32_i32$2 | 0;
              $139 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
              $139$hi = i64toi32_i32$2;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
              $140$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $141$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $140$hi;
              i64toi32_i32$0 = $141$hi;
              i64toi32_i32$0 = $140$hi;
              i64toi32_i32$1 = i64toi32_i32$2;
              i64toi32_i32$2 = $141$hi;
              i64toi32_i32$3 = 16;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = 0;
                $102 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$2 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                $102 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
              }
              $142$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $143$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $142$hi;
              i64toi32_i32$2 = $143$hi;
              i64toi32_i32$2 = $142$hi;
              i64toi32_i32$0 = $102;
              i64toi32_i32$1 = $143$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$1 = i64toi32_i32$2 & i64toi32_i32$1 | 0;
              i64toi32_i32$2 = (66656 + 10240 | 0) + ((i64toi32_i32$0 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $145$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $139$hi;
              i64toi32_i32$0 = $145$hi;
              $368 = i64toi32_i32$1;
              i64toi32_i32$0 = $139$hi;
              i64toi32_i32$2 = $139;
              i64toi32_i32$1 = $145$hi;
              i64toi32_i32$3 = $368;
              i64toi32_i32$1 = i64toi32_i32$0 ^ i64toi32_i32$1 | 0;
              $146 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
              $146$hi = i64toi32_i32$1;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0;
              $147$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $148$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $147$hi;
              i64toi32_i32$2 = $148$hi;
              i64toi32_i32$2 = $147$hi;
              i64toi32_i32$0 = i64toi32_i32$1;
              i64toi32_i32$1 = $148$hi;
              i64toi32_i32$3 = 24;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $103 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                $103 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
              }
              $149$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $150$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $149$hi;
              i64toi32_i32$1 = $150$hi;
              i64toi32_i32$1 = $149$hi;
              i64toi32_i32$2 = $103;
              i64toi32_i32$0 = $150$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$0 = i64toi32_i32$1 & i64toi32_i32$0 | 0;
              i64toi32_i32$1 = (66656 + 8192 | 0) + ((i64toi32_i32$2 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $152$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $146$hi;
              i64toi32_i32$2 = $152$hi;
              $392 = i64toi32_i32$0;
              i64toi32_i32$2 = $146$hi;
              i64toi32_i32$1 = $146;
              i64toi32_i32$0 = $152$hi;
              i64toi32_i32$3 = $392;
              i64toi32_i32$0 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
              $153 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
              $153$hi = i64toi32_i32$0;
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] | 0;
              $154$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $155$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $154$hi;
              i64toi32_i32$1 = $155$hi;
              i64toi32_i32$1 = $154$hi;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$0 = $155$hi;
              i64toi32_i32$3 = 32;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $104_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                $104_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
              }
              $156$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $157$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $156$hi;
              i64toi32_i32$0 = $157$hi;
              i64toi32_i32$0 = $156$hi;
              i64toi32_i32$1 = $104_1;
              i64toi32_i32$2 = $157$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$2 = i64toi32_i32$0 & i64toi32_i32$2 | 0;
              i64toi32_i32$0 = (66656 + 6144 | 0) + ((i64toi32_i32$1 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $159$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $153$hi;
              i64toi32_i32$1 = $159$hi;
              $416 = i64toi32_i32$2;
              i64toi32_i32$1 = $153$hi;
              i64toi32_i32$0 = $153;
              i64toi32_i32$2 = $159$hi;
              i64toi32_i32$3 = $416;
              i64toi32_i32$2 = i64toi32_i32$1 ^ i64toi32_i32$2 | 0;
              $160 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
              $160$hi = i64toi32_i32$2;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
              $161$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $162$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $161$hi;
              i64toi32_i32$0 = $162$hi;
              i64toi32_i32$0 = $161$hi;
              i64toi32_i32$1 = i64toi32_i32$2;
              i64toi32_i32$2 = $162$hi;
              i64toi32_i32$3 = 40;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = 0;
                $105_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$2 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                $105_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
              }
              $163$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $164$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $163$hi;
              i64toi32_i32$2 = $164$hi;
              i64toi32_i32$2 = $163$hi;
              i64toi32_i32$0 = $105_1;
              i64toi32_i32$1 = $164$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$1 = i64toi32_i32$2 & i64toi32_i32$1 | 0;
              i64toi32_i32$2 = (66656 + 4096 | 0) + ((i64toi32_i32$0 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $166$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $160$hi;
              i64toi32_i32$0 = $166$hi;
              $440 = i64toi32_i32$1;
              i64toi32_i32$0 = $160$hi;
              i64toi32_i32$2 = $160;
              i64toi32_i32$1 = $166$hi;
              i64toi32_i32$3 = $440;
              i64toi32_i32$1 = i64toi32_i32$0 ^ i64toi32_i32$1 | 0;
              $167 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
              $167$hi = i64toi32_i32$1;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0;
              $168$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $169$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $168$hi;
              i64toi32_i32$2 = $169$hi;
              i64toi32_i32$2 = $168$hi;
              i64toi32_i32$0 = i64toi32_i32$1;
              i64toi32_i32$1 = $169$hi;
              i64toi32_i32$3 = 48;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $106_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                $106_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
              }
              $170$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $171$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $170$hi;
              i64toi32_i32$1 = $171$hi;
              i64toi32_i32$1 = $170$hi;
              i64toi32_i32$2 = $106_1;
              i64toi32_i32$0 = $171$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$0 = i64toi32_i32$1 & i64toi32_i32$0 | 0;
              i64toi32_i32$1 = (66656 + 2048 | 0) + ((i64toi32_i32$2 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $173$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $167$hi;
              i64toi32_i32$2 = $173$hi;
              $464 = i64toi32_i32$0;
              i64toi32_i32$2 = $167$hi;
              i64toi32_i32$1 = $167;
              i64toi32_i32$0 = $173$hi;
              i64toi32_i32$3 = $464;
              i64toi32_i32$0 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
              $174 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
              $174$hi = i64toi32_i32$0;
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] | 0;
              $175$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $176$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $175$hi;
              i64toi32_i32$1 = $176$hi;
              i64toi32_i32$1 = $175$hi;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$0 = $176$hi;
              i64toi32_i32$3 = 56;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $107_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                $107_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
              }
              i64toi32_i32$1 = 66656 + ($107_1 << 3 | 0) | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $178$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $174$hi;
              i64toi32_i32$2 = $178$hi;
              $482 = i64toi32_i32$0;
              i64toi32_i32$2 = $174$hi;
              i64toi32_i32$1 = $174;
              i64toi32_i32$0 = $178$hi;
              i64toi32_i32$3 = $482;
              i64toi32_i32$0 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
              $485 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
              i64toi32_i32$1 = $5_1;
              HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] = $485;
              HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] = i64toi32_i32$0;
              HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = (HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] | 0) + 8 | 0;
              HEAP32[(i64toi32_i32$1 + 16 | 0) >> 2] = (HEAP32[(i64toi32_i32$1 + 16 | 0) >> 2] | 0) - 8 | 0;
              continue label$5;
            };
          }
          label$6: {
            label$7: while (1) {
              if (!(HEAP32[($5_1 + 16 | 0) >> 2] | 0)) {
                break label$6;
              }
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] | 0;
              $180$hi = i64toi32_i32$1;
              $99_1 = HEAP32[(i64toi32_i32$2 + 12 | 0) >> 2] | 0;
              HEAP32[(i64toi32_i32$2 + 12 | 0) >> 2] = $99_1 + 1 | 0;
              i64toi32_i32$1 = 0;
              $181$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $180$hi;
              i64toi32_i32$1 = $181$hi;
              i64toi32_i32$1 = $180$hi;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$0 = $181$hi;
              i64toi32_i32$3 = (HEAPU8[$99_1 >> 0] | 0) & 255 | 0;
              i64toi32_i32$0 = i64toi32_i32$1 ^ i64toi32_i32$0 | 0;
              $182$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $183$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $182$hi;
              i64toi32_i32$0 = $183$hi;
              i64toi32_i32$0 = $182$hi;
              i64toi32_i32$1 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
              i64toi32_i32$2 = $183$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$2 = i64toi32_i32$0 & i64toi32_i32$2 | 0;
              i64toi32_i32$0 = 66656 + ((i64toi32_i32$1 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $185 = i64toi32_i32$2;
              $185$hi = i64toi32_i32$1;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0;
              $186$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $187$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $186$hi;
              i64toi32_i32$2 = $187$hi;
              i64toi32_i32$2 = $186$hi;
              i64toi32_i32$0 = i64toi32_i32$1;
              i64toi32_i32$1 = $187$hi;
              i64toi32_i32$3 = 8;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $108_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                $108_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
              }
              $188$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $185$hi;
              i64toi32_i32$1 = $188$hi;
              i64toi32_i32$1 = $185$hi;
              i64toi32_i32$2 = $185;
              i64toi32_i32$0 = $188$hi;
              i64toi32_i32$3 = $108_1;
              i64toi32_i32$0 = i64toi32_i32$1 ^ i64toi32_i32$0 | 0;
              $545 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
              i64toi32_i32$2 = $5_1;
              HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] = $545;
              HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] = i64toi32_i32$0;
              HEAP32[(i64toi32_i32$2 + 16 | 0) >> 2] = (HEAP32[(i64toi32_i32$2 + 16 | 0) >> 2] | 0) + -1 | 0;
              continue label$7;
            };
          }
          i64toi32_i32$1 = $5_1;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
          i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
          $190$hi = i64toi32_i32$2;
          i64toi32_i32$2 = -1;
          $191$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $190$hi;
          i64toi32_i32$2 = $191$hi;
          i64toi32_i32$2 = $190$hi;
          i64toi32_i32$1 = i64toi32_i32$0;
          i64toi32_i32$0 = $191$hi;
          i64toi32_i32$3 = -1;
          i64toi32_i32$0 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
          i64toi32_i32$1 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$0;
          return i64toi32_i32$1 | 0;
        }

        function $8($0_1, $0$hi, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,i64toi32_i32$2 = 0,i64toi32_i32$3 = 0,i64toi32_i32$4 = 0,$5_1 = 0,$116$hi = 0,$117$hi = 0,$9_1 = 0,$119$hi = 0,$120$hi = 0,$100_1 = 0,$121$hi = 0,$18_1 = 0,$122$hi = 0,$124$hi = 0,$125$hi = 0,$126$hi = 0,$101_1 = 0,$127$hi = 0,$129$hi = 0,$132$hi = 0,$133$hi = 0,$135$hi = 0,$136$hi = 0,$137$hi = 0,$102 = 0,$138$hi = 0,$139$hi = 0,$141$hi = 0,$142$hi = 0,$143$hi = 0,$144$hi = 0,$103 = 0,$145$hi = 0,$146$hi = 0,$148$hi = 0,$149$hi = 0,$150$hi = 0,$151$hi = 0,$104_1 = 0,$152$hi = 0,$153$hi = 0,$155$hi = 0,$156$hi = 0,$157$hi = 0,$158$hi = 0,$105_1 = 0,$159$hi = 0,$160$hi = 0,$162$hi = 0,$163$hi = 0,$164$hi = 0,$165$hi = 0,$106_1 = 0,$166$hi = 0,$167$hi = 0,$169$hi = 0,$170$hi = 0,$171$hi = 0,$172$hi = 0,$107_1 = 0,$173$hi = 0,$174$hi = 0,$176$hi = 0,$177$hi = 0,$178$hi = 0,$179$hi = 0,$108_1 = 0,$181$hi = 0,$183$hi = 0,$184$hi = 0,$109_1 = 0,$185$hi = 0,$99_1 = 0,$186$hi = 0,$188$hi = 0,$189$hi = 0,$190$hi = 0,$110_1 = 0,$191$hi = 0,$194$hi = 0,$195$hi = 0,$220 = 0,$124 = 0,$282 = 0,$129 = 0,$306$hi = 0,$310 = 0,$135 = 0,$348 = 0,$142 = 0,$372 = 0,$149 = 0,$396 = 0,$156 = 0,$420 = 0,$163 = 0,$444 = 0,$170 = 0,$468 = 0,$177 = 0,$489 = 0,$492 = 0,$188 = 0,$552 = 0;
          $5_1 = global$0 - 32 | 0;
          global$0 = $5_1;
          i64toi32_i32$0 = $0$hi;
          i64toi32_i32$1 = $5_1;
          HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] = $0_1;
          HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] = i64toi32_i32$0;
          HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] = $1_1;
          HEAP32[(i64toi32_i32$1 + 16 | 0) >> 2] = $2_1;
          HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] | 0;
          i64toi32_i32$2 = i64toi32_i32$1;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
          i64toi32_i32$1 = $5(i64toi32_i32$0 | 0, i64toi32_i32$1 | 0) | 0;
          i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
          $116$hi = i64toi32_i32$0;
          i64toi32_i32$0 = -1;
          $117$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $116$hi;
          i64toi32_i32$0 = $117$hi;
          i64toi32_i32$0 = $116$hi;
          i64toi32_i32$2 = i64toi32_i32$1;
          i64toi32_i32$1 = $117$hi;
          i64toi32_i32$3 = -1;
          i64toi32_i32$1 = i64toi32_i32$0 ^ i64toi32_i32$1 | 0;
          $220 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
          i64toi32_i32$2 = $5_1;
          HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] = $220;
          HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] = i64toi32_i32$1;
          label$1: while (1) {
            $9_1 = 0;
            label$2: {
              if (!(HEAP32[($5_1 + 16 | 0) >> 2] | 0)) {
                break label$2;
              }
              $9_1 = ((HEAP32[($5_1 + 12 | 0) >> 2] | 0) & 7 | 0 | 0) != (0 | 0);
            }
            label$3: {
              if (!($9_1 & 1 | 0)) {
                break label$3;
              }
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0;
              $119$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $120$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $119$hi;
              i64toi32_i32$2 = $120$hi;
              i64toi32_i32$2 = $119$hi;
              i64toi32_i32$0 = i64toi32_i32$1;
              i64toi32_i32$1 = $120$hi;
              i64toi32_i32$3 = 56;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $100_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                $100_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
              }
              $121$hi = i64toi32_i32$1;
              $18_1 = HEAP32[($5_1 + 12 | 0) >> 2] | 0;
              HEAP32[($5_1 + 12 | 0) >> 2] = $18_1 + 1 | 0;
              i64toi32_i32$1 = 0;
              $122$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $121$hi;
              i64toi32_i32$1 = $122$hi;
              i64toi32_i32$1 = $121$hi;
              i64toi32_i32$2 = $100_1;
              i64toi32_i32$0 = $122$hi;
              i64toi32_i32$3 = (HEAPU8[$18_1 >> 0] | 0) & 255 | 0;
              i64toi32_i32$0 = i64toi32_i32$1 ^ i64toi32_i32$0 | 0;
              i64toi32_i32$1 = 83040 + ((i64toi32_i32$2 ^ i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $124 = i64toi32_i32$0;
              $124$hi = i64toi32_i32$2;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
              $125$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $126$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $125$hi;
              i64toi32_i32$0 = $126$hi;
              i64toi32_i32$0 = $125$hi;
              i64toi32_i32$1 = i64toi32_i32$2;
              i64toi32_i32$2 = $126$hi;
              i64toi32_i32$3 = 8;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
                $101_1 = 0;
              } else {
                i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$4 | 0) | 0;
                $101_1 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
              }
              $127$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $124$hi;
              i64toi32_i32$2 = $127$hi;
              i64toi32_i32$2 = $124$hi;
              i64toi32_i32$0 = $124;
              i64toi32_i32$1 = $127$hi;
              i64toi32_i32$3 = $101_1;
              i64toi32_i32$1 = i64toi32_i32$2 ^ i64toi32_i32$1 | 0;
              $282 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
              i64toi32_i32$0 = $5_1;
              HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] = $282;
              HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] = i64toi32_i32$1;
              HEAP32[(i64toi32_i32$0 + 16 | 0) >> 2] = (HEAP32[(i64toi32_i32$0 + 16 | 0) >> 2] | 0) + -1 | 0;
              continue label$1;
            }
            break label$1;
          };
          label$4: {
            label$5: while (1) {
              if (!((HEAP32[($5_1 + 16 | 0) >> 2] | 0) >>> 0 >= 8 >>> 0 & 1 | 0)) {
                break label$4;
              }
              i64toi32_i32$2 = HEAP32[($5_1 + 12 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $129 = i64toi32_i32$1;
              $129$hi = i64toi32_i32$0;
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] | 0;
              $306$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $129$hi;
              i64toi32_i32$1 = $306$hi;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$0 = $129$hi;
              i64toi32_i32$3 = $129;
              i64toi32_i32$0 = i64toi32_i32$1 ^ i64toi32_i32$0 | 0;
              $310 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
              i64toi32_i32$2 = $5_1;
              HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] = $310;
              HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] = i64toi32_i32$0;
              i64toi32_i32$1 = i64toi32_i32$2;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
              $132$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $133$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $132$hi;
              i64toi32_i32$2 = $133$hi;
              i64toi32_i32$2 = $132$hi;
              i64toi32_i32$1 = i64toi32_i32$0;
              i64toi32_i32$0 = $133$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
              i64toi32_i32$2 = 83040 + ((i64toi32_i32$1 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $135 = i64toi32_i32$0;
              $135$hi = i64toi32_i32$1;
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] | 0;
              $136$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $137$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $136$hi;
              i64toi32_i32$0 = $137$hi;
              i64toi32_i32$0 = $136$hi;
              i64toi32_i32$2 = i64toi32_i32$1;
              i64toi32_i32$1 = $137$hi;
              i64toi32_i32$3 = 8;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $102 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                $102 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
              }
              $138$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $139$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $138$hi;
              i64toi32_i32$1 = $139$hi;
              i64toi32_i32$1 = $138$hi;
              i64toi32_i32$0 = $102;
              i64toi32_i32$2 = $139$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
              i64toi32_i32$1 = (83040 + 2048 | 0) + ((i64toi32_i32$0 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $141$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $135$hi;
              i64toi32_i32$0 = $141$hi;
              $348 = i64toi32_i32$2;
              i64toi32_i32$0 = $135$hi;
              i64toi32_i32$1 = $135;
              i64toi32_i32$2 = $141$hi;
              i64toi32_i32$3 = $348;
              i64toi32_i32$2 = i64toi32_i32$0 ^ i64toi32_i32$2 | 0;
              $142 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
              $142$hi = i64toi32_i32$2;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0;
              $143$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $144$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $143$hi;
              i64toi32_i32$1 = $144$hi;
              i64toi32_i32$1 = $143$hi;
              i64toi32_i32$0 = i64toi32_i32$2;
              i64toi32_i32$2 = $144$hi;
              i64toi32_i32$3 = 16;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = 0;
                $103 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                $103 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
              }
              $145$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $146$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $145$hi;
              i64toi32_i32$2 = $146$hi;
              i64toi32_i32$2 = $145$hi;
              i64toi32_i32$1 = $103;
              i64toi32_i32$0 = $146$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
              i64toi32_i32$2 = (83040 + 4096 | 0) + ((i64toi32_i32$1 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $148$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $142$hi;
              i64toi32_i32$1 = $148$hi;
              $372 = i64toi32_i32$0;
              i64toi32_i32$1 = $142$hi;
              i64toi32_i32$2 = $142;
              i64toi32_i32$0 = $148$hi;
              i64toi32_i32$3 = $372;
              i64toi32_i32$0 = i64toi32_i32$1 ^ i64toi32_i32$0 | 0;
              $149 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
              $149$hi = i64toi32_i32$0;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
              $150$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $151$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $150$hi;
              i64toi32_i32$2 = $151$hi;
              i64toi32_i32$2 = $150$hi;
              i64toi32_i32$1 = i64toi32_i32$0;
              i64toi32_i32$0 = $151$hi;
              i64toi32_i32$3 = 24;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $104_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                $104_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
              }
              $152$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $153$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $152$hi;
              i64toi32_i32$0 = $153$hi;
              i64toi32_i32$0 = $152$hi;
              i64toi32_i32$2 = $104_1;
              i64toi32_i32$1 = $153$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
              i64toi32_i32$0 = (83040 + 6144 | 0) + ((i64toi32_i32$2 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $155$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $149$hi;
              i64toi32_i32$2 = $155$hi;
              $396 = i64toi32_i32$1;
              i64toi32_i32$2 = $149$hi;
              i64toi32_i32$0 = $149;
              i64toi32_i32$1 = $155$hi;
              i64toi32_i32$3 = $396;
              i64toi32_i32$1 = i64toi32_i32$2 ^ i64toi32_i32$1 | 0;
              $156 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
              $156$hi = i64toi32_i32$1;
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] | 0;
              $157$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $158$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $157$hi;
              i64toi32_i32$0 = $158$hi;
              i64toi32_i32$0 = $157$hi;
              i64toi32_i32$2 = i64toi32_i32$1;
              i64toi32_i32$1 = $158$hi;
              i64toi32_i32$3 = 32;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $105_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                $105_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
              }
              $159$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $160$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $159$hi;
              i64toi32_i32$1 = $160$hi;
              i64toi32_i32$1 = $159$hi;
              i64toi32_i32$0 = $105_1;
              i64toi32_i32$2 = $160$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
              i64toi32_i32$1 = (83040 + 8192 | 0) + ((i64toi32_i32$0 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $162$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $156$hi;
              i64toi32_i32$0 = $162$hi;
              $420 = i64toi32_i32$2;
              i64toi32_i32$0 = $156$hi;
              i64toi32_i32$1 = $156;
              i64toi32_i32$2 = $162$hi;
              i64toi32_i32$3 = $420;
              i64toi32_i32$2 = i64toi32_i32$0 ^ i64toi32_i32$2 | 0;
              $163 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
              $163$hi = i64toi32_i32$2;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0;
              $164$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $165$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $164$hi;
              i64toi32_i32$1 = $165$hi;
              i64toi32_i32$1 = $164$hi;
              i64toi32_i32$0 = i64toi32_i32$2;
              i64toi32_i32$2 = $165$hi;
              i64toi32_i32$3 = 40;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = 0;
                $106_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                $106_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
              }
              $166$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $167$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $166$hi;
              i64toi32_i32$2 = $167$hi;
              i64toi32_i32$2 = $166$hi;
              i64toi32_i32$1 = $106_1;
              i64toi32_i32$0 = $167$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
              i64toi32_i32$2 = (83040 + 10240 | 0) + ((i64toi32_i32$1 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $169$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $163$hi;
              i64toi32_i32$1 = $169$hi;
              $444 = i64toi32_i32$0;
              i64toi32_i32$1 = $163$hi;
              i64toi32_i32$2 = $163;
              i64toi32_i32$0 = $169$hi;
              i64toi32_i32$3 = $444;
              i64toi32_i32$0 = i64toi32_i32$1 ^ i64toi32_i32$0 | 0;
              $170 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
              $170$hi = i64toi32_i32$0;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
              $171$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $172$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $171$hi;
              i64toi32_i32$2 = $172$hi;
              i64toi32_i32$2 = $171$hi;
              i64toi32_i32$1 = i64toi32_i32$0;
              i64toi32_i32$0 = $172$hi;
              i64toi32_i32$3 = 48;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $107_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                $107_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
              }
              $173$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $174$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $173$hi;
              i64toi32_i32$0 = $174$hi;
              i64toi32_i32$0 = $173$hi;
              i64toi32_i32$2 = $107_1;
              i64toi32_i32$1 = $174$hi;
              i64toi32_i32$3 = 255;
              i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
              i64toi32_i32$0 = (83040 + 12288 | 0) + ((i64toi32_i32$2 & i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $176$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $170$hi;
              i64toi32_i32$2 = $176$hi;
              $468 = i64toi32_i32$1;
              i64toi32_i32$2 = $170$hi;
              i64toi32_i32$0 = $170;
              i64toi32_i32$1 = $176$hi;
              i64toi32_i32$3 = $468;
              i64toi32_i32$1 = i64toi32_i32$2 ^ i64toi32_i32$1 | 0;
              $177 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
              $177$hi = i64toi32_i32$1;
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] | 0;
              $178$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $179$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $178$hi;
              i64toi32_i32$0 = $179$hi;
              i64toi32_i32$0 = $178$hi;
              i64toi32_i32$2 = i64toi32_i32$1;
              i64toi32_i32$1 = $179$hi;
              i64toi32_i32$3 = 56;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $108_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                $108_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
              }
              i64toi32_i32$0 = (83040 + 14336 | 0) + ($108_1 << 3 | 0) | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $181$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $177$hi;
              i64toi32_i32$2 = $181$hi;
              $489 = i64toi32_i32$1;
              i64toi32_i32$2 = $177$hi;
              i64toi32_i32$0 = $177;
              i64toi32_i32$1 = $181$hi;
              i64toi32_i32$3 = $489;
              i64toi32_i32$1 = i64toi32_i32$2 ^ i64toi32_i32$1 | 0;
              $492 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
              i64toi32_i32$0 = $5_1;
              HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] = $492;
              HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] = i64toi32_i32$1;
              HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] = (HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] | 0) + 8 | 0;
              HEAP32[(i64toi32_i32$0 + 16 | 0) >> 2] = (HEAP32[(i64toi32_i32$0 + 16 | 0) >> 2] | 0) - 8 | 0;
              continue label$5;
            };
          }
          label$6: {
            label$7: while (1) {
              if (!(HEAP32[($5_1 + 16 | 0) >> 2] | 0)) {
                break label$6;
              }
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] | 0;
              $183$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $184$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $183$hi;
              i64toi32_i32$0 = $184$hi;
              i64toi32_i32$0 = $183$hi;
              i64toi32_i32$2 = i64toi32_i32$1;
              i64toi32_i32$1 = $184$hi;
              i64toi32_i32$3 = 56;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $109_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                $109_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
              }
              $185$hi = i64toi32_i32$1;
              $99_1 = HEAP32[($5_1 + 12 | 0) >> 2] | 0;
              HEAP32[($5_1 + 12 | 0) >> 2] = $99_1 + 1 | 0;
              i64toi32_i32$1 = 0;
              $186$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $185$hi;
              i64toi32_i32$1 = $186$hi;
              i64toi32_i32$1 = $185$hi;
              i64toi32_i32$0 = $109_1;
              i64toi32_i32$2 = $186$hi;
              i64toi32_i32$3 = (HEAPU8[$99_1 >> 0] | 0) & 255 | 0;
              i64toi32_i32$2 = i64toi32_i32$1 ^ i64toi32_i32$2 | 0;
              i64toi32_i32$1 = 83040 + ((i64toi32_i32$0 ^ i64toi32_i32$3 | 0) << 3 | 0) | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $188 = i64toi32_i32$2;
              $188$hi = i64toi32_i32$0;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 24 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0;
              $189$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $190$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $189$hi;
              i64toi32_i32$2 = $190$hi;
              i64toi32_i32$2 = $189$hi;
              i64toi32_i32$1 = i64toi32_i32$0;
              i64toi32_i32$0 = $190$hi;
              i64toi32_i32$3 = 8;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
                $110_1 = 0;
              } else {
                i64toi32_i32$0 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$4 | 0) | 0;
                $110_1 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
              }
              $191$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $188$hi;
              i64toi32_i32$0 = $191$hi;
              i64toi32_i32$0 = $188$hi;
              i64toi32_i32$2 = $188;
              i64toi32_i32$1 = $191$hi;
              i64toi32_i32$3 = $110_1;
              i64toi32_i32$1 = i64toi32_i32$0 ^ i64toi32_i32$1 | 0;
              $552 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
              i64toi32_i32$2 = $5_1;
              HEAP32[(i64toi32_i32$2 + 24 | 0) >> 2] = $552;
              HEAP32[(i64toi32_i32$2 + 28 | 0) >> 2] = i64toi32_i32$1;
              HEAP32[(i64toi32_i32$2 + 16 | 0) >> 2] = (HEAP32[(i64toi32_i32$2 + 16 | 0) >> 2] | 0) + -1 | 0;
              continue label$7;
            };
          }
          i64toi32_i32$0 = $5_1;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 24 | 0) >> 2] | 0;
          i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 28 | 0) >> 2] | 0;
          i64toi32_i32$2 = $5(i64toi32_i32$1 | 0, i64toi32_i32$2 | 0) | 0;
          i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
          $194$hi = i64toi32_i32$1;
          i64toi32_i32$1 = -1;
          $195$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $194$hi;
          i64toi32_i32$1 = $195$hi;
          i64toi32_i32$1 = $194$hi;
          i64toi32_i32$0 = i64toi32_i32$2;
          i64toi32_i32$2 = $195$hi;
          i64toi32_i32$3 = -1;
          i64toi32_i32$2 = i64toi32_i32$1 ^ i64toi32_i32$2 | 0;
          global$0 = $5_1 + 32 | 0;
          i64toi32_i32$0 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$2;
          return i64toi32_i32$0 | 0;
        }

        function $9($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var $4_1 = 0,$5_1 = 0;
          $4_1 = global$0 - 16 | 0;
          global$0 = $4_1;
          HEAP32[($4_1 + 12 | 0) >> 2] = $0_1;
          HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;
          $5_1 = HEAP32[($4_1 + 12 | 0) >> 2] | 0;
          HEAP32[$4_1 >> 2] = HEAP32[($4_1 + 8 | 0) >> 2] | 0;
          $15($5_1 | 0, 65574 | 0, $4_1 | 0) | 0;
          global$0 = $4_1 + 16 | 0;
          return;
        }

        function $10($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var $4_1 = 0,i64toi32_i32$2 = 0,$5_1 = 0,i64toi32_i32$1 = 0;
          $4_1 = global$0 - 16 | 0;
          global$0 = $4_1;
          HEAP32[($4_1 + 12 | 0) >> 2] = $0_1;
          HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;
          $5_1 = HEAP32[($4_1 + 12 | 0) >> 2] | 0;
          i64toi32_i32$2 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          HEAP32[$4_1 >> 2] = HEAP32[i64toi32_i32$2 >> 2] | 0;
          HEAP32[($4_1 + 4 | 0) >> 2] = i64toi32_i32$1;
          $14($5_1 | 0, 65574 | 0, $4_1 | 0) | 0;
          global$0 = $4_1 + 16 | 0;
          return;
        }

        function $11($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $5_1 = 0,i64toi32_i32$2 = 0,i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,i64toi32_i32$4 = 0,i64toi32_i32$3 = 0,$65$hi = 0,$66$hi = 0,$21_1 = 0,$72$hi = 0,$92_1 = 0,$98_1 = 0,$130 = 0,$183 = 0,$215 = 0,$72_1 = 0,$230$hi = 0,$234 = 0,$240 = 0;
          $5_1 = global$0 - 1072 | 0;
          global$0 = $5_1;
          HEAP32[($5_1 + 1068 | 0) >> 2] = $0_1;
          HEAP32[($5_1 + 1064 | 0) >> 2] = $1_1;
          HEAP32[($5_1 + 1060 | 0) >> 2] = $2_1;
          i64toi32_i32$2 = HEAP32[($5_1 + 1068 | 0) >> 2] | 0;
          i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $92_1 = i64toi32_i32$0;
          i64toi32_i32$0 = $5_1;
          HEAP32[($5_1 + 1048 | 0) >> 2] = $92_1;
          HEAP32[($5_1 + 1052 | 0) >> 2] = i64toi32_i32$1;
          i64toi32_i32$2 = HEAP32[($5_1 + 1064 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $98_1 = i64toi32_i32$1;
          i64toi32_i32$1 = $5_1;
          HEAP32[($5_1 + 1040 | 0) >> 2] = $98_1;
          HEAP32[($5_1 + 1044 | 0) >> 2] = i64toi32_i32$0;
          label$1: {
            label$2: {
              if (HEAP32[($5_1 + 1060 | 0) >> 2] | 0) {
                break label$2;
              }
              break label$1;
            }
            i64toi32_i32$0 = -915646571;
            i64toi32_i32$1 = $5_1;
            HEAP32[$5_1 >> 2] = -679014590;
            HEAP32[($5_1 + 4 | 0) >> 2] = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$1 = $5_1;
            HEAP32[($5_1 + 1024 | 0) >> 2] = 1;
            HEAP32[($5_1 + 1028 | 0) >> 2] = i64toi32_i32$0;
            HEAP32[($5_1 + 1036 | 0) >> 2] = 1;
            label$3: {
              label$4: while (1) {
                if (!((HEAP32[($5_1 + 1036 | 0) >> 2] | 0) >>> 0 < 64 >>> 0 & 1 | 0)) {
                  break label$3;
                }
                i64toi32_i32$2 = $5_1;
                i64toi32_i32$0 = HEAP32[($5_1 + 1024 | 0) >> 2] | 0;
                i64toi32_i32$1 = HEAP32[($5_1 + 1028 | 0) >> 2] | 0;
                $130 = i64toi32_i32$0;
                i64toi32_i32$0 = $5_1 + ((HEAP32[($5_1 + 1036 | 0) >> 2] | 0) << 3 | 0) | 0;
                HEAP32[i64toi32_i32$0 >> 2] = $130;
                HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;
                i64toi32_i32$2 = $5_1;
                i64toi32_i32$1 = HEAP32[($5_1 + 1024 | 0) >> 2] | 0;
                i64toi32_i32$0 = HEAP32[($5_1 + 1028 | 0) >> 2] | 0;
                $65$hi = i64toi32_i32$0;
                i64toi32_i32$0 = 0;
                $66$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $65$hi;
                i64toi32_i32$0 = $66$hi;
                i64toi32_i32$0 = $65$hi;
                i64toi32_i32$2 = i64toi32_i32$1;
                i64toi32_i32$1 = $66$hi;
                i64toi32_i32$3 = 1;
                i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                  $21_1 = 0;
                } else {
                  i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$4 | 0) | 0;
                  $21_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                }
                i64toi32_i32$2 = $5_1;
                HEAP32[($5_1 + 1024 | 0) >> 2] = $21_1;
                HEAP32[($5_1 + 1028 | 0) >> 2] = i64toi32_i32$1;
                HEAP32[($5_1 + 1036 | 0) >> 2] = (HEAP32[($5_1 + 1036 | 0) >> 2] | 0) + 1 | 0;
                continue label$4;
              };
            }
            $12($5_1 + 512 | 0 | 0, $5_1 | 0);
            $12($5_1 | 0, $5_1 + 512 | 0 | 0);
            label$5: while (1) {
              $12($5_1 + 512 | 0 | 0, $5_1 | 0);
              label$6: {
                if (!((HEAP32[($5_1 + 1060 | 0) >> 2] | 0) & 1 | 0)) {
                  break label$6;
                }
                i64toi32_i32$0 = $5_1;
                i64toi32_i32$1 = HEAP32[($5_1 + 1048 | 0) >> 2] | 0;
                i64toi32_i32$2 = HEAP32[($5_1 + 1052 | 0) >> 2] | 0;
                i64toi32_i32$2 = $13($5_1 + 512 | 0 | 0, i64toi32_i32$1 | 0, i64toi32_i32$2 | 0) | 0;
                i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
                $183 = i64toi32_i32$2;
                i64toi32_i32$2 = $5_1;
                HEAP32[($5_1 + 1048 | 0) >> 2] = $183;
                HEAP32[($5_1 + 1052 | 0) >> 2] = i64toi32_i32$1;
              }
              HEAP32[($5_1 + 1060 | 0) >> 2] = (HEAP32[($5_1 + 1060 | 0) >> 2] | 0) >>> 1 | 0;
              label$7: {
                label$8: {
                  if (HEAP32[($5_1 + 1060 | 0) >> 2] | 0) {
                    break label$8;
                  }
                  break label$7;
                }
                $12($5_1 | 0, $5_1 + 512 | 0 | 0);
                label$9: {
                  if (!((HEAP32[($5_1 + 1060 | 0) >> 2] | 0) & 1 | 0)) {
                    break label$9;
                  }
                  i64toi32_i32$0 = $5_1;
                  i64toi32_i32$1 = HEAP32[($5_1 + 1048 | 0) >> 2] | 0;
                  i64toi32_i32$2 = HEAP32[($5_1 + 1052 | 0) >> 2] | 0;
                  i64toi32_i32$2 = $13($5_1 | 0, i64toi32_i32$1 | 0, i64toi32_i32$2 | 0) | 0;
                  i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
                  $215 = i64toi32_i32$2;
                  i64toi32_i32$2 = $5_1;
                  HEAP32[($5_1 + 1048 | 0) >> 2] = $215;
                  HEAP32[($5_1 + 1052 | 0) >> 2] = i64toi32_i32$1;
                }
                HEAP32[($5_1 + 1060 | 0) >> 2] = (HEAP32[($5_1 + 1060 | 0) >> 2] | 0) >>> 1 | 0;
                if (HEAP32[($5_1 + 1060 | 0) >> 2] | 0) {
                  continue label$5;
                }
              }
              break label$5;
            };
            i64toi32_i32$0 = $5_1;
            i64toi32_i32$1 = HEAP32[($5_1 + 1040 | 0) >> 2] | 0;
            i64toi32_i32$2 = HEAP32[($5_1 + 1044 | 0) >> 2] | 0;
            $72_1 = i64toi32_i32$1;
            $72$hi = i64toi32_i32$2;
            i64toi32_i32$0 = $5_1;
            i64toi32_i32$2 = HEAP32[($5_1 + 1048 | 0) >> 2] | 0;
            i64toi32_i32$1 = HEAP32[($5_1 + 1052 | 0) >> 2] | 0;
            $230$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $72$hi;
            i64toi32_i32$1 = $230$hi;
            i64toi32_i32$0 = i64toi32_i32$2;
            i64toi32_i32$2 = $72$hi;
            i64toi32_i32$3 = $72_1;
            i64toi32_i32$2 = i64toi32_i32$1 ^ i64toi32_i32$2 | 0;
            $234 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
            i64toi32_i32$0 = $5_1;
            HEAP32[($5_1 + 1048 | 0) >> 2] = $234;
            HEAP32[($5_1 + 1052 | 0) >> 2] = i64toi32_i32$2;
            i64toi32_i32$1 = $5_1;
            i64toi32_i32$2 = HEAP32[($5_1 + 1048 | 0) >> 2] | 0;
            i64toi32_i32$0 = HEAP32[($5_1 + 1052 | 0) >> 2] | 0;
            $240 = i64toi32_i32$2;
            i64toi32_i32$2 = HEAP32[($5_1 + 1068 | 0) >> 2] | 0;
            HEAP32[i64toi32_i32$2 >> 2] = $240;
            HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] = i64toi32_i32$0;
          }
          global$0 = $5_1 + 1072 | 0;
          return;
        }

        function $12($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var $4_1 = 0,i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,$78_1 = 0;
          $4_1 = global$0 - 16 | 0;
          global$0 = $4_1;
          HEAP32[($4_1 + 12 | 0) >> 2] = $0_1;
          HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;
          HEAP32[($4_1 + 4 | 0) >> 2] = 0;
          label$1: {
            label$2: while (1) {
              if (!((HEAP32[($4_1 + 4 | 0) >> 2] | 0) >>> 0 < 64 >>> 0 & 1 | 0)) {
                break label$1;
              }
              i64toi32_i32$2 = (HEAP32[($4_1 + 8 | 0) >> 2] | 0) + ((HEAP32[($4_1 + 4 | 0) >> 2] | 0) << 3 | 0) | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              i64toi32_i32$1 = $13(HEAP32[($4_1 + 8 | 0) >> 2] | 0 | 0, i64toi32_i32$0 | 0, i64toi32_i32$1 | 0) | 0;
              i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
              $78_1 = i64toi32_i32$1;
              i64toi32_i32$1 = (HEAP32[($4_1 + 12 | 0) >> 2] | 0) + ((HEAP32[($4_1 + 4 | 0) >> 2] | 0) << 3 | 0) | 0;
              HEAP32[i64toi32_i32$1 >> 2] = $78_1;
              HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
              HEAP32[($4_1 + 4 | 0) >> 2] = (HEAP32[($4_1 + 4 | 0) >> 2] | 0) + 1 | 0;
              continue label$2;
            };
          }
          global$0 = $4_1 + 16 | 0;
          return;
        }

        function $13($0_1, $1_1, $1$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          var i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,$4_1 = 0,i64toi32_i32$3 = 0,i64toi32_i32$4 = 0,$16$hi = 0,$17$hi = 0,$18$hi = 0,$19$hi = 0,$20$hi = 0,$21$hi = 0,$22$hi = 0,$25$hi = 0,$26$hi = 0,$21_1 = 0,$22_1 = 0,$68$hi = 0,$72_1 = 0;
          $4_1 = global$0 - 32 | 0;
          HEAP32[($4_1 + 28 | 0) >> 2] = $0_1;
          i64toi32_i32$0 = $1$hi;
          i64toi32_i32$1 = $4_1;
          HEAP32[(i64toi32_i32$1 + 16 | 0) >> 2] = $1_1;
          HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] = i64toi32_i32$0;
          i64toi32_i32$0 = 0;
          HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] = 0;
          HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = i64toi32_i32$0;
          label$1: {
            label$2: while (1) {
              i64toi32_i32$2 = $4_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 16 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 20 | 0) >> 2] | 0;
              $16$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $17$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $16$hi;
              i64toi32_i32$1 = $17$hi;
              i64toi32_i32$1 = $16$hi;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$0 = $17$hi;
              i64toi32_i32$3 = 0;
              if (!(((i64toi32_i32$2 | 0) != (i64toi32_i32$3 | 0) | (i64toi32_i32$1 | 0) != (i64toi32_i32$0 | 0) | 0) & 1 | 0)) {
                break label$1;
              }
              i64toi32_i32$3 = $4_1;
              i64toi32_i32$2 = HEAP32[($4_1 + 16 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[($4_1 + 20 | 0) >> 2] | 0;
              $18$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $19$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $18$hi;
              i64toi32_i32$1 = $19$hi;
              i64toi32_i32$1 = $18$hi;
              i64toi32_i32$3 = i64toi32_i32$2;
              i64toi32_i32$2 = $19$hi;
              i64toi32_i32$0 = 1;
              i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
              $20$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $21$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $20$hi;
              i64toi32_i32$2 = $21$hi;
              i64toi32_i32$2 = $20$hi;
              i64toi32_i32$1 = i64toi32_i32$3 & i64toi32_i32$0 | 0;
              i64toi32_i32$3 = $21$hi;
              i64toi32_i32$0 = 0;
              label$3: {
                if (!(((i64toi32_i32$1 | 0) != (i64toi32_i32$0 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$3 | 0) | 0) & 1 | 0)) {
                  break label$3;
                }
                i64toi32_i32$0 = HEAP32[($4_1 + 28 | 0) >> 2] | 0;
                i64toi32_i32$1 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                $22_1 = i64toi32_i32$1;
                $22$hi = i64toi32_i32$2;
                i64toi32_i32$0 = $4_1;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 8 | 0) >> 2] | 0;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] | 0;
                $68$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $22$hi;
                i64toi32_i32$1 = $68$hi;
                i64toi32_i32$0 = i64toi32_i32$2;
                i64toi32_i32$2 = $22$hi;
                i64toi32_i32$3 = $22_1;
                i64toi32_i32$2 = i64toi32_i32$1 ^ i64toi32_i32$2 | 0;
                $72_1 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
                i64toi32_i32$0 = $4_1;
                HEAP32[(i64toi32_i32$0 + 8 | 0) >> 2] = $72_1;
                HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] = i64toi32_i32$2;
              }
              i64toi32_i32$1 = $4_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 16 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] | 0;
              $25$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $26$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $25$hi;
              i64toi32_i32$0 = $26$hi;
              i64toi32_i32$0 = $25$hi;
              i64toi32_i32$1 = i64toi32_i32$2;
              i64toi32_i32$2 = $26$hi;
              i64toi32_i32$3 = 1;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = 0;
                $21_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$2 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                $21_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
              }
              i64toi32_i32$1 = $4_1;
              HEAP32[(i64toi32_i32$1 + 16 | 0) >> 2] = $21_1;
              HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] = i64toi32_i32$2;
              HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] = (HEAP32[(i64toi32_i32$1 + 28 | 0) >> 2] | 0) + 8 | 0;
              continue label$2;
            };
          }
          i64toi32_i32$0 = $4_1;
          i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 8 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] | 0;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$1;
          return i64toi32_i32$2 | 0;
        }

        function $14($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $3_1 = 0;
          $3_1 = global$0 - 16 | 0;
          global$0 = $3_1;
          HEAP32[($3_1 + 12 | 0) >> 2] = $2_1;
          $2_1 = $45($0_1 | 0, $1_1 | 0, $2_1 | 0) | 0;
          global$0 = $3_1 + 16 | 0;
          return $2_1 | 0;
        }

        function $15($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $3_1 = 0;
          $3_1 = global$0 - 16 | 0;
          global$0 = $3_1;
          HEAP32[($3_1 + 12 | 0) >> 2] = $2_1;
          $2_1 = $73($0_1 | 0, $1_1 | 0, $2_1 | 0) | 0;
          global$0 = $3_1 + 16 | 0;
          return $2_1 | 0;
        }

        function $16($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $3_1 = 0,i64toi32_i32$0 = 0,$4_1 = 0,i64toi32_i32$1 = 0,$6_1 = 0,$5_1 = 0,$6$hi = 0;
          label$1: {
            if (!$2_1) {
              break label$1;
            }
            HEAP8[$0_1 >> 0] = $1_1;
            $3_1 = $0_1 + $2_1 | 0;
            HEAP8[($3_1 + -1 | 0) >> 0] = $1_1;
            if ($2_1 >>> 0 < 3 >>> 0) {
              break label$1;
            }
            HEAP8[($0_1 + 2 | 0) >> 0] = $1_1;
            HEAP8[($0_1 + 1 | 0) >> 0] = $1_1;
            HEAP8[($3_1 + -3 | 0) >> 0] = $1_1;
            HEAP8[($3_1 + -2 | 0) >> 0] = $1_1;
            if ($2_1 >>> 0 < 7 >>> 0) {
              break label$1;
            }
            HEAP8[($0_1 + 3 | 0) >> 0] = $1_1;
            HEAP8[($3_1 + -4 | 0) >> 0] = $1_1;
            if ($2_1 >>> 0 < 9 >>> 0) {
              break label$1;
            }
            $4_1 = (0 - $0_1 | 0) & 3 | 0;
            $3_1 = $0_1 + $4_1 | 0;
            $1_1 = Math_imul($1_1 & 255 | 0, 16843009);
            HEAP32[$3_1 >> 2] = $1_1;
            $4_1 = ($2_1 - $4_1 | 0) & -4 | 0;
            $2_1 = $3_1 + $4_1 | 0;
            HEAP32[($2_1 + -4 | 0) >> 2] = $1_1;
            if ($4_1 >>> 0 < 9 >>> 0) {
              break label$1;
            }
            HEAP32[($3_1 + 8 | 0) >> 2] = $1_1;
            HEAP32[($3_1 + 4 | 0) >> 2] = $1_1;
            HEAP32[($2_1 + -8 | 0) >> 2] = $1_1;
            HEAP32[($2_1 + -12 | 0) >> 2] = $1_1;
            if ($4_1 >>> 0 < 25 >>> 0) {
              break label$1;
            }
            HEAP32[($3_1 + 24 | 0) >> 2] = $1_1;
            HEAP32[($3_1 + 20 | 0) >> 2] = $1_1;
            HEAP32[($3_1 + 16 | 0) >> 2] = $1_1;
            HEAP32[($3_1 + 12 | 0) >> 2] = $1_1;
            HEAP32[($2_1 + -16 | 0) >> 2] = $1_1;
            HEAP32[($2_1 + -20 | 0) >> 2] = $1_1;
            HEAP32[($2_1 + -24 | 0) >> 2] = $1_1;
            HEAP32[($2_1 + -28 | 0) >> 2] = $1_1;
            $5_1 = $3_1 & 4 | 0 | 24 | 0;
            $2_1 = $4_1 - $5_1 | 0;
            if ($2_1 >>> 0 < 32 >>> 0) {
              break label$1;
            }
            i64toi32_i32$0 = 0;
            i64toi32_i32$1 = 1;
            i64toi32_i32$1 = __wasm_i64_mul($1_1 | 0, i64toi32_i32$0 | 0, 1 | 0, i64toi32_i32$1 | 0) | 0;
            i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
            $6_1 = i64toi32_i32$1;
            $6$hi = i64toi32_i32$0;
            $1_1 = $3_1 + $5_1 | 0;
            label$2: while (1) {
              i64toi32_i32$0 = $6$hi;
              i64toi32_i32$1 = $1_1;
              HEAP32[($1_1 + 24 | 0) >> 2] = $6_1;
              HEAP32[($1_1 + 28 | 0) >> 2] = i64toi32_i32$0;
              i64toi32_i32$1 = $1_1;
              HEAP32[($1_1 + 16 | 0) >> 2] = $6_1;
              HEAP32[($1_1 + 20 | 0) >> 2] = i64toi32_i32$0;
              i64toi32_i32$1 = $1_1;
              HEAP32[($1_1 + 8 | 0) >> 2] = $6_1;
              HEAP32[($1_1 + 12 | 0) >> 2] = i64toi32_i32$0;
              i64toi32_i32$1 = $1_1;
              HEAP32[$1_1 >> 2] = $6_1;
              HEAP32[($1_1 + 4 | 0) >> 2] = i64toi32_i32$0;
              $1_1 = $1_1 + 32 | 0;
              $2_1 = $2_1 + -32 | 0;
              if ($2_1 >>> 0 > 31 >>> 0) {
                continue label$2;
              }
              break label$2;
            };
          }
          return $0_1 | 0;
        }

        function $17() {
          return 99424 | 0;
        }

        function $18($0_1) {
          $0_1 = $0_1 | 0;
          return 1 | 0;
        }

        function $19($0_1) {
          $0_1 = $0_1 | 0;
        }

        function $20($0_1) {
          $0_1 = $0_1 | 0;
        }

        function $21($0_1) {
          $0_1 = $0_1 | 0;
        }

        function $22() {
          $20(99428 | 0);
          return 99432 | 0;
        }

        function $23() {
          $21(99428 | 0);
        }

        function $24($0_1) {
          $0_1 = $0_1 | 0;
          var $1_1 = 0;
          $1_1 = HEAP32[($0_1 + 72 | 0) >> 2] | 0;
          HEAP32[($0_1 + 72 | 0) >> 2] = $1_1 + -1 | 0 | $1_1 | 0;
          label$1: {
            $1_1 = HEAP32[$0_1 >> 2] | 0;
            if (!($1_1 & 8 | 0)) {
              break label$1;
            }
            HEAP32[$0_1 >> 2] = $1_1 | 32 | 0;
            return -1 | 0;
          }
          HEAP32[($0_1 + 4 | 0) >> 2] = 0;
          HEAP32[($0_1 + 8 | 0) >> 2] = 0;
          $1_1 = HEAP32[($0_1 + 44 | 0) >> 2] | 0;
          HEAP32[($0_1 + 28 | 0) >> 2] = $1_1;
          HEAP32[($0_1 + 20 | 0) >> 2] = $1_1;
          HEAP32[($0_1 + 16 | 0) >> 2] = $1_1 + (HEAP32[($0_1 + 48 | 0) >> 2] | 0) | 0;
          return 0 | 0;
        }

        function $25($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $3_1 = 0,$4_1 = 0;
          $3_1 = ($2_1 | 0) != (0 | 0);
          label$1: {
            label$2: {
              label$3: {
                if (!($0_1 & 3 | 0)) {
                  break label$3;
                }
                if (!$2_1) {
                  break label$3;
                }
                $4_1 = $1_1 & 255 | 0;
                label$4: while (1) {
                  if ((HEAPU8[$0_1 >> 0] | 0 | 0) == ($4_1 | 0)) {
                    break label$2;
                  }
                  $2_1 = $2_1 + -1 | 0;
                  $3_1 = ($2_1 | 0) != (0 | 0);
                  $0_1 = $0_1 + 1 | 0;
                  if (!($0_1 & 3 | 0)) {
                    break label$3;
                  }
                  if ($2_1) {
                    continue label$4;
                  }
                  break label$4;
                };
              }
              if (!$3_1) {
                break label$1;
              }
              label$5: {
                if ((HEAPU8[$0_1 >> 0] | 0 | 0) == ($1_1 & 255 | 0 | 0)) {
                  break label$5;
                }
                if ($2_1 >>> 0 < 4 >>> 0) {
                  break label$5;
                }
                $4_1 = Math_imul($1_1 & 255 | 0, 16843009);
                label$6: while (1) {
                  $3_1 = (HEAP32[$0_1 >> 2] | 0) ^ $4_1 | 0;
                  if ((($3_1 ^ -1 | 0) & ($3_1 + -16843009 | 0) | 0) & -2139062144 | 0) {
                    break label$2;
                  }
                  $0_1 = $0_1 + 4 | 0;
                  $2_1 = $2_1 + -4 | 0;
                  if ($2_1 >>> 0 > 3 >>> 0) {
                    continue label$6;
                  }
                  break label$6;
                };
              }
              if (!$2_1) {
                break label$1;
              }
            }
            $3_1 = $1_1 & 255 | 0;
            label$7: while (1) {
              label$8: {
                if ((HEAPU8[$0_1 >> 0] | 0 | 0) != ($3_1 | 0)) {
                  break label$8;
                }
                return $0_1 | 0;
              }
              $0_1 = $0_1 + 1 | 0;
              $2_1 = $2_1 + -1 | 0;
              if ($2_1) {
                continue label$7;
              }
              break label$7;
            };
          }
          return 0 | 0;
        }

        function $26($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var $2_1 = 0;
          $2_1 = $25($0_1 | 0, 0 | 0, $1_1 | 0) | 0;
          return ($2_1 ? $2_1 - $0_1 | 0 : $1_1) | 0;
        }

        function $27($0_1, $1_1) {
          $0_1 = +$0_1;
          $1_1 = $1_1 | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,i64toi32_i32$3 = 0,$3_1 = 0,i64toi32_i32$2 = 0,i64toi32_i32$4 = 0,$2_1 = 0,$10_1 = 0,$2$hi = 0;
          label$1: {
            wasm2js_scratch_store_f64(+$0_1);
            i64toi32_i32$0 = wasm2js_scratch_load_i32(1 | 0) | 0;
            $2_1 = wasm2js_scratch_load_i32(0 | 0) | 0;
            $2$hi = i64toi32_i32$0;
            i64toi32_i32$2 = $2_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$3 = 52;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = 0;
              $10_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
            } else {
              i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              $10_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
            }
            $3_1 = $10_1 & 2047 | 0;
            if (($3_1 | 0) == (2047 | 0)) {
              break label$1;
            }
            label$2: {
              if ($3_1) {
                break label$2;
              }
              label$3: {
                label$4: {
                  if ($0_1 != 0.0) {
                    break label$4;
                  }
                  $3_1 = 0;
                  break label$3;
                }
                $0_1 = +$27(+($0_1 * 18446744073709551615.0), $1_1 | 0);
                $3_1 = (HEAP32[$1_1 >> 2] | 0) + -64 | 0;
              }
              HEAP32[$1_1 >> 2] = $3_1;
              return +$0_1;
            }
            HEAP32[$1_1 >> 2] = $3_1 + -1022 | 0;
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$0 = $2_1;
            i64toi32_i32$2 = -2146435073;
            i64toi32_i32$3 = -1;
            i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
            i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$3 | 0;
            i64toi32_i32$0 = 1071644672;
            i64toi32_i32$3 = 0;
            i64toi32_i32$0 = i64toi32_i32$2 | i64toi32_i32$0 | 0;
            wasm2js_scratch_store_i32(0 | 0, i64toi32_i32$1 | i64toi32_i32$3 | 0 | 0);
            wasm2js_scratch_store_i32(1 | 0, i64toi32_i32$0 | 0);
            $0_1 = +wasm2js_scratch_load_f64();
          }
          return +$0_1;
        }

        function $28($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $4_1 = 0,$3_1 = 0,$5_1 = 0;
          label$1: {
            if ($2_1 >>> 0 < 512 >>> 0) {
              break label$1;
            }
            fimport$0($0_1 | 0, $1_1 | 0, $2_1 | 0);
            return $0_1 | 0;
          }
          $3_1 = $0_1 + $2_1 | 0;
          label$2: {
            label$3: {
              if (($1_1 ^ $0_1 | 0) & 3 | 0) {
                break label$3;
              }
              label$4: {
                label$5: {
                  if ($0_1 & 3 | 0) {
                    break label$5;
                  }
                  $2_1 = $0_1;
                  break label$4;
                }
                label$6: {
                  if ($2_1) {
                    break label$6;
                  }
                  $2_1 = $0_1;
                  break label$4;
                }
                $2_1 = $0_1;
                label$7: while (1) {
                  HEAP8[$2_1 >> 0] = HEAPU8[$1_1 >> 0] | 0;
                  $1_1 = $1_1 + 1 | 0;
                  $2_1 = $2_1 + 1 | 0;
                  if (!($2_1 & 3 | 0)) {
                    break label$4;
                  }
                  if ($2_1 >>> 0 < $3_1 >>> 0) {
                    continue label$7;
                  }
                  break label$7;
                };
              }
              label$8: {
                $4_1 = $3_1 & -4 | 0;
                if ($4_1 >>> 0 < 64 >>> 0) {
                  break label$8;
                }
                $5_1 = $4_1 + -64 | 0;
                if ($2_1 >>> 0 > $5_1 >>> 0) {
                  break label$8;
                }
                label$9: while (1) {
                  HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2] | 0;
                  HEAP32[($2_1 + 4 | 0) >> 2] = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 8 | 0) >> 2] = HEAP32[($1_1 + 8 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 12 | 0) >> 2] = HEAP32[($1_1 + 12 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 16 | 0) >> 2] = HEAP32[($1_1 + 16 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 20 | 0) >> 2] = HEAP32[($1_1 + 20 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 24 | 0) >> 2] = HEAP32[($1_1 + 24 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 28 | 0) >> 2] = HEAP32[($1_1 + 28 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 32 | 0) >> 2] = HEAP32[($1_1 + 32 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 36 | 0) >> 2] = HEAP32[($1_1 + 36 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 40 | 0) >> 2] = HEAP32[($1_1 + 40 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 44 | 0) >> 2] = HEAP32[($1_1 + 44 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 48 | 0) >> 2] = HEAP32[($1_1 + 48 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 52 | 0) >> 2] = HEAP32[($1_1 + 52 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 56 | 0) >> 2] = HEAP32[($1_1 + 56 | 0) >> 2] | 0;
                  HEAP32[($2_1 + 60 | 0) >> 2] = HEAP32[($1_1 + 60 | 0) >> 2] | 0;
                  $1_1 = $1_1 + 64 | 0;
                  $2_1 = $2_1 + 64 | 0;
                  if ($2_1 >>> 0 <= $5_1 >>> 0) {
                    continue label$9;
                  }
                  break label$9;
                };
              }
              if ($2_1 >>> 0 >= $4_1 >>> 0) {
                break label$2;
              }
              label$10: while (1) {
                HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2] | 0;
                $1_1 = $1_1 + 4 | 0;
                $2_1 = $2_1 + 4 | 0;
                if ($2_1 >>> 0 < $4_1 >>> 0) {
                  continue label$10;
                }
                break label$2;
              };
            }
            label$11: {
              if ($3_1 >>> 0 >= 4 >>> 0) {
                break label$11;
              }
              $2_1 = $0_1;
              break label$2;
            }
            label$12: {
              $4_1 = $3_1 + -4 | 0;
              if ($4_1 >>> 0 >= $0_1 >>> 0) {
                break label$12;
              }
              $2_1 = $0_1;
              break label$2;
            }
            $2_1 = $0_1;
            label$13: while (1) {
              HEAP8[$2_1 >> 0] = HEAPU8[$1_1 >> 0] | 0;
              HEAP8[($2_1 + 1 | 0) >> 0] = HEAPU8[($1_1 + 1 | 0) >> 0] | 0;
              HEAP8[($2_1 + 2 | 0) >> 0] = HEAPU8[($1_1 + 2 | 0) >> 0] | 0;
              HEAP8[($2_1 + 3 | 0) >> 0] = HEAPU8[($1_1 + 3 | 0) >> 0] | 0;
              $1_1 = $1_1 + 4 | 0;
              $2_1 = $2_1 + 4 | 0;
              if ($2_1 >>> 0 <= $4_1 >>> 0) {
                continue label$13;
              }
              break label$13;
            };
          }
          label$14: {
            if ($2_1 >>> 0 >= $3_1 >>> 0) {
              break label$14;
            }
            label$15: while (1) {
              HEAP8[$2_1 >> 0] = HEAPU8[$1_1 >> 0] | 0;
              $1_1 = $1_1 + 1 | 0;
              $2_1 = $2_1 + 1 | 0;
              if (($2_1 | 0) != ($3_1 | 0)) {
                continue label$15;
              }
              break label$15;
            };
          }
          return $0_1 | 0;
        }

        function $29($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $3_1 = 0,$4_1 = 0,$5_1 = 0;
          label$1: {
            label$2: {
              $3_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;
              if ($3_1) {
                break label$2;
              }
              $4_1 = 0;
              if ($24($2_1 | 0) | 0) {
                break label$1;
              }
              $3_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;
            }
            label$3: {
              $4_1 = HEAP32[($2_1 + 20 | 0) >> 2] | 0;
              if (($3_1 - $4_1 | 0) >>> 0 >= $1_1 >>> 0) {
                break label$3;
              }
              return FUNCTION_TABLE[HEAP32[($2_1 + 36 | 0) >> 2] | 0 | 0]($2_1, $0_1, $1_1) | 0 | 0;
            }
            label$4: {
              label$5: {
                if ((HEAP32[($2_1 + 80 | 0) >> 2] | 0 | 0) < (0 | 0)) {
                  break label$5;
                }
                if (!$1_1) {
                  break label$5;
                }
                $3_1 = $1_1;
                label$6: {
                  label$7: while (1) {
                    $5_1 = $0_1 + $3_1 | 0;
                    if ((HEAPU8[($5_1 + -1 | 0) >> 0] | 0 | 0) == (10 | 0)) {
                      break label$6;
                    }
                    $3_1 = $3_1 + -1 | 0;
                    if (!$3_1) {
                      break label$5;
                    }
                    continue label$7;
                  };
                }
                $4_1 = FUNCTION_TABLE[HEAP32[($2_1 + 36 | 0) >> 2] | 0 | 0]($2_1, $0_1, $3_1) | 0;
                if ($4_1 >>> 0 < $3_1 >>> 0) {
                  break label$1;
                }
                $1_1 = $1_1 - $3_1 | 0;
                $4_1 = HEAP32[($2_1 + 20 | 0) >> 2] | 0;
                break label$4;
              }
              $5_1 = $0_1;
              $3_1 = 0;
            }
            $28($4_1 | 0, $5_1 | 0, $1_1 | 0) | 0;
            HEAP32[($2_1 + 20 | 0) >> 2] = (HEAP32[($2_1 + 20 | 0) >> 2] | 0) + $1_1 | 0;
            $4_1 = $3_1 + $1_1 | 0;
          }
          return $4_1 | 0;
        }

        function $30($0_1, $1_1, $2_1, $3_1, $4_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          $4_1 = $4_1 | 0;
          var $5_1 = 0,i64toi32_i32$0 = 0,$8_1 = 0,$6_1 = 0,$7_1 = 0;
          $5_1 = global$0 - 208 | 0;
          global$0 = $5_1;
          HEAP32[($5_1 + 204 | 0) >> 2] = $2_1;
          $16($5_1 + 160 | 0 | 0, 0 | 0, 40 | 0) | 0;
          HEAP32[($5_1 + 200 | 0) >> 2] = HEAP32[($5_1 + 204 | 0) >> 2] | 0;
          label$1: {
            label$2: {
              if (($31(0 | 0, $1_1 | 0, $5_1 + 200 | 0 | 0, $5_1 + 80 | 0 | 0, $5_1 + 160 | 0 | 0, $3_1 | 0, $4_1 | 0) | 0 | 0) >= (0 | 0)) {
                break label$2;
              }
              $4_1 = -1;
              break label$1;
            }
            label$3: {
              label$4: {
                if ((HEAP32[($0_1 + 76 | 0) >> 2] | 0 | 0) >= (0 | 0)) {
                  break label$4;
                }
                $6_1 = 1;
                break label$3;
              }
              $6_1 = !($18($0_1 | 0) | 0);
            }
            $7_1 = HEAP32[$0_1 >> 2] | 0;
            HEAP32[$0_1 >> 2] = $7_1 & -33 | 0;
            label$5: {
              label$6: {
                label$7: {
                  label$8: {
                    if (HEAP32[($0_1 + 48 | 0) >> 2] | 0) {
                      break label$8;
                    }
                    HEAP32[($0_1 + 48 | 0) >> 2] = 80;
                    HEAP32[($0_1 + 28 | 0) >> 2] = 0;
                    i64toi32_i32$0 = 0;
                    HEAP32[($0_1 + 16 | 0) >> 2] = 0;
                    HEAP32[($0_1 + 20 | 0) >> 2] = i64toi32_i32$0;
                    $8_1 = HEAP32[($0_1 + 44 | 0) >> 2] | 0;
                    HEAP32[($0_1 + 44 | 0) >> 2] = $5_1;
                    break label$7;
                  }
                  $8_1 = 0;
                  if (HEAP32[($0_1 + 16 | 0) >> 2] | 0) {
                    break label$6;
                  }
                }
                $2_1 = -1;
                if ($24($0_1 | 0) | 0) {
                  break label$5;
                }
              }
              $2_1 = $31($0_1 | 0, $1_1 | 0, $5_1 + 200 | 0 | 0, $5_1 + 80 | 0 | 0, $5_1 + 160 | 0 | 0, $3_1 | 0, $4_1 | 0) | 0;
            }
            $4_1 = $7_1 & 32 | 0;
            label$9: {
              if (!$8_1) {
                break label$9;
              }
              FUNCTION_TABLE[HEAP32[($0_1 + 36 | 0) >> 2] | 0 | 0]($0_1, 0, 0) | 0;
              HEAP32[($0_1 + 48 | 0) >> 2] = 0;
              HEAP32[($0_1 + 44 | 0) >> 2] = $8_1;
              HEAP32[($0_1 + 28 | 0) >> 2] = 0;
              $3_1 = HEAP32[($0_1 + 20 | 0) >> 2] | 0;
              i64toi32_i32$0 = 0;
              HEAP32[($0_1 + 16 | 0) >> 2] = 0;
              HEAP32[($0_1 + 20 | 0) >> 2] = i64toi32_i32$0;
              $2_1 = $3_1 ? $2_1 : -1;
            }
            $3_1 = HEAP32[$0_1 >> 2] | 0;
            HEAP32[$0_1 >> 2] = $3_1 | $4_1 | 0;
            $4_1 = $3_1 & 32 | 0 ? -1 : $2_1;
            if ($6_1) {
              break label$1;
            }
            $19($0_1 | 0);
          }
          global$0 = $5_1 + 208 | 0;
          return $4_1 | 0;
        }

        function $31($0_1, $1_1, $2_1, $3_1, $4_1, $5_1, $6_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          $4_1 = $4_1 | 0;
          $5_1 = $5_1 | 0;
          $6_1 = $6_1 | 0;
          var $12_1 = 0,$7_1 = 0,$15_1 = 0,$20_1 = 0,i64toi32_i32$1 = 0,$17_1 = 0,$14_1 = 0,$13_1 = 0,i64toi32_i32$2 = 0,i64toi32_i32$0 = 0,$11_1 = 0,$16_1 = 0,$19_1 = 0,$22_1 = 0,i64toi32_i32$3 = 0,i64toi32_i32$5 = 0,$9_1 = 0,$18_1 = 0,$24_1 = 0,$10_1 = 0,$25_1 = 0,$25$hi = 0,$21_1 = 0,$23_1 = 0,$33_1 = 0,$34_1 = 0,$35_1 = 0,$8_1 = 0,$266 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $7_1 = global$0 - 80 | 0;
          global$0 = $7_1;
          HEAP32[($7_1 + 76 | 0) >> 2] = $1_1;
          $8_1 = $7_1 + 55 | 0;
          $9_1 = $7_1 + 56 | 0;
          $10_1 = 0;
          $11_1 = 0;
          label$1: {
            label$2: {
              label$3: {
                label$4: {
                  label$5: while (1) {
                    $12_1 = 0;
                    label$6: while (1) {
                      $13_1 = $1_1;
                      if (($12_1 | 0) > ($11_1 ^ 2147483647 | 0 | 0)) {
                        break label$4;
                      }
                      $11_1 = $12_1 + $11_1 | 0;
                      $12_1 = $1_1;
                      label$7: {
                        label$8: {
                          label$9: {
                            label$10: {
                              label$11: {
                                $14_1 = HEAPU8[$12_1 >> 0] | 0;
                                if (!$14_1) {
                                  break label$11;
                                }
                                label$12: while (1) {
                                  label$13: {
                                    label$14: {
                                      label$15: {
                                        $14_1 = $14_1 & 255 | 0;
                                        if ($14_1) {
                                          break label$15;
                                        }
                                        $1_1 = $12_1;
                                        break label$14;
                                      }
                                      if (($14_1 | 0) != (37 | 0)) {
                                        break label$13;
                                      }
                                      $14_1 = $12_1;
                                      label$16: while (1) {
                                        label$17: {
                                          if ((HEAPU8[($14_1 + 1 | 0) >> 0] | 0 | 0) == (37 | 0)) {
                                            break label$17;
                                          }
                                          $1_1 = $14_1;
                                          break label$14;
                                        }
                                        $12_1 = $12_1 + 1 | 0;
                                        $15_1 = HEAPU8[($14_1 + 2 | 0) >> 0] | 0;
                                        $1_1 = $14_1 + 2 | 0;
                                        $14_1 = $1_1;
                                        if (($15_1 | 0) == (37 | 0)) {
                                          continue label$16;
                                        }
                                        break label$16;
                                      };
                                    }
                                    $12_1 = $12_1 - $13_1 | 0;
                                    $14_1 = $11_1 ^ 2147483647 | 0;
                                    if (($12_1 | 0) > ($14_1 | 0)) {
                                      break label$4;
                                    }
                                    label$18: {
                                      if (!$0_1) {
                                        break label$18;
                                      }
                                      $32($0_1 | 0, $13_1 | 0, $12_1 | 0);
                                    }
                                    if ($12_1) {
                                      continue label$6;
                                    }
                                    HEAP32[($7_1 + 76 | 0) >> 2] = $1_1;
                                    $12_1 = $1_1 + 1 | 0;
                                    $16_1 = -1;
                                    label$19: {
                                      $15_1 = (HEAP8[($1_1 + 1 | 0) >> 0] | 0) + -48 | 0;
                                      if ($15_1 >>> 0 > 9 >>> 0) {
                                        break label$19;
                                      }
                                      if ((HEAPU8[($1_1 + 2 | 0) >> 0] | 0 | 0) != (36 | 0)) {
                                        break label$19;
                                      }
                                      $12_1 = $1_1 + 3 | 0;
                                      $10_1 = 1;
                                      $16_1 = $15_1;
                                    }
                                    HEAP32[($7_1 + 76 | 0) >> 2] = $12_1;
                                    $17_1 = 0;
                                    label$20: {
                                      label$21: {
                                        $18_1 = HEAP8[$12_1 >> 0] | 0;
                                        $1_1 = $18_1 + -32 | 0;
                                        if ($1_1 >>> 0 <= 31 >>> 0) {
                                          break label$21;
                                        }
                                        $15_1 = $12_1;
                                        break label$20;
                                      }
                                      $17_1 = 0;
                                      $15_1 = $12_1;
                                      $1_1 = 1 << $1_1 | 0;
                                      if (!($1_1 & 75913 | 0)) {
                                        break label$20;
                                      }
                                      label$22: while (1) {
                                        $15_1 = $12_1 + 1 | 0;
                                        HEAP32[($7_1 + 76 | 0) >> 2] = $15_1;
                                        $17_1 = $1_1 | $17_1 | 0;
                                        $18_1 = HEAP8[($12_1 + 1 | 0) >> 0] | 0;
                                        $1_1 = $18_1 + -32 | 0;
                                        if ($1_1 >>> 0 >= 32 >>> 0) {
                                          break label$20;
                                        }
                                        $12_1 = $15_1;
                                        $1_1 = 1 << $1_1 | 0;
                                        if ($1_1 & 75913 | 0) {
                                          continue label$22;
                                        }
                                        break label$22;
                                      };
                                    }
                                    label$23: {
                                      label$24: {
                                        if (($18_1 | 0) != (42 | 0)) {
                                          break label$24;
                                        }
                                        label$25: {
                                          label$26: {
                                            $12_1 = (HEAP8[($15_1 + 1 | 0) >> 0] | 0) + -48 | 0;
                                            if ($12_1 >>> 0 > 9 >>> 0) {
                                              break label$26;
                                            }
                                            if ((HEAPU8[($15_1 + 2 | 0) >> 0] | 0 | 0) != (36 | 0)) {
                                              break label$26;
                                            }
                                            label$27: {
                                              label$28: {
                                                if ($0_1) {
                                                  break label$28;
                                                }
                                                HEAP32[($4_1 + ($12_1 << 2 | 0) | 0) >> 2] = 10;
                                                $19_1 = 0;
                                                break label$27;
                                              }
                                              $19_1 = HEAP32[($3_1 + ($12_1 << 3 | 0) | 0) >> 2] | 0;
                                            }
                                            $1_1 = $15_1 + 3 | 0;
                                            $10_1 = 1;
                                            break label$25;
                                          }
                                          if ($10_1) {
                                            break label$10;
                                          }
                                          $1_1 = $15_1 + 1 | 0;
                                          label$29: {
                                            if ($0_1) {
                                              break label$29;
                                            }
                                            HEAP32[($7_1 + 76 | 0) >> 2] = $1_1;
                                            $10_1 = 0;
                                            $19_1 = 0;
                                            break label$23;
                                          }
                                          $12_1 = HEAP32[$2_1 >> 2] | 0;
                                          HEAP32[$2_1 >> 2] = $12_1 + 4 | 0;
                                          $19_1 = HEAP32[$12_1 >> 2] | 0;
                                          $10_1 = 0;
                                        }
                                        HEAP32[($7_1 + 76 | 0) >> 2] = $1_1;
                                        if (($19_1 | 0) > (-1 | 0)) {
                                          break label$23;
                                        }
                                        $19_1 = 0 - $19_1 | 0;
                                        $17_1 = $17_1 | 8192 | 0;
                                        break label$23;
                                      }
                                      $19_1 = $33($7_1 + 76 | 0 | 0) | 0;
                                      if (($19_1 | 0) < (0 | 0)) {
                                        break label$4;
                                      }
                                      $1_1 = HEAP32[($7_1 + 76 | 0) >> 2] | 0;
                                    }
                                    $12_1 = 0;
                                    $20_1 = -1;
                                    label$30: {
                                      label$31: {
                                        if ((HEAPU8[$1_1 >> 0] | 0 | 0) == (46 | 0)) {
                                          break label$31;
                                        }
                                        $21_1 = 0;
                                        break label$30;
                                      }
                                      label$32: {
                                        if ((HEAPU8[($1_1 + 1 | 0) >> 0] | 0 | 0) != (42 | 0)) {
                                          break label$32;
                                        }
                                        label$33: {
                                          label$34: {
                                            $15_1 = (HEAP8[($1_1 + 2 | 0) >> 0] | 0) + -48 | 0;
                                            if ($15_1 >>> 0 > 9 >>> 0) {
                                              break label$34;
                                            }
                                            if ((HEAPU8[($1_1 + 3 | 0) >> 0] | 0 | 0) != (36 | 0)) {
                                              break label$34;
                                            }
                                            label$35: {
                                              label$36: {
                                                if ($0_1) {
                                                  break label$36;
                                                }
                                                HEAP32[($4_1 + ($15_1 << 2 | 0) | 0) >> 2] = 10;
                                                $20_1 = 0;
                                                break label$35;
                                              }
                                              $20_1 = HEAP32[($3_1 + ($15_1 << 3 | 0) | 0) >> 2] | 0;
                                            }
                                            $1_1 = $1_1 + 4 | 0;
                                            break label$33;
                                          }
                                          if ($10_1) {
                                            break label$10;
                                          }
                                          $1_1 = $1_1 + 2 | 0;
                                          label$37: {
                                            if ($0_1) {
                                              break label$37;
                                            }
                                            $20_1 = 0;
                                            break label$33;
                                          }
                                          $15_1 = HEAP32[$2_1 >> 2] | 0;
                                          HEAP32[$2_1 >> 2] = $15_1 + 4 | 0;
                                          $20_1 = HEAP32[$15_1 >> 2] | 0;
                                        }
                                        HEAP32[($7_1 + 76 | 0) >> 2] = $1_1;
                                        $21_1 = ($20_1 | 0) > (-1 | 0);
                                        break label$30;
                                      }
                                      HEAP32[($7_1 + 76 | 0) >> 2] = $1_1 + 1 | 0;
                                      $21_1 = 1;
                                      $20_1 = $33($7_1 + 76 | 0 | 0) | 0;
                                      $1_1 = HEAP32[($7_1 + 76 | 0) >> 2] | 0;
                                    }
                                    label$38: while (1) {
                                      $15_1 = $12_1;
                                      $22_1 = 28;
                                      $18_1 = $1_1;
                                      $12_1 = HEAP8[$1_1 >> 0] | 0;
                                      if (($12_1 + -123 | 0) >>> 0 < -58 >>> 0) {
                                        break label$3;
                                      }
                                      $1_1 = $1_1 + 1 | 0;
                                      $12_1 = HEAPU8[(($12_1 + Math_imul($15_1, 58) | 0) + 65551 | 0) >> 0] | 0;
                                      if (($12_1 + -1 | 0) >>> 0 < 8 >>> 0) {
                                        continue label$38;
                                      }
                                      break label$38;
                                    };
                                    HEAP32[($7_1 + 76 | 0) >> 2] = $1_1;
                                    label$39: {
                                      label$40: {
                                        if (($12_1 | 0) == (27 | 0)) {
                                          break label$40;
                                        }
                                        if (!$12_1) {
                                          break label$3;
                                        }
                                        label$41: {
                                          if (($16_1 | 0) < (0 | 0)) {
                                            break label$41;
                                          }
                                          label$42: {
                                            if ($0_1) {
                                              break label$42;
                                            }
                                            HEAP32[($4_1 + ($16_1 << 2 | 0) | 0) >> 2] = $12_1;
                                            continue label$5;
                                          }
                                          i64toi32_i32$2 = $3_1 + ($16_1 << 3 | 0) | 0;
                                          i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                                          i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                                          $266 = i64toi32_i32$0;
                                          i64toi32_i32$0 = $7_1;
                                          HEAP32[($7_1 + 64 | 0) >> 2] = $266;
                                          HEAP32[($7_1 + 68 | 0) >> 2] = i64toi32_i32$1;
                                          break label$39;
                                        }
                                        if (!$0_1) {
                                          break label$7;
                                        }
                                        $34($7_1 + 64 | 0 | 0, $12_1 | 0, $2_1 | 0, $6_1 | 0);
                                        break label$39;
                                      }
                                      if (($16_1 | 0) > (-1 | 0)) {
                                        break label$3;
                                      }
                                      $12_1 = 0;
                                      if (!$0_1) {
                                        continue label$6;
                                      }
                                    }
                                    if ((HEAPU8[$0_1 >> 0] | 0) & 32 | 0) {
                                      break label$2;
                                    }
                                    $23_1 = $17_1 & -65537 | 0;
                                    $17_1 = $17_1 & 8192 | 0 ? $23_1 : $17_1;
                                    $16_1 = 0;
                                    $24_1 = 65545;
                                    $22_1 = $9_1;
                                    label$43: {
                                      label$44: {
                                        label$45: {
                                          label$46: {
                                            label$47: {
                                              label$48: {
                                                label$49: {
                                                  label$50: {
                                                    label$51: {
                                                      label$52: {
                                                        label$53: {
                                                          label$54: {
                                                            label$55: {
                                                              label$56: {
                                                                label$57: {
                                                                  label$58: {
                                                                    $12_1 = HEAP8[$18_1 >> 0] | 0;
                                                                    $12_1 = $15_1 ? ($12_1 & 15 | 0 | 0) == (3 | 0) ? $12_1 & -45 | 0 : $12_1 : $12_1;
                                                                    switch ($12_1 + -88 | 0 | 0) {
                                                                      case 11:
                                                                        break label$43;
                                                                      case 9:
                                                                      case 13:
                                                                      case 14:
                                                                      case 15:
                                                                        break label$44;
                                                                      case 27:
                                                                        break label$49;
                                                                      case 12:
                                                                      case 17:
                                                                        break label$52;
                                                                      case 23:
                                                                        break label$53;
                                                                      case 0:
                                                                      case 32:
                                                                        break label$54;
                                                                      case 24:
                                                                        break label$55;
                                                                      case 22:
                                                                        break label$56;
                                                                      case 29:
                                                                        break label$57;
                                                                      case 1:
                                                                      case 2:
                                                                      case 3:
                                                                      case 4:
                                                                      case 5:
                                                                      case 6:
                                                                      case 7:
                                                                      case 8:
                                                                      case 10:
                                                                      case 16:
                                                                      case 18:
                                                                      case 19:
                                                                      case 20:
                                                                      case 21:
                                                                      case 25:
                                                                      case 26:
                                                                      case 28:
                                                                      case 30:
                                                                      case 31:
                                                                        break label$8;
                                                                      default:
                                                                        break label$58;
                                                                    };
                                                                  }
                                                                  $22_1 = $9_1;
                                                                  label$59: {
                                                                    switch ($12_1 + -65 | 0 | 0) {
                                                                      case 0:
                                                                      case 4:
                                                                      case 5:
                                                                      case 6:
                                                                        break label$44;
                                                                      case 2:
                                                                        break label$47;
                                                                      case 1:
                                                                      case 3:
                                                                        break label$8;
                                                                      default:
                                                                        break label$59;
                                                                    };
                                                                  }
                                                                  if (($12_1 | 0) == (83 | 0)) {
                                                                    break label$48;
                                                                  }
                                                                  break label$9;
                                                                }
                                                                $16_1 = 0;
                                                                $24_1 = 65545;
                                                                i64toi32_i32$2 = $7_1;
                                                                i64toi32_i32$1 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                                                i64toi32_i32$0 = HEAP32[($7_1 + 68 | 0) >> 2] | 0;
                                                                $25_1 = i64toi32_i32$1;
                                                                $25$hi = i64toi32_i32$0;
                                                                break label$51;
                                                              }
                                                              $12_1 = 0;
                                                              label$60: {
                                                                switch ($15_1 & 255 | 0 | 0) {
                                                                  case 0:
                                                                    HEAP32[(HEAP32[($7_1 + 64 | 0) >> 2] | 0) >> 2] = $11_1;
                                                                    continue label$6;
                                                                  case 1:
                                                                    HEAP32[(HEAP32[($7_1 + 64 | 0) >> 2] | 0) >> 2] = $11_1;
                                                                    continue label$6;
                                                                  case 2:
                                                                    i64toi32_i32$1 = $11_1;
                                                                    i64toi32_i32$0 = i64toi32_i32$1 >> 31 | 0;
                                                                    i64toi32_i32$1 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                                                    HEAP32[i64toi32_i32$1 >> 2] = $11_1;
                                                                    HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
                                                                    continue label$6;
                                                                  case 3:
                                                                    HEAP16[(HEAP32[($7_1 + 64 | 0) >> 2] | 0) >> 1] = $11_1;
                                                                    continue label$6;
                                                                  case 4:
                                                                    HEAP8[(HEAP32[($7_1 + 64 | 0) >> 2] | 0) >> 0] = $11_1;
                                                                    continue label$6;
                                                                  case 6:
                                                                    HEAP32[(HEAP32[($7_1 + 64 | 0) >> 2] | 0) >> 2] = $11_1;
                                                                    continue label$6;
                                                                  case 7:
                                                                    break label$60;
                                                                  default:
                                                                    continue label$6;
                                                                };
                                                              }
                                                              i64toi32_i32$1 = $11_1;
                                                              i64toi32_i32$0 = i64toi32_i32$1 >> 31 | 0;
                                                              i64toi32_i32$1 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                                              HEAP32[i64toi32_i32$1 >> 2] = $11_1;
                                                              HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
                                                              continue label$6;
                                                            }
                                                            $20_1 = $20_1 >>> 0 > 8 >>> 0 ? $20_1 : 8;
                                                            $17_1 = $17_1 | 8 | 0;
                                                            $12_1 = 120;
                                                          }
                                                          i64toi32_i32$2 = $7_1;
                                                          i64toi32_i32$0 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                                          i64toi32_i32$1 = HEAP32[($7_1 + 68 | 0) >> 2] | 0;
                                                          $13_1 = $35(i64toi32_i32$0 | 0, i64toi32_i32$1 | 0, $9_1 | 0, $12_1 & 32 | 0 | 0) | 0;
                                                          $16_1 = 0;
                                                          $24_1 = 65545;
                                                          i64toi32_i32$2 = $7_1;
                                                          i64toi32_i32$1 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                                          i64toi32_i32$0 = HEAP32[($7_1 + 68 | 0) >> 2] | 0;
                                                          if (!(i64toi32_i32$1 | i64toi32_i32$0 | 0)) {
                                                            break label$50;
                                                          }
                                                          if (!($17_1 & 8 | 0)) {
                                                            break label$50;
                                                          }
                                                          $24_1 = ($12_1 >>> 4 | 0) + 65545 | 0;
                                                          $16_1 = 2;
                                                          break label$50;
                                                        }
                                                        $16_1 = 0;
                                                        $24_1 = 65545;
                                                        i64toi32_i32$2 = $7_1;
                                                        i64toi32_i32$0 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                                        i64toi32_i32$1 = HEAP32[($7_1 + 68 | 0) >> 2] | 0;
                                                        $13_1 = $36(i64toi32_i32$0 | 0, i64toi32_i32$1 | 0, $9_1 | 0) | 0;
                                                        if (!($17_1 & 8 | 0)) {
                                                          break label$50;
                                                        }
                                                        $12_1 = $9_1 - $13_1 | 0;
                                                        $20_1 = ($20_1 | 0) > ($12_1 | 0) ? $20_1 : $12_1 + 1 | 0;
                                                        break label$50;
                                                      }
                                                      label$67: {
                                                        i64toi32_i32$2 = $7_1;
                                                        i64toi32_i32$1 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                                        i64toi32_i32$0 = HEAP32[($7_1 + 68 | 0) >> 2] | 0;
                                                        $25_1 = i64toi32_i32$1;
                                                        $25$hi = i64toi32_i32$0;
                                                        i64toi32_i32$2 = i64toi32_i32$1;
                                                        i64toi32_i32$1 = -1;
                                                        i64toi32_i32$3 = -1;
                                                        if ((i64toi32_i32$0 | 0) > (i64toi32_i32$1 | 0)) {
                                                          $33_1 = 1;
                                                        } else {
                                                          if ((i64toi32_i32$0 | 0) >= (i64toi32_i32$1 | 0)) {
                                                            if (i64toi32_i32$2 >>> 0 <= i64toi32_i32$3 >>> 0) {
                                                              $34_1 = 0;
                                                            } else {
                                                              $34_1 = 1;
                                                            }
                                                            $35_1 = $34_1;
                                                          } else {
                                                            $35_1 = 0;
                                                          }
                                                          $33_1 = $35_1;
                                                        }
                                                        if ($33_1) {
                                                          break label$67;
                                                        }
                                                        i64toi32_i32$2 = $25$hi;
                                                        i64toi32_i32$2 = 0;
                                                        i64toi32_i32$3 = 0;
                                                        i64toi32_i32$0 = $25$hi;
                                                        i64toi32_i32$1 = $25_1;
                                                        i64toi32_i32$5 = (i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0) + i64toi32_i32$0 | 0;
                                                        i64toi32_i32$5 = i64toi32_i32$2 - i64toi32_i32$5 | 0;
                                                        $25_1 = i64toi32_i32$3 - i64toi32_i32$1 | 0;
                                                        $25$hi = i64toi32_i32$5;
                                                        i64toi32_i32$3 = $7_1;
                                                        HEAP32[($7_1 + 64 | 0) >> 2] = $25_1;
                                                        HEAP32[($7_1 + 68 | 0) >> 2] = i64toi32_i32$5;
                                                        $16_1 = 1;
                                                        $24_1 = 65545;
                                                        break label$51;
                                                      }
                                                      label$68: {
                                                        if (!($17_1 & 2048 | 0)) {
                                                          break label$68;
                                                        }
                                                        $16_1 = 1;
                                                        $24_1 = 65546;
                                                        break label$51;
                                                      }
                                                      $16_1 = $17_1 & 1 | 0;
                                                      $24_1 = $16_1 ? 65547 : 65545;
                                                    }
                                                    i64toi32_i32$5 = $25$hi;
                                                    $13_1 = $37($25_1 | 0, i64toi32_i32$5 | 0, $9_1 | 0) | 0;
                                                  }
                                                  if ($21_1 & ($20_1 | 0) < (0 | 0) | 0) {
                                                    break label$4;
                                                  }
                                                  $17_1 = $21_1 ? $17_1 & -65537 | 0 : $17_1;
                                                  label$69: {
                                                    i64toi32_i32$2 = $7_1;
                                                    i64toi32_i32$5 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                                    i64toi32_i32$3 = HEAP32[($7_1 + 68 | 0) >> 2] | 0;
                                                    $25_1 = i64toi32_i32$5;
                                                    $25$hi = i64toi32_i32$3;
                                                    i64toi32_i32$2 = i64toi32_i32$5;
                                                    i64toi32_i32$5 = 0;
                                                    i64toi32_i32$1 = 0;
                                                    if ((i64toi32_i32$2 | 0) != (i64toi32_i32$1 | 0) | (i64toi32_i32$3 | 0) != (i64toi32_i32$5 | 0) | 0) {
                                                      break label$69;
                                                    }
                                                    if ($20_1) {
                                                      break label$69;
                                                    }
                                                    $13_1 = $9_1;
                                                    $22_1 = $13_1;
                                                    $20_1 = 0;
                                                    break label$8;
                                                  }
                                                  i64toi32_i32$2 = $25$hi;
                                                  $12_1 = ($9_1 - $13_1 | 0) + !($25_1 | i64toi32_i32$2 | 0) | 0;
                                                  $20_1 = ($20_1 | 0) > ($12_1 | 0) ? $20_1 : $12_1;
                                                  break label$9;
                                                }
                                                $12_1 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                                $13_1 = $12_1 ? $12_1 : 65597;
                                                $12_1 = $26($13_1 | 0, ($20_1 >>> 0 < 2147483647 >>> 0 ? $20_1 : 2147483647) | 0) | 0;
                                                $22_1 = $13_1 + $12_1 | 0;
                                                label$70: {
                                                  if (($20_1 | 0) <= (-1 | 0)) {
                                                    break label$70;
                                                  }
                                                  $17_1 = $23_1;
                                                  $20_1 = $12_1;
                                                  break label$8;
                                                }
                                                $17_1 = $23_1;
                                                $20_1 = $12_1;
                                                if (HEAPU8[$22_1 >> 0] | 0) {
                                                  break label$4;
                                                }
                                                break label$8;
                                              }
                                              label$71: {
                                                if (!$20_1) {
                                                  break label$71;
                                                }
                                                $14_1 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                                break label$46;
                                              }
                                              $12_1 = 0;
                                              $38($0_1 | 0, 32 | 0, $19_1 | 0, 0 | 0, $17_1 | 0);
                                              break label$45;
                                            }
                                            HEAP32[($7_1 + 12 | 0) >> 2] = 0;
                                            i64toi32_i32$1 = $7_1;
                                            i64toi32_i32$2 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                            i64toi32_i32$3 = HEAP32[($7_1 + 68 | 0) >> 2] | 0;
                                            HEAP32[($7_1 + 8 | 0) >> 2] = i64toi32_i32$2;
                                            HEAP32[($7_1 + 64 | 0) >> 2] = $7_1 + 8 | 0;
                                            $14_1 = $7_1 + 8 | 0;
                                            $20_1 = -1;
                                          }
                                          $12_1 = 0;
                                          label$72: {
                                            label$73: while (1) {
                                              $15_1 = HEAP32[$14_1 >> 2] | 0;
                                              if (!$15_1) {
                                                break label$72;
                                              }
                                              $15_1 = $76($7_1 + 4 | 0 | 0, $15_1 | 0) | 0;
                                              if (($15_1 | 0) < (0 | 0)) {
                                                break label$2;
                                              }
                                              if ($15_1 >>> 0 > ($20_1 - $12_1 | 0) >>> 0) {
                                                break label$72;
                                              }
                                              $14_1 = $14_1 + 4 | 0;
                                              $12_1 = $15_1 + $12_1 | 0;
                                              if ($12_1 >>> 0 < $20_1 >>> 0) {
                                                continue label$73;
                                              }
                                              break label$73;
                                            };
                                          }
                                          $22_1 = 61;
                                          if (($12_1 | 0) < (0 | 0)) {
                                            break label$3;
                                          }
                                          $38($0_1 | 0, 32 | 0, $19_1 | 0, $12_1 | 0, $17_1 | 0);
                                          label$74: {
                                            if ($12_1) {
                                              break label$74;
                                            }
                                            $12_1 = 0;
                                            break label$45;
                                          }
                                          $15_1 = 0;
                                          $14_1 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                          label$75: while (1) {
                                            $13_1 = HEAP32[$14_1 >> 2] | 0;
                                            if (!$13_1) {
                                              break label$45;
                                            }
                                            $13_1 = $76($7_1 + 4 | 0 | 0, $13_1 | 0) | 0;
                                            $15_1 = $13_1 + $15_1 | 0;
                                            if ($15_1 >>> 0 > $12_1 >>> 0) {
                                              break label$45;
                                            }
                                            $32($0_1 | 0, $7_1 + 4 | 0 | 0, $13_1 | 0);
                                            $14_1 = $14_1 + 4 | 0;
                                            if ($15_1 >>> 0 < $12_1 >>> 0) {
                                              continue label$75;
                                            }
                                            break label$75;
                                          };
                                        }
                                        $38($0_1 | 0, 32 | 0, $19_1 | 0, $12_1 | 0, $17_1 ^ 8192 | 0 | 0);
                                        $12_1 = ($19_1 | 0) > ($12_1 | 0) ? $19_1 : $12_1;
                                        continue label$6;
                                      }
                                      if ($21_1 & ($20_1 | 0) < (0 | 0) | 0) {
                                        break label$4;
                                      }
                                      $22_1 = 61;
                                      $12_1 = FUNCTION_TABLE[$5_1 | 0]($0_1, +HEAPF64[($7_1 + 64 | 0) >> 3], $19_1, $20_1, $17_1, $12_1) | 0;
                                      if (($12_1 | 0) >= (0 | 0)) {
                                        continue label$6;
                                      }
                                      break label$3;
                                    }
                                    i64toi32_i32$1 = $7_1;
                                    i64toi32_i32$3 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
                                    i64toi32_i32$2 = HEAP32[($7_1 + 68 | 0) >> 2] | 0;
                                    HEAP8[($7_1 + 55 | 0) >> 0] = i64toi32_i32$3;
                                    $20_1 = 1;
                                    $13_1 = $8_1;
                                    $22_1 = $9_1;
                                    $17_1 = $23_1;
                                    break label$8;
                                  }
                                  $14_1 = HEAPU8[($12_1 + 1 | 0) >> 0] | 0;
                                  $12_1 = $12_1 + 1 | 0;
                                  continue label$12;
                                };
                              }
                              if ($0_1) {
                                break label$1;
                              }
                              if (!$10_1) {
                                break label$7;
                              }
                              $12_1 = 1;
                              label$76: {
                                label$77: while (1) {
                                  $14_1 = HEAP32[($4_1 + ($12_1 << 2 | 0) | 0) >> 2] | 0;
                                  if (!$14_1) {
                                    break label$76;
                                  }
                                  $34($3_1 + ($12_1 << 3 | 0) | 0 | 0, $14_1 | 0, $2_1 | 0, $6_1 | 0);
                                  $11_1 = 1;
                                  $12_1 = $12_1 + 1 | 0;
                                  if (($12_1 | 0) != (10 | 0)) {
                                    continue label$77;
                                  }
                                  break label$1;
                                };
                              }
                              $11_1 = 1;
                              if ($12_1 >>> 0 >= 10 >>> 0) {
                                break label$1;
                              }
                              label$78: while (1) {
                                if (HEAP32[($4_1 + ($12_1 << 2 | 0) | 0) >> 2] | 0) {
                                  break label$10;
                                }
                                $11_1 = 1;
                                $12_1 = $12_1 + 1 | 0;
                                if (($12_1 | 0) == (10 | 0)) {
                                  break label$1;
                                }
                                continue label$78;
                              };
                            }
                            $22_1 = 28;
                            break label$3;
                          }
                          $22_1 = $9_1;
                        }
                        $1_1 = $22_1 - $13_1 | 0;
                        $18_1 = ($20_1 | 0) > ($1_1 | 0) ? $20_1 : $1_1;
                        if (($18_1 | 0) > ($16_1 ^ 2147483647 | 0 | 0)) {
                          break label$4;
                        }
                        $22_1 = 61;
                        $15_1 = $16_1 + $18_1 | 0;
                        $12_1 = ($19_1 | 0) > ($15_1 | 0) ? $19_1 : $15_1;
                        if (($12_1 | 0) > ($14_1 | 0)) {
                          break label$3;
                        }
                        $38($0_1 | 0, 32 | 0, $12_1 | 0, $15_1 | 0, $17_1 | 0);
                        $32($0_1 | 0, $24_1 | 0, $16_1 | 0);
                        $38($0_1 | 0, 48 | 0, $12_1 | 0, $15_1 | 0, $17_1 ^ 65536 | 0 | 0);
                        $38($0_1 | 0, 48 | 0, $18_1 | 0, $1_1 | 0, 0 | 0);
                        $32($0_1 | 0, $13_1 | 0, $1_1 | 0);
                        $38($0_1 | 0, 32 | 0, $12_1 | 0, $15_1 | 0, $17_1 ^ 8192 | 0 | 0);
                        $1_1 = HEAP32[($7_1 + 76 | 0) >> 2] | 0;
                        continue label$6;
                      }
                      break label$6;
                    };
                    break label$5;
                  };
                  $11_1 = 0;
                  break label$1;
                }
                $22_1 = 61;
              }
              (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = $22_1), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
            }
            $11_1 = -1;
          }
          global$0 = $7_1 + 80 | 0;
          return $11_1 | 0;
        }

        function $32($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          label$1: {
            if ((HEAPU8[$0_1 >> 0] | 0) & 32 | 0) {
              break label$1;
            }
            $29($1_1 | 0, $2_1 | 0, $0_1 | 0) | 0;
          }
        }

        function $33($0_1) {
          $0_1 = $0_1 | 0;
          var $3_1 = 0,$1_1 = 0,$2_1 = 0,$4_1 = 0,$5_1 = 0;
          $1_1 = 0;
          label$1: {
            $2_1 = HEAP32[$0_1 >> 2] | 0;
            $3_1 = (HEAP8[$2_1 >> 0] | 0) + -48 | 0;
            if ($3_1 >>> 0 <= 9 >>> 0) {
              break label$1;
            }
            return 0 | 0;
          }
          label$2: while (1) {
            $4_1 = -1;
            label$3: {
              if ($1_1 >>> 0 > 214748364 >>> 0) {
                break label$3;
              }
              $1_1 = Math_imul($1_1, 10);
              $4_1 = $3_1 >>> 0 > ($1_1 ^ 2147483647 | 0) >>> 0 ? -1 : $3_1 + $1_1 | 0;
            }
            $3_1 = $2_1 + 1 | 0;
            HEAP32[$0_1 >> 2] = $3_1;
            $5_1 = HEAP8[($2_1 + 1 | 0) >> 0] | 0;
            $1_1 = $4_1;
            $2_1 = $3_1;
            $3_1 = $5_1 + -48 | 0;
            if ($3_1 >>> 0 < 10 >>> 0) {
              continue label$2;
            }
            break label$2;
          };
          return $1_1 | 0;
        }

        function $34($0_1, $1_1, $2_1, $3_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,$21_1 = 0,$29_1 = 0,$37_1 = 0,$45_1 = 0,$55_1 = 0,$63_1 = 0,$71_1 = 0,$79_1 = 0,$87_1 = 0,$97_1 = 0,$105_1 = 0,$115 = 0,$125 = 0,$133 = 0,$141 = 0;
          label$1: {
            switch ($1_1 + -9 | 0 | 0) {
              case 0:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2] | 0;
                return;
              case 1:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$0 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$1 = i64toi32_i32$0 >> 31 | 0;
                $21_1 = i64toi32_i32$0;
                i64toi32_i32$0 = $0_1;
                HEAP32[i64toi32_i32$0 >> 2] = $21_1;
                HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;
                return;
              case 2:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$1 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$0 = 0;
                $29_1 = i64toi32_i32$1;
                i64toi32_i32$1 = $0_1;
                HEAP32[i64toi32_i32$1 >> 2] = $29_1;
                HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
                return;
              case 4:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$0 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$1 = i64toi32_i32$0 >> 31 | 0;
                $37_1 = i64toi32_i32$0;
                i64toi32_i32$0 = $0_1;
                HEAP32[i64toi32_i32$0 >> 2] = $37_1;
                HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;
                return;
              case 5:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$1 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$0 = 0;
                $45_1 = i64toi32_i32$1;
                i64toi32_i32$1 = $0_1;
                HEAP32[i64toi32_i32$1 >> 2] = $45_1;
                HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
                return;
              case 3:
                $1_1 = ((HEAP32[$2_1 >> 2] | 0) + 7 | 0) & -8 | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 8 | 0;
                i64toi32_i32$0 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                $55_1 = i64toi32_i32$0;
                i64toi32_i32$0 = $0_1;
                HEAP32[i64toi32_i32$0 >> 2] = $55_1;
                HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;
                return;
              case 6:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$1 = HEAP16[$1_1 >> 1] | 0;
                i64toi32_i32$0 = i64toi32_i32$1 >> 31 | 0;
                $63_1 = i64toi32_i32$1;
                i64toi32_i32$1 = $0_1;
                HEAP32[i64toi32_i32$1 >> 2] = $63_1;
                HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
                return;
              case 7:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$0 = HEAPU16[$1_1 >> 1] | 0;
                i64toi32_i32$1 = 0;
                $71_1 = i64toi32_i32$0;
                i64toi32_i32$0 = $0_1;
                HEAP32[i64toi32_i32$0 >> 2] = $71_1;
                HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;
                return;
              case 8:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$1 = HEAP8[$1_1 >> 0] | 0;
                i64toi32_i32$0 = i64toi32_i32$1 >> 31 | 0;
                $79_1 = i64toi32_i32$1;
                i64toi32_i32$1 = $0_1;
                HEAP32[i64toi32_i32$1 >> 2] = $79_1;
                HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
                return;
              case 9:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$0 = HEAPU8[$1_1 >> 0] | 0;
                i64toi32_i32$1 = 0;
                $87_1 = i64toi32_i32$0;
                i64toi32_i32$0 = $0_1;
                HEAP32[i64toi32_i32$0 >> 2] = $87_1;
                HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;
                return;
              case 10:
                $1_1 = ((HEAP32[$2_1 >> 2] | 0) + 7 | 0) & -8 | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 8 | 0;
                i64toi32_i32$1 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$0 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                $97_1 = i64toi32_i32$1;
                i64toi32_i32$1 = $0_1;
                HEAP32[i64toi32_i32$1 >> 2] = $97_1;
                HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
                return;
              case 11:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$0 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$1 = 0;
                $105_1 = i64toi32_i32$0;
                i64toi32_i32$0 = $0_1;
                HEAP32[i64toi32_i32$0 >> 2] = $105_1;
                HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;
                return;
              case 12:
                $1_1 = ((HEAP32[$2_1 >> 2] | 0) + 7 | 0) & -8 | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 8 | 0;
                i64toi32_i32$1 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$0 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                $115 = i64toi32_i32$1;
                i64toi32_i32$1 = $0_1;
                HEAP32[i64toi32_i32$1 >> 2] = $115;
                HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
                return;
              case 13:
                $1_1 = ((HEAP32[$2_1 >> 2] | 0) + 7 | 0) & -8 | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 8 | 0;
                i64toi32_i32$0 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                $125 = i64toi32_i32$0;
                i64toi32_i32$0 = $0_1;
                HEAP32[i64toi32_i32$0 >> 2] = $125;
                HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;
                return;
              case 14:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$1 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$0 = i64toi32_i32$1 >> 31 | 0;
                $133 = i64toi32_i32$1;
                i64toi32_i32$1 = $0_1;
                HEAP32[i64toi32_i32$1 >> 2] = $133;
                HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
                return;
              case 15:
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 4 | 0;
                i64toi32_i32$0 = HEAP32[$1_1 >> 2] | 0;
                i64toi32_i32$1 = 0;
                $141 = i64toi32_i32$0;
                i64toi32_i32$0 = $0_1;
                HEAP32[i64toi32_i32$0 >> 2] = $141;
                HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;
                return;
              case 16:
                $1_1 = ((HEAP32[$2_1 >> 2] | 0) + 7 | 0) & -8 | 0;
                HEAP32[$2_1 >> 2] = $1_1 + 8 | 0;
                HEAPF64[$0_1 >> 3] = +HEAPF64[$1_1 >> 3];
                return;
              case 17:
                FUNCTION_TABLE[$3_1 | 0]($0_1, $2_1);
                break;
              default:
                break label$1;
            };
          }
        }

        function $35($0_1, $0$hi, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$4 = 0,i64toi32_i32$3 = 0,$10_1 = 0,$3_1 = 0;
          label$1: {
            i64toi32_i32$0 = $0$hi;
            if (!($0_1 | i64toi32_i32$0 | 0)) {
              break label$1;
            }
            label$2: while (1) {
              $1_1 = $1_1 + -1 | 0;
              i64toi32_i32$0 = $0$hi;
              HEAP8[$1_1 >> 0] = HEAPU8[(($0_1 & 15 | 0) + 66080 | 0) >> 0] | 0 | $2_1 | 0;
              i64toi32_i32$2 = $0_1;
              i64toi32_i32$1 = 0;
              i64toi32_i32$3 = 15;
              $3_1 = i64toi32_i32$0 >>> 0 > i64toi32_i32$1 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$2 >>> 0 > i64toi32_i32$3 >>> 0 | 0) | 0;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$3 = $0_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$1 = 4;
              i64toi32_i32$4 = i64toi32_i32$1 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $10_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                $10_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$4 | 0) | 0;
              }
              $0_1 = $10_1;
              $0$hi = i64toi32_i32$0;
              if ($3_1) {
                continue label$2;
              }
              break label$2;
            };
          }
          return $1_1 | 0;
        }

        function $36($0_1, $0$hi, $1_1) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          $1_1 = $1_1 | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$4 = 0,i64toi32_i32$3 = 0,$9_1 = 0,$2_1 = 0;
          label$1: {
            i64toi32_i32$0 = $0$hi;
            if (!($0_1 | i64toi32_i32$0 | 0)) {
              break label$1;
            }
            label$2: while (1) {
              $1_1 = $1_1 + -1 | 0;
              i64toi32_i32$0 = $0$hi;
              HEAP8[$1_1 >> 0] = $0_1 & 7 | 0 | 48 | 0;
              i64toi32_i32$2 = $0_1;
              i64toi32_i32$1 = 0;
              i64toi32_i32$3 = 7;
              $2_1 = i64toi32_i32$0 >>> 0 > i64toi32_i32$1 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$2 >>> 0 > i64toi32_i32$3 >>> 0 | 0) | 0;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$3 = $0_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$1 = 3;
              i64toi32_i32$4 = i64toi32_i32$1 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $9_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                $9_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$4 | 0) | 0;
              }
              $0_1 = $9_1;
              $0$hi = i64toi32_i32$0;
              if ($2_1) {
                continue label$2;
              }
              break label$2;
            };
          }
          return $1_1 | 0;
        }

        function $37($0_1, $0$hi, $1_1) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          $1_1 = $1_1 | 0;
          var i64toi32_i32$2 = 0,i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,$3_1 = 0,i64toi32_i32$5 = 0,i64toi32_i32$3 = 0,$2_1 = 0,$2$hi = 0,$4_1 = 0,$16_1 = 0,$16$hi = 0,$5_1 = 0;
          label$1: {
            label$2: {
              i64toi32_i32$0 = $0$hi;
              i64toi32_i32$2 = $0_1;
              i64toi32_i32$1 = 1;
              i64toi32_i32$3 = 0;
              if (i64toi32_i32$0 >>> 0 > i64toi32_i32$1 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$2 >>> 0 >= i64toi32_i32$3 >>> 0 | 0) | 0) {
                break label$2;
              }
              i64toi32_i32$2 = i64toi32_i32$0;
              $2_1 = $0_1;
              $2$hi = i64toi32_i32$2;
              break label$1;
            }
            label$3: while (1) {
              $1_1 = $1_1 + -1 | 0;
              i64toi32_i32$2 = $0$hi;
              i64toi32_i32$0 = 0;
              i64toi32_i32$0 = __wasm_i64_udiv($0_1 | 0, i64toi32_i32$2 | 0, 10 | 0, i64toi32_i32$0 | 0) | 0;
              i64toi32_i32$2 = i64toi32_i32$HIGH_BITS;
              $2_1 = i64toi32_i32$0;
              $2$hi = i64toi32_i32$2;
              i64toi32_i32$0 = 0;
              i64toi32_i32$0 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$2 | 0, 10 | 0, i64toi32_i32$0 | 0) | 0;
              i64toi32_i32$2 = i64toi32_i32$HIGH_BITS;
              $16_1 = i64toi32_i32$0;
              $16$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $0$hi;
              i64toi32_i32$3 = $0_1;
              i64toi32_i32$0 = $16$hi;
              i64toi32_i32$1 = $16_1;
              i64toi32_i32$5 = ($0_1 >>> 0 < i64toi32_i32$1 >>> 0) + i64toi32_i32$0 | 0;
              i64toi32_i32$5 = i64toi32_i32$2 - i64toi32_i32$5 | 0;
              HEAP8[$1_1 >> 0] = $0_1 - i64toi32_i32$1 | 0 | 48 | 0;
              i64toi32_i32$5 = i64toi32_i32$2;
              i64toi32_i32$5 = i64toi32_i32$2;
              i64toi32_i32$2 = $0_1;
              i64toi32_i32$3 = 9;
              i64toi32_i32$1 = -1;
              $3_1 = i64toi32_i32$5 >>> 0 > i64toi32_i32$3 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$2 >>> 0 > i64toi32_i32$1 >>> 0 | 0) | 0;
              i64toi32_i32$2 = $2$hi;
              $0_1 = $2_1;
              $0$hi = i64toi32_i32$2;
              if ($3_1) {
                continue label$3;
              }
              break label$3;
            };
          }
          label$4: {
            i64toi32_i32$2 = $2$hi;
            $3_1 = $2_1;
            if (!$3_1) {
              break label$4;
            }
            label$5: while (1) {
              $1_1 = $1_1 + -1 | 0;
              $4_1 = ($3_1 >>> 0) / (10 >>> 0) | 0;
              HEAP8[$1_1 >> 0] = $3_1 - Math_imul($4_1, 10) | 0 | 48 | 0;
              $5_1 = $3_1 >>> 0 > 9 >>> 0;
              $3_1 = $4_1;
              if ($5_1) {
                continue label$5;
              }
              break label$5;
            };
          }
          return $1_1 | 0;
        }

        function $38($0_1, $1_1, $2_1, $3_1, $4_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          $4_1 = $4_1 | 0;
          var $5_1 = 0;
          $5_1 = global$0 - 256 | 0;
          global$0 = $5_1;
          label$1: {
            if (($2_1 | 0) <= ($3_1 | 0)) {
              break label$1;
            }
            if ($4_1 & 73728 | 0) {
              break label$1;
            }
            $3_1 = $2_1 - $3_1 | 0;
            $2_1 = $3_1 >>> 0 < 256 >>> 0;
            $16($5_1 | 0, $1_1 & 255 | 0 | 0, ($2_1 ? $3_1 : 256) | 0) | 0;
            label$2: {
              if ($2_1) {
                break label$2;
              }
              label$3: while (1) {
                $32($0_1 | 0, $5_1 | 0, 256 | 0);
                $3_1 = $3_1 + -256 | 0;
                if ($3_1 >>> 0 > 255 >>> 0) {
                  continue label$3;
                }
                break label$3;
              };
            }
            $32($0_1 | 0, $5_1 | 0, $3_1 | 0);
          }
          global$0 = $5_1 + 256 | 0;
        }

        function $39($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          return $30($0_1 | 0, $1_1 | 0, $2_1 | 0, 1 | 0, 2 | 0) | 0 | 0;
        }

        function $40($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {
          $0_1 = $0_1 | 0;
          $1_1 = +$1_1;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          $4_1 = $4_1 | 0;
          $5_1 = $5_1 | 0;
          var $10_1 = 0,$11_1 = 0,$12_1 = 0,$18_1 = 0,$6_1 = 0,$21_1 = 0,i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,$15_1 = 0,i64toi32_i32$4 = 0,$22_1 = 0,$23_1 = 0,i64toi32_i32$2 = 0,i64toi32_i32$3 = 0,i64toi32_i32$5 = 0,$19_1 = 0,$17_1 = 0,$8_1 = 0,$26_1 = 0.0,$24_1 = 0,$13_1 = 0,$24$hi = 0,$14_1 = 0,$16_1 = 0,$20_1 = 0,$9_1 = 0,$7_1 = 0,$45_1 = 0,$46_1 = 0,$47_1 = 0,$25$hi = 0,$48_1 = 0,$25_1 = 0,$167 = 0,$169$hi = 0,$171$hi = 0,$173 = 0,$173$hi = 0,$175$hi = 0,$179 = 0,$179$hi = 0,$391 = 0.0,$855 = 0;
          $6_1 = global$0 - 560 | 0;
          global$0 = $6_1;
          $7_1 = 0;
          HEAP32[($6_1 + 44 | 0) >> 2] = 0;
          label$1: {
            label$2: {
              i64toi32_i32$0 = $42(+$1_1) | 0;
              i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
              $24_1 = i64toi32_i32$0;
              $24$hi = i64toi32_i32$1;
              i64toi32_i32$2 = i64toi32_i32$0;
              i64toi32_i32$0 = -1;
              i64toi32_i32$3 = -1;
              if ((i64toi32_i32$1 | 0) > (i64toi32_i32$0 | 0)) {
                $45_1 = 1;
              } else {
                if ((i64toi32_i32$1 | 0) >= (i64toi32_i32$0 | 0)) {
                  if (i64toi32_i32$2 >>> 0 <= i64toi32_i32$3 >>> 0) {
                    $46_1 = 0;
                  } else {
                    $46_1 = 1;
                  }
                  $47_1 = $46_1;
                } else {
                  $47_1 = 0;
                }
                $45_1 = $47_1;
              }
              if ($45_1) {
                break label$2;
              }
              $8_1 = 1;
              $9_1 = 65555;
              $1_1 = -$1_1;
              i64toi32_i32$2 = $42(+$1_1) | 0;
              i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
              $24_1 = i64toi32_i32$2;
              $24$hi = i64toi32_i32$1;
              break label$1;
            }
            label$3: {
              if (!($4_1 & 2048 | 0)) {
                break label$3;
              }
              $8_1 = 1;
              $9_1 = 65558;
              break label$1;
            }
            $8_1 = $4_1 & 1 | 0;
            $9_1 = $8_1 ? 65561 : 65556;
            $7_1 = !$8_1;
          }
          label$4: {
            label$5: {
              i64toi32_i32$1 = $24$hi;
              i64toi32_i32$3 = $24_1;
              i64toi32_i32$2 = 2146435072;
              i64toi32_i32$0 = 0;
              i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
              i64toi32_i32$1 = i64toi32_i32$3 & i64toi32_i32$0 | 0;
              i64toi32_i32$3 = 2146435072;
              i64toi32_i32$0 = 0;
              if ((i64toi32_i32$1 | 0) != (i64toi32_i32$0 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$3 | 0) | 0) {
                break label$5;
              }
              $10_1 = $8_1 + 3 | 0;
              $38($0_1 | 0, 32 | 0, $2_1 | 0, $10_1 | 0, $4_1 & -65537 | 0 | 0);
              $32($0_1 | 0, $9_1 | 0, $8_1 | 0);
              $11_1 = $5_1 & 32 | 0;
              $32($0_1 | 0, ($1_1 != $1_1 ? $11_1 ? 65579 : 65587 : $11_1 ? 65583 : 65591) | 0, 3 | 0);
              $38($0_1 | 0, 32 | 0, $2_1 | 0, $10_1 | 0, $4_1 ^ 8192 | 0 | 0);
              $12_1 = ($10_1 | 0) > ($2_1 | 0) ? $10_1 : $2_1;
              break label$4;
            }
            $13_1 = $6_1 + 16 | 0;
            label$6: {
              label$7: {
                label$8: {
                  label$9: {
                    $1_1 = +$27(+$1_1, $6_1 + 44 | 0 | 0);
                    $1_1 = $1_1 + $1_1;
                    if ($1_1 == 0.0) {
                      break label$9;
                    }
                    $10_1 = HEAP32[($6_1 + 44 | 0) >> 2] | 0;
                    HEAP32[($6_1 + 44 | 0) >> 2] = $10_1 + -1 | 0;
                    $14_1 = $5_1 | 32 | 0;
                    if (($14_1 | 0) != (97 | 0)) {
                      break label$8;
                    }
                    break label$6;
                  }
                  $14_1 = $5_1 | 32 | 0;
                  if (($14_1 | 0) == (97 | 0)) {
                    break label$6;
                  }
                  $15_1 = ($3_1 | 0) < (0 | 0) ? 6 : $3_1;
                  $16_1 = HEAP32[($6_1 + 44 | 0) >> 2] | 0;
                  break label$7;
                }
                $16_1 = $10_1 + -29 | 0;
                HEAP32[($6_1 + 44 | 0) >> 2] = $16_1;
                $15_1 = ($3_1 | 0) < (0 | 0) ? 6 : $3_1;
                $1_1 = $1_1 * 268435456.0;
              }
              $17_1 = ($6_1 + 48 | 0) + (($16_1 | 0) < (0 | 0) ? 0 : 288) | 0;
              $11_1 = $17_1;
              label$10: while (1) {
                label$11: {
                  label$12: {
                    if (!($1_1 < 4294967296.0 & $1_1 >= 0.0 | 0)) {
                      break label$12;
                    }
                    $10_1 = ~~$1_1 >>> 0;
                    break label$11;
                  }
                  $10_1 = 0;
                }
                HEAP32[$11_1 >> 2] = $10_1;
                $11_1 = $11_1 + 4 | 0;
                $1_1 = ($1_1 - +($10_1 >>> 0)) * 1.0e9;
                if ($1_1 != 0.0) {
                  continue label$10;
                }
                break label$10;
              };
              label$13: {
                label$14: {
                  if (($16_1 | 0) >= (1 | 0)) {
                    break label$14;
                  }
                  $3_1 = $16_1;
                  $10_1 = $11_1;
                  $18_1 = $17_1;
                  break label$13;
                }
                $18_1 = $17_1;
                $3_1 = $16_1;
                label$15: while (1) {
                  $3_1 = ($3_1 | 0) < (29 | 0) ? $3_1 : 29;
                  label$16: {
                    $10_1 = $11_1 + -4 | 0;
                    if ($10_1 >>> 0 < $18_1 >>> 0) {
                      break label$16;
                    }
                    i64toi32_i32$1 = 0;
                    $25_1 = $3_1;
                    $25$hi = i64toi32_i32$1;
                    i64toi32_i32$1 = 0;
                    $24_1 = 0;
                    $24$hi = i64toi32_i32$1;
                    label$17: while (1) {
                      $167 = $10_1;
                      i64toi32_i32$0 = $10_1;
                      i64toi32_i32$1 = HEAP32[$10_1 >> 2] | 0;
                      i64toi32_i32$2 = 0;
                      $169$hi = i64toi32_i32$2;
                      i64toi32_i32$2 = $25$hi;
                      i64toi32_i32$2 = $169$hi;
                      i64toi32_i32$0 = i64toi32_i32$1;
                      i64toi32_i32$1 = $25$hi;
                      i64toi32_i32$3 = $25_1;
                      i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
                      if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                        i64toi32_i32$1 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
                        $48_1 = 0;
                      } else {
                        i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$4 | 0) | 0;
                        $48_1 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
                      }
                      $171$hi = i64toi32_i32$1;
                      i64toi32_i32$1 = $24$hi;
                      i64toi32_i32$2 = $24_1;
                      i64toi32_i32$0 = 0;
                      i64toi32_i32$3 = -1;
                      i64toi32_i32$0 = i64toi32_i32$1 & i64toi32_i32$0 | 0;
                      $173 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
                      $173$hi = i64toi32_i32$0;
                      i64toi32_i32$0 = $171$hi;
                      i64toi32_i32$1 = $48_1;
                      i64toi32_i32$2 = $173$hi;
                      i64toi32_i32$3 = $173;
                      i64toi32_i32$4 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
                      i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$2 | 0;
                      if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                        i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                      }
                      $24_1 = i64toi32_i32$4;
                      $24$hi = i64toi32_i32$5;
                      $175$hi = i64toi32_i32$5;
                      i64toi32_i32$1 = 0;
                      i64toi32_i32$1 = __wasm_i64_udiv(i64toi32_i32$4 | 0, i64toi32_i32$5 | 0, 1e9 | 0, i64toi32_i32$1 | 0) | 0;
                      i64toi32_i32$5 = i64toi32_i32$HIGH_BITS;
                      $24_1 = i64toi32_i32$1;
                      $24$hi = i64toi32_i32$5;
                      i64toi32_i32$1 = 0;
                      i64toi32_i32$1 = __wasm_i64_mul($24_1 | 0, i64toi32_i32$5 | 0, 1e9 | 0, i64toi32_i32$1 | 0) | 0;
                      i64toi32_i32$5 = i64toi32_i32$HIGH_BITS;
                      $179 = i64toi32_i32$1;
                      $179$hi = i64toi32_i32$5;
                      i64toi32_i32$5 = $175$hi;
                      i64toi32_i32$0 = i64toi32_i32$4;
                      i64toi32_i32$1 = $179$hi;
                      i64toi32_i32$3 = $179;
                      i64toi32_i32$2 = i64toi32_i32$0 - i64toi32_i32$3 | 0;
                      i64toi32_i32$4 = (i64toi32_i32$0 >>> 0 < i64toi32_i32$3 >>> 0) + i64toi32_i32$1 | 0;
                      i64toi32_i32$4 = i64toi32_i32$5 - i64toi32_i32$4 | 0;
                      HEAP32[$167 >> 2] = i64toi32_i32$2;
                      $10_1 = $10_1 + -4 | 0;
                      if ($10_1 >>> 0 >= $18_1 >>> 0) {
                        continue label$17;
                      }
                      break label$17;
                    };
                    i64toi32_i32$4 = $24$hi;
                    $10_1 = $24_1;
                    if (!$10_1) {
                      break label$16;
                    }
                    $18_1 = $18_1 + -4 | 0;
                    HEAP32[$18_1 >> 2] = $10_1;
                  }
                  label$18: {
                    label$19: while (1) {
                      $10_1 = $11_1;
                      if ($10_1 >>> 0 <= $18_1 >>> 0) {
                        break label$18;
                      }
                      $11_1 = $10_1 + -4 | 0;
                      if (!(HEAP32[$11_1 >> 2] | 0)) {
                        continue label$19;
                      }
                      break label$19;
                    };
                  }
                  $3_1 = (HEAP32[($6_1 + 44 | 0) >> 2] | 0) - $3_1 | 0;
                  HEAP32[($6_1 + 44 | 0) >> 2] = $3_1;
                  $11_1 = $10_1;
                  if (($3_1 | 0) > (0 | 0)) {
                    continue label$15;
                  }
                  break label$15;
                };
              }
              label$20: {
                if (($3_1 | 0) > (-1 | 0)) {
                  break label$20;
                }
                $19_1 = ((($15_1 + 25 | 0) >>> 0) / (9 >>> 0) | 0) + 1 | 0;
                $20_1 = ($14_1 | 0) == (102 | 0);
                label$21: while (1) {
                  $11_1 = 0 - $3_1 | 0;
                  $21_1 = ($11_1 | 0) < (9 | 0) ? $11_1 : 9;
                  label$22: {
                    label$23: {
                      if ($18_1 >>> 0 < $10_1 >>> 0) {
                        break label$23;
                      }
                      $11_1 = !(HEAP32[$18_1 >> 2] | 0) << 2 | 0;
                      break label$22;
                    }
                    $22_1 = 1e9 >>> $21_1 | 0;
                    $23_1 = (-1 << $21_1 | 0) ^ -1 | 0;
                    $3_1 = 0;
                    $11_1 = $18_1;
                    label$24: while (1) {
                      $12_1 = HEAP32[$11_1 >> 2] | 0;
                      HEAP32[$11_1 >> 2] = ($12_1 >>> $21_1 | 0) + $3_1 | 0;
                      $3_1 = Math_imul($12_1 & $23_1 | 0, $22_1);
                      $11_1 = $11_1 + 4 | 0;
                      if ($11_1 >>> 0 < $10_1 >>> 0) {
                        continue label$24;
                      }
                      break label$24;
                    };
                    $11_1 = !(HEAP32[$18_1 >> 2] | 0) << 2 | 0;
                    if (!$3_1) {
                      break label$22;
                    }
                    HEAP32[$10_1 >> 2] = $3_1;
                    $10_1 = $10_1 + 4 | 0;
                  }
                  $3_1 = (HEAP32[($6_1 + 44 | 0) >> 2] | 0) + $21_1 | 0;
                  HEAP32[($6_1 + 44 | 0) >> 2] = $3_1;
                  $18_1 = $18_1 + $11_1 | 0;
                  $11_1 = $20_1 ? $17_1 : $18_1;
                  $10_1 = (($10_1 - $11_1 | 0) >> 2 | 0 | 0) > ($19_1 | 0) ? $11_1 + ($19_1 << 2 | 0) | 0 : $10_1;
                  if (($3_1 | 0) < (0 | 0)) {
                    continue label$21;
                  }
                  break label$21;
                };
              }
              $3_1 = 0;
              label$25: {
                if ($18_1 >>> 0 >= $10_1 >>> 0) {
                  break label$25;
                }
                $3_1 = Math_imul(($17_1 - $18_1 | 0) >> 2 | 0, 9);
                $11_1 = 10;
                $12_1 = HEAP32[$18_1 >> 2] | 0;
                if ($12_1 >>> 0 < 10 >>> 0) {
                  break label$25;
                }
                label$26: while (1) {
                  $3_1 = $3_1 + 1 | 0;
                  $11_1 = Math_imul($11_1, 10);
                  if ($12_1 >>> 0 >= $11_1 >>> 0) {
                    continue label$26;
                  }
                  break label$26;
                };
              }
              label$27: {
                $11_1 = ($15_1 - (($14_1 | 0) == (102 | 0) ? 0 : $3_1) | 0) - (($15_1 | 0) != (0 | 0) & ($14_1 | 0) == (103 | 0) | 0) | 0;
                if (($11_1 | 0) >= (Math_imul(($10_1 - $17_1 | 0) >> 2 | 0, 9) + -9 | 0 | 0)) {
                  break label$27;
                }
                $12_1 = $11_1 + 9216 | 0;
                $22_1 = ($12_1 | 0) / (9 | 0) | 0;
                $19_1 = (($6_1 + 48 | 0) + (($16_1 | 0) < (0 | 0) ? 4 : 292) | 0) + ($22_1 << 2 | 0) | 0;
                $21_1 = $19_1 + -4096 | 0;
                $11_1 = 10;
                label$28: {
                  $12_1 = $12_1 - Math_imul($22_1, 9) | 0;
                  if (($12_1 | 0) > (7 | 0)) {
                    break label$28;
                  }
                  label$29: while (1) {
                    $11_1 = Math_imul($11_1, 10);
                    $12_1 = $12_1 + 1 | 0;
                    if (($12_1 | 0) != (8 | 0)) {
                      continue label$29;
                    }
                    break label$29;
                  };
                }
                $23_1 = $19_1 + -4092 | 0;
                label$30: {
                  label$31: {
                    $12_1 = HEAP32[$21_1 >> 2] | 0;
                    $20_1 = ($12_1 >>> 0) / ($11_1 >>> 0) | 0;
                    $22_1 = $12_1 - Math_imul($20_1, $11_1) | 0;
                    if ($22_1) {
                      break label$31;
                    }
                    if (($23_1 | 0) == ($10_1 | 0)) {
                      break label$30;
                    }
                  }
                  label$32: {
                    label$33: {
                      if ($20_1 & 1 | 0) {
                        break label$33;
                      }
                      $1_1 = 9007199254740992.0;
                      if (($11_1 | 0) != (1e9 | 0)) {
                        break label$32;
                      }
                      if ($21_1 >>> 0 <= $18_1 >>> 0) {
                        break label$32;
                      }
                      if (!((HEAPU8[($19_1 + -4100 | 0) >> 0] | 0) & 1 | 0)) {
                        break label$32;
                      }
                    }
                    $1_1 = 9007199254740994.0;
                  }
                  $391 = ($23_1 | 0) == ($10_1 | 0) ? 1.0 : 1.5;
                  $23_1 = $11_1 >>> 1 | 0;
                  $26_1 = $22_1 >>> 0 < $23_1 >>> 0 ? .5 : ($22_1 | 0) == ($23_1 | 0) ? $391 : 1.5;
                  label$34: {
                    if ($7_1) {
                      break label$34;
                    }
                    if ((HEAPU8[$9_1 >> 0] | 0 | 0) != (45 | 0)) {
                      break label$34;
                    }
                    $26_1 = -$26_1;
                    $1_1 = -$1_1;
                  }
                  $12_1 = $12_1 - $22_1 | 0;
                  HEAP32[$21_1 >> 2] = $12_1;
                  if ($1_1 + $26_1 == $1_1) {
                    break label$30;
                  }
                  $11_1 = $12_1 + $11_1 | 0;
                  HEAP32[$21_1 >> 2] = $11_1;
                  label$35: {
                    if ($11_1 >>> 0 < 1e9 >>> 0) {
                      break label$35;
                    }
                    label$36: while (1) {
                      HEAP32[$21_1 >> 2] = 0;
                      label$37: {
                        $21_1 = $21_1 + -4 | 0;
                        if ($21_1 >>> 0 >= $18_1 >>> 0) {
                          break label$37;
                        }
                        $18_1 = $18_1 + -4 | 0;
                        HEAP32[$18_1 >> 2] = 0;
                      }
                      $11_1 = (HEAP32[$21_1 >> 2] | 0) + 1 | 0;
                      HEAP32[$21_1 >> 2] = $11_1;
                      if ($11_1 >>> 0 > 999999999 >>> 0) {
                        continue label$36;
                      }
                      break label$36;
                    };
                  }
                  $3_1 = Math_imul(($17_1 - $18_1 | 0) >> 2 | 0, 9);
                  $11_1 = 10;
                  $12_1 = HEAP32[$18_1 >> 2] | 0;
                  if ($12_1 >>> 0 < 10 >>> 0) {
                    break label$30;
                  }
                  label$38: while (1) {
                    $3_1 = $3_1 + 1 | 0;
                    $11_1 = Math_imul($11_1, 10);
                    if ($12_1 >>> 0 >= $11_1 >>> 0) {
                      continue label$38;
                    }
                    break label$38;
                  };
                }
                $11_1 = $21_1 + 4 | 0;
                $10_1 = $10_1 >>> 0 > $11_1 >>> 0 ? $11_1 : $10_1;
              }
              label$39: {
                label$40: while (1) {
                  $11_1 = $10_1;
                  $12_1 = $10_1 >>> 0 <= $18_1 >>> 0;
                  if ($12_1) {
                    break label$39;
                  }
                  $10_1 = $10_1 + -4 | 0;
                  if (!(HEAP32[$10_1 >> 2] | 0)) {
                    continue label$40;
                  }
                  break label$40;
                };
              }
              label$41: {
                label$42: {
                  if (($14_1 | 0) == (103 | 0)) {
                    break label$42;
                  }
                  $21_1 = $4_1 & 8 | 0;
                  break label$41;
                }
                $10_1 = $15_1 ? $15_1 : 1;
                $21_1 = ($10_1 | 0) > ($3_1 | 0) & ($3_1 | 0) > (-5 | 0) | 0;
                $15_1 = ($21_1 ? $3_1 ^ -1 | 0 : -1) + $10_1 | 0;
                $5_1 = ($21_1 ? -1 : -2) + $5_1 | 0;
                $21_1 = $4_1 & 8 | 0;
                if ($21_1) {
                  break label$41;
                }
                $10_1 = -9;
                label$43: {
                  if ($12_1) {
                    break label$43;
                  }
                  $21_1 = HEAP32[($11_1 + -4 | 0) >> 2] | 0;
                  if (!$21_1) {
                    break label$43;
                  }
                  $12_1 = 10;
                  $10_1 = 0;
                  if (($21_1 >>> 0) % (10 >>> 0) | 0) {
                    break label$43;
                  }
                  label$44: while (1) {
                    $22_1 = $10_1;
                    $10_1 = $10_1 + 1 | 0;
                    $12_1 = Math_imul($12_1, 10);
                    if (!(($21_1 >>> 0) % ($12_1 >>> 0) | 0)) {
                      continue label$44;
                    }
                    break label$44;
                  };
                  $10_1 = $22_1 ^ -1 | 0;
                }
                $12_1 = Math_imul(($11_1 - $17_1 | 0) >> 2 | 0, 9);
                label$45: {
                  if (($5_1 & -33 | 0 | 0) != (70 | 0)) {
                    break label$45;
                  }
                  $21_1 = 0;
                  $10_1 = ($12_1 + $10_1 | 0) + -9 | 0;
                  $10_1 = ($10_1 | 0) > (0 | 0) ? $10_1 : 0;
                  $15_1 = ($15_1 | 0) < ($10_1 | 0) ? $15_1 : $10_1;
                  break label$41;
                }
                $21_1 = 0;
                $10_1 = (($3_1 + $12_1 | 0) + $10_1 | 0) + -9 | 0;
                $10_1 = ($10_1 | 0) > (0 | 0) ? $10_1 : 0;
                $15_1 = ($15_1 | 0) < ($10_1 | 0) ? $15_1 : $10_1;
              }
              $12_1 = -1;
              $22_1 = $15_1 | $21_1 | 0;
              if (($15_1 | 0) > (($22_1 ? 2147483645 : 2147483646) | 0)) {
                break label$4;
              }
              $23_1 = ($15_1 + (($22_1 | 0) != (0 | 0)) | 0) + 1 | 0;
              label$46: {
                label$47: {
                  $20_1 = $5_1 & -33 | 0;
                  if (($20_1 | 0) != (70 | 0)) {
                    break label$47;
                  }
                  if (($3_1 | 0) > ($23_1 ^ 2147483647 | 0 | 0)) {
                    break label$4;
                  }
                  $10_1 = ($3_1 | 0) > (0 | 0) ? $3_1 : 0;
                  break label$46;
                }
                label$48: {
                  $10_1 = $3_1 >> 31 | 0;
                  i64toi32_i32$4 = 0;
                  $10_1 = $37(($3_1 ^ $10_1 | 0) - $10_1 | 0 | 0, i64toi32_i32$4 | 0, $13_1 | 0) | 0;
                  if (($13_1 - $10_1 | 0 | 0) > (1 | 0)) {
                    break label$48;
                  }
                  label$49: while (1) {
                    $10_1 = $10_1 + -1 | 0;
                    HEAP8[$10_1 >> 0] = 48;
                    if (($13_1 - $10_1 | 0 | 0) < (2 | 0)) {
                      continue label$49;
                    }
                    break label$49;
                  };
                }
                $19_1 = $10_1 + -2 | 0;
                HEAP8[$19_1 >> 0] = $5_1;
                $12_1 = -1;
                HEAP8[($10_1 + -1 | 0) >> 0] = ($3_1 | 0) < (0 | 0) ? 45 : 43;
                $10_1 = $13_1 - $19_1 | 0;
                if (($10_1 | 0) > ($23_1 ^ 2147483647 | 0 | 0)) {
                  break label$4;
                }
              }
              $12_1 = -1;
              $10_1 = $10_1 + $23_1 | 0;
              if (($10_1 | 0) > ($8_1 ^ 2147483647 | 0 | 0)) {
                break label$4;
              }
              $23_1 = $10_1 + $8_1 | 0;
              $38($0_1 | 0, 32 | 0, $2_1 | 0, $23_1 | 0, $4_1 | 0);
              $32($0_1 | 0, $9_1 | 0, $8_1 | 0);
              $38($0_1 | 0, 48 | 0, $2_1 | 0, $23_1 | 0, $4_1 ^ 65536 | 0 | 0);
              label$50: {
                label$51: {
                  label$52: {
                    label$53: {
                      if (($20_1 | 0) != (70 | 0)) {
                        break label$53;
                      }
                      $21_1 = $6_1 + 16 | 0 | 8 | 0;
                      $3_1 = $6_1 + 16 | 0 | 9 | 0;
                      $12_1 = $18_1 >>> 0 > $17_1 >>> 0 ? $17_1 : $18_1;
                      $18_1 = $12_1;
                      label$54: while (1) {
                        i64toi32_i32$5 = $18_1;
                        i64toi32_i32$4 = HEAP32[$18_1 >> 2] | 0;
                        i64toi32_i32$0 = 0;
                        $10_1 = $37(i64toi32_i32$4 | 0, i64toi32_i32$0 | 0, $3_1 | 0) | 0;
                        label$55: {
                          label$56: {
                            if (($18_1 | 0) == ($12_1 | 0)) {
                              break label$56;
                            }
                            if ($10_1 >>> 0 <= ($6_1 + 16 | 0) >>> 0) {
                              break label$55;
                            }
                            label$57: while (1) {
                              $10_1 = $10_1 + -1 | 0;
                              HEAP8[$10_1 >> 0] = 48;
                              if ($10_1 >>> 0 > ($6_1 + 16 | 0) >>> 0) {
                                continue label$57;
                              }
                              break label$55;
                            };
                          }
                          if (($10_1 | 0) != ($3_1 | 0)) {
                            break label$55;
                          }
                          HEAP8[($6_1 + 24 | 0) >> 0] = 48;
                          $10_1 = $21_1;
                        }
                        $32($0_1 | 0, $10_1 | 0, $3_1 - $10_1 | 0 | 0);
                        $18_1 = $18_1 + 4 | 0;
                        if ($18_1 >>> 0 <= $17_1 >>> 0) {
                          continue label$54;
                        }
                        break label$54;
                      };
                      label$58: {
                        if (!$22_1) {
                          break label$58;
                        }
                        $32($0_1 | 0, 65595 | 0, 1 | 0);
                      }
                      if ($18_1 >>> 0 >= $11_1 >>> 0) {
                        break label$52;
                      }
                      if (($15_1 | 0) < (1 | 0)) {
                        break label$52;
                      }
                      label$59: while (1) {
                        label$60: {
                          i64toi32_i32$5 = $18_1;
                          i64toi32_i32$0 = HEAP32[$18_1 >> 2] | 0;
                          i64toi32_i32$4 = 0;
                          $10_1 = $37(i64toi32_i32$0 | 0, i64toi32_i32$4 | 0, $3_1 | 0) | 0;
                          if ($10_1 >>> 0 <= ($6_1 + 16 | 0) >>> 0) {
                            break label$60;
                          }
                          label$61: while (1) {
                            $10_1 = $10_1 + -1 | 0;
                            HEAP8[$10_1 >> 0] = 48;
                            if ($10_1 >>> 0 > ($6_1 + 16 | 0) >>> 0) {
                              continue label$61;
                            }
                            break label$61;
                          };
                        }
                        $32($0_1 | 0, $10_1 | 0, (($15_1 | 0) < (9 | 0) ? $15_1 : 9) | 0);
                        $10_1 = $15_1 + -9 | 0;
                        $18_1 = $18_1 + 4 | 0;
                        if ($18_1 >>> 0 >= $11_1 >>> 0) {
                          break label$51;
                        }
                        $12_1 = ($15_1 | 0) > (9 | 0);
                        $15_1 = $10_1;
                        if ($12_1) {
                          continue label$59;
                        }
                        break label$51;
                      };
                    }
                    label$62: {
                      if (($15_1 | 0) < (0 | 0)) {
                        break label$62;
                      }
                      $22_1 = $11_1 >>> 0 > $18_1 >>> 0 ? $11_1 : $18_1 + 4 | 0;
                      $17_1 = $6_1 + 16 | 0 | 8 | 0;
                      $3_1 = $6_1 + 16 | 0 | 9 | 0;
                      $11_1 = $18_1;
                      label$63: while (1) {
                        label$64: {
                          i64toi32_i32$5 = $11_1;
                          i64toi32_i32$4 = HEAP32[$11_1 >> 2] | 0;
                          i64toi32_i32$0 = 0;
                          $10_1 = $37(i64toi32_i32$4 | 0, i64toi32_i32$0 | 0, $3_1 | 0) | 0;
                          if (($10_1 | 0) != ($3_1 | 0)) {
                            break label$64;
                          }
                          HEAP8[($6_1 + 24 | 0) >> 0] = 48;
                          $10_1 = $17_1;
                        }
                        label$65: {
                          label$66: {
                            if (($11_1 | 0) == ($18_1 | 0)) {
                              break label$66;
                            }
                            if ($10_1 >>> 0 <= ($6_1 + 16 | 0) >>> 0) {
                              break label$65;
                            }
                            label$67: while (1) {
                              $10_1 = $10_1 + -1 | 0;
                              HEAP8[$10_1 >> 0] = 48;
                              if ($10_1 >>> 0 > ($6_1 + 16 | 0) >>> 0) {
                                continue label$67;
                              }
                              break label$65;
                            };
                          }
                          $32($0_1 | 0, $10_1 | 0, 1 | 0);
                          $10_1 = $10_1 + 1 | 0;
                          if (!($15_1 | $21_1 | 0)) {
                            break label$65;
                          }
                          $32($0_1 | 0, 65595 | 0, 1 | 0);
                        }
                        $12_1 = $3_1 - $10_1 | 0;
                        $32($0_1 | 0, $10_1 | 0, (($15_1 | 0) > ($12_1 | 0) ? $12_1 : $15_1) | 0);
                        $15_1 = $15_1 - $12_1 | 0;
                        $11_1 = $11_1 + 4 | 0;
                        if ($11_1 >>> 0 >= $22_1 >>> 0) {
                          break label$62;
                        }
                        if (($15_1 | 0) > (-1 | 0)) {
                          continue label$63;
                        }
                        break label$63;
                      };
                    }
                    $38($0_1 | 0, 48 | 0, $15_1 + 18 | 0 | 0, 18 | 0, 0 | 0);
                    $32($0_1 | 0, $19_1 | 0, $13_1 - $19_1 | 0 | 0);
                    break label$50;
                  }
                  $10_1 = $15_1;
                }
                $38($0_1 | 0, 48 | 0, $10_1 + 9 | 0 | 0, 9 | 0, 0 | 0);
              }
              $38($0_1 | 0, 32 | 0, $2_1 | 0, $23_1 | 0, $4_1 ^ 8192 | 0 | 0);
              $12_1 = ($23_1 | 0) > ($2_1 | 0) ? $23_1 : $2_1;
              break label$4;
            }
            $23_1 = $9_1 + ((($5_1 << 26 | 0) >> 31 | 0) & 9 | 0) | 0;
            label$68: {
              if ($3_1 >>> 0 > 11 >>> 0) {
                break label$68;
              }
              $10_1 = 12 - $3_1 | 0;
              $26_1 = 16.0;
              label$69: while (1) {
                $26_1 = $26_1 * 16.0;
                $10_1 = $10_1 + -1 | 0;
                if ($10_1) {
                  continue label$69;
                }
                break label$69;
              };
              label$70: {
                if ((HEAPU8[$23_1 >> 0] | 0 | 0) != (45 | 0)) {
                  break label$70;
                }
                $1_1 = -($26_1 + (-$1_1 - $26_1));
                break label$68;
              }
              $1_1 = $1_1 + $26_1 - $26_1;
            }
            label$71: {
              $10_1 = HEAP32[($6_1 + 44 | 0) >> 2] | 0;
              $855 = $10_1;
              $10_1 = $10_1 >> 31 | 0;
              i64toi32_i32$0 = 0;
              $10_1 = $37(($855 ^ $10_1 | 0) - $10_1 | 0 | 0, i64toi32_i32$0 | 0, $13_1 | 0) | 0;
              if (($10_1 | 0) != ($13_1 | 0)) {
                break label$71;
              }
              HEAP8[($6_1 + 15 | 0) >> 0] = 48;
              $10_1 = $6_1 + 15 | 0;
            }
            $21_1 = $8_1 | 2 | 0;
            $18_1 = $5_1 & 32 | 0;
            $11_1 = HEAP32[($6_1 + 44 | 0) >> 2] | 0;
            $22_1 = $10_1 + -2 | 0;
            HEAP8[$22_1 >> 0] = $5_1 + 15 | 0;
            HEAP8[($10_1 + -1 | 0) >> 0] = ($11_1 | 0) < (0 | 0) ? 45 : 43;
            $12_1 = $4_1 & 8 | 0;
            $11_1 = $6_1 + 16 | 0;
            label$72: while (1) {
              $10_1 = $11_1;
              label$73: {
                label$74: {
                  if (!(Math_abs($1_1) < 2147483648.0)) {
                    break label$74;
                  }
                  $11_1 = ~~$1_1;
                  break label$73;
                }
                $11_1 = -2147483648;
              }
              HEAP8[$10_1 >> 0] = HEAPU8[($11_1 + 66080 | 0) >> 0] | 0 | $18_1 | 0;
              $1_1 = ($1_1 - +($11_1 | 0)) * 16.0;
              label$75: {
                $11_1 = $10_1 + 1 | 0;
                if (($11_1 - ($6_1 + 16 | 0) | 0 | 0) != (1 | 0)) {
                  break label$75;
                }
                label$76: {
                  if ($12_1) {
                    break label$76;
                  }
                  if (($3_1 | 0) > (0 | 0)) {
                    break label$76;
                  }
                  if ($1_1 == 0.0) {
                    break label$75;
                  }
                }
                HEAP8[($10_1 + 1 | 0) >> 0] = 46;
                $11_1 = $10_1 + 2 | 0;
              }
              if ($1_1 != 0.0) {
                continue label$72;
              }
              break label$72;
            };
            $12_1 = -1;
            $18_1 = $13_1 - $22_1 | 0;
            $19_1 = $21_1 + $18_1 | 0;
            if ((2147483645 - $19_1 | 0 | 0) < ($3_1 | 0)) {
              break label$4;
            }
            $10_1 = $11_1 - ($6_1 + 16 | 0) | 0;
            $3_1 = $3_1 ? ($10_1 + -2 | 0 | 0) < ($3_1 | 0) ? $3_1 + 2 | 0 : $10_1 : $10_1;
            $11_1 = $19_1 + $3_1 | 0;
            $38($0_1 | 0, 32 | 0, $2_1 | 0, $11_1 | 0, $4_1 | 0);
            $32($0_1 | 0, $23_1 | 0, $21_1 | 0);
            $38($0_1 | 0, 48 | 0, $2_1 | 0, $11_1 | 0, $4_1 ^ 65536 | 0 | 0);
            $32($0_1 | 0, $6_1 + 16 | 0 | 0, $10_1 | 0);
            $38($0_1 | 0, 48 | 0, $3_1 - $10_1 | 0 | 0, 0 | 0, 0 | 0);
            $32($0_1 | 0, $22_1 | 0, $18_1 | 0);
            $38($0_1 | 0, 32 | 0, $2_1 | 0, $11_1 | 0, $4_1 ^ 8192 | 0 | 0);
            $12_1 = ($11_1 | 0) > ($2_1 | 0) ? $11_1 : $2_1;
          }
          global$0 = $6_1 + 560 | 0;
          return $12_1 | 0;
        }

        function $41($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var i64toi32_i32$2 = 0,i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,$2_1 = 0,$12_1 = 0,$12$hi = 0,$15_1 = 0,$15$hi = 0,wasm2js_i32$0 = 0,wasm2js_f64$0 = 0.0;
          $2_1 = ((HEAP32[$1_1 >> 2] | 0) + 7 | 0) & -8 | 0;
          HEAP32[$1_1 >> 2] = $2_1 + 16 | 0;
          i64toi32_i32$2 = $2_1;
          i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $12_1 = i64toi32_i32$0;
          $12$hi = i64toi32_i32$1;
          i64toi32_i32$2 = i64toi32_i32$2 + 8 | 0;
          i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $15_1 = i64toi32_i32$1;
          $15$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $12$hi;
          i64toi32_i32$1 = $15$hi;
          (wasm2js_i32$0 = $0_1, wasm2js_f64$0 = +$100($12_1 | 0, i64toi32_i32$0 | 0, $15_1 | 0, i64toi32_i32$1 | 0)), HEAPF64[wasm2js_i32$0 >> 3] = wasm2js_f64$0;
        }

        function $42($0_1) {
          $0_1 = +$0_1;
          var i64toi32_i32$0 = 0,i64toi32_i32$1 = 0;
          wasm2js_scratch_store_f64(+$0_1);
          i64toi32_i32$0 = wasm2js_scratch_load_i32(1 | 0) | 0;
          i64toi32_i32$1 = wasm2js_scratch_load_i32(0 | 0) | 0;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$0;
          return i64toi32_i32$1 | 0;
        }

        function $43($0_1, $1_1, $2_1, $3_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          var $4_1 = 0,$5_1 = 0,$6_1 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $4_1 = global$0 - 160 | 0;
          global$0 = $4_1;
          $5_1 = $1_1 ? $0_1 : $4_1 + 158 | 0;
          HEAP32[($4_1 + 148 | 0) >> 2] = $5_1;
          $0_1 = -1;
          $6_1 = $1_1 + -1 | 0;
          HEAP32[($4_1 + 152 | 0) >> 2] = $6_1 >>> 0 > $1_1 >>> 0 ? 0 : $6_1;
          $4_1 = $16($4_1 | 0, 0 | 0, 144 | 0) | 0;
          HEAP32[($4_1 + 76 | 0) >> 2] = -1;
          HEAP32[($4_1 + 36 | 0) >> 2] = 3;
          HEAP32[($4_1 + 80 | 0) >> 2] = -1;
          HEAP32[($4_1 + 44 | 0) >> 2] = $4_1 + 159 | 0;
          HEAP32[($4_1 + 84 | 0) >> 2] = $4_1 + 148 | 0;
          label$1: {
            label$2: {
              if (($1_1 | 0) > (-1 | 0)) {
                break label$2;
              }
              (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 61), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              break label$1;
            }
            HEAP8[$5_1 >> 0] = 0;
            $0_1 = $39($4_1 | 0, $2_1 | 0, $3_1 | 0) | 0;
          }
          global$0 = $4_1 + 160 | 0;
          return $0_1 | 0;
        }

        function $44($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $3_1 = 0,$5_1 = 0,$4_1 = 0,$7_1 = 0,$6_1 = 0;
          $3_1 = HEAP32[($0_1 + 84 | 0) >> 2] | 0;
          $4_1 = HEAP32[$3_1 >> 2] | 0;
          label$1: {
            $5_1 = HEAP32[($3_1 + 4 | 0) >> 2] | 0;
            $6_1 = HEAP32[($0_1 + 28 | 0) >> 2] | 0;
            $7_1 = (HEAP32[($0_1 + 20 | 0) >> 2] | 0) - $6_1 | 0;
            $7_1 = $5_1 >>> 0 < $7_1 >>> 0 ? $5_1 : $7_1;
            if (!$7_1) {
              break label$1;
            }
            $28($4_1 | 0, $6_1 | 0, $7_1 | 0) | 0;
            $4_1 = (HEAP32[$3_1 >> 2] | 0) + $7_1 | 0;
            HEAP32[$3_1 >> 2] = $4_1;
            $5_1 = (HEAP32[($3_1 + 4 | 0) >> 2] | 0) - $7_1 | 0;
            HEAP32[($3_1 + 4 | 0) >> 2] = $5_1;
          }
          label$2: {
            $5_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $5_1 : $2_1;
            if (!$5_1) {
              break label$2;
            }
            $28($4_1 | 0, $1_1 | 0, $5_1 | 0) | 0;
            $4_1 = (HEAP32[$3_1 >> 2] | 0) + $5_1 | 0;
            HEAP32[$3_1 >> 2] = $4_1;
            HEAP32[($3_1 + 4 | 0) >> 2] = (HEAP32[($3_1 + 4 | 0) >> 2] | 0) - $5_1 | 0;
          }
          HEAP8[$4_1 >> 0] = 0;
          $3_1 = HEAP32[($0_1 + 44 | 0) >> 2] | 0;
          HEAP32[($0_1 + 28 | 0) >> 2] = $3_1;
          HEAP32[($0_1 + 20 | 0) >> 2] = $3_1;
          return $2_1 | 0;
        }

        function $45($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          return $43($0_1 | 0, 2147483647 | 0, $1_1 | 0, $2_1 | 0) | 0 | 0;
        }

        function $46($0_1) {
          $0_1 = $0_1 | 0;
          var $1_1 = 0,$2_1 = 0;
          $1_1 = HEAP32[($0_1 + 72 | 0) >> 2] | 0;
          HEAP32[($0_1 + 72 | 0) >> 2] = $1_1 + -1 | 0 | $1_1 | 0;
          label$1: {
            if ((HEAP32[($0_1 + 20 | 0) >> 2] | 0 | 0) == (HEAP32[($0_1 + 28 | 0) >> 2] | 0 | 0)) {
              break label$1;
            }
            FUNCTION_TABLE[HEAP32[($0_1 + 36 | 0) >> 2] | 0 | 0]($0_1, 0, 0) | 0;
          }
          HEAP32[($0_1 + 28 | 0) >> 2] = 0;
          HEAP32[($0_1 + 16 | 0) >> 2] = 0;
          HEAP32[($0_1 + 20 | 0) >> 2] = 0;
          label$2: {
            $1_1 = HEAP32[$0_1 >> 2] | 0;
            if (!($1_1 & 4 | 0)) {
              break label$2;
            }
            HEAP32[$0_1 >> 2] = $1_1 | 32 | 0;
            return -1 | 0;
          }
          $2_1 = (HEAP32[($0_1 + 44 | 0) >> 2] | 0) + (HEAP32[($0_1 + 48 | 0) >> 2] | 0) | 0;
          HEAP32[($0_1 + 8 | 0) >> 2] = $2_1;
          HEAP32[($0_1 + 4 | 0) >> 2] = $2_1;
          return ($1_1 << 27 | 0) >> 31 | 0 | 0;
        }

        function $47($0_1) {
          $0_1 = $0_1 | 0;
          var $1_1 = 0,$2_1 = 0;
          $1_1 = global$0 - 16 | 0;
          global$0 = $1_1;
          $2_1 = -1;
          label$1: {
            if ($46($0_1 | 0) | 0) {
              break label$1;
            }
            if ((FUNCTION_TABLE[HEAP32[($0_1 + 32 | 0) >> 2] | 0 | 0]($0_1, $1_1 + 15 | 0, 1) | 0 | 0) != (1 | 0)) {
              break label$1;
            }
            $2_1 = HEAPU8[($1_1 + 15 | 0) >> 0] | 0;
          }
          global$0 = $1_1 + 16 | 0;
          return $2_1 | 0;
        }

        function $48($0_1, $1_1, $1$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          var i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,$2_1 = 0,$3_1 = 0,i64toi32_i32$2 = 0,$11_1 = 0,$12_1 = 0,$14_1 = 0,$13_1 = 0,$21$hi = 0,i64toi32_i32$3 = 0;
          i64toi32_i32$0 = $1$hi;
          i64toi32_i32$1 = $0_1;
          HEAP32[(i64toi32_i32$1 + 112 | 0) >> 2] = $1_1;
          HEAP32[(i64toi32_i32$1 + 116 | 0) >> 2] = $1$hi;
          $2_1 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
          i64toi32_i32$1 = (HEAP32[(i64toi32_i32$1 + 44 | 0) >> 2] | 0) - $2_1 | 0;
          i64toi32_i32$0 = i64toi32_i32$1 >> 31 | 0;
          $13_1 = i64toi32_i32$1;
          i64toi32_i32$1 = $0_1;
          HEAP32[(i64toi32_i32$1 + 120 | 0) >> 2] = $13_1;
          HEAP32[(i64toi32_i32$1 + 124 | 0) >> 2] = i64toi32_i32$0;
          $3_1 = HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] | 0;
          label$1: {
            i64toi32_i32$0 = $1$hi;
            if (!($1_1 | $1$hi | 0)) {
              break label$1;
            }
            i64toi32_i32$1 = $3_1 - $2_1 | 0;
            i64toi32_i32$0 = i64toi32_i32$1 >> 31 | 0;
            $21$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$0 = $21$hi;
            i64toi32_i32$2 = i64toi32_i32$1;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$3 = $1_1;
            if ((i64toi32_i32$0 | 0) < (i64toi32_i32$1 | 0)) {
              $11_1 = 1;
            } else {
              if ((i64toi32_i32$0 | 0) <= (i64toi32_i32$1 | 0)) {
                if (i64toi32_i32$2 >>> 0 > i64toi32_i32$3 >>> 0) {
                  $12_1 = 0;
                } else {
                  $12_1 = 1;
                }
                $14_1 = $12_1;
              } else {
                $14_1 = 0;
              }
              $11_1 = $14_1;
            }
            if ($11_1) {
              break label$1;
            }
            i64toi32_i32$2 = $1$hi;
            $3_1 = $2_1 + $1_1 | 0;
          }
          HEAP32[($0_1 + 104 | 0) >> 2] = $3_1;
        }

        function $49($0_1) {
          $0_1 = $0_1 | 0;
          var i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$5 = 0,i64toi32_i32$0 = 0,i64toi32_i32$4 = 0,i64toi32_i32$3 = 0,$1_1 = 0,$4$hi = 0,$2_1 = 0,$5$hi = 0,$3_1 = 0,$5_1 = 0,$4_1 = 0,$26_1 = 0,$27_1 = 0,$28_1 = 0,$29_1 = 0,$30_1 = 0,$31_1 = 0,$7_1 = 0,$7$hi = 0,$15_1 = 0,$15$hi = 0,$35_1 = 0,$40_1 = 0,$40$hi = 0,$59_1 = 0,$59$hi = 0,$67_1 = 0,$74_1 = 0,$74$hi = 0;
          i64toi32_i32$2 = $0_1;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 120 | 0) >> 2] | 0;
          i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 124 | 0) >> 2] | 0;
          $7_1 = i64toi32_i32$0;
          $7$hi = i64toi32_i32$1;
          $1_1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $2_1 = HEAP32[(i64toi32_i32$2 + 44 | 0) >> 2] | 0;
          i64toi32_i32$0 = $1_1 - $2_1 | 0;
          i64toi32_i32$1 = i64toi32_i32$0 >> 31 | 0;
          $15_1 = i64toi32_i32$0;
          $15$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $7$hi;
          i64toi32_i32$2 = $7_1;
          i64toi32_i32$0 = $15$hi;
          i64toi32_i32$3 = $15_1;
          i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
          i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$0 | 0;
          if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
            i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
          }
          $4_1 = i64toi32_i32$4;
          $4$hi = i64toi32_i32$5;
          label$1: {
            label$2: {
              label$3: {
                i64toi32_i32$1 = $0_1;
                i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 112 | 0) >> 2] | 0;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 116 | 0) >> 2] | 0;
                $5_1 = i64toi32_i32$5;
                $5$hi = i64toi32_i32$2;
                if (!(i64toi32_i32$5 | i64toi32_i32$2 | 0)) {
                  break label$3;
                }
                i64toi32_i32$2 = $4$hi;
                i64toi32_i32$2 = $5$hi;
                i64toi32_i32$2 = $4$hi;
                i64toi32_i32$1 = i64toi32_i32$4;
                i64toi32_i32$5 = $5$hi;
                i64toi32_i32$3 = $5_1;
                if ((i64toi32_i32$2 | 0) > (i64toi32_i32$5 | 0)) {
                  $26_1 = 1;
                } else {
                  if ((i64toi32_i32$2 | 0) >= (i64toi32_i32$5 | 0)) {
                    if (i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0) {
                      $27_1 = 0;
                    } else {
                      $27_1 = 1;
                    }
                    $28_1 = $27_1;
                  } else {
                    $28_1 = 0;
                  }
                  $26_1 = $28_1;
                }
                if ($26_1) {
                  break label$2;
                }
              }
              $2_1 = $47($0_1 | 0) | 0;
              if (($2_1 | 0) > (-1 | 0)) {
                break label$1;
              }
              $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
              $2_1 = HEAP32[($0_1 + 44 | 0) >> 2] | 0;
            }
            i64toi32_i32$2 = $0_1;
            i64toi32_i32$1 = -1;
            HEAP32[(i64toi32_i32$2 + 112 | 0) >> 2] = -1;
            HEAP32[(i64toi32_i32$2 + 116 | 0) >> 2] = i64toi32_i32$1;
            HEAP32[(i64toi32_i32$2 + 104 | 0) >> 2] = $1_1;
            $35_1 = i64toi32_i32$2;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$2 = $2_1 - $1_1 | 0;
            i64toi32_i32$1 = i64toi32_i32$2 >> 31 | 0;
            $40_1 = i64toi32_i32$2;
            $40$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$3 = $4_1;
            i64toi32_i32$2 = $40$hi;
            i64toi32_i32$5 = $40_1;
            i64toi32_i32$0 = i64toi32_i32$3 + i64toi32_i32$5 | 0;
            i64toi32_i32$4 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
            if (i64toi32_i32$0 >>> 0 < i64toi32_i32$5 >>> 0) {
              i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
            }
            i64toi32_i32$3 = $35_1;
            HEAP32[(i64toi32_i32$3 + 120 | 0) >> 2] = i64toi32_i32$0;
            HEAP32[(i64toi32_i32$3 + 124 | 0) >> 2] = i64toi32_i32$4;
            return -1 | 0;
          }
          i64toi32_i32$4 = $4$hi;
          i64toi32_i32$1 = $4_1;
          i64toi32_i32$3 = 0;
          i64toi32_i32$5 = 1;
          i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
          i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
          if (i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0) {
            i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
          }
          $4_1 = i64toi32_i32$2;
          $4$hi = i64toi32_i32$0;
          $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
          $3_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
          label$4: {
            i64toi32_i32$4 = $0_1;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 112 | 0) >> 2] | 0;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 116 | 0) >> 2] | 0;
            $5_1 = i64toi32_i32$0;
            $5$hi = i64toi32_i32$1;
            i64toi32_i32$4 = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$5 = 0;
            if ((i64toi32_i32$4 | 0) == (i64toi32_i32$5 | 0) & (i64toi32_i32$1 | 0) == (i64toi32_i32$0 | 0) | 0) {
              break label$4;
            }
            i64toi32_i32$4 = i64toi32_i32$1;
            i64toi32_i32$4 = $4$hi;
            i64toi32_i32$4 = i64toi32_i32$1;
            i64toi32_i32$5 = $5_1;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$0 = i64toi32_i32$2;
            i64toi32_i32$3 = i64toi32_i32$5 - i64toi32_i32$2 | 0;
            i64toi32_i32$2 = (i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0) + i64toi32_i32$1 | 0;
            i64toi32_i32$2 = i64toi32_i32$4 - i64toi32_i32$2 | 0;
            $5_1 = i64toi32_i32$3;
            $5$hi = i64toi32_i32$2;
            i64toi32_i32$5 = $3_1 - $1_1 | 0;
            i64toi32_i32$2 = i64toi32_i32$5 >> 31 | 0;
            $59_1 = i64toi32_i32$5;
            $59$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $5$hi;
            i64toi32_i32$4 = i64toi32_i32$3;
            i64toi32_i32$5 = $59$hi;
            i64toi32_i32$0 = $59_1;
            if ((i64toi32_i32$2 | 0) > (i64toi32_i32$5 | 0)) {
              $29_1 = 1;
            } else {
              if ((i64toi32_i32$2 | 0) >= (i64toi32_i32$5 | 0)) {
                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0) {
                  $30_1 = 0;
                } else {
                  $30_1 = 1;
                }
                $31_1 = $30_1;
              } else {
                $31_1 = 0;
              }
              $29_1 = $31_1;
            }
            if ($29_1) {
              break label$4;
            }
            i64toi32_i32$4 = $5$hi;
            $3_1 = $1_1 + $5_1 | 0;
          }
          HEAP32[($0_1 + 104 | 0) >> 2] = $3_1;
          $67_1 = $0_1;
          i64toi32_i32$4 = $4$hi;
          $3_1 = HEAP32[($0_1 + 44 | 0) >> 2] | 0;
          i64toi32_i32$2 = $3_1 - $1_1 | 0;
          i64toi32_i32$4 = i64toi32_i32$2 >> 31 | 0;
          $74_1 = i64toi32_i32$2;
          $74$hi = i64toi32_i32$4;
          i64toi32_i32$4 = $4$hi;
          i64toi32_i32$0 = $4_1;
          i64toi32_i32$2 = $74$hi;
          i64toi32_i32$5 = $74_1;
          i64toi32_i32$1 = i64toi32_i32$0 + i64toi32_i32$5 | 0;
          i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
          if (i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0) {
            i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
          }
          i64toi32_i32$0 = $67_1;
          HEAP32[(i64toi32_i32$0 + 120 | 0) >> 2] = i64toi32_i32$1;
          HEAP32[(i64toi32_i32$0 + 124 | 0) >> 2] = i64toi32_i32$3;
          label$5: {
            if ($1_1 >>> 0 > $3_1 >>> 0) {
              break label$5;
            }
            HEAP8[($1_1 + -1 | 0) >> 0] = $2_1;
          }
          return $2_1 | 0;
        }

        function $50($0_1, $1_1) {
          $0_1 = +$0_1;
          $1_1 = $1_1 | 0;
          var i64toi32_i32$4 = 0,i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$3 = 0,$8_1 = 0,$32_1 = 0.0,i64toi32_i32$0 = 0;
          label$1: {
            label$2: {
              if (($1_1 | 0) < (1024 | 0)) {
                break label$2;
              }
              $0_1 = $0_1 * 8988465674311579538646525.0e283;
              label$3: {
                if ($1_1 >>> 0 >= 2047 >>> 0) {
                  break label$3;
                }
                $1_1 = $1_1 + -1023 | 0;
                break label$1;
              }
              $0_1 = $0_1 * 8988465674311579538646525.0e283;
              $1_1 = (($1_1 | 0) < (3069 | 0) ? $1_1 : 3069) + -2046 | 0;
              break label$1;
            }
            if (($1_1 | 0) > (-1023 | 0)) {
              break label$1;
            }
            $0_1 = $0_1 * 2.004168360008973e-292;
            label$4: {
              if ($1_1 >>> 0 <= -1992 >>> 0) {
                break label$4;
              }
              $1_1 = $1_1 + 969 | 0;
              break label$1;
            }
            $0_1 = $0_1 * 2.004168360008973e-292;
            $1_1 = (($1_1 | 0) > (-2960 | 0) ? $1_1 : -2960) + 1938 | 0;
          }
          $32_1 = $0_1;
          i64toi32_i32$0 = 0;
          i64toi32_i32$2 = $1_1 + 1023 | 0;
          i64toi32_i32$1 = 0;
          i64toi32_i32$3 = 52;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
            $8_1 = 0;
          } else {
            i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$4 | 0) | 0;
            $8_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
          }
          wasm2js_scratch_store_i32(0 | 0, $8_1 | 0);
          wasm2js_scratch_store_i32(1 | 0, i64toi32_i32$1 | 0);
          return +($32_1 * +wasm2js_scratch_load_f64());
        }

        function $51($0_1, $1_1, $1$hi, $2_1, $2$hi, $3_1, $3$hi, $4_1, $4$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          $3$hi = $3$hi | 0;
          $4_1 = $4_1 | 0;
          $4$hi = $4$hi | 0;
          var i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$4 = 0,i64toi32_i32$3 = 0,$22_1 = 0,$23_1 = 0,$24_1 = 0,$7_1 = 0,$11_1 = 0,$18$hi = 0,$20_1 = 0,$20$hi = 0,$21_1 = 0;
          i64toi32_i32$0 = $1$hi;
          i64toi32_i32$1 = $0_1;
          HEAP32[i64toi32_i32$1 >> 2] = $1_1;
          HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
          $7_1 = i64toi32_i32$1;
          i64toi32_i32$0 = $4$hi;
          i64toi32_i32$2 = $4_1;
          i64toi32_i32$1 = 0;
          i64toi32_i32$3 = 48;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$1 = 0;
            $22_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
          } else {
            i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
            $22_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
          }
          $11_1 = $22_1 & 32768 | 0;
          i64toi32_i32$1 = $2$hi;
          i64toi32_i32$0 = $2_1;
          i64toi32_i32$2 = 2147418112;
          i64toi32_i32$3 = 0;
          i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
          i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$3 | 0;
          i64toi32_i32$0 = 0;
          i64toi32_i32$3 = 48;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$0 = 0;
            $23_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
          } else {
            i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
            $23_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
          }
          i64toi32_i32$0 = 0;
          i64toi32_i32$2 = $11_1 | $23_1 | 0;
          i64toi32_i32$1 = 0;
          i64toi32_i32$3 = 48;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
            $24_1 = 0;
          } else {
            i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$4 | 0) | 0;
            $24_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
          }
          $18$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $2$hi;
          i64toi32_i32$0 = $2_1;
          i64toi32_i32$2 = 65535;
          i64toi32_i32$3 = -1;
          i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
          $20_1 = i64toi32_i32$0 & i64toi32_i32$3 | 0;
          $20$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $18$hi;
          i64toi32_i32$1 = $24_1;
          i64toi32_i32$0 = $20$hi;
          i64toi32_i32$3 = $20_1;
          i64toi32_i32$0 = i64toi32_i32$2 | i64toi32_i32$0 | 0;
          $21_1 = i64toi32_i32$1 | i64toi32_i32$3 | 0;
          i64toi32_i32$1 = $7_1;
          HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] = $21_1;
          HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = i64toi32_i32$0;
        }

        function $52($0_1, $1_1, $1$hi, $2_1, $2$hi, $3_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          var i64toi32_i32$2 = 0,i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,i64toi32_i32$3 = 0,$4_1 = 0,i64toi32_i32$4 = 0,$20_1 = 0,$70_1 = 0,$71_1 = 0,$71$hi = 0,$72_1 = 0,$72$hi = 0,$76$hi = 0,$80_1 = 0,$83_1 = 0;
          $4_1 = global$0 - 80 | 0;
          global$0 = $4_1;
          label$1: {
            label$2: {
              if (($3_1 | 0) < (16384 | 0)) {
                break label$2;
              }
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$0 = $2$hi;
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$1 = $2$hi;
              i64toi32_i32$2 = 0;
              i64toi32_i32$3 = 2147352576;
              $97($4_1 + 32 | 0 | 0, $1_1 | 0, i64toi32_i32$0 | 0, $2_1 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$3 | 0);
              i64toi32_i32$1 = ($4_1 + 32 | 0) + 8 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $2_1 = i64toi32_i32$3;
              $2$hi = i64toi32_i32$2;
              i64toi32_i32$1 = $4_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 32 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$1 + 36 | 0) >> 2] | 0;
              $1_1 = i64toi32_i32$2;
              $1$hi = i64toi32_i32$3;
              label$3: {
                if ($3_1 >>> 0 >= 32767 >>> 0) {
                  break label$3;
                }
                $3_1 = $3_1 + -16383 | 0;
                break label$1;
              }
              i64toi32_i32$3 = $1$hi;
              i64toi32_i32$3 = $2$hi;
              i64toi32_i32$3 = $1$hi;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$1 = 0;
              i64toi32_i32$0 = 2147352576;
              $97($4_1 + 16 | 0 | 0, $1_1 | 0, i64toi32_i32$3 | 0, $2_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$0 | 0);
              $3_1 = (($3_1 | 0) < (49149 | 0) ? $3_1 : 49149) + -32766 | 0;
              i64toi32_i32$2 = ($4_1 + 16 | 0) + 8 | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $2_1 = i64toi32_i32$0;
              $2$hi = i64toi32_i32$1;
              i64toi32_i32$2 = $4_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 16 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 20 | 0) >> 2] | 0;
              $1_1 = i64toi32_i32$1;
              $1$hi = i64toi32_i32$0;
              break label$1;
            }
            if (($3_1 | 0) > (-16383 | 0)) {
              break label$1;
            }
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$2 = 0;
            i64toi32_i32$3 = 7471104;
            $97($4_1 + 64 | 0 | 0, $1_1 | 0, i64toi32_i32$0 | 0, $2_1 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$3 | 0);
            i64toi32_i32$1 = ($4_1 + 64 | 0) + 8 | 0;
            i64toi32_i32$3 = HEAP32[i64toi32_i32$1 >> 2] | 0;
            i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
            $2_1 = i64toi32_i32$3;
            $2$hi = i64toi32_i32$2;
            i64toi32_i32$1 = $4_1;
            i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 64 | 0) >> 2] | 0;
            i64toi32_i32$3 = HEAP32[(i64toi32_i32$1 + 68 | 0) >> 2] | 0;
            $1_1 = i64toi32_i32$2;
            $1$hi = i64toi32_i32$3;
            label$4: {
              if ($3_1 >>> 0 <= -32652 >>> 0) {
                break label$4;
              }
              $3_1 = $3_1 + 16269 | 0;
              break label$1;
            }
            i64toi32_i32$3 = $1$hi;
            i64toi32_i32$3 = $2$hi;
            i64toi32_i32$3 = $1$hi;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$1 = 0;
            i64toi32_i32$0 = 7471104;
            $97($4_1 + 48 | 0 | 0, $1_1 | 0, i64toi32_i32$3 | 0, $2_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$0 | 0);
            $3_1 = (($3_1 | 0) > (-48920 | 0) ? $3_1 : -48920) + 32538 | 0;
            i64toi32_i32$2 = ($4_1 + 48 | 0) + 8 | 0;
            i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
            $2_1 = i64toi32_i32$0;
            $2$hi = i64toi32_i32$1;
            i64toi32_i32$2 = $4_1;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 48 | 0) >> 2] | 0;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 52 | 0) >> 2] | 0;
            $1_1 = i64toi32_i32$1;
            $1$hi = i64toi32_i32$0;
          }
          $70_1 = $4_1;
          i64toi32_i32$0 = $1$hi;
          $71_1 = $1_1;
          $71$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $2$hi;
          $72_1 = $2_1;
          $72$hi = i64toi32_i32$0;
          i64toi32_i32$0 = 0;
          i64toi32_i32$2 = $3_1 + 16383 | 0;
          i64toi32_i32$1 = 0;
          i64toi32_i32$3 = 48;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
            $20_1 = 0;
          } else {
            i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$4 | 0) | 0;
            $20_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
          }
          $76$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $71$hi;
          i64toi32_i32$2 = $72$hi;
          i64toi32_i32$0 = 0;
          i64toi32_i32$3 = $76$hi;
          $97($70_1 | 0, $71_1 | 0, i64toi32_i32$1 | 0, $72_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$0 | 0, $20_1 | 0, i64toi32_i32$3 | 0);
          i64toi32_i32$2 = $4_1 + 8 | 0;
          i64toi32_i32$3 = HEAP32[i64toi32_i32$2 >> 2] | 0;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $80_1 = i64toi32_i32$3;
          i64toi32_i32$3 = $0_1;
          HEAP32[(i64toi32_i32$3 + 8 | 0) >> 2] = $80_1;
          HEAP32[(i64toi32_i32$3 + 12 | 0) >> 2] = i64toi32_i32$0;
          i64toi32_i32$2 = $4_1;
          i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
          i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $83_1 = i64toi32_i32$0;
          i64toi32_i32$0 = $0_1;
          HEAP32[i64toi32_i32$0 >> 2] = $83_1;
          HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$3;
          global$0 = i64toi32_i32$2 + 80 | 0;
        }

        function $53($0_1, $0$hi, $1_1, $1$hi) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          var i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$3 = 0,i64toi32_i32$4 = 0,$2$hi = 0,$2_1 = 0,$13_1 = 0,$3_1 = 0,$4_1 = 0;
          i64toi32_i32$0 = $1$hi;
          i64toi32_i32$2 = $1_1;
          i64toi32_i32$1 = 65535;
          i64toi32_i32$3 = -1;
          i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
          $2_1 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
          $2$hi = i64toi32_i32$1;
          label$1: {
            label$2: {
              i64toi32_i32$1 = i64toi32_i32$0;
              i64toi32_i32$0 = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              i64toi32_i32$3 = 48;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = 0;
                $13_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                $13_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
              }
              $3_1 = $13_1 & 32767 | 0;
              if (($3_1 | 0) == (32767 | 0)) {
                break label$2;
              }
              $4_1 = 4;
              if ($3_1) {
                break label$1;
              }
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$2 = $0$hi;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$1 = $2_1;
              i64toi32_i32$0 = $0$hi;
              i64toi32_i32$3 = $0_1;
              i64toi32_i32$0 = i64toi32_i32$2 | i64toi32_i32$0 | 0;
              return (!(i64toi32_i32$1 | i64toi32_i32$3 | 0 | i64toi32_i32$0 | 0) ? 2 : 3) | 0;
            }
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$0 = $0$hi;
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$2 = $2_1;
            i64toi32_i32$1 = $0$hi;
            i64toi32_i32$3 = $0_1;
            i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
            $4_1 = !(i64toi32_i32$2 | i64toi32_i32$3 | 0 | i64toi32_i32$1 | 0);
          }
          return $4_1 | 0;
        }

        function $54($0_1, $1_1, $1$hi, $2_1, $2$hi, $3_1, $3$hi, $4_1, $4$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          $3$hi = $3$hi | 0;
          $4_1 = $4_1 | 0;
          $4$hi = $4$hi | 0;
          var i64toi32_i32$3 = 0,i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$4 = 0,$5_1 = 0,i64toi32_i32$5 = 0,$10$hi = 0,$10_1 = 0,$9$hi = 0,$8_1 = 0,$9_1 = 0,i64toi32_i32$6 = 0,$6_1 = 0,$11$hi = 0,$52_1 = 0,$7_1 = 0,$53_1 = 0,$54_1 = 0,$55_1 = 0,$11_1 = 0,$56_1 = 0,$57_1 = 0,$58_1 = 0,$59_1 = 0,$60_1 = 0,$61_1 = 0,$62_1 = 0,$63_1 = 0,$64_1 = 0,$65_1 = 0,$66_1 = 0,$67_1 = 0,$68_1 = 0,$69_1 = 0,$70_1 = 0,$71_1 = 0,$123$hi = 0,$126 = 0,$127$hi = 0,$148 = 0,$148$hi = 0,$150$hi = 0,$153 = 0,$153$hi = 0,$155$hi = 0,$167$hi = 0,$170 = 0,$171$hi = 0,$200 = 0,$200$hi = 0,$202$hi = 0,$211 = 0,$212 = 0,$212$hi = 0,$214 = 0,$214$hi = 0,$220$hi = 0,$221 = 0,$221$hi = 0,$228 = 0,$228$hi = 0,$233$hi = 0;
          $5_1 = global$0 - 128 | 0;
          global$0 = $5_1;
          label$1: {
            label$2: {
              label$3: {
                i64toi32_i32$0 = $3$hi;
                i64toi32_i32$0 = $4$hi;
                i64toi32_i32$0 = $3$hi;
                i64toi32_i32$1 = $4$hi;
                i64toi32_i32$2 = 0;
                i64toi32_i32$3 = 0;
                if (!($87($3_1 | 0, i64toi32_i32$0 | 0, $4_1 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$3 | 0) | 0)) {
                  break label$3;
                }
                i64toi32_i32$3 = i64toi32_i32$0;
                i64toi32_i32$3 = i64toi32_i32$1;
                i64toi32_i32$3 = i64toi32_i32$0;
                i64toi32_i32$2 = i64toi32_i32$1;
                $6_1 = $53($3_1 | 0, i64toi32_i32$0 | 0, $4_1 | 0, i64toi32_i32$1 | 0) | 0;
                i64toi32_i32$2 = $2$hi;
                i64toi32_i32$1 = $2_1;
                i64toi32_i32$3 = 0;
                i64toi32_i32$0 = 48;
                i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                  i64toi32_i32$3 = 0;
                  $52_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                } else {
                  i64toi32_i32$3 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                  $52_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
                }
                $7_1 = $52_1;
                $8_1 = $7_1 & 32767 | 0;
                if (($8_1 | 0) == (32767 | 0)) {
                  break label$3;
                }
                if ($6_1) {
                  break label$2;
                }
              }
              i64toi32_i32$3 = $1$hi;
              i64toi32_i32$3 = $2$hi;
              i64toi32_i32$3 = $3$hi;
              i64toi32_i32$3 = $4$hi;
              i64toi32_i32$3 = $1$hi;
              i64toi32_i32$1 = $2$hi;
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$0 = $4$hi;
              $97($5_1 + 16 | 0 | 0, $1_1 | 0, i64toi32_i32$3 | 0, $2_1 | 0, i64toi32_i32$1 | 0, $3_1 | 0, i64toi32_i32$2 | 0, $4_1 | 0, i64toi32_i32$0 | 0);
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 16 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 20 | 0) >> 2] | 0;
              $4_1 = i64toi32_i32$0;
              $4$hi = i64toi32_i32$2;
              i64toi32_i32$1 = (i64toi32_i32$1 + 16 | 0) + 8 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $3_1 = i64toi32_i32$2;
              $3$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $4$hi;
              i64toi32_i32$0 = $3$hi;
              i64toi32_i32$0 = $4$hi;
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$1 = i64toi32_i32$0;
              i64toi32_i32$3 = i64toi32_i32$2;
              $89($5_1 | 0, $4_1 | 0, i64toi32_i32$0 | 0, $3_1 | 0, i64toi32_i32$2 | 0, $4_1 | 0, i64toi32_i32$0 | 0, $3_1 | 0, i64toi32_i32$2 | 0);
              i64toi32_i32$2 = $5_1 + 8 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $2_1 = i64toi32_i32$3;
              $2$hi = i64toi32_i32$1;
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $4_1 = i64toi32_i32$1;
              $4$hi = i64toi32_i32$3;
              break label$1;
            }
            label$4: {
              i64toi32_i32$3 = $1$hi;
              i64toi32_i32$3 = $2$hi;
              i64toi32_i32$2 = $2_1;
              i64toi32_i32$1 = 2147483647;
              i64toi32_i32$0 = -1;
              i64toi32_i32$1 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
              $9_1 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
              $9$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $3$hi;
              i64toi32_i32$1 = $4$hi;
              i64toi32_i32$3 = $4_1;
              i64toi32_i32$2 = 2147483647;
              i64toi32_i32$0 = -1;
              i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
              $10_1 = i64toi32_i32$3 & i64toi32_i32$0 | 0;
              $10$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $1$hi;
              i64toi32_i32$3 = $9$hi;
              i64toi32_i32$1 = $3$hi;
              i64toi32_i32$0 = $10$hi;
              if (($87($1_1 | 0, i64toi32_i32$2 | 0, $9_1 | 0, i64toi32_i32$3 | 0, $3_1 | 0, i64toi32_i32$1 | 0, $10_1 | 0, i64toi32_i32$0 | 0) | 0 | 0) > (0 | 0)) {
                break label$4;
              }
              label$5: {
                i64toi32_i32$0 = i64toi32_i32$2;
                i64toi32_i32$0 = i64toi32_i32$3;
                i64toi32_i32$0 = i64toi32_i32$1;
                i64toi32_i32$0 = $10$hi;
                i64toi32_i32$0 = i64toi32_i32$2;
                i64toi32_i32$1 = i64toi32_i32$3;
                i64toi32_i32$3 = $3$hi;
                i64toi32_i32$2 = $10$hi;
                if (!($87($1_1 | 0, i64toi32_i32$0 | 0, $9_1 | 0, i64toi32_i32$1 | 0, $3_1 | 0, i64toi32_i32$3 | 0, $10_1 | 0, i64toi32_i32$2 | 0) | 0)) {
                  break label$5;
                }
                i64toi32_i32$2 = i64toi32_i32$0;
                i64toi32_i32$2 = i64toi32_i32$0;
                $4_1 = $1_1;
                $4$hi = i64toi32_i32$0;
                break label$1;
              }
              i64toi32_i32$2 = $1$hi;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$2 = $1$hi;
              i64toi32_i32$3 = $2$hi;
              i64toi32_i32$1 = 0;
              i64toi32_i32$0 = 0;
              $97($5_1 + 112 | 0 | 0, $1_1 | 0, i64toi32_i32$2 | 0, $2_1 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$0 | 0);
              i64toi32_i32$3 = $5_1 + 120 | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $2_1 = i64toi32_i32$0;
              $2$hi = i64toi32_i32$1;
              i64toi32_i32$3 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 112 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 116 | 0) >> 2] | 0;
              $4_1 = i64toi32_i32$1;
              $4$hi = i64toi32_i32$0;
              break label$1;
            }
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$3 = $4_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$2 = 48;
            i64toi32_i32$4 = i64toi32_i32$2 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = 0;
              $53_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
            } else {
              i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              $53_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$4 | 0) | 0;
            }
            $6_1 = $53_1 & 32767 | 0;
            label$6: {
              label$7: {
                if (!$8_1) {
                  break label$7;
                }
                i64toi32_i32$1 = $1$hi;
                $4_1 = $1_1;
                $4$hi = i64toi32_i32$1;
                break label$6;
              }
              i64toi32_i32$1 = $1$hi;
              i64toi32_i32$1 = $9$hi;
              i64toi32_i32$1 = $1$hi;
              i64toi32_i32$3 = $9$hi;
              i64toi32_i32$0 = 0;
              i64toi32_i32$2 = 1081540608;
              $97($5_1 + 96 | 0 | 0, $1_1 | 0, i64toi32_i32$1 | 0, $9_1 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$2 | 0);
              i64toi32_i32$3 = $5_1 + 104 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $9_1 = i64toi32_i32$2;
              $9$hi = i64toi32_i32$0;
              i64toi32_i32$3 = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              i64toi32_i32$1 = 48;
              i64toi32_i32$4 = i64toi32_i32$1 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = 0;
                $54_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$2 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                $54_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$4 | 0) | 0;
              }
              $8_1 = $54_1 + -120 | 0;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 96 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 100 | 0) >> 2] | 0;
              $4_1 = i64toi32_i32$2;
              $4$hi = i64toi32_i32$3;
            }
            label$8: {
              if ($6_1) {
                break label$8;
              }
              i64toi32_i32$3 = $3$hi;
              i64toi32_i32$3 = $10$hi;
              i64toi32_i32$3 = $3$hi;
              i64toi32_i32$2 = $10$hi;
              i64toi32_i32$0 = 0;
              i64toi32_i32$1 = 1081540608;
              $97($5_1 + 80 | 0 | 0, $3_1 | 0, i64toi32_i32$3 | 0, $10_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$1 | 0);
              i64toi32_i32$2 = $5_1 + 88 | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $10_1 = i64toi32_i32$1;
              $10$hi = i64toi32_i32$0;
              i64toi32_i32$2 = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              i64toi32_i32$3 = 48;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $55_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                $55_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
              }
              $6_1 = $55_1 + -120 | 0;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 80 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 84 | 0) >> 2] | 0;
              $3_1 = i64toi32_i32$1;
              $3$hi = i64toi32_i32$2;
            }
            i64toi32_i32$2 = $10$hi;
            i64toi32_i32$0 = $10_1;
            i64toi32_i32$1 = 65535;
            i64toi32_i32$3 = -1;
            i64toi32_i32$1 = i64toi32_i32$2 & i64toi32_i32$1 | 0;
            i64toi32_i32$2 = i64toi32_i32$0 & i64toi32_i32$3 | 0;
            i64toi32_i32$0 = 65536;
            i64toi32_i32$3 = 0;
            i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
            $11_1 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
            $11$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $9$hi;
            i64toi32_i32$1 = $9_1;
            i64toi32_i32$2 = 65535;
            i64toi32_i32$3 = -1;
            i64toi32_i32$2 = i64toi32_i32$0 & i64toi32_i32$2 | 0;
            i64toi32_i32$0 = i64toi32_i32$1 & i64toi32_i32$3 | 0;
            i64toi32_i32$1 = 65536;
            i64toi32_i32$3 = 0;
            i64toi32_i32$1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
            $9_1 = i64toi32_i32$0 | i64toi32_i32$3 | 0;
            $9$hi = i64toi32_i32$1;
            label$9: {
              if (($8_1 | 0) <= ($6_1 | 0)) {
                break label$9;
              }
              label$10: while (1) {
                label$11: {
                  label$12: {
                    i64toi32_i32$1 = $9$hi;
                    i64toi32_i32$1 = $11$hi;
                    i64toi32_i32$1 = $9$hi;
                    i64toi32_i32$2 = $9_1;
                    i64toi32_i32$0 = $11$hi;
                    i64toi32_i32$3 = $11_1;
                    i64toi32_i32$4 = i64toi32_i32$2 - i64toi32_i32$3 | 0;
                    i64toi32_i32$6 = i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0;
                    i64toi32_i32$5 = i64toi32_i32$6 + i64toi32_i32$0 | 0;
                    i64toi32_i32$5 = i64toi32_i32$1 - i64toi32_i32$5 | 0;
                    $123$hi = i64toi32_i32$5;
                    i64toi32_i32$5 = $4$hi;
                    i64toi32_i32$5 = $3$hi;
                    i64toi32_i32$5 = $4$hi;
                    i64toi32_i32$1 = $4_1;
                    i64toi32_i32$2 = $3$hi;
                    i64toi32_i32$3 = $3_1;
                    $126 = $4$hi >>> 0 < i64toi32_i32$2 >>> 0 | (($4$hi | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0 | 0) | 0;
                    i64toi32_i32$1 = 0;
                    $127$hi = i64toi32_i32$1;
                    i64toi32_i32$1 = $123$hi;
                    i64toi32_i32$3 = i64toi32_i32$4;
                    i64toi32_i32$5 = $127$hi;
                    i64toi32_i32$2 = $126;
                    i64toi32_i32$0 = i64toi32_i32$3 - i64toi32_i32$2 | 0;
                    i64toi32_i32$6 = i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0;
                    i64toi32_i32$4 = i64toi32_i32$6 + i64toi32_i32$5 | 0;
                    i64toi32_i32$4 = i64toi32_i32$1 - i64toi32_i32$4 | 0;
                    $10_1 = i64toi32_i32$0;
                    $10$hi = i64toi32_i32$4;
                    i64toi32_i32$1 = i64toi32_i32$0;
                    i64toi32_i32$3 = 0;
                    i64toi32_i32$2 = 0;
                    if ((i64toi32_i32$4 | 0) < (i64toi32_i32$3 | 0)) {
                      $56_1 = 1;
                    } else {
                      if ((i64toi32_i32$4 | 0) <= (i64toi32_i32$3 | 0)) {
                        if (i64toi32_i32$1 >>> 0 >= i64toi32_i32$2 >>> 0) {
                          $57_1 = 0;
                        } else {
                          $57_1 = 1;
                        }
                        $58_1 = $57_1;
                      } else {
                        $58_1 = 0;
                      }
                      $56_1 = $58_1;
                    }
                    if ($56_1) {
                      break label$12;
                    }
                    label$13: {
                      i64toi32_i32$1 = $10$hi;
                      i64toi32_i32$1 = $4$hi;
                      i64toi32_i32$1 = $3$hi;
                      i64toi32_i32$1 = $4$hi;
                      i64toi32_i32$2 = $4_1;
                      i64toi32_i32$4 = $3$hi;
                      i64toi32_i32$3 = $3_1;
                      i64toi32_i32$5 = i64toi32_i32$2 - i64toi32_i32$3 | 0;
                      i64toi32_i32$6 = i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0;
                      i64toi32_i32$0 = i64toi32_i32$6 + i64toi32_i32$4 | 0;
                      i64toi32_i32$0 = i64toi32_i32$1 - i64toi32_i32$0 | 0;
                      $4_1 = i64toi32_i32$5;
                      $4$hi = i64toi32_i32$0;
                      i64toi32_i32$0 = $10$hi;
                      i64toi32_i32$1 = $10_1;
                      i64toi32_i32$2 = $4$hi;
                      i64toi32_i32$3 = $4_1;
                      i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
                      i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$3 | 0;
                      i64toi32_i32$1 = 0;
                      i64toi32_i32$3 = 0;
                      if ((i64toi32_i32$0 | 0) != (i64toi32_i32$3 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$1 | 0) | 0) {
                        break label$13;
                      }
                      i64toi32_i32$0 = $1$hi;
                      i64toi32_i32$0 = $2$hi;
                      i64toi32_i32$0 = $1$hi;
                      i64toi32_i32$2 = $2$hi;
                      i64toi32_i32$3 = 0;
                      i64toi32_i32$1 = 0;
                      $97($5_1 + 32 | 0 | 0, $1_1 | 0, i64toi32_i32$0 | 0, $2_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$1 | 0);
                      i64toi32_i32$2 = $5_1 + 40 | 0;
                      i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                      i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                      $2_1 = i64toi32_i32$1;
                      $2$hi = i64toi32_i32$3;
                      i64toi32_i32$2 = $5_1;
                      i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 32 | 0) >> 2] | 0;
                      i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 36 | 0) >> 2] | 0;
                      $4_1 = i64toi32_i32$3;
                      $4$hi = i64toi32_i32$1;
                      break label$1;
                    }
                    i64toi32_i32$1 = $10$hi;
                    i64toi32_i32$2 = $10_1;
                    i64toi32_i32$3 = 0;
                    i64toi32_i32$0 = 1;
                    i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                    if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                      i64toi32_i32$3 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                      $59_1 = 0;
                    } else {
                      i64toi32_i32$3 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
                      $59_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                    }
                    $148 = $59_1;
                    $148$hi = i64toi32_i32$3;
                    i64toi32_i32$3 = $4$hi;
                    i64toi32_i32$1 = $4_1;
                    i64toi32_i32$2 = 0;
                    i64toi32_i32$0 = 63;
                    i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                    if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                      i64toi32_i32$2 = 0;
                      $60_1 = i64toi32_i32$3 >>> i64toi32_i32$4 | 0;
                    } else {
                      i64toi32_i32$2 = i64toi32_i32$3 >>> i64toi32_i32$4 | 0;
                      $60_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$3 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
                    }
                    $150$hi = i64toi32_i32$2;
                    i64toi32_i32$2 = $148$hi;
                    i64toi32_i32$3 = $148;
                    i64toi32_i32$1 = $150$hi;
                    i64toi32_i32$0 = $60_1;
                    i64toi32_i32$1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
                    $9_1 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
                    $9$hi = i64toi32_i32$1;
                    break label$11;
                  }
                  i64toi32_i32$1 = $9$hi;
                  i64toi32_i32$2 = $9_1;
                  i64toi32_i32$3 = 0;
                  i64toi32_i32$0 = 1;
                  i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                  if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                    i64toi32_i32$3 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                    $61_1 = 0;
                  } else {
                    i64toi32_i32$3 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
                    $61_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                  }
                  $153 = $61_1;
                  $153$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = $4$hi;
                  i64toi32_i32$1 = $4_1;
                  i64toi32_i32$2 = 0;
                  i64toi32_i32$0 = 63;
                  i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                  if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                    i64toi32_i32$2 = 0;
                    $62_1 = i64toi32_i32$3 >>> i64toi32_i32$4 | 0;
                  } else {
                    i64toi32_i32$2 = i64toi32_i32$3 >>> i64toi32_i32$4 | 0;
                    $62_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$3 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
                  }
                  $155$hi = i64toi32_i32$2;
                  i64toi32_i32$2 = $153$hi;
                  i64toi32_i32$3 = $153;
                  i64toi32_i32$1 = $155$hi;
                  i64toi32_i32$0 = $62_1;
                  i64toi32_i32$1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
                  $9_1 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
                  $9$hi = i64toi32_i32$1;
                }
                i64toi32_i32$1 = $4$hi;
                i64toi32_i32$2 = $4_1;
                i64toi32_i32$3 = 0;
                i64toi32_i32$0 = 1;
                i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                  $63_1 = 0;
                } else {
                  i64toi32_i32$3 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
                  $63_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                }
                $4_1 = $63_1;
                $4$hi = i64toi32_i32$3;
                $8_1 = $8_1 + -1 | 0;
                if (($8_1 | 0) > ($6_1 | 0)) {
                  continue label$10;
                }
                break label$10;
              };
              $8_1 = $6_1;
            }
            label$14: {
              label$15: {
                i64toi32_i32$3 = $9$hi;
                i64toi32_i32$3 = $11$hi;
                i64toi32_i32$3 = $9$hi;
                i64toi32_i32$1 = $9_1;
                i64toi32_i32$2 = $11$hi;
                i64toi32_i32$0 = $11_1;
                i64toi32_i32$4 = i64toi32_i32$1 - i64toi32_i32$0 | 0;
                i64toi32_i32$6 = i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0;
                i64toi32_i32$5 = i64toi32_i32$6 + i64toi32_i32$2 | 0;
                i64toi32_i32$5 = i64toi32_i32$3 - i64toi32_i32$5 | 0;
                $167$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$5 = $3$hi;
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$3 = $4_1;
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$0 = $3_1;
                $170 = $4$hi >>> 0 < i64toi32_i32$1 >>> 0 | (($4$hi | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0;
                i64toi32_i32$3 = 0;
                $171$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $167$hi;
                i64toi32_i32$0 = i64toi32_i32$4;
                i64toi32_i32$5 = $171$hi;
                i64toi32_i32$1 = $170;
                i64toi32_i32$2 = i64toi32_i32$0 - i64toi32_i32$1 | 0;
                i64toi32_i32$6 = i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0;
                i64toi32_i32$4 = i64toi32_i32$6 + i64toi32_i32$5 | 0;
                i64toi32_i32$4 = i64toi32_i32$3 - i64toi32_i32$4 | 0;
                $10_1 = i64toi32_i32$2;
                $10$hi = i64toi32_i32$4;
                i64toi32_i32$3 = i64toi32_i32$2;
                i64toi32_i32$0 = 0;
                i64toi32_i32$1 = 0;
                if ((i64toi32_i32$4 | 0) > (i64toi32_i32$0 | 0)) {
                  $64_1 = 1;
                } else {
                  if ((i64toi32_i32$4 | 0) >= (i64toi32_i32$0 | 0)) {
                    if (i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0) {
                      $65_1 = 0;
                    } else {
                      $65_1 = 1;
                    }
                    $66_1 = $65_1;
                  } else {
                    $66_1 = 0;
                  }
                  $64_1 = $66_1;
                }
                if ($64_1) {
                  break label$15;
                }
                i64toi32_i32$3 = $9$hi;
                $10_1 = $9_1;
                $10$hi = i64toi32_i32$3;
                break label$14;
              }
              i64toi32_i32$3 = $10$hi;
              i64toi32_i32$3 = $4$hi;
              i64toi32_i32$3 = $3$hi;
              i64toi32_i32$3 = $4$hi;
              i64toi32_i32$1 = $4_1;
              i64toi32_i32$4 = $3$hi;
              i64toi32_i32$0 = $3_1;
              i64toi32_i32$5 = i64toi32_i32$1 - i64toi32_i32$0 | 0;
              i64toi32_i32$6 = i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0;
              i64toi32_i32$2 = i64toi32_i32$6 + i64toi32_i32$4 | 0;
              i64toi32_i32$2 = i64toi32_i32$3 - i64toi32_i32$2 | 0;
              $4_1 = i64toi32_i32$5;
              $4$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $10$hi;
              i64toi32_i32$3 = $10_1;
              i64toi32_i32$1 = $4$hi;
              i64toi32_i32$0 = $4_1;
              i64toi32_i32$1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
              i64toi32_i32$2 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
              i64toi32_i32$3 = 0;
              i64toi32_i32$0 = 0;
              if ((i64toi32_i32$2 | 0) != (i64toi32_i32$0 | 0) | (i64toi32_i32$1 | 0) != (i64toi32_i32$3 | 0) | 0) {
                break label$14;
              }
              i64toi32_i32$2 = $1$hi;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$2 = $1$hi;
              i64toi32_i32$1 = $2$hi;
              i64toi32_i32$0 = 0;
              i64toi32_i32$3 = 0;
              $97($5_1 + 48 | 0 | 0, $1_1 | 0, i64toi32_i32$2 | 0, $2_1 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$3 | 0);
              i64toi32_i32$1 = $5_1 + 56 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $2_1 = i64toi32_i32$3;
              $2$hi = i64toi32_i32$0;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 48 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$1 + 52 | 0) >> 2] | 0;
              $4_1 = i64toi32_i32$0;
              $4$hi = i64toi32_i32$3;
              break label$1;
            }
            label$16: {
              i64toi32_i32$3 = $10$hi;
              i64toi32_i32$1 = $10_1;
              i64toi32_i32$0 = 65535;
              i64toi32_i32$2 = -1;
              if (i64toi32_i32$3 >>> 0 > i64toi32_i32$0 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$1 >>> 0 > i64toi32_i32$2 >>> 0 | 0) | 0) {
                break label$16;
              }
              label$17: while (1) {
                i64toi32_i32$1 = $4$hi;
                i64toi32_i32$2 = $4_1;
                i64toi32_i32$3 = 0;
                i64toi32_i32$0 = 63;
                i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                  i64toi32_i32$3 = 0;
                  $67_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                } else {
                  i64toi32_i32$3 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                  $67_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
                }
                $3_1 = $67_1;
                $3$hi = i64toi32_i32$3;
                $8_1 = $8_1 + -1 | 0;
                i64toi32_i32$3 = $4$hi;
                i64toi32_i32$1 = $4_1;
                i64toi32_i32$2 = 0;
                i64toi32_i32$0 = 1;
                i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
                  $68_1 = 0;
                } else {
                  i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$4 | 0) | 0;
                  $68_1 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
                }
                $4_1 = $68_1;
                $4$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $3$hi;
                $200 = $3_1;
                $200$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $10$hi;
                i64toi32_i32$3 = $10_1;
                i64toi32_i32$1 = 0;
                i64toi32_i32$0 = 1;
                i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$3 << i64toi32_i32$4 | 0;
                  $69_1 = 0;
                } else {
                  i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$4 | 0) | 0;
                  $69_1 = i64toi32_i32$3 << i64toi32_i32$4 | 0;
                }
                $202$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $200$hi;
                i64toi32_i32$2 = $200;
                i64toi32_i32$3 = $202$hi;
                i64toi32_i32$0 = $69_1;
                i64toi32_i32$3 = i64toi32_i32$1 | i64toi32_i32$3 | 0;
                $10_1 = i64toi32_i32$2 | i64toi32_i32$0 | 0;
                $10$hi = i64toi32_i32$3;
                i64toi32_i32$1 = $10_1;
                i64toi32_i32$2 = 65536;
                i64toi32_i32$0 = 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0) {
                  continue label$17;
                }
                break label$17;
              };
            }
            $6_1 = $7_1 & 32768 | 0;
            label$18: {
              if (($8_1 | 0) > (0 | 0)) {
                break label$18;
              }
              $211 = $5_1 + 64 | 0;
              i64toi32_i32$1 = $4$hi;
              $212 = $4_1;
              $212$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $10$hi;
              i64toi32_i32$0 = $10_1;
              i64toi32_i32$3 = 65535;
              i64toi32_i32$2 = -1;
              i64toi32_i32$3 = i64toi32_i32$1 & i64toi32_i32$3 | 0;
              $214 = i64toi32_i32$0 & i64toi32_i32$2 | 0;
              $214$hi = i64toi32_i32$3;
              i64toi32_i32$3 = 0;
              i64toi32_i32$1 = $8_1 + 120 | 0 | $6_1 | 0;
              i64toi32_i32$0 = 0;
              i64toi32_i32$2 = 48;
              i64toi32_i32$4 = i64toi32_i32$2 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
                $70_1 = 0;
              } else {
                i64toi32_i32$0 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$4 | 0) | 0;
                $70_1 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
              }
              $220$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $214$hi;
              i64toi32_i32$3 = $214;
              i64toi32_i32$1 = $220$hi;
              i64toi32_i32$2 = $70_1;
              i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
              $221 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
              $221$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $212$hi;
              i64toi32_i32$3 = $221$hi;
              i64toi32_i32$0 = 0;
              i64toi32_i32$2 = 1065811968;
              $97($211 | 0, $212 | 0, i64toi32_i32$1 | 0, $221 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$2 | 0);
              i64toi32_i32$3 = $5_1 + 72 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $2_1 = i64toi32_i32$2;
              $2$hi = i64toi32_i32$0;
              i64toi32_i32$3 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 64 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 68 | 0) >> 2] | 0;
              $4_1 = i64toi32_i32$0;
              $4$hi = i64toi32_i32$2;
              break label$1;
            }
            i64toi32_i32$2 = $10$hi;
            i64toi32_i32$3 = $10_1;
            i64toi32_i32$0 = 65535;
            i64toi32_i32$1 = -1;
            i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
            $228 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
            $228$hi = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$2 = $8_1 | $6_1 | 0;
            i64toi32_i32$3 = 0;
            i64toi32_i32$1 = 48;
            i64toi32_i32$4 = i64toi32_i32$1 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
              i64toi32_i32$3 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
              $71_1 = 0;
            } else {
              i64toi32_i32$3 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$4 | 0) | 0;
              $71_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
            }
            $233$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $228$hi;
            i64toi32_i32$0 = $228;
            i64toi32_i32$2 = $233$hi;
            i64toi32_i32$1 = $71_1;
            i64toi32_i32$2 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
            $2_1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
            $2$hi = i64toi32_i32$2;
          }
          i64toi32_i32$2 = $4$hi;
          i64toi32_i32$0 = $0_1;
          HEAP32[i64toi32_i32$0 >> 2] = $4_1;
          HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$2;
          i64toi32_i32$2 = $2$hi;
          HEAP32[(i64toi32_i32$0 + 8 | 0) >> 2] = $2_1;
          HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] = i64toi32_i32$2;
          global$0 = $5_1 + 128 | 0;
        }

        function $55($0_1, $1_1, $1$hi, $2_1, $2$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          var i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,$5_1 = 0;
          i64toi32_i32$0 = $2$hi;
          i64toi32_i32$2 = $2_1;
          i64toi32_i32$1 = 2147483647;
          i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
          $5_1 = i64toi32_i32$2 & -1 | 0;
          i64toi32_i32$2 = $0_1;
          HEAP32[(i64toi32_i32$2 + 8 | 0) >> 2] = $5_1;
          HEAP32[(i64toi32_i32$2 + 12 | 0) >> 2] = i64toi32_i32$1;
          i64toi32_i32$1 = $1$hi;
          HEAP32[i64toi32_i32$2 >> 2] = $1_1;
          HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] = i64toi32_i32$1;
        }

        function $56($0_1, $1_1, $2_1, $3_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$3 = 0,$8_1 = 0,$10_1 = 0,$10$hi = 0,$4_1 = 0,$9_1 = 0,$11_1 = 0,$11$hi = 0,$7_1 = 0,$5_1 = 0,$6_1 = 0,$20_1 = 0,$21_1 = 0,$22_1 = 0,$23_1 = 0,$24_1 = 0,$25_1 = 0,$26_1 = 0,$27_1 = 0,$28_1 = 0,$29_1 = 0,$30_1 = 0,$31_1 = 0,$32_1 = 0,$33_1 = 0,$34_1 = 0,$35_1 = 0,$36_1 = 0,$37_1 = 0,$38_1 = 0,$39_1 = 0,$40_1 = 0,$12_1 = 0,$12$hi = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $4_1 = global$0 - 48 | 0;
          global$0 = $4_1;
          i64toi32_i32$0 = 0;
          $10_1 = 0;
          $10$hi = i64toi32_i32$0;
          label$1: {
            label$2: {
              if ($2_1 >>> 0 > 2 >>> 0) {
                break label$2;
              }
              $2_1 = $2_1 << 2 | 0;
              $5_1 = HEAP32[($2_1 + 66156 | 0) >> 2] | 0;
              $6_1 = HEAP32[($2_1 + 66144 | 0) >> 2] | 0;
              label$3: while (1) {
                label$4: {
                  label$5: {
                    $2_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                    if (($2_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                      break label$5;
                    }
                    HEAP32[($1_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                    $2_1 = HEAPU8[$2_1 >> 0] | 0;
                    break label$4;
                  }
                  $2_1 = $49($1_1 | 0) | 0;
                }
                if ($57($2_1 | 0) | 0) {
                  continue label$3;
                }
                break label$3;
              };
              $7_1 = 1;
              label$6: {
                label$7: {
                  switch ($2_1 + -43 | 0 | 0) {
                    case 0:
                    case 2:
                      break label$7;
                    default:
                      break label$6;
                  };
                }
                $7_1 = ($2_1 | 0) == (45 | 0) ? -1 : 1;
                label$8: {
                  $2_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                  if (($2_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                    break label$8;
                  }
                  HEAP32[($1_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                  $2_1 = HEAPU8[$2_1 >> 0] | 0;
                  break label$6;
                }
                $2_1 = $49($1_1 | 0) | 0;
              }
              $8_1 = 0;
              label$9: {
                label$10: {
                  label$11: {
                    if (($2_1 & -33 | 0 | 0) != (73 | 0)) {
                      break label$11;
                    }
                    label$12: while (1) {
                      if (($8_1 | 0) == (7 | 0)) {
                        break label$10;
                      }
                      label$13: {
                        label$14: {
                          $2_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                          if (($2_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                            break label$14;
                          }
                          HEAP32[($1_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                          $2_1 = HEAPU8[$2_1 >> 0] | 0;
                          break label$13;
                        }
                        $2_1 = $49($1_1 | 0) | 0;
                      }
                      $9_1 = $8_1 + 65537 | 0;
                      $8_1 = $8_1 + 1 | 0;
                      if (($2_1 | 32 | 0 | 0) == (HEAP8[$9_1 >> 0] | 0 | 0)) {
                        continue label$12;
                      }
                      break label$12;
                    };
                  }
                  label$15: {
                    if (($8_1 | 0) == (3 | 0)) {
                      break label$15;
                    }
                    if (($8_1 | 0) == (8 | 0)) {
                      break label$10;
                    }
                    if (!$3_1) {
                      break label$9;
                    }
                    if ($8_1 >>> 0 < 4 >>> 0) {
                      break label$9;
                    }
                    if (($8_1 | 0) == (8 | 0)) {
                      break label$10;
                    }
                  }
                  label$16: {
                    i64toi32_i32$2 = $1_1;
                    i64toi32_i32$0 = HEAP32[($1_1 + 112 | 0) >> 2] | 0;
                    i64toi32_i32$1 = HEAP32[($1_1 + 116 | 0) >> 2] | 0;
                    $10_1 = i64toi32_i32$0;
                    $10$hi = i64toi32_i32$1;
                    i64toi32_i32$2 = i64toi32_i32$0;
                    i64toi32_i32$0 = 0;
                    i64toi32_i32$3 = 0;
                    if ((i64toi32_i32$1 | 0) < (i64toi32_i32$0 | 0)) {
                      $20_1 = 1;
                    } else {
                      if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$0 | 0)) {
                        if (i64toi32_i32$2 >>> 0 >= i64toi32_i32$3 >>> 0) {
                          $21_1 = 0;
                        } else {
                          $21_1 = 1;
                        }
                        $22_1 = $21_1;
                      } else {
                        $22_1 = 0;
                      }
                      $20_1 = $22_1;
                    }
                    if ($20_1) {
                      break label$16;
                    }
                    HEAP32[($1_1 + 4 | 0) >> 2] = (HEAP32[($1_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                  }
                  if (!$3_1) {
                    break label$10;
                  }
                  if ($8_1 >>> 0 < 4 >>> 0) {
                    break label$10;
                  }
                  i64toi32_i32$2 = $10$hi;
                  i64toi32_i32$3 = $10_1;
                  i64toi32_i32$1 = 0;
                  i64toi32_i32$0 = 0;
                  if ((i64toi32_i32$2 | 0) < (i64toi32_i32$1 | 0)) {
                    $23_1 = 1;
                  } else {
                    if ((i64toi32_i32$2 | 0) <= (i64toi32_i32$1 | 0)) {
                      if (i64toi32_i32$3 >>> 0 >= i64toi32_i32$0 >>> 0) {
                        $24_1 = 0;
                      } else {
                        $24_1 = 1;
                      }
                      $25_1 = $24_1;
                    } else {
                      $25_1 = 0;
                    }
                    $23_1 = $25_1;
                  }
                  $2_1 = $23_1;
                  label$17: while (1) {
                    label$18: {
                      if ($2_1) {
                        break label$18;
                      }
                      HEAP32[($1_1 + 4 | 0) >> 2] = (HEAP32[($1_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                    }
                    $8_1 = $8_1 + -1 | 0;
                    if ($8_1 >>> 0 > 3 >>> 0) {
                      continue label$17;
                    }
                    break label$17;
                  };
                }
                $91($4_1 | 0, Math_fround(Math_fround(Math_fround($7_1 | 0) * Math_fround(Infinity))));
                i64toi32_i32$0 = $4_1 + 8 | 0;
                i64toi32_i32$3 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                $11_1 = i64toi32_i32$3;
                $11$hi = i64toi32_i32$2;
                i64toi32_i32$0 = $4_1;
                i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                $10_1 = i64toi32_i32$2;
                $10$hi = i64toi32_i32$3;
                break label$1;
              }
              label$19: {
                label$20: {
                  label$21: {
                    label$22: {
                      label$23: {
                        if ($8_1) {
                          break label$23;
                        }
                        $8_1 = 0;
                        if (($2_1 & -33 | 0 | 0) != (78 | 0)) {
                          break label$23;
                        }
                        label$24: while (1) {
                          if (($8_1 | 0) == (2 | 0)) {
                            break label$22;
                          }
                          label$25: {
                            label$26: {
                              $2_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                              if (($2_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                                break label$26;
                              }
                              HEAP32[($1_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                              $2_1 = HEAPU8[$2_1 >> 0] | 0;
                              break label$25;
                            }
                            $2_1 = $49($1_1 | 0) | 0;
                          }
                          $9_1 = $8_1 + 65580 | 0;
                          $8_1 = $8_1 + 1 | 0;
                          if (($2_1 | 32 | 0 | 0) == (HEAP8[$9_1 >> 0] | 0 | 0)) {
                            continue label$24;
                          }
                          break label$24;
                        };
                      }
                      switch ($8_1 | 0) {
                        case 0:
                          break label$19;
                        case 3:
                          break label$22;
                        default:
                          break label$21;
                      };
                    }
                    label$27: {
                      label$28: {
                        $2_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                        if (($2_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                          break label$28;
                        }
                        HEAP32[($1_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                        $2_1 = HEAPU8[$2_1 >> 0] | 0;
                        break label$27;
                      }
                      $2_1 = $49($1_1 | 0) | 0;
                    }
                    label$29: {
                      label$30: {
                        if (($2_1 | 0) != (40 | 0)) {
                          break label$30;
                        }
                        $8_1 = 1;
                        break label$29;
                      }
                      i64toi32_i32$3 = 0;
                      $10_1 = 0;
                      $10$hi = i64toi32_i32$3;
                      i64toi32_i32$3 = 2147450880;
                      $11_1 = 0;
                      $11$hi = i64toi32_i32$3;
                      i64toi32_i32$0 = $1_1;
                      i64toi32_i32$3 = HEAP32[($1_1 + 112 | 0) >> 2] | 0;
                      i64toi32_i32$2 = HEAP32[($1_1 + 116 | 0) >> 2] | 0;
                      i64toi32_i32$0 = i64toi32_i32$3;
                      i64toi32_i32$3 = 0;
                      i64toi32_i32$1 = 0;
                      if ((i64toi32_i32$2 | 0) < (i64toi32_i32$3 | 0)) {
                        $26_1 = 1;
                      } else {
                        if ((i64toi32_i32$2 | 0) <= (i64toi32_i32$3 | 0)) {
                          if (i64toi32_i32$0 >>> 0 >= i64toi32_i32$1 >>> 0) {
                            $27_1 = 0;
                          } else {
                            $27_1 = 1;
                          }
                          $28_1 = $27_1;
                        } else {
                          $28_1 = 0;
                        }
                        $26_1 = $28_1;
                      }
                      if ($26_1) {
                        break label$1;
                      }
                      HEAP32[($1_1 + 4 | 0) >> 2] = (HEAP32[($1_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                      break label$1;
                    }
                    label$31: while (1) {
                      label$32: {
                        label$33: {
                          $2_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                          if (($2_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                            break label$33;
                          }
                          HEAP32[($1_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                          $2_1 = HEAPU8[$2_1 >> 0] | 0;
                          break label$32;
                        }
                        $2_1 = $49($1_1 | 0) | 0;
                      }
                      $9_1 = $2_1 + -65 | 0;
                      label$34: {
                        label$35: {
                          if (($2_1 + -48 | 0) >>> 0 < 10 >>> 0) {
                            break label$35;
                          }
                          if ($9_1 >>> 0 < 26 >>> 0) {
                            break label$35;
                          }
                          $9_1 = $2_1 + -97 | 0;
                          if (($2_1 | 0) == (95 | 0)) {
                            break label$35;
                          }
                          if ($9_1 >>> 0 >= 26 >>> 0) {
                            break label$34;
                          }
                        }
                        $8_1 = $8_1 + 1 | 0;
                        continue label$31;
                      }
                      break label$31;
                    };
                    i64toi32_i32$0 = 2147450880;
                    $11_1 = 0;
                    $11$hi = i64toi32_i32$0;
                    if (($2_1 | 0) == (41 | 0)) {
                      break label$1;
                    }
                    label$36: {
                      i64toi32_i32$1 = $1_1;
                      i64toi32_i32$0 = HEAP32[($1_1 + 112 | 0) >> 2] | 0;
                      i64toi32_i32$2 = HEAP32[($1_1 + 116 | 0) >> 2] | 0;
                      $12_1 = i64toi32_i32$0;
                      $12$hi = i64toi32_i32$2;
                      i64toi32_i32$1 = i64toi32_i32$0;
                      i64toi32_i32$0 = 0;
                      i64toi32_i32$3 = 0;
                      if ((i64toi32_i32$2 | 0) < (i64toi32_i32$0 | 0)) {
                        $29_1 = 1;
                      } else {
                        if ((i64toi32_i32$2 | 0) <= (i64toi32_i32$0 | 0)) {
                          if (i64toi32_i32$1 >>> 0 >= i64toi32_i32$3 >>> 0) {
                            $30_1 = 0;
                          } else {
                            $30_1 = 1;
                          }
                          $31_1 = $30_1;
                        } else {
                          $31_1 = 0;
                        }
                        $29_1 = $31_1;
                      }
                      if ($29_1) {
                        break label$36;
                      }
                      HEAP32[($1_1 + 4 | 0) >> 2] = (HEAP32[($1_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                    }
                    label$37: {
                      label$38: {
                        if (!$3_1) {
                          break label$38;
                        }
                        if ($8_1) {
                          break label$37;
                        }
                        i64toi32_i32$1 = 0;
                        $10_1 = 0;
                        $10$hi = i64toi32_i32$1;
                        break label$1;
                      }
                      (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 28), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
                      i64toi32_i32$1 = 0;
                      $10_1 = 0;
                      $10$hi = i64toi32_i32$1;
                      break label$20;
                    }
                    label$39: while (1) {
                      label$40: {
                        i64toi32_i32$1 = $12$hi;
                        i64toi32_i32$3 = $12_1;
                        i64toi32_i32$2 = 0;
                        i64toi32_i32$0 = 0;
                        if ((i64toi32_i32$1 | 0) < (i64toi32_i32$2 | 0)) {
                          $32_1 = 1;
                        } else {
                          if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$2 | 0)) {
                            if (i64toi32_i32$3 >>> 0 >= i64toi32_i32$0 >>> 0) {
                              $33_1 = 0;
                            } else {
                              $33_1 = 1;
                            }
                            $34_1 = $33_1;
                          } else {
                            $34_1 = 0;
                          }
                          $32_1 = $34_1;
                        }
                        if ($32_1) {
                          break label$40;
                        }
                        HEAP32[($1_1 + 4 | 0) >> 2] = (HEAP32[($1_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                      }
                      i64toi32_i32$3 = 0;
                      $10_1 = 0;
                      $10$hi = i64toi32_i32$3;
                      $8_1 = $8_1 + -1 | 0;
                      if ($8_1) {
                        continue label$39;
                      }
                      break label$1;
                    };
                  }
                  i64toi32_i32$3 = 0;
                  $10_1 = 0;
                  $10$hi = i64toi32_i32$3;
                  label$41: {
                    i64toi32_i32$0 = $1_1;
                    i64toi32_i32$3 = HEAP32[($1_1 + 112 | 0) >> 2] | 0;
                    i64toi32_i32$1 = HEAP32[($1_1 + 116 | 0) >> 2] | 0;
                    i64toi32_i32$0 = i64toi32_i32$3;
                    i64toi32_i32$3 = 0;
                    i64toi32_i32$2 = 0;
                    if ((i64toi32_i32$1 | 0) < (i64toi32_i32$3 | 0)) {
                      $35_1 = 1;
                    } else {
                      if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$3 | 0)) {
                        if (i64toi32_i32$0 >>> 0 >= i64toi32_i32$2 >>> 0) {
                          $36_1 = 0;
                        } else {
                          $36_1 = 1;
                        }
                        $37_1 = $36_1;
                      } else {
                        $37_1 = 0;
                      }
                      $35_1 = $37_1;
                    }
                    if ($35_1) {
                      break label$41;
                    }
                    HEAP32[($1_1 + 4 | 0) >> 2] = (HEAP32[($1_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                  }
                  (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 28), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
                }
                i64toi32_i32$0 = $10$hi;
                $48($1_1 | 0, $10_1 | 0, i64toi32_i32$0 | 0);
                break label$2;
              }
              label$42: {
                if (($2_1 | 0) != (48 | 0)) {
                  break label$42;
                }
                label$43: {
                  label$44: {
                    $8_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                    if (($8_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                      break label$44;
                    }
                    HEAP32[($1_1 + 4 | 0) >> 2] = $8_1 + 1 | 0;
                    $8_1 = HEAPU8[$8_1 >> 0] | 0;
                    break label$43;
                  }
                  $8_1 = $49($1_1 | 0) | 0;
                }
                label$45: {
                  if (($8_1 & -33 | 0 | 0) != (88 | 0)) {
                    break label$45;
                  }
                  $58($4_1 + 16 | 0 | 0, $1_1 | 0, $6_1 | 0, $5_1 | 0, $7_1 | 0, $3_1 | 0);
                  i64toi32_i32$2 = $4_1 + 24 | 0;
                  i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                  $11_1 = i64toi32_i32$0;
                  $11$hi = i64toi32_i32$1;
                  i64toi32_i32$2 = $4_1;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 16 | 0) >> 2] | 0;
                  i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 20 | 0) >> 2] | 0;
                  $10_1 = i64toi32_i32$1;
                  $10$hi = i64toi32_i32$0;
                  break label$1;
                }
                i64toi32_i32$2 = $1_1;
                i64toi32_i32$0 = HEAP32[($1_1 + 112 | 0) >> 2] | 0;
                i64toi32_i32$1 = HEAP32[($1_1 + 116 | 0) >> 2] | 0;
                i64toi32_i32$2 = i64toi32_i32$0;
                i64toi32_i32$0 = 0;
                i64toi32_i32$3 = 0;
                if ((i64toi32_i32$1 | 0) < (i64toi32_i32$0 | 0)) {
                  $38_1 = 1;
                } else {
                  if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$0 | 0)) {
                    if (i64toi32_i32$2 >>> 0 >= i64toi32_i32$3 >>> 0) {
                      $39_1 = 0;
                    } else {
                      $39_1 = 1;
                    }
                    $40_1 = $39_1;
                  } else {
                    $40_1 = 0;
                  }
                  $38_1 = $40_1;
                }
                if ($38_1) {
                  break label$42;
                }
                HEAP32[($1_1 + 4 | 0) >> 2] = (HEAP32[($1_1 + 4 | 0) >> 2] | 0) + -1 | 0;
              }
              $59($4_1 + 32 | 0 | 0, $1_1 | 0, $2_1 | 0, $6_1 | 0, $5_1 | 0, $7_1 | 0, $3_1 | 0);
              i64toi32_i32$3 = $4_1 + 40 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $11_1 = i64toi32_i32$2;
              $11$hi = i64toi32_i32$1;
              i64toi32_i32$3 = $4_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 32 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 36 | 0) >> 2] | 0;
              $10_1 = i64toi32_i32$1;
              $10$hi = i64toi32_i32$2;
              break label$1;
            }
            i64toi32_i32$2 = 0;
            $11_1 = 0;
            $11$hi = i64toi32_i32$2;
          }
          i64toi32_i32$2 = $10$hi;
          i64toi32_i32$1 = $0_1;
          HEAP32[i64toi32_i32$1 >> 2] = $10_1;
          HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$2;
          i64toi32_i32$2 = $11$hi;
          HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] = $11_1;
          HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = i64toi32_i32$2;
          global$0 = $4_1 + 48 | 0;
        }

        function $57($0_1) {
          $0_1 = $0_1 | 0;
          return ($0_1 | 0) == (32 | 0) | ($0_1 + -9 | 0) >>> 0 < 5 >>> 0 | 0 | 0;
        }

        function $58($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          $4_1 = $4_1 | 0;
          $5_1 = $5_1 | 0;
          var i64toi32_i32$3 = 0,i64toi32_i32$0 = 0,i64toi32_i32$4 = 0,i64toi32_i32$1 = 0,i64toi32_i32$5 = 0,i64toi32_i32$2 = 0,$6_1 = 0,$7_1 = 0,$16$hi = 0,$19$hi = 0,$16_1 = 0,$19_1 = 0,$15$hi = 0,$17$hi = 0,$14$hi = 0,$15_1 = 0,$17_1 = 0,$18$hi = 0,$14_1 = 0,$10_1 = 0,$18_1 = 0,$8_1 = 0,$9_1 = 0,$20$hi = 0,$12_1 = 0,$20_1 = 0,$11_1 = 0,$13_1 = 0,$104_1 = 0,$105_1 = 0,$106_1 = 0,$107_1 = 0,$108_1 = 0,$109_1 = 0,$110_1 = 0,$111_1 = 0,$112_1 = 0,$113 = 0,$114 = 0,$115 = 0,$116 = 0,$117 = 0,$118 = 0,$119 = 0,$120 = 0,$121 = 0,$122 = 0,$123 = 0,$124 = 0,$125 = 0,$127 = 0,$128 = 0,$129 = 0,$126 = 0,$126$hi = 0,$130 = 0,$130$hi = 0,$141 = 0,$141$hi = 0,$145 = 0,$145$hi = 0,$163 = 0,$163$hi = 0,$167 = 0,$167$hi = 0,$267$hi = 0,$274$hi = 0,$283 = 0,$283$hi = 0,$287 = 0,$287$hi = 0,$291 = 0,$291$hi = 0,$295 = 0,$295$hi = 0,$305 = 0,$305$hi = 0,$321$hi = 0,$131 = 0,$326 = 0,$326$hi = 0,$330$hi = 0,$132 = 0,$333 = 0,$333$hi = 0,$350$hi = 0,$358 = 0,$359 = 0,$362$hi = 0,$386 = 0,$386$hi = 0,$390 = 0,$390$hi = 0,$426 = 0,$426$hi = 0,$430 = 0,$430$hi = 0,$434 = 0,$434$hi = 0,$438 = 0,$438$hi = 0,$447 = 0,$447$hi = 0,$450 = 0,$450$hi = 0,$454 = 0,$454$hi = 0,$458 = 0,$458$hi = 0,$460 = 0,$460$hi = 0,$464 = 0,$464$hi = 0,$468 = 0,$468$hi = 0,$472 = 0,$472$hi = 0,$504 = 0,$504$hi = 0,$508 = 0,$508$hi = 0,$512 = 0,$512$hi = 0,$516 = 0,$516$hi = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $6_1 = global$0 - 432 | 0;
          global$0 = $6_1;
          label$1: {
            label$2: {
              $7_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
              if (($7_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                break label$2;
              }
              HEAP32[($1_1 + 4 | 0) >> 2] = $7_1 + 1 | 0;
              $7_1 = HEAPU8[$7_1 >> 0] | 0;
              break label$1;
            }
            $7_1 = $49($1_1 | 0) | 0;
          }
          $8_1 = 0;
          i64toi32_i32$0 = 0;
          $14_1 = 0;
          $14$hi = i64toi32_i32$0;
          $9_1 = 0;
          label$3: {
            label$4: {
              label$5: {
                label$6: while (1) {
                  label$7: {
                    if (($7_1 | 0) == (48 | 0)) {
                      break label$7;
                    }
                    if (($7_1 | 0) != (46 | 0)) {
                      break label$3;
                    }
                    $7_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                    if (($7_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                      break label$5;
                    }
                    HEAP32[($1_1 + 4 | 0) >> 2] = $7_1 + 1 | 0;
                    $7_1 = HEAPU8[$7_1 >> 0] | 0;
                    break label$4;
                  }
                  label$8: {
                    $7_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                    if (($7_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                      break label$8;
                    }
                    $9_1 = 1;
                    HEAP32[($1_1 + 4 | 0) >> 2] = $7_1 + 1 | 0;
                    $7_1 = HEAPU8[$7_1 >> 0] | 0;
                    continue label$6;
                  }
                  $9_1 = 1;
                  $7_1 = $49($1_1 | 0) | 0;
                  continue label$6;
                };
              }
              $7_1 = $49($1_1 | 0) | 0;
            }
            $8_1 = 1;
            i64toi32_i32$0 = 0;
            $14_1 = 0;
            $14$hi = i64toi32_i32$0;
            if (($7_1 | 0) != (48 | 0)) {
              break label$3;
            }
            label$9: while (1) {
              label$10: {
                label$11: {
                  $7_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                  if (($7_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                    break label$11;
                  }
                  HEAP32[($1_1 + 4 | 0) >> 2] = $7_1 + 1 | 0;
                  $7_1 = HEAPU8[$7_1 >> 0] | 0;
                  break label$10;
                }
                $7_1 = $49($1_1 | 0) | 0;
              }
              i64toi32_i32$0 = $14$hi;
              i64toi32_i32$2 = $14_1;
              i64toi32_i32$1 = -1;
              i64toi32_i32$3 = -1;
              i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
              i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
              }
              $14_1 = i64toi32_i32$4;
              $14$hi = i64toi32_i32$5;
              if (($7_1 | 0) == (48 | 0)) {
                continue label$9;
              }
              break label$9;
            };
            $8_1 = 1;
            $9_1 = 1;
          }
          i64toi32_i32$5 = 1073676288;
          $15_1 = 0;
          $15$hi = i64toi32_i32$5;
          $10_1 = 0;
          i64toi32_i32$5 = 0;
          $16_1 = 0;
          $16$hi = i64toi32_i32$5;
          i64toi32_i32$5 = 0;
          $17_1 = 0;
          $17$hi = i64toi32_i32$5;
          i64toi32_i32$5 = 0;
          $18_1 = 0;
          $18$hi = i64toi32_i32$5;
          $11_1 = 0;
          i64toi32_i32$5 = 0;
          $19_1 = 0;
          $19$hi = i64toi32_i32$5;
          label$12: {
            label$13: while (1) {
              $12_1 = $7_1;
              label$14: {
                label$15: {
                  $13_1 = $7_1 + -48 | 0;
                  if ($13_1 >>> 0 < 10 >>> 0) {
                    break label$15;
                  }
                  $12_1 = $7_1 | 32 | 0;
                  label$16: {
                    if (($7_1 | 0) == (46 | 0)) {
                      break label$16;
                    }
                    if (($12_1 + -97 | 0) >>> 0 > 5 >>> 0) {
                      break label$12;
                    }
                  }
                  if (($7_1 | 0) != (46 | 0)) {
                    break label$15;
                  }
                  if ($8_1) {
                    break label$12;
                  }
                  $8_1 = 1;
                  i64toi32_i32$5 = $19$hi;
                  $14_1 = $19_1;
                  $14$hi = i64toi32_i32$5;
                  break label$14;
                }
                $7_1 = ($7_1 | 0) > (57 | 0) ? $12_1 + -87 | 0 : $13_1;
                label$17: {
                  label$18: {
                    i64toi32_i32$5 = $19$hi;
                    i64toi32_i32$0 = $19_1;
                    i64toi32_i32$2 = 0;
                    i64toi32_i32$3 = 7;
                    if ((i64toi32_i32$5 | 0) > (i64toi32_i32$2 | 0)) {
                      $104_1 = 1;
                    } else {
                      if ((i64toi32_i32$5 | 0) >= (i64toi32_i32$2 | 0)) {
                        if (i64toi32_i32$0 >>> 0 <= i64toi32_i32$3 >>> 0) {
                          $105_1 = 0;
                        } else {
                          $105_1 = 1;
                        }
                        $106_1 = $105_1;
                      } else {
                        $106_1 = 0;
                      }
                      $104_1 = $106_1;
                    }
                    if ($104_1) {
                      break label$18;
                    }
                    $10_1 = $7_1 + ($10_1 << 4 | 0) | 0;
                    break label$17;
                  }
                  label$19: {
                    i64toi32_i32$0 = $19$hi;
                    i64toi32_i32$3 = $19_1;
                    i64toi32_i32$5 = 0;
                    i64toi32_i32$2 = 28;
                    if (i64toi32_i32$0 >>> 0 > i64toi32_i32$5 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$3 >>> 0 > i64toi32_i32$2 >>> 0 | 0) | 0) {
                      break label$19;
                    }
                    $92($6_1 + 48 | 0 | 0, $7_1 | 0);
                    i64toi32_i32$3 = $18$hi;
                    i64toi32_i32$3 = $15$hi;
                    i64toi32_i32$3 = $18$hi;
                    i64toi32_i32$0 = $15$hi;
                    i64toi32_i32$2 = 0;
                    i64toi32_i32$5 = 1073414144;
                    $97($6_1 + 32 | 0 | 0, $18_1 | 0, i64toi32_i32$3 | 0, $15_1 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$5 | 0);
                    i64toi32_i32$0 = $6_1;
                    i64toi32_i32$5 = HEAP32[(i64toi32_i32$0 + 48 | 0) >> 2] | 0;
                    i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 52 | 0) >> 2] | 0;
                    $126 = i64toi32_i32$5;
                    $126$hi = i64toi32_i32$2;
                    i64toi32_i32$0 = (i64toi32_i32$0 + 48 | 0) + 8 | 0;
                    i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                    i64toi32_i32$5 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                    $130 = i64toi32_i32$2;
                    $130$hi = i64toi32_i32$5;
                    i64toi32_i32$0 = $6_1;
                    i64toi32_i32$5 = HEAP32[(i64toi32_i32$0 + 32 | 0) >> 2] | 0;
                    i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 36 | 0) >> 2] | 0;
                    $18_1 = i64toi32_i32$5;
                    $18$hi = i64toi32_i32$2;
                    i64toi32_i32$0 = (i64toi32_i32$0 + 32 | 0) + 8 | 0;
                    i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                    i64toi32_i32$5 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                    $15_1 = i64toi32_i32$2;
                    $15$hi = i64toi32_i32$5;
                    i64toi32_i32$5 = $126$hi;
                    i64toi32_i32$2 = $130$hi;
                    i64toi32_i32$0 = $18$hi;
                    i64toi32_i32$3 = $15$hi;
                    $97($6_1 + 16 | 0 | 0, $126 | 0, i64toi32_i32$5 | 0, $130 | 0, i64toi32_i32$2 | 0, $18_1 | 0, i64toi32_i32$0 | 0, $15_1 | 0, i64toi32_i32$3 | 0);
                    i64toi32_i32$2 = $6_1;
                    i64toi32_i32$3 = HEAP32[($6_1 + 16 | 0) >> 2] | 0;
                    i64toi32_i32$0 = HEAP32[($6_1 + 20 | 0) >> 2] | 0;
                    $141 = i64toi32_i32$3;
                    $141$hi = i64toi32_i32$0;
                    i64toi32_i32$2 = ($6_1 + 16 | 0) + 8 | 0;
                    i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                    i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                    $145 = i64toi32_i32$0;
                    $145$hi = i64toi32_i32$3;
                    i64toi32_i32$3 = $16$hi;
                    i64toi32_i32$3 = $17$hi;
                    i64toi32_i32$3 = $141$hi;
                    i64toi32_i32$0 = $145$hi;
                    i64toi32_i32$2 = $16$hi;
                    i64toi32_i32$5 = $17$hi;
                    $85($6_1 | 0, $141 | 0, i64toi32_i32$3 | 0, $145 | 0, i64toi32_i32$0 | 0, $16_1 | 0, i64toi32_i32$2 | 0, $17_1 | 0, i64toi32_i32$5 | 0);
                    i64toi32_i32$0 = $6_1 + 8 | 0;
                    i64toi32_i32$5 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                    i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                    $17_1 = i64toi32_i32$5;
                    $17$hi = i64toi32_i32$2;
                    i64toi32_i32$0 = $6_1;
                    i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                    i64toi32_i32$5 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                    $16_1 = i64toi32_i32$2;
                    $16$hi = i64toi32_i32$5;
                    break label$17;
                  }
                  if (!$7_1) {
                    break label$17;
                  }
                  if ($11_1) {
                    break label$17;
                  }
                  i64toi32_i32$5 = $18$hi;
                  i64toi32_i32$5 = $15$hi;
                  i64toi32_i32$5 = $18$hi;
                  i64toi32_i32$2 = $15$hi;
                  i64toi32_i32$0 = 0;
                  i64toi32_i32$3 = 1073610752;
                  $97($6_1 + 80 | 0 | 0, $18_1 | 0, i64toi32_i32$5 | 0, $15_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$3 | 0);
                  i64toi32_i32$2 = $6_1;
                  i64toi32_i32$3 = HEAP32[($6_1 + 80 | 0) >> 2] | 0;
                  i64toi32_i32$0 = HEAP32[($6_1 + 84 | 0) >> 2] | 0;
                  $163 = i64toi32_i32$3;
                  $163$hi = i64toi32_i32$0;
                  i64toi32_i32$2 = ($6_1 + 80 | 0) + 8 | 0;
                  i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                  $167 = i64toi32_i32$0;
                  $167$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = $16$hi;
                  i64toi32_i32$3 = $17$hi;
                  i64toi32_i32$3 = $163$hi;
                  i64toi32_i32$0 = $167$hi;
                  i64toi32_i32$2 = $16$hi;
                  i64toi32_i32$5 = $17$hi;
                  $85($6_1 + 64 | 0 | 0, $163 | 0, i64toi32_i32$3 | 0, $167 | 0, i64toi32_i32$0 | 0, $16_1 | 0, i64toi32_i32$2 | 0, $17_1 | 0, i64toi32_i32$5 | 0);
                  i64toi32_i32$0 = ($6_1 + 64 | 0) + 8 | 0;
                  i64toi32_i32$5 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                  i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                  $17_1 = i64toi32_i32$5;
                  $17$hi = i64toi32_i32$2;
                  $11_1 = 1;
                  i64toi32_i32$0 = $6_1;
                  i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 64 | 0) >> 2] | 0;
                  i64toi32_i32$5 = HEAP32[(i64toi32_i32$0 + 68 | 0) >> 2] | 0;
                  $16_1 = i64toi32_i32$2;
                  $16$hi = i64toi32_i32$5;
                }
                i64toi32_i32$5 = $19$hi;
                i64toi32_i32$0 = $19_1;
                i64toi32_i32$2 = 0;
                i64toi32_i32$3 = 1;
                i64toi32_i32$1 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
                i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                }
                $19_1 = i64toi32_i32$1;
                $19$hi = i64toi32_i32$4;
                $9_1 = 1;
              }
              label$20: {
                $7_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                if (($7_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                  break label$20;
                }
                HEAP32[($1_1 + 4 | 0) >> 2] = $7_1 + 1 | 0;
                $7_1 = HEAPU8[$7_1 >> 0] | 0;
                continue label$13;
              }
              $7_1 = $49($1_1 | 0) | 0;
              continue label$13;
            };
          }
          label$21: {
            label$22: {
              if ($9_1) {
                break label$22;
              }
              label$23: {
                label$24: {
                  label$25: {
                    i64toi32_i32$5 = $1_1;
                    i64toi32_i32$4 = HEAP32[(i64toi32_i32$5 + 112 | 0) >> 2] | 0;
                    i64toi32_i32$0 = HEAP32[(i64toi32_i32$5 + 116 | 0) >> 2] | 0;
                    i64toi32_i32$5 = i64toi32_i32$4;
                    i64toi32_i32$4 = 0;
                    i64toi32_i32$3 = 0;
                    if ((i64toi32_i32$0 | 0) < (i64toi32_i32$4 | 0)) {
                      $107_1 = 1;
                    } else {
                      if ((i64toi32_i32$0 | 0) <= (i64toi32_i32$4 | 0)) {
                        if (i64toi32_i32$5 >>> 0 >= i64toi32_i32$3 >>> 0) {
                          $108_1 = 0;
                        } else {
                          $108_1 = 1;
                        }
                        $109_1 = $108_1;
                      } else {
                        $109_1 = 0;
                      }
                      $107_1 = $109_1;
                    }
                    if ($107_1) {
                      break label$25;
                    }
                    $7_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                    HEAP32[($1_1 + 4 | 0) >> 2] = $7_1 + -1 | 0;
                    if (!$5_1) {
                      break label$24;
                    }
                    HEAP32[($1_1 + 4 | 0) >> 2] = $7_1 + -2 | 0;
                    if (!$8_1) {
                      break label$23;
                    }
                    HEAP32[($1_1 + 4 | 0) >> 2] = $7_1 + -3 | 0;
                    break label$23;
                  }
                  if ($5_1) {
                    break label$23;
                  }
                }
                i64toi32_i32$5 = 0;
                $48($1_1 | 0, 0 | 0, i64toi32_i32$5 | 0);
              }
              $90($6_1 + 96 | 0 | 0, +(+($4_1 | 0) * 0.0));
              i64toi32_i32$3 = $6_1 + 104 | 0;
              i64toi32_i32$5 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $19_1 = i64toi32_i32$5;
              $19$hi = i64toi32_i32$0;
              i64toi32_i32$3 = $6_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 96 | 0) >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$3 + 100 | 0) >> 2] | 0;
              $16_1 = i64toi32_i32$0;
              $16$hi = i64toi32_i32$5;
              break label$21;
            }
            label$26: {
              i64toi32_i32$5 = $19$hi;
              i64toi32_i32$3 = $19_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$4 = 7;
              if ((i64toi32_i32$5 | 0) > (i64toi32_i32$0 | 0)) {
                $110_1 = 1;
              } else {
                if ((i64toi32_i32$5 | 0) >= (i64toi32_i32$0 | 0)) {
                  if (i64toi32_i32$3 >>> 0 <= i64toi32_i32$4 >>> 0) {
                    $111_1 = 0;
                  } else {
                    $111_1 = 1;
                  }
                  $112_1 = $111_1;
                } else {
                  $112_1 = 0;
                }
                $110_1 = $112_1;
              }
              if ($110_1) {
                break label$26;
              }
              i64toi32_i32$3 = $19$hi;
              $15_1 = $19_1;
              $15$hi = i64toi32_i32$3;
              label$27: while (1) {
                $10_1 = $10_1 << 4 | 0;
                i64toi32_i32$3 = $15$hi;
                i64toi32_i32$4 = $15_1;
                i64toi32_i32$5 = 0;
                i64toi32_i32$0 = 1;
                i64toi32_i32$2 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
                i64toi32_i32$1 = i64toi32_i32$3 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$0 >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
                }
                $15_1 = i64toi32_i32$2;
                $15$hi = i64toi32_i32$1;
                i64toi32_i32$3 = i64toi32_i32$2;
                i64toi32_i32$4 = 0;
                i64toi32_i32$0 = 8;
                if ((i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | (i64toi32_i32$1 | 0) != (i64toi32_i32$4 | 0) | 0) {
                  continue label$27;
                }
                break label$27;
              };
            }
            label$28: {
              label$29: {
                label$30: {
                  label$31: {
                    if (($7_1 & -33 | 0 | 0) != (80 | 0)) {
                      break label$31;
                    }
                    i64toi32_i32$3 = $60($1_1 | 0, $5_1 | 0) | 0;
                    i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
                    $15_1 = i64toi32_i32$3;
                    $15$hi = i64toi32_i32$1;
                    i64toi32_i32$0 = i64toi32_i32$3;
                    i64toi32_i32$3 = -2147483648;
                    i64toi32_i32$4 = 0;
                    if ((i64toi32_i32$0 | 0) != (i64toi32_i32$4 | 0) | (i64toi32_i32$1 | 0) != (i64toi32_i32$3 | 0) | 0) {
                      break label$28;
                    }
                    label$32: {
                      if (!$5_1) {
                        break label$32;
                      }
                      i64toi32_i32$4 = $1_1;
                      i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 112 | 0) >> 2] | 0;
                      i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 116 | 0) >> 2] | 0;
                      i64toi32_i32$4 = i64toi32_i32$0;
                      i64toi32_i32$0 = -1;
                      i64toi32_i32$3 = -1;
                      if ((i64toi32_i32$1 | 0) > (i64toi32_i32$0 | 0)) {
                        $113 = 1;
                      } else {
                        if ((i64toi32_i32$1 | 0) >= (i64toi32_i32$0 | 0)) {
                          if (i64toi32_i32$4 >>> 0 <= i64toi32_i32$3 >>> 0) {
                            $114 = 0;
                          } else {
                            $114 = 1;
                          }
                          $115 = $114;
                        } else {
                          $115 = 0;
                        }
                        $113 = $115;
                      }
                      if ($113) {
                        break label$30;
                      }
                      break label$29;
                    }
                    i64toi32_i32$4 = 0;
                    $16_1 = 0;
                    $16$hi = i64toi32_i32$4;
                    i64toi32_i32$4 = 0;
                    $48($1_1 | 0, 0 | 0, i64toi32_i32$4 | 0);
                    i64toi32_i32$4 = 0;
                    $19_1 = 0;
                    $19$hi = i64toi32_i32$4;
                    break label$21;
                  }
                  i64toi32_i32$4 = 0;
                  $15_1 = 0;
                  $15$hi = i64toi32_i32$4;
                  i64toi32_i32$3 = $1_1;
                  i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 112 | 0) >> 2] | 0;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 116 | 0) >> 2] | 0;
                  i64toi32_i32$3 = i64toi32_i32$4;
                  i64toi32_i32$4 = 0;
                  i64toi32_i32$0 = 0;
                  if ((i64toi32_i32$1 | 0) < (i64toi32_i32$4 | 0)) {
                    $116 = 1;
                  } else {
                    if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$4 | 0)) {
                      if (i64toi32_i32$3 >>> 0 >= i64toi32_i32$0 >>> 0) {
                        $117 = 0;
                      } else {
                        $117 = 1;
                      }
                      $118 = $117;
                    } else {
                      $118 = 0;
                    }
                    $116 = $118;
                  }
                  if ($116) {
                    break label$28;
                  }
                }
                HEAP32[($1_1 + 4 | 0) >> 2] = (HEAP32[($1_1 + 4 | 0) >> 2] | 0) + -1 | 0;
              }
              i64toi32_i32$3 = 0;
              $15_1 = 0;
              $15$hi = i64toi32_i32$3;
            }
            label$33: {
              if ($10_1) {
                break label$33;
              }
              $90($6_1 + 112 | 0 | 0, +(+($4_1 | 0) * 0.0));
              i64toi32_i32$0 = $6_1 + 120 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $19_1 = i64toi32_i32$3;
              $19$hi = i64toi32_i32$1;
              i64toi32_i32$0 = $6_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 112 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 116 | 0) >> 2] | 0;
              $16_1 = i64toi32_i32$1;
              $16$hi = i64toi32_i32$3;
              break label$21;
            }
            label$34: {
              i64toi32_i32$3 = $14$hi;
              i64toi32_i32$3 = $19$hi;
              i64toi32_i32$5 = $8_1;
              i64toi32_i32$3 = $14$hi;
              i64toi32_i32$1 = $19$hi;
              i64toi32_i32$4 = i64toi32_i32$5 ? $14_1 : $19_1;
              i64toi32_i32$0 = i64toi32_i32$5 ? i64toi32_i32$3 : i64toi32_i32$1;
              i64toi32_i32$5 = i64toi32_i32$4;
              i64toi32_i32$4 = 0;
              i64toi32_i32$3 = 2;
              i64toi32_i32$1 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$4 = i64toi32_i32$5 << i64toi32_i32$1 | 0;
                $119 = 0;
              } else {
                i64toi32_i32$4 = ((1 << i64toi32_i32$1 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$1 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$1 | 0) | 0;
                $119 = i64toi32_i32$5 << i64toi32_i32$1 | 0;
              }
              $267$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $15$hi;
              i64toi32_i32$4 = $267$hi;
              i64toi32_i32$0 = $119;
              i64toi32_i32$5 = $15$hi;
              i64toi32_i32$3 = $15_1;
              i64toi32_i32$1 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
              i64toi32_i32$2 = i64toi32_i32$4 + i64toi32_i32$5 | 0;
              if (i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
              }
              i64toi32_i32$4 = i64toi32_i32$1;
              i64toi32_i32$0 = -1;
              i64toi32_i32$3 = -32;
              i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
              i64toi32_i32$1 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
              if (i64toi32_i32$5 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
              }
              $19_1 = i64toi32_i32$5;
              $19$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $274$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $19$hi;
              i64toi32_i32$2 = i64toi32_i32$5;
              i64toi32_i32$4 = $274$hi;
              i64toi32_i32$3 = 0 - $3_1 | 0;
              if ((i64toi32_i32$1 | 0) < (i64toi32_i32$4 | 0)) {
                $120 = 1;
              } else {
                if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$4 | 0)) {
                  if (i64toi32_i32$2 >>> 0 > i64toi32_i32$3 >>> 0) {
                    $121 = 0;
                  } else {
                    $121 = 1;
                  }
                  $122 = $121;
                } else {
                  $122 = 0;
                }
                $120 = $122;
              }
              if ($120) {
                break label$34;
              }
              (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 68), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              $92($6_1 + 160 | 0 | 0, $4_1 | 0);
              i64toi32_i32$3 = $6_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 160 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 164 | 0) >> 2] | 0;
              $283 = i64toi32_i32$2;
              $283$hi = i64toi32_i32$1;
              i64toi32_i32$3 = (i64toi32_i32$3 + 160 | 0) + 8 | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $287 = i64toi32_i32$1;
              $287$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $283$hi;
              i64toi32_i32$1 = $287$hi;
              i64toi32_i32$3 = -1;
              i64toi32_i32$4 = 2147418111;
              $97($6_1 + 144 | 0 | 0, $283 | 0, i64toi32_i32$2 | 0, $287 | 0, i64toi32_i32$1 | 0, -1 | 0, i64toi32_i32$3 | 0, -1 | 0, i64toi32_i32$4 | 0);
              i64toi32_i32$1 = $6_1;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$1 + 144 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$1 + 148 | 0) >> 2] | 0;
              $291 = i64toi32_i32$4;
              $291$hi = i64toi32_i32$3;
              i64toi32_i32$1 = (i64toi32_i32$1 + 144 | 0) + 8 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $295 = i64toi32_i32$3;
              $295$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $291$hi;
              i64toi32_i32$3 = $295$hi;
              i64toi32_i32$1 = -1;
              i64toi32_i32$2 = 2147418111;
              $97($6_1 + 128 | 0 | 0, $291 | 0, i64toi32_i32$4 | 0, $295 | 0, i64toi32_i32$3 | 0, -1 | 0, i64toi32_i32$1 | 0, -1 | 0, i64toi32_i32$2 | 0);
              i64toi32_i32$3 = ($6_1 + 128 | 0) + 8 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $19_1 = i64toi32_i32$2;
              $19$hi = i64toi32_i32$1;
              i64toi32_i32$3 = $6_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 128 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 132 | 0) >> 2] | 0;
              $16_1 = i64toi32_i32$1;
              $16$hi = i64toi32_i32$2;
              break label$21;
            }
            label$35: {
              i64toi32_i32$2 = $19$hi;
              i64toi32_i32$1 = $3_1 + -226 | 0;
              i64toi32_i32$2 = i64toi32_i32$1 >> 31 | 0;
              $305 = i64toi32_i32$1;
              $305$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $19$hi;
              i64toi32_i32$3 = $19_1;
              i64toi32_i32$1 = $305$hi;
              i64toi32_i32$4 = $305;
              if ((i64toi32_i32$2 | 0) < (i64toi32_i32$1 | 0)) {
                $123 = 1;
              } else {
                if ((i64toi32_i32$2 | 0) <= (i64toi32_i32$1 | 0)) {
                  if (i64toi32_i32$3 >>> 0 >= i64toi32_i32$4 >>> 0) {
                    $124 = 0;
                  } else {
                    $124 = 1;
                  }
                  $125 = $124;
                } else {
                  $125 = 0;
                }
                $123 = $125;
              }
              if ($123) {
                break label$35;
              }
              label$36: {
                if (($10_1 | 0) <= (-1 | 0)) {
                  break label$36;
                }
                label$37: while (1) {
                  i64toi32_i32$3 = $16$hi;
                  i64toi32_i32$3 = $17$hi;
                  i64toi32_i32$3 = $16$hi;
                  i64toi32_i32$2 = $17$hi;
                  i64toi32_i32$4 = 0;
                  i64toi32_i32$1 = -1073807360;
                  $85($6_1 + 416 | 0 | 0, $16_1 | 0, i64toi32_i32$3 | 0, $17_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$1 | 0);
                  i64toi32_i32$1 = i64toi32_i32$3;
                  i64toi32_i32$1 = i64toi32_i32$2;
                  i64toi32_i32$1 = i64toi32_i32$3;
                  i64toi32_i32$4 = i64toi32_i32$2;
                  i64toi32_i32$2 = 0;
                  i64toi32_i32$3 = 1073610752;
                  $7_1 = $88($16_1 | 0, i64toi32_i32$1 | 0, $17_1 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$3 | 0) | 0;
                  i64toi32_i32$3 = i64toi32_i32$1;
                  i64toi32_i32$3 = i64toi32_i32$4;
                  i64toi32_i32$4 = $6_1;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 416 | 0) >> 2] | 0;
                  i64toi32_i32$2 = HEAP32[(i64toi32_i32$4 + 420 | 0) >> 2] | 0;
                  $321$hi = i64toi32_i32$2;
                  i64toi32_i32$2 = i64toi32_i32$1;
                  $7_1 = ($7_1 | 0) > (-1 | 0);
                  i64toi32_i32$0 = $7_1;
                  i64toi32_i32$2 = $321$hi;
                  $131 = i64toi32_i32$3;
                  i64toi32_i32$3 = i64toi32_i32$1;
                  i64toi32_i32$1 = i64toi32_i32$0 ? $131 : $16_1;
                  i64toi32_i32$4 = i64toi32_i32$0 ? i64toi32_i32$2 : i64toi32_i32$3;
                  $326 = i64toi32_i32$1;
                  $326$hi = i64toi32_i32$4;
                  i64toi32_i32$0 = ($6_1 + 416 | 0) + 8 | 0;
                  i64toi32_i32$4 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                  $330$hi = i64toi32_i32$1;
                  i64toi32_i32$1 = $17$hi;
                  i64toi32_i32$3 = $7_1;
                  i64toi32_i32$1 = $330$hi;
                  $132 = i64toi32_i32$4;
                  i64toi32_i32$4 = $17$hi;
                  i64toi32_i32$2 = i64toi32_i32$3 ? $132 : $17_1;
                  i64toi32_i32$0 = i64toi32_i32$3 ? i64toi32_i32$1 : i64toi32_i32$4;
                  $333 = i64toi32_i32$2;
                  $333$hi = i64toi32_i32$0;
                  i64toi32_i32$0 = $16$hi;
                  i64toi32_i32$2 = i64toi32_i32$4;
                  i64toi32_i32$3 = $326$hi;
                  i64toi32_i32$1 = $333$hi;
                  $85($6_1 + 400 | 0 | 0, $16_1 | 0, i64toi32_i32$0 | 0, $17_1 | 0, i64toi32_i32$4 | 0, $326 | 0, i64toi32_i32$3 | 0, $333 | 0, i64toi32_i32$1 | 0);
                  i64toi32_i32$1 = $19$hi;
                  i64toi32_i32$2 = $19_1;
                  i64toi32_i32$3 = -1;
                  i64toi32_i32$0 = -1;
                  i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
                  i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
                  if (i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0) {
                    i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                  }
                  $19_1 = i64toi32_i32$4;
                  $19$hi = i64toi32_i32$5;
                  i64toi32_i32$1 = ($6_1 + 400 | 0) + 8 | 0;
                  i64toi32_i32$5 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                  i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                  $17_1 = i64toi32_i32$5;
                  $17$hi = i64toi32_i32$2;
                  i64toi32_i32$1 = $6_1;
                  i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 400 | 0) >> 2] | 0;
                  i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 404 | 0) >> 2] | 0;
                  $16_1 = i64toi32_i32$2;
                  $16$hi = i64toi32_i32$5;
                  $10_1 = $10_1 << 1 | 0 | $7_1 | 0;
                  if (($10_1 | 0) > (-1 | 0)) {
                    continue label$37;
                  }
                  break label$37;
                };
              }
              label$38: {
                label$39: {
                  i64toi32_i32$5 = $19$hi;
                  i64toi32_i32$2 = $3_1;
                  i64toi32_i32$5 = i64toi32_i32$2 >> 31 | 0;
                  $350$hi = i64toi32_i32$5;
                  i64toi32_i32$5 = $19$hi;
                  i64toi32_i32$1 = $19_1;
                  i64toi32_i32$2 = $350$hi;
                  i64toi32_i32$0 = $3_1;
                  i64toi32_i32$3 = i64toi32_i32$1 - i64toi32_i32$0 | 0;
                  i64toi32_i32$4 = (i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0) + i64toi32_i32$2 | 0;
                  i64toi32_i32$4 = i64toi32_i32$5 - i64toi32_i32$4 | 0;
                  i64toi32_i32$5 = i64toi32_i32$3;
                  i64toi32_i32$1 = 0;
                  i64toi32_i32$0 = 32;
                  i64toi32_i32$2 = i64toi32_i32$3 + i64toi32_i32$0 | 0;
                  i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
                  if (i64toi32_i32$2 >>> 0 < i64toi32_i32$0 >>> 0) {
                    i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                  }
                  $14_1 = i64toi32_i32$2;
                  $14$hi = i64toi32_i32$3;
                  $7_1 = i64toi32_i32$2;
                  $358 = (i64toi32_i32$2 | 0) > (0 | 0) ? i64toi32_i32$2 : 0;
                  $359 = $2_1;
                  i64toi32_i32$3 = 0;
                  $362$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = $14$hi;
                  i64toi32_i32$4 = i64toi32_i32$2;
                  i64toi32_i32$5 = $362$hi;
                  i64toi32_i32$0 = $2_1;
                  if ((i64toi32_i32$3 | 0) < (i64toi32_i32$5 | 0)) {
                    $127 = 1;
                  } else {
                    if ((i64toi32_i32$3 | 0) <= (i64toi32_i32$5 | 0)) {
                      if (i64toi32_i32$4 >>> 0 >= i64toi32_i32$0 >>> 0) {
                        $128 = 0;
                      } else {
                        $128 = 1;
                      }
                      $129 = $128;
                    } else {
                      $129 = 0;
                    }
                    $127 = $129;
                  }
                  $7_1 = $127 ? $358 : $359;
                  if (($7_1 | 0) < (113 | 0)) {
                    break label$39;
                  }
                  $92($6_1 + 384 | 0 | 0, $4_1 | 0);
                  i64toi32_i32$0 = $6_1 + 392 | 0;
                  i64toi32_i32$4 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                  $14_1 = i64toi32_i32$4;
                  $14$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = 0;
                  $15_1 = 0;
                  $15$hi = i64toi32_i32$3;
                  i64toi32_i32$0 = $6_1;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 384 | 0) >> 2] | 0;
                  i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 388 | 0) >> 2] | 0;
                  $18_1 = i64toi32_i32$3;
                  $18$hi = i64toi32_i32$4;
                  i64toi32_i32$4 = 0;
                  $20_1 = 0;
                  $20$hi = i64toi32_i32$4;
                  break label$38;
                }
                $90($6_1 + 352 | 0 | 0, + +$50(+1.0, 144 - $7_1 | 0 | 0));
                $92($6_1 + 336 | 0 | 0, $4_1 | 0);
                i64toi32_i32$0 = $6_1;
                i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 352 | 0) >> 2] | 0;
                i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 356 | 0) >> 2] | 0;
                $386 = i64toi32_i32$4;
                $386$hi = i64toi32_i32$3;
                i64toi32_i32$0 = (i64toi32_i32$0 + 352 | 0) + 8 | 0;
                i64toi32_i32$3 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                $390 = i64toi32_i32$3;
                $390$hi = i64toi32_i32$4;
                i64toi32_i32$0 = $6_1;
                i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 336 | 0) >> 2] | 0;
                i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 340 | 0) >> 2] | 0;
                $18_1 = i64toi32_i32$4;
                $18$hi = i64toi32_i32$3;
                i64toi32_i32$0 = (i64toi32_i32$0 + 336 | 0) + 8 | 0;
                i64toi32_i32$3 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                $14_1 = i64toi32_i32$3;
                $14$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $386$hi;
                i64toi32_i32$3 = $390$hi;
                i64toi32_i32$0 = $18$hi;
                i64toi32_i32$5 = $14$hi;
                $51($6_1 + 368 | 0 | 0, $386 | 0, i64toi32_i32$4 | 0, $390 | 0, i64toi32_i32$3 | 0, $18_1 | 0, i64toi32_i32$0 | 0, $14_1 | 0, i64toi32_i32$5 | 0);
                i64toi32_i32$3 = ($6_1 + 368 | 0) + 8 | 0;
                i64toi32_i32$5 = HEAP32[i64toi32_i32$3 >> 2] | 0;
                i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
                $20_1 = i64toi32_i32$5;
                $20$hi = i64toi32_i32$0;
                i64toi32_i32$3 = $6_1;
                i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 368 | 0) >> 2] | 0;
                i64toi32_i32$5 = HEAP32[(i64toi32_i32$3 + 372 | 0) >> 2] | 0;
                $15_1 = i64toi32_i32$0;
                $15$hi = i64toi32_i32$5;
              }
              i64toi32_i32$5 = $16$hi;
              i64toi32_i32$5 = $17$hi;
              i64toi32_i32$5 = $16$hi;
              i64toi32_i32$0 = $17$hi;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = 0;
              $7_1 = !($10_1 & 1 | 0) & (($7_1 | 0) < (32 | 0) & ($87($16_1 | 0, i64toi32_i32$5 | 0, $17_1 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$4 | 0) | 0 | 0) != (0 | 0) | 0) | 0;
              $93($6_1 + 320 | 0 | 0, $10_1 | $7_1 | 0 | 0);
              i64toi32_i32$4 = $18$hi;
              i64toi32_i32$4 = $14$hi;
              i64toi32_i32$0 = $6_1;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 320 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 324 | 0) >> 2] | 0;
              $426 = i64toi32_i32$4;
              $426$hi = i64toi32_i32$3;
              i64toi32_i32$0 = (i64toi32_i32$0 + 320 | 0) + 8 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $430 = i64toi32_i32$3;
              $430$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $18$hi;
              i64toi32_i32$3 = $14$hi;
              i64toi32_i32$0 = $426$hi;
              i64toi32_i32$5 = $430$hi;
              $97($6_1 + 304 | 0 | 0, $18_1 | 0, i64toi32_i32$4 | 0, $14_1 | 0, i64toi32_i32$3 | 0, $426 | 0, i64toi32_i32$0 | 0, $430 | 0, i64toi32_i32$5 | 0);
              i64toi32_i32$3 = $6_1;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$3 + 304 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 308 | 0) >> 2] | 0;
              $434 = i64toi32_i32$5;
              $434$hi = i64toi32_i32$0;
              i64toi32_i32$3 = (i64toi32_i32$3 + 304 | 0) + 8 | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $438 = i64toi32_i32$0;
              $438$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $15$hi;
              i64toi32_i32$5 = $20$hi;
              i64toi32_i32$5 = $434$hi;
              i64toi32_i32$0 = $438$hi;
              i64toi32_i32$3 = $15$hi;
              i64toi32_i32$4 = $20$hi;
              $85($6_1 + 272 | 0 | 0, $434 | 0, i64toi32_i32$5 | 0, $438 | 0, i64toi32_i32$0 | 0, $15_1 | 0, i64toi32_i32$3 | 0, $20_1 | 0, i64toi32_i32$4 | 0);
              i64toi32_i32$4 = $18$hi;
              i64toi32_i32$4 = $14$hi;
              i64toi32_i32$4 = $16$hi;
              i64toi32_i32$1 = $7_1;
              i64toi32_i32$4 = 0;
              i64toi32_i32$3 = $16$hi;
              i64toi32_i32$5 = i64toi32_i32$1 ? 0 : $16_1;
              i64toi32_i32$0 = i64toi32_i32$1 ? i64toi32_i32$4 : i64toi32_i32$3;
              $447 = i64toi32_i32$5;
              $447$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $17$hi;
              i64toi32_i32$3 = i64toi32_i32$1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$5 = $17$hi;
              i64toi32_i32$4 = i64toi32_i32$3 ? 0 : $17_1;
              i64toi32_i32$1 = i64toi32_i32$3 ? i64toi32_i32$0 : i64toi32_i32$5;
              $450 = i64toi32_i32$4;
              $450$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $18$hi;
              i64toi32_i32$4 = $14$hi;
              i64toi32_i32$3 = $447$hi;
              i64toi32_i32$0 = $450$hi;
              $97($6_1 + 288 | 0 | 0, $18_1 | 0, i64toi32_i32$1 | 0, $14_1 | 0, i64toi32_i32$4 | 0, $447 | 0, i64toi32_i32$3 | 0, $450 | 0, i64toi32_i32$0 | 0);
              i64toi32_i32$4 = $6_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 288 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 292 | 0) >> 2] | 0;
              $454 = i64toi32_i32$0;
              $454$hi = i64toi32_i32$3;
              i64toi32_i32$4 = (i64toi32_i32$4 + 288 | 0) + 8 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $458 = i64toi32_i32$3;
              $458$hi = i64toi32_i32$0;
              i64toi32_i32$4 = $6_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 272 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 276 | 0) >> 2] | 0;
              $460 = i64toi32_i32$0;
              $460$hi = i64toi32_i32$3;
              i64toi32_i32$4 = (i64toi32_i32$4 + 272 | 0) + 8 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $464 = i64toi32_i32$3;
              $464$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $454$hi;
              i64toi32_i32$3 = $458$hi;
              i64toi32_i32$4 = $460$hi;
              i64toi32_i32$1 = $464$hi;
              $85($6_1 + 256 | 0 | 0, $454 | 0, i64toi32_i32$0 | 0, $458 | 0, i64toi32_i32$3 | 0, $460 | 0, i64toi32_i32$4 | 0, $464 | 0, i64toi32_i32$1 | 0);
              i64toi32_i32$3 = $6_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 256 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 260 | 0) >> 2] | 0;
              $468 = i64toi32_i32$1;
              $468$hi = i64toi32_i32$4;
              i64toi32_i32$3 = (i64toi32_i32$3 + 256 | 0) + 8 | 0;
              i64toi32_i32$4 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $472 = i64toi32_i32$4;
              $472$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $15$hi;
              i64toi32_i32$1 = $20$hi;
              i64toi32_i32$1 = $468$hi;
              i64toi32_i32$4 = $472$hi;
              i64toi32_i32$3 = $15$hi;
              i64toi32_i32$0 = $20$hi;
              $99($6_1 + 240 | 0 | 0, $468 | 0, i64toi32_i32$1 | 0, $472 | 0, i64toi32_i32$4 | 0, $15_1 | 0, i64toi32_i32$3 | 0, $20_1 | 0, i64toi32_i32$0 | 0);
              label$40: {
                i64toi32_i32$4 = $6_1;
                i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 240 | 0) >> 2] | 0;
                i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 244 | 0) >> 2] | 0;
                $16_1 = i64toi32_i32$0;
                $16$hi = i64toi32_i32$3;
                i64toi32_i32$4 = (i64toi32_i32$4 + 240 | 0) + 8 | 0;
                i64toi32_i32$3 = HEAP32[i64toi32_i32$4 >> 2] | 0;
                i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
                $17_1 = i64toi32_i32$3;
                $17$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $16$hi;
                i64toi32_i32$3 = $17$hi;
                i64toi32_i32$4 = 0;
                i64toi32_i32$1 = 0;
                if ($87($16_1 | 0, i64toi32_i32$0 | 0, $17_1 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$1 | 0) | 0) {
                  break label$40;
                }
                (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 68), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              }
              i64toi32_i32$1 = $16$hi;
              i64toi32_i32$1 = $17$hi;
              i64toi32_i32$1 = $19$hi;
              i64toi32_i32$1 = $16$hi;
              i64toi32_i32$4 = $17$hi;
              $52($6_1 + 224 | 0 | 0, $16_1 | 0, i64toi32_i32$1 | 0, $17_1 | 0, i64toi32_i32$4 | 0, $19_1 | 0);
              i64toi32_i32$3 = ($6_1 + 224 | 0) + 8 | 0;
              i64toi32_i32$4 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $19_1 = i64toi32_i32$4;
              $19$hi = i64toi32_i32$1;
              i64toi32_i32$3 = $6_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 224 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 228 | 0) >> 2] | 0;
              $16_1 = i64toi32_i32$1;
              $16$hi = i64toi32_i32$4;
              break label$21;
            }
            (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 68), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
            $92($6_1 + 208 | 0 | 0, $4_1 | 0);
            i64toi32_i32$3 = $6_1;
            i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 208 | 0) >> 2] | 0;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 212 | 0) >> 2] | 0;
            $504 = i64toi32_i32$4;
            $504$hi = i64toi32_i32$1;
            i64toi32_i32$3 = (i64toi32_i32$3 + 208 | 0) + 8 | 0;
            i64toi32_i32$1 = HEAP32[i64toi32_i32$3 >> 2] | 0;
            i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
            $508 = i64toi32_i32$1;
            $508$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $504$hi;
            i64toi32_i32$1 = $508$hi;
            i64toi32_i32$3 = 0;
            i64toi32_i32$0 = 65536;
            $97($6_1 + 192 | 0 | 0, $504 | 0, i64toi32_i32$4 | 0, $508 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$0 | 0);
            i64toi32_i32$1 = $6_1;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 192 | 0) >> 2] | 0;
            i64toi32_i32$3 = HEAP32[(i64toi32_i32$1 + 196 | 0) >> 2] | 0;
            $512 = i64toi32_i32$0;
            $512$hi = i64toi32_i32$3;
            i64toi32_i32$1 = (i64toi32_i32$1 + 192 | 0) + 8 | 0;
            i64toi32_i32$3 = HEAP32[i64toi32_i32$1 >> 2] | 0;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
            $516 = i64toi32_i32$3;
            $516$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $512$hi;
            i64toi32_i32$3 = $516$hi;
            i64toi32_i32$1 = 0;
            i64toi32_i32$4 = 65536;
            $97($6_1 + 176 | 0 | 0, $512 | 0, i64toi32_i32$0 | 0, $516 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$4 | 0);
            i64toi32_i32$3 = ($6_1 + 176 | 0) + 8 | 0;
            i64toi32_i32$4 = HEAP32[i64toi32_i32$3 >> 2] | 0;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
            $19_1 = i64toi32_i32$4;
            $19$hi = i64toi32_i32$1;
            i64toi32_i32$3 = $6_1;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 176 | 0) >> 2] | 0;
            i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 180 | 0) >> 2] | 0;
            $16_1 = i64toi32_i32$1;
            $16$hi = i64toi32_i32$4;
          }
          i64toi32_i32$4 = $16$hi;
          i64toi32_i32$1 = $0_1;
          HEAP32[i64toi32_i32$1 >> 2] = $16_1;
          HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$4;
          i64toi32_i32$4 = $19$hi;
          HEAP32[(i64toi32_i32$1 + 8 | 0) >> 2] = $19_1;
          HEAP32[(i64toi32_i32$1 + 12 | 0) >> 2] = i64toi32_i32$4;
          global$0 = $6_1 + 432 | 0;
        }

        function $59($0_1, $1_1, $2_1, $3_1, $4_1, $5_1, $6_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          $4_1 = $4_1 | 0;
          $5_1 = $5_1 | 0;
          $6_1 = $6_1 | 0;
          var i64toi32_i32$4 = 0,i64toi32_i32$5 = 0,i64toi32_i32$1 = 0,$7_1 = 0,i64toi32_i32$3 = 0,i64toi32_i32$2 = 0,$18$hi = 0,$14_1 = 0,$18_1 = 0,$19$hi = 0,$19_1 = 0,$13_1 = 0,i64toi32_i32$0 = 0,$15_1 = 0,$16_1 = 0,$11_1 = 0,$21$hi = 0,$20$hi = 0,$8_1 = 0,$12_1 = 0,$21_1 = 0,$20_1 = 0,$9_1 = 0,$22$hi = 0,$23$hi = 0,$22_1 = 0,$23_1 = 0,$10_1 = 0,$165 = 0,$166 = 0,$167 = 0,$168 = 0,$169 = 0,$170 = 0,$171 = 0,$172 = 0,$173 = 0,$174 = 0,$175 = 0,$176 = 0,$177 = 0,$178 = 0,$179 = 0,$180 = 0,$17_1 = 0,$24_1 = 0.0,$124 = 0,$230 = 0,$230$hi = 0,$234 = 0,$234$hi = 0,$236 = 0,$236$hi = 0,$240 = 0,$240$hi = 0,$250$hi = 0,$259 = 0,$259$hi = 0,$263 = 0,$263$hi = 0,$267 = 0,$267$hi = 0,$271 = 0,$271$hi = 0,$281 = 0,$281$hi = 0,$290 = 0,$290$hi = 0,$294 = 0,$294$hi = 0,$298 = 0,$298$hi = 0,$302 = 0,$302$hi = 0,$351 = 0,$351$hi = 0,$355 = 0,$355$hi = 0,$357 = 0,$357$hi = 0,$361 = 0,$361$hi = 0,$380 = 0,$380$hi = 0,$384 = 0,$384$hi = 0,$386 = 0,$386$hi = 0,$390 = 0,$390$hi = 0,$401 = 0,$401$hi = 0,$405 = 0,$405$hi = 0,$407 = 0,$407$hi = 0,$411 = 0,$411$hi = 0,$439 = 0,$439$hi = 0,$443 = 0,$443$hi = 0,$445 = 0,$445$hi = 0,$449 = 0,$449$hi = 0,$459 = 0,$459$hi = 0,$463 = 0,$463$hi = 0,$465 = 0,$465$hi = 0,$469 = 0,$469$hi = 0,$508 = 0,$586$hi = 0,$588$hi = 0,$596 = 0,$596$hi = 0,$738 = 0,$738$hi = 0,$742 = 0,$742$hi = 0,$744 = 0,$744$hi = 0,$748 = 0,$748$hi = 0,$767 = 0,$767$hi = 0,$771 = 0,$771$hi = 0,$813 = 0,$874 = 0,$874$hi = 0,$878 = 0,$878$hi = 0,$897 = 0,$897$hi = 0,$901 = 0,$901$hi = 0,$919 = 0,$919$hi = 0,$923 = 0,$923$hi = 0,$960 = 0,$960$hi = 0,$964 = 0,$964$hi = 0,$983 = 0,$983$hi = 0,$987 = 0,$987$hi = 0,$1010 = 0,$1010$hi = 0,$1014 = 0,$1014$hi = 0,$1030 = 0,$1030$hi = 0,$1034 = 0,$1034$hi = 0,$1048 = 0,$1048$hi = 0,$1052 = 0,$1052$hi = 0,$1073 = 0,$1073$hi = 0,$1077 = 0,$1077$hi = 0,$1100 = 0,$1100$hi = 0,$1104 = 0,$1104$hi = 0,$1109$hi = 0,$181 = 0,$1116$hi = 0,$182 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $7_1 = global$0 - 8976 | 0;
          global$0 = $7_1;
          $8_1 = 0;
          $9_1 = 0 - $4_1 | 0;
          $10_1 = $9_1 - $3_1 | 0;
          i64toi32_i32$0 = 0;
          $18_1 = 0;
          $18$hi = i64toi32_i32$0;
          $11_1 = 0;
          label$1: {
            label$2: {
              label$3: {
                label$4: while (1) {
                  label$5: {
                    if (($2_1 | 0) == (48 | 0)) {
                      break label$5;
                    }
                    if (($2_1 | 0) != (46 | 0)) {
                      break label$1;
                    }
                    $2_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                    if (($2_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                      break label$3;
                    }
                    HEAP32[($1_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                    $2_1 = HEAPU8[$2_1 >> 0] | 0;
                    break label$2;
                  }
                  label$6: {
                    $2_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                    if (($2_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                      break label$6;
                    }
                    $11_1 = 1;
                    HEAP32[($1_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                    $2_1 = HEAPU8[$2_1 >> 0] | 0;
                    continue label$4;
                  }
                  $11_1 = 1;
                  $2_1 = $49($1_1 | 0) | 0;
                  continue label$4;
                };
              }
              $2_1 = $49($1_1 | 0) | 0;
            }
            $8_1 = 1;
            i64toi32_i32$0 = 0;
            $18_1 = 0;
            $18$hi = i64toi32_i32$0;
            if (($2_1 | 0) != (48 | 0)) {
              break label$1;
            }
            label$7: while (1) {
              label$8: {
                label$9: {
                  $2_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                  if (($2_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                    break label$9;
                  }
                  HEAP32[($1_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                  $2_1 = HEAPU8[$2_1 >> 0] | 0;
                  break label$8;
                }
                $2_1 = $49($1_1 | 0) | 0;
              }
              i64toi32_i32$0 = $18$hi;
              i64toi32_i32$2 = $18_1;
              i64toi32_i32$1 = -1;
              i64toi32_i32$3 = -1;
              i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
              i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
              }
              $18_1 = i64toi32_i32$4;
              $18$hi = i64toi32_i32$5;
              if (($2_1 | 0) == (48 | 0)) {
                continue label$7;
              }
              break label$7;
            };
            $11_1 = 1;
            $8_1 = 1;
          }
          $12_1 = 0;
          HEAP32[($7_1 + 784 | 0) >> 2] = 0;
          $13_1 = $2_1 + -48 | 0;
          label$10: {
            label$11: {
              label$12: {
                label$13: {
                  label$14: {
                    label$15: {
                      label$16: {
                        $14_1 = ($2_1 | 0) == (46 | 0);
                        if ($14_1) {
                          break label$16;
                        }
                        i64toi32_i32$5 = 0;
                        $19_1 = 0;
                        $19$hi = i64toi32_i32$5;
                        if ($13_1 >>> 0 <= 9 >>> 0) {
                          break label$16;
                        }
                        $15_1 = 0;
                        $16_1 = 0;
                        break label$15;
                      }
                      i64toi32_i32$5 = 0;
                      $19_1 = 0;
                      $19$hi = i64toi32_i32$5;
                      $16_1 = 0;
                      $15_1 = 0;
                      $12_1 = 0;
                      label$17: while (1) {
                        label$18: {
                          label$19: {
                            if (!($14_1 & 1 | 0)) {
                              break label$19;
                            }
                            label$20: {
                              if ($8_1) {
                                break label$20;
                              }
                              i64toi32_i32$5 = $19$hi;
                              $18_1 = $19_1;
                              $18$hi = i64toi32_i32$5;
                              $8_1 = 1;
                              break label$18;
                            }
                            $14_1 = !$11_1;
                            break label$14;
                          }
                          i64toi32_i32$5 = $19$hi;
                          i64toi32_i32$0 = $19_1;
                          i64toi32_i32$2 = 0;
                          i64toi32_i32$3 = 1;
                          i64toi32_i32$1 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
                          i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$2 | 0;
                          if (i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0) {
                            i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                          }
                          $19_1 = i64toi32_i32$1;
                          $19$hi = i64toi32_i32$4;
                          label$21: {
                            if (($15_1 | 0) > (2044 | 0)) {
                              break label$21;
                            }
                            $14_1 = ($7_1 + 784 | 0) + ($15_1 << 2 | 0) | 0;
                            label$22: {
                              if (!$16_1) {
                                break label$22;
                              }
                              $13_1 = ($2_1 + Math_imul(HEAP32[$14_1 >> 2] | 0, 10) | 0) + -48 | 0;
                            }
                            i64toi32_i32$4 = $19$hi;
                            $12_1 = ($2_1 | 0) == (48 | 0) ? $12_1 : $19_1;
                            HEAP32[$14_1 >> 2] = $13_1;
                            $11_1 = 1;
                            $2_1 = $16_1 + 1 | 0;
                            $124 = $2_1;
                            $2_1 = ($2_1 | 0) == (9 | 0);
                            $16_1 = $2_1 ? 0 : $124;
                            $15_1 = $15_1 + $2_1 | 0;
                            break label$18;
                          }
                          if (($2_1 | 0) == (48 | 0)) {
                            break label$18;
                          }
                          HEAP32[($7_1 + 8960 | 0) >> 2] = HEAP32[($7_1 + 8960 | 0) >> 2] | 0 | 1 | 0;
                          $12_1 = 18396;
                        }
                        label$23: {
                          label$24: {
                            $2_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
                            if (($2_1 | 0) == (HEAP32[($1_1 + 104 | 0) >> 2] | 0 | 0)) {
                              break label$24;
                            }
                            HEAP32[($1_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                            $2_1 = HEAPU8[$2_1 >> 0] | 0;
                            break label$23;
                          }
                          $2_1 = $49($1_1 | 0) | 0;
                        }
                        $13_1 = $2_1 + -48 | 0;
                        $14_1 = ($2_1 | 0) == (46 | 0);
                        if ($14_1) {
                          continue label$17;
                        }
                        if ($13_1 >>> 0 < 10 >>> 0) {
                          continue label$17;
                        }
                        break label$17;
                      };
                    }
                    i64toi32_i32$4 = $18$hi;
                    i64toi32_i32$4 = $19$hi;
                    i64toi32_i32$2 = $8_1;
                    i64toi32_i32$4 = $18$hi;
                    i64toi32_i32$0 = $19$hi;
                    i64toi32_i32$3 = i64toi32_i32$2 ? $18_1 : $19_1;
                    i64toi32_i32$5 = i64toi32_i32$2 ? i64toi32_i32$4 : i64toi32_i32$0;
                    $18_1 = i64toi32_i32$3;
                    $18$hi = i64toi32_i32$5;
                    label$25: {
                      if (!$11_1) {
                        break label$25;
                      }
                      if (($2_1 & -33 | 0 | 0) != (69 | 0)) {
                        break label$25;
                      }
                      label$26: {
                        i64toi32_i32$5 = $60($1_1 | 0, $6_1 | 0) | 0;
                        i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
                        $20_1 = i64toi32_i32$5;
                        $20$hi = i64toi32_i32$3;
                        i64toi32_i32$2 = i64toi32_i32$5;
                        i64toi32_i32$5 = -2147483648;
                        i64toi32_i32$4 = 0;
                        if ((i64toi32_i32$2 | 0) != (i64toi32_i32$4 | 0) | (i64toi32_i32$3 | 0) != (i64toi32_i32$5 | 0) | 0) {
                          break label$26;
                        }
                        if (!$6_1) {
                          break label$12;
                        }
                        i64toi32_i32$2 = 0;
                        $20_1 = 0;
                        $20$hi = i64toi32_i32$2;
                        i64toi32_i32$4 = $1_1;
                        i64toi32_i32$2 = HEAP32[(i64toi32_i32$4 + 112 | 0) >> 2] | 0;
                        i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 116 | 0) >> 2] | 0;
                        i64toi32_i32$4 = i64toi32_i32$2;
                        i64toi32_i32$2 = 0;
                        i64toi32_i32$5 = 0;
                        if ((i64toi32_i32$3 | 0) < (i64toi32_i32$2 | 0)) {
                          $165 = 1;
                        } else {
                          if ((i64toi32_i32$3 | 0) <= (i64toi32_i32$2 | 0)) {
                            if (i64toi32_i32$4 >>> 0 >= i64toi32_i32$5 >>> 0) {
                              $166 = 0;
                            } else {
                              $166 = 1;
                            }
                            $167 = $166;
                          } else {
                            $167 = 0;
                          }
                          $165 = $167;
                        }
                        if ($165) {
                          break label$26;
                        }
                        HEAP32[($1_1 + 4 | 0) >> 2] = (HEAP32[($1_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                      }
                      i64toi32_i32$4 = $20$hi;
                      i64toi32_i32$4 = $18$hi;
                      i64toi32_i32$4 = $20$hi;
                      i64toi32_i32$5 = $20_1;
                      i64toi32_i32$3 = $18$hi;
                      i64toi32_i32$2 = $18_1;
                      i64toi32_i32$0 = i64toi32_i32$5 + i64toi32_i32$2 | 0;
                      i64toi32_i32$1 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
                      if (i64toi32_i32$0 >>> 0 < i64toi32_i32$2 >>> 0) {
                        i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
                      }
                      $18_1 = i64toi32_i32$0;
                      $18$hi = i64toi32_i32$1;
                      break label$11;
                    }
                    $14_1 = !$11_1;
                    if (($2_1 | 0) < (0 | 0)) {
                      break label$13;
                    }
                  }
                  i64toi32_i32$4 = $1_1;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 112 | 0) >> 2] | 0;
                  i64toi32_i32$5 = HEAP32[(i64toi32_i32$4 + 116 | 0) >> 2] | 0;
                  i64toi32_i32$4 = i64toi32_i32$1;
                  i64toi32_i32$1 = 0;
                  i64toi32_i32$2 = 0;
                  if ((i64toi32_i32$5 | 0) < (i64toi32_i32$1 | 0)) {
                    $168 = 1;
                  } else {
                    if ((i64toi32_i32$5 | 0) <= (i64toi32_i32$1 | 0)) {
                      if (i64toi32_i32$4 >>> 0 >= i64toi32_i32$2 >>> 0) {
                        $169 = 0;
                      } else {
                        $169 = 1;
                      }
                      $170 = $169;
                    } else {
                      $170 = 0;
                    }
                    $168 = $170;
                  }
                  if ($168) {
                    break label$13;
                  }
                  HEAP32[($1_1 + 4 | 0) >> 2] = (HEAP32[($1_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                }
                if (!$14_1) {
                  break label$11;
                }
                (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 28), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              }
              i64toi32_i32$4 = 0;
              $19_1 = 0;
              $19$hi = i64toi32_i32$4;
              i64toi32_i32$4 = 0;
              $48($1_1 | 0, 0 | 0, i64toi32_i32$4 | 0);
              i64toi32_i32$4 = 0;
              $18_1 = 0;
              $18$hi = i64toi32_i32$4;
              break label$10;
            }
            label$27: {
              $1_1 = HEAP32[($7_1 + 784 | 0) >> 2] | 0;
              if ($1_1) {
                break label$27;
              }
              $90($7_1 | 0, +(+($5_1 | 0) * 0.0));
              i64toi32_i32$2 = $7_1 + 8 | 0;
              i64toi32_i32$4 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $18_1 = i64toi32_i32$4;
              $18$hi = i64toi32_i32$5;
              i64toi32_i32$2 = $7_1;
              i64toi32_i32$5 = HEAP32[$7_1 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[($7_1 + 4 | 0) >> 2] | 0;
              $19_1 = i64toi32_i32$5;
              $19$hi = i64toi32_i32$4;
              break label$10;
            }
            label$28: {
              i64toi32_i32$4 = $19$hi;
              i64toi32_i32$2 = $19_1;
              i64toi32_i32$5 = 0;
              i64toi32_i32$1 = 9;
              if ((i64toi32_i32$4 | 0) > (i64toi32_i32$5 | 0)) {
                $171 = 1;
              } else {
                if ((i64toi32_i32$4 | 0) >= (i64toi32_i32$5 | 0)) {
                  if (i64toi32_i32$2 >>> 0 <= i64toi32_i32$1 >>> 0) {
                    $172 = 0;
                  } else {
                    $172 = 1;
                  }
                  $173 = $172;
                } else {
                  $173 = 0;
                }
                $171 = $173;
              }
              if ($171) {
                break label$28;
              }
              i64toi32_i32$2 = $18$hi;
              i64toi32_i32$2 = $19$hi;
              i64toi32_i32$2 = $18$hi;
              i64toi32_i32$1 = $18_1;
              i64toi32_i32$4 = $19$hi;
              i64toi32_i32$5 = $19_1;
              if ((i64toi32_i32$1 | 0) != (i64toi32_i32$5 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$4 | 0) | 0) {
                break label$28;
              }
              label$29: {
                if (($3_1 | 0) > (30 | 0)) {
                  break label$29;
                }
                if ($1_1 >>> $3_1 | 0) {
                  break label$28;
                }
              }
              $92($7_1 + 48 | 0 | 0, $5_1 | 0);
              $93($7_1 + 32 | 0 | 0, $1_1 | 0);
              i64toi32_i32$5 = $7_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 48 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 52 | 0) >> 2] | 0;
              $230 = i64toi32_i32$1;
              $230$hi = i64toi32_i32$2;
              i64toi32_i32$5 = (i64toi32_i32$5 + 48 | 0) + 8 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$5 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
              $234 = i64toi32_i32$2;
              $234$hi = i64toi32_i32$1;
              i64toi32_i32$5 = $7_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 32 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 36 | 0) >> 2] | 0;
              $236 = i64toi32_i32$1;
              $236$hi = i64toi32_i32$2;
              i64toi32_i32$5 = (i64toi32_i32$5 + 32 | 0) + 8 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$5 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
              $240 = i64toi32_i32$2;
              $240$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $230$hi;
              i64toi32_i32$2 = $234$hi;
              i64toi32_i32$5 = $236$hi;
              i64toi32_i32$4 = $240$hi;
              $97($7_1 + 16 | 0 | 0, $230 | 0, i64toi32_i32$1 | 0, $234 | 0, i64toi32_i32$2 | 0, $236 | 0, i64toi32_i32$5 | 0, $240 | 0, i64toi32_i32$4 | 0);
              i64toi32_i32$2 = ($7_1 + 16 | 0) + 8 | 0;
              i64toi32_i32$4 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $18_1 = i64toi32_i32$4;
              $18$hi = i64toi32_i32$5;
              i64toi32_i32$2 = $7_1;
              i64toi32_i32$5 = HEAP32[($7_1 + 16 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[($7_1 + 20 | 0) >> 2] | 0;
              $19_1 = i64toi32_i32$5;
              $19$hi = i64toi32_i32$4;
              break label$10;
            }
            label$30: {
              i64toi32_i32$4 = $18$hi;
              i64toi32_i32$4 = 0;
              $250$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $18$hi;
              i64toi32_i32$2 = $18_1;
              i64toi32_i32$5 = $250$hi;
              i64toi32_i32$1 = $9_1 >>> 1 | 0;
              if ((i64toi32_i32$4 | 0) < (i64toi32_i32$5 | 0)) {
                $174 = 1;
              } else {
                if ((i64toi32_i32$4 | 0) <= (i64toi32_i32$5 | 0)) {
                  if (i64toi32_i32$2 >>> 0 > i64toi32_i32$1 >>> 0) {
                    $175 = 0;
                  } else {
                    $175 = 1;
                  }
                  $176 = $175;
                } else {
                  $176 = 0;
                }
                $174 = $176;
              }
              if ($174) {
                break label$30;
              }
              (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 68), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              $92($7_1 + 96 | 0 | 0, $5_1 | 0);
              i64toi32_i32$1 = $7_1;
              i64toi32_i32$2 = HEAP32[($7_1 + 96 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[($7_1 + 100 | 0) >> 2] | 0;
              $259 = i64toi32_i32$2;
              $259$hi = i64toi32_i32$4;
              i64toi32_i32$1 = ($7_1 + 96 | 0) + 8 | 0;
              i64toi32_i32$4 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $263 = i64toi32_i32$4;
              $263$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $259$hi;
              i64toi32_i32$4 = $263$hi;
              i64toi32_i32$1 = -1;
              i64toi32_i32$5 = 2147418111;
              $97($7_1 + 80 | 0 | 0, $259 | 0, i64toi32_i32$2 | 0, $263 | 0, i64toi32_i32$4 | 0, -1 | 0, i64toi32_i32$1 | 0, -1 | 0, i64toi32_i32$5 | 0);
              i64toi32_i32$4 = $7_1;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$4 + 80 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 84 | 0) >> 2] | 0;
              $267 = i64toi32_i32$5;
              $267$hi = i64toi32_i32$1;
              i64toi32_i32$4 = (i64toi32_i32$4 + 80 | 0) + 8 | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $271 = i64toi32_i32$1;
              $271$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $267$hi;
              i64toi32_i32$1 = $271$hi;
              i64toi32_i32$4 = -1;
              i64toi32_i32$2 = 2147418111;
              $97($7_1 + 64 | 0 | 0, $267 | 0, i64toi32_i32$5 | 0, $271 | 0, i64toi32_i32$1 | 0, -1 | 0, i64toi32_i32$4 | 0, -1 | 0, i64toi32_i32$2 | 0);
              i64toi32_i32$1 = ($7_1 + 64 | 0) + 8 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $18_1 = i64toi32_i32$2;
              $18$hi = i64toi32_i32$4;
              i64toi32_i32$1 = $7_1;
              i64toi32_i32$4 = HEAP32[($7_1 + 64 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[($7_1 + 68 | 0) >> 2] | 0;
              $19_1 = i64toi32_i32$4;
              $19$hi = i64toi32_i32$2;
              break label$10;
            }
            label$31: {
              i64toi32_i32$2 = $18$hi;
              i64toi32_i32$4 = $4_1 + -226 | 0;
              i64toi32_i32$2 = i64toi32_i32$4 >> 31 | 0;
              $281 = i64toi32_i32$4;
              $281$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $18$hi;
              i64toi32_i32$1 = $18_1;
              i64toi32_i32$4 = $281$hi;
              i64toi32_i32$5 = $281;
              if ((i64toi32_i32$2 | 0) > (i64toi32_i32$4 | 0)) {
                $177 = 1;
              } else {
                if ((i64toi32_i32$2 | 0) >= (i64toi32_i32$4 | 0)) {
                  if (i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0) {
                    $178 = 0;
                  } else {
                    $178 = 1;
                  }
                  $179 = $178;
                } else {
                  $179 = 0;
                }
                $177 = $179;
              }
              if ($177) {
                break label$31;
              }
              (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 68), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              $92($7_1 + 144 | 0 | 0, $5_1 | 0);
              i64toi32_i32$5 = $7_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 144 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 148 | 0) >> 2] | 0;
              $290 = i64toi32_i32$1;
              $290$hi = i64toi32_i32$2;
              i64toi32_i32$5 = (i64toi32_i32$5 + 144 | 0) + 8 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$5 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
              $294 = i64toi32_i32$2;
              $294$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $290$hi;
              i64toi32_i32$2 = $294$hi;
              i64toi32_i32$5 = 0;
              i64toi32_i32$4 = 65536;
              $97($7_1 + 128 | 0 | 0, $290 | 0, i64toi32_i32$1 | 0, $294 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$5 | 0, 0 | 0, i64toi32_i32$4 | 0);
              i64toi32_i32$2 = $7_1;
              i64toi32_i32$4 = HEAP32[($7_1 + 128 | 0) >> 2] | 0;
              i64toi32_i32$5 = HEAP32[($7_1 + 132 | 0) >> 2] | 0;
              $298 = i64toi32_i32$4;
              $298$hi = i64toi32_i32$5;
              i64toi32_i32$2 = ($7_1 + 128 | 0) + 8 | 0;
              i64toi32_i32$5 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $302 = i64toi32_i32$5;
              $302$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $298$hi;
              i64toi32_i32$5 = $302$hi;
              i64toi32_i32$2 = 0;
              i64toi32_i32$1 = 65536;
              $97($7_1 + 112 | 0 | 0, $298 | 0, i64toi32_i32$4 | 0, $302 | 0, i64toi32_i32$5 | 0, 0 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$1 | 0);
              i64toi32_i32$5 = ($7_1 + 112 | 0) + 8 | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$5 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
              $18_1 = i64toi32_i32$1;
              $18$hi = i64toi32_i32$2;
              i64toi32_i32$5 = $7_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 112 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 116 | 0) >> 2] | 0;
              $19_1 = i64toi32_i32$2;
              $19$hi = i64toi32_i32$1;
              break label$10;
            }
            label$32: {
              if (!$16_1) {
                break label$32;
              }
              label$33: {
                if (($16_1 | 0) > (8 | 0)) {
                  break label$33;
                }
                $2_1 = ($7_1 + 784 | 0) + ($15_1 << 2 | 0) | 0;
                $1_1 = HEAP32[$2_1 >> 2] | 0;
                label$34: while (1) {
                  $1_1 = Math_imul($1_1, 10);
                  $16_1 = $16_1 + 1 | 0;
                  if (($16_1 | 0) != (9 | 0)) {
                    continue label$34;
                  }
                  break label$34;
                };
                HEAP32[$2_1 >> 2] = $1_1;
              }
              $15_1 = $15_1 + 1 | 0;
            }
            i64toi32_i32$1 = $18$hi;
            $16_1 = $18_1;
            label$35: {
              if (($12_1 | 0) >= (9 | 0)) {
                break label$35;
              }
              if (($12_1 | 0) > ($16_1 | 0)) {
                break label$35;
              }
              if (($16_1 | 0) > (17 | 0)) {
                break label$35;
              }
              label$36: {
                if (($16_1 | 0) != (9 | 0)) {
                  break label$36;
                }
                $92($7_1 + 192 | 0 | 0, $5_1 | 0);
                $93($7_1 + 176 | 0 | 0, HEAP32[($7_1 + 784 | 0) >> 2] | 0 | 0);
                i64toi32_i32$5 = $7_1;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 192 | 0) >> 2] | 0;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 196 | 0) >> 2] | 0;
                $351 = i64toi32_i32$1;
                $351$hi = i64toi32_i32$2;
                i64toi32_i32$5 = (i64toi32_i32$5 + 192 | 0) + 8 | 0;
                i64toi32_i32$2 = HEAP32[i64toi32_i32$5 >> 2] | 0;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
                $355 = i64toi32_i32$2;
                $355$hi = i64toi32_i32$1;
                i64toi32_i32$5 = $7_1;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 176 | 0) >> 2] | 0;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 180 | 0) >> 2] | 0;
                $357 = i64toi32_i32$1;
                $357$hi = i64toi32_i32$2;
                i64toi32_i32$5 = (i64toi32_i32$5 + 176 | 0) + 8 | 0;
                i64toi32_i32$2 = HEAP32[i64toi32_i32$5 >> 2] | 0;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
                $361 = i64toi32_i32$2;
                $361$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $351$hi;
                i64toi32_i32$2 = $355$hi;
                i64toi32_i32$5 = $357$hi;
                i64toi32_i32$4 = $361$hi;
                $97($7_1 + 160 | 0 | 0, $351 | 0, i64toi32_i32$1 | 0, $355 | 0, i64toi32_i32$2 | 0, $357 | 0, i64toi32_i32$5 | 0, $361 | 0, i64toi32_i32$4 | 0);
                i64toi32_i32$2 = ($7_1 + 160 | 0) + 8 | 0;
                i64toi32_i32$4 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                i64toi32_i32$5 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                $18_1 = i64toi32_i32$4;
                $18$hi = i64toi32_i32$5;
                i64toi32_i32$2 = $7_1;
                i64toi32_i32$5 = HEAP32[($7_1 + 160 | 0) >> 2] | 0;
                i64toi32_i32$4 = HEAP32[($7_1 + 164 | 0) >> 2] | 0;
                $19_1 = i64toi32_i32$5;
                $19$hi = i64toi32_i32$4;
                break label$10;
              }
              label$37: {
                if (($16_1 | 0) > (8 | 0)) {
                  break label$37;
                }
                $92($7_1 + 272 | 0 | 0, $5_1 | 0);
                $93($7_1 + 256 | 0 | 0, HEAP32[($7_1 + 784 | 0) >> 2] | 0 | 0);
                i64toi32_i32$2 = $7_1;
                i64toi32_i32$4 = HEAP32[($7_1 + 272 | 0) >> 2] | 0;
                i64toi32_i32$5 = HEAP32[($7_1 + 276 | 0) >> 2] | 0;
                $380 = i64toi32_i32$4;
                $380$hi = i64toi32_i32$5;
                i64toi32_i32$2 = ($7_1 + 272 | 0) + 8 | 0;
                i64toi32_i32$5 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                i64toi32_i32$4 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                $384 = i64toi32_i32$5;
                $384$hi = i64toi32_i32$4;
                i64toi32_i32$2 = $7_1;
                i64toi32_i32$4 = HEAP32[($7_1 + 256 | 0) >> 2] | 0;
                i64toi32_i32$5 = HEAP32[($7_1 + 260 | 0) >> 2] | 0;
                $386 = i64toi32_i32$4;
                $386$hi = i64toi32_i32$5;
                i64toi32_i32$2 = ($7_1 + 256 | 0) + 8 | 0;
                i64toi32_i32$5 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                i64toi32_i32$4 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                $390 = i64toi32_i32$5;
                $390$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $380$hi;
                i64toi32_i32$5 = $384$hi;
                i64toi32_i32$2 = $386$hi;
                i64toi32_i32$1 = $390$hi;
                $97($7_1 + 240 | 0 | 0, $380 | 0, i64toi32_i32$4 | 0, $384 | 0, i64toi32_i32$5 | 0, $386 | 0, i64toi32_i32$2 | 0, $390 | 0, i64toi32_i32$1 | 0);
                $92($7_1 + 224 | 0 | 0, HEAP32[(((8 - $16_1 | 0) << 2 | 0) + 66112 | 0) >> 2] | 0 | 0);
                i64toi32_i32$5 = $7_1;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 240 | 0) >> 2] | 0;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 244 | 0) >> 2] | 0;
                $401 = i64toi32_i32$1;
                $401$hi = i64toi32_i32$2;
                i64toi32_i32$5 = (i64toi32_i32$5 + 240 | 0) + 8 | 0;
                i64toi32_i32$2 = HEAP32[i64toi32_i32$5 >> 2] | 0;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
                $405 = i64toi32_i32$2;
                $405$hi = i64toi32_i32$1;
                i64toi32_i32$5 = $7_1;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 224 | 0) >> 2] | 0;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 228 | 0) >> 2] | 0;
                $407 = i64toi32_i32$1;
                $407$hi = i64toi32_i32$2;
                i64toi32_i32$5 = (i64toi32_i32$5 + 224 | 0) + 8 | 0;
                i64toi32_i32$2 = HEAP32[i64toi32_i32$5 >> 2] | 0;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
                $411 = i64toi32_i32$2;
                $411$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $401$hi;
                i64toi32_i32$2 = $405$hi;
                i64toi32_i32$5 = $407$hi;
                i64toi32_i32$4 = $411$hi;
                $89($7_1 + 208 | 0 | 0, $401 | 0, i64toi32_i32$1 | 0, $405 | 0, i64toi32_i32$2 | 0, $407 | 0, i64toi32_i32$5 | 0, $411 | 0, i64toi32_i32$4 | 0);
                i64toi32_i32$2 = ($7_1 + 208 | 0) + 8 | 0;
                i64toi32_i32$4 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                i64toi32_i32$5 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                $18_1 = i64toi32_i32$4;
                $18$hi = i64toi32_i32$5;
                i64toi32_i32$2 = $7_1;
                i64toi32_i32$5 = HEAP32[($7_1 + 208 | 0) >> 2] | 0;
                i64toi32_i32$4 = HEAP32[($7_1 + 212 | 0) >> 2] | 0;
                $19_1 = i64toi32_i32$5;
                $19$hi = i64toi32_i32$4;
                break label$10;
              }
              $1_1 = HEAP32[($7_1 + 784 | 0) >> 2] | 0;
              label$38: {
                $2_1 = ($3_1 + Math_imul($16_1, -3) | 0) + 27 | 0;
                if (($2_1 | 0) > (30 | 0)) {
                  break label$38;
                }
                if ($1_1 >>> $2_1 | 0) {
                  break label$35;
                }
              }
              $92($7_1 + 352 | 0 | 0, $5_1 | 0);
              $93($7_1 + 336 | 0 | 0, $1_1 | 0);
              i64toi32_i32$2 = $7_1;
              i64toi32_i32$4 = HEAP32[($7_1 + 352 | 0) >> 2] | 0;
              i64toi32_i32$5 = HEAP32[($7_1 + 356 | 0) >> 2] | 0;
              $439 = i64toi32_i32$4;
              $439$hi = i64toi32_i32$5;
              i64toi32_i32$2 = ($7_1 + 352 | 0) + 8 | 0;
              i64toi32_i32$5 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $443 = i64toi32_i32$5;
              $443$hi = i64toi32_i32$4;
              i64toi32_i32$2 = $7_1;
              i64toi32_i32$4 = HEAP32[($7_1 + 336 | 0) >> 2] | 0;
              i64toi32_i32$5 = HEAP32[($7_1 + 340 | 0) >> 2] | 0;
              $445 = i64toi32_i32$4;
              $445$hi = i64toi32_i32$5;
              i64toi32_i32$2 = ($7_1 + 336 | 0) + 8 | 0;
              i64toi32_i32$5 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $449 = i64toi32_i32$5;
              $449$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $439$hi;
              i64toi32_i32$5 = $443$hi;
              i64toi32_i32$2 = $445$hi;
              i64toi32_i32$1 = $449$hi;
              $97($7_1 + 320 | 0 | 0, $439 | 0, i64toi32_i32$4 | 0, $443 | 0, i64toi32_i32$5 | 0, $445 | 0, i64toi32_i32$2 | 0, $449 | 0, i64toi32_i32$1 | 0);
              $92($7_1 + 304 | 0 | 0, HEAP32[(($16_1 << 2 | 0) + 66072 | 0) >> 2] | 0 | 0);
              i64toi32_i32$5 = $7_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 320 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 324 | 0) >> 2] | 0;
              $459 = i64toi32_i32$1;
              $459$hi = i64toi32_i32$2;
              i64toi32_i32$5 = (i64toi32_i32$5 + 320 | 0) + 8 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$5 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
              $463 = i64toi32_i32$2;
              $463$hi = i64toi32_i32$1;
              i64toi32_i32$5 = $7_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 304 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 308 | 0) >> 2] | 0;
              $465 = i64toi32_i32$1;
              $465$hi = i64toi32_i32$2;
              i64toi32_i32$5 = (i64toi32_i32$5 + 304 | 0) + 8 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$5 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
              $469 = i64toi32_i32$2;
              $469$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $459$hi;
              i64toi32_i32$2 = $463$hi;
              i64toi32_i32$5 = $465$hi;
              i64toi32_i32$4 = $469$hi;
              $97($7_1 + 288 | 0 | 0, $459 | 0, i64toi32_i32$1 | 0, $463 | 0, i64toi32_i32$2 | 0, $465 | 0, i64toi32_i32$5 | 0, $469 | 0, i64toi32_i32$4 | 0);
              i64toi32_i32$2 = ($7_1 + 288 | 0) + 8 | 0;
              i64toi32_i32$4 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $18_1 = i64toi32_i32$4;
              $18$hi = i64toi32_i32$5;
              i64toi32_i32$2 = $7_1;
              i64toi32_i32$5 = HEAP32[($7_1 + 288 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[($7_1 + 292 | 0) >> 2] | 0;
              $19_1 = i64toi32_i32$5;
              $19$hi = i64toi32_i32$4;
              break label$10;
            }
            label$39: while (1) {
              $14_1 = $15_1;
              $15_1 = $14_1 + -1 | 0;
              if (!(HEAP32[(($7_1 + 784 | 0) + ($15_1 << 2 | 0) | 0) >> 2] | 0)) {
                continue label$39;
              }
              break label$39;
            };
            $12_1 = 0;
            label$40: {
              label$41: {
                $1_1 = ($16_1 | 0) % (9 | 0) | 0;
                if ($1_1) {
                  break label$41;
                }
                $13_1 = 0;
                break label$40;
              }
              $13_1 = 0;
              $9_1 = ($16_1 | 0) < (0 | 0) ? $1_1 + 9 | 0 : $1_1;
              label$42: {
                label$43: {
                  if ($14_1) {
                    break label$43;
                  }
                  $14_1 = 0;
                  break label$42;
                }
                $11_1 = HEAP32[(((8 - $9_1 | 0) << 2 | 0) + 66112 | 0) >> 2] | 0;
                $6_1 = (1e9 | 0) / ($11_1 | 0) | 0;
                $2_1 = 0;
                $1_1 = 0;
                $13_1 = 0;
                label$44: while (1) {
                  $15_1 = ($7_1 + 784 | 0) + ($1_1 << 2 | 0) | 0;
                  $508 = $15_1;
                  $15_1 = HEAP32[$15_1 >> 2] | 0;
                  $8_1 = ($15_1 >>> 0) / ($11_1 >>> 0) | 0;
                  $2_1 = $8_1 + $2_1 | 0;
                  HEAP32[$508 >> 2] = $2_1;
                  $2_1 = ($1_1 | 0) == ($13_1 | 0) & !$2_1 | 0;
                  $13_1 = $2_1 ? ($13_1 + 1 | 0) & 2047 | 0 : $13_1;
                  $16_1 = $2_1 ? $16_1 + -9 | 0 : $16_1;
                  $2_1 = Math_imul($6_1, $15_1 - Math_imul($8_1, $11_1) | 0);
                  $1_1 = $1_1 + 1 | 0;
                  if (($1_1 | 0) != ($14_1 | 0)) {
                    continue label$44;
                  }
                  break label$44;
                };
                if (!$2_1) {
                  break label$42;
                }
                HEAP32[(($7_1 + 784 | 0) + ($14_1 << 2 | 0) | 0) >> 2] = $2_1;
                $14_1 = $14_1 + 1 | 0;
              }
              $16_1 = ($16_1 - $9_1 | 0) + 9 | 0;
            }
            label$45: while (1) {
              $9_1 = ($7_1 + 784 | 0) + ($13_1 << 2 | 0) | 0;
              $6_1 = ($16_1 | 0) < (36 | 0);
              label$46: {
                label$47: while (1) {
                  label$48: {
                    if ($6_1) {
                      break label$48;
                    }
                    if (($16_1 | 0) != (36 | 0)) {
                      break label$46;
                    }
                    if ((HEAP32[$9_1 >> 2] | 0) >>> 0 >= 10384593 >>> 0) {
                      break label$46;
                    }
                  }
                  $15_1 = $14_1 + 2047 | 0;
                  $11_1 = 0;
                  label$49: while (1) {
                    $2_1 = $14_1;
                    label$50: {
                      label$51: {
                        $1_1 = $15_1 & 2047 | 0;
                        $14_1 = ($7_1 + 784 | 0) + ($1_1 << 2 | 0) | 0;
                        i64toi32_i32$2 = $14_1;
                        i64toi32_i32$4 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                        i64toi32_i32$5 = 0;
                        i64toi32_i32$2 = i64toi32_i32$4;
                        i64toi32_i32$4 = 0;
                        i64toi32_i32$1 = 29;
                        i64toi32_i32$3 = i64toi32_i32$1 & 31 | 0;
                        if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                          i64toi32_i32$4 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
                          $180 = 0;
                        } else {
                          i64toi32_i32$4 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$3 | 0) | 0;
                          $180 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
                        }
                        $586$hi = i64toi32_i32$4;
                        i64toi32_i32$4 = 0;
                        $588$hi = i64toi32_i32$4;
                        i64toi32_i32$4 = $586$hi;
                        i64toi32_i32$5 = $180;
                        i64toi32_i32$2 = $588$hi;
                        i64toi32_i32$1 = $11_1;
                        i64toi32_i32$3 = i64toi32_i32$5 + i64toi32_i32$1 | 0;
                        i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
                        if (i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0) {
                          i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                        }
                        $18_1 = i64toi32_i32$3;
                        $18$hi = i64toi32_i32$0;
                        i64toi32_i32$4 = i64toi32_i32$3;
                        i64toi32_i32$5 = 0;
                        i64toi32_i32$1 = 1000000001;
                        if (i64toi32_i32$0 >>> 0 > i64toi32_i32$5 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$4 >>> 0 >= i64toi32_i32$1 >>> 0 | 0) | 0) {
                          break label$51;
                        }
                        $11_1 = 0;
                        break label$50;
                      }
                      i64toi32_i32$4 = $18$hi;
                      i64toi32_i32$0 = 0;
                      i64toi32_i32$0 = __wasm_i64_udiv($18_1 | 0, i64toi32_i32$4 | 0, 1e9 | 0, i64toi32_i32$0 | 0) | 0;
                      i64toi32_i32$4 = i64toi32_i32$HIGH_BITS;
                      $19_1 = i64toi32_i32$0;
                      $19$hi = i64toi32_i32$4;
                      i64toi32_i32$0 = 0;
                      i64toi32_i32$0 = __wasm_i64_mul($19_1 | 0, i64toi32_i32$4 | 0, 1e9 | 0, i64toi32_i32$0 | 0) | 0;
                      i64toi32_i32$4 = i64toi32_i32$HIGH_BITS;
                      $596 = i64toi32_i32$0;
                      $596$hi = i64toi32_i32$4;
                      i64toi32_i32$4 = $18$hi;
                      i64toi32_i32$1 = $18_1;
                      i64toi32_i32$0 = $596$hi;
                      i64toi32_i32$5 = $596;
                      i64toi32_i32$2 = i64toi32_i32$1 - i64toi32_i32$5 | 0;
                      i64toi32_i32$3 = (i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0) + i64toi32_i32$0 | 0;
                      i64toi32_i32$3 = i64toi32_i32$4 - i64toi32_i32$3 | 0;
                      $18_1 = i64toi32_i32$2;
                      $18$hi = i64toi32_i32$3;
                      i64toi32_i32$3 = $19$hi;
                      $11_1 = $19_1;
                    }
                    i64toi32_i32$3 = $18$hi;
                    $15_1 = $18_1;
                    HEAP32[$14_1 >> 2] = $15_1;
                    $8_1 = ($2_1 + -1 | 0) & 2047 | 0;
                    $14_1 = ($1_1 | 0) != ($8_1 | 0) ? $2_1 : ($1_1 | 0) == ($13_1 | 0) ? $2_1 : $15_1 ? $2_1 : $1_1;
                    $15_1 = $1_1 + -1 | 0;
                    if (($1_1 | 0) != ($13_1 | 0)) {
                      continue label$49;
                    }
                    break label$49;
                  };
                  $12_1 = $12_1 + -29 | 0;
                  $14_1 = $2_1;
                  if (!$11_1) {
                    continue label$47;
                  }
                  break label$47;
                };
                label$52: {
                  label$53: {
                    $13_1 = ($13_1 + -1 | 0) & 2047 | 0;
                    if (($13_1 | 0) == ($2_1 | 0)) {
                      break label$53;
                    }
                    $14_1 = $2_1;
                    break label$52;
                  }
                  $1_1 = ($7_1 + 784 | 0) + ((($2_1 + 2046 | 0) & 2047 | 0) << 2 | 0) | 0;
                  HEAP32[$1_1 >> 2] = HEAP32[$1_1 >> 2] | 0 | (HEAP32[(($7_1 + 784 | 0) + ($8_1 << 2 | 0) | 0) >> 2] | 0) | 0;
                  $14_1 = $8_1;
                }
                $16_1 = $16_1 + 9 | 0;
                HEAP32[(($7_1 + 784 | 0) + ($13_1 << 2 | 0) | 0) >> 2] = $11_1;
                continue label$45;
              }
              break label$45;
            };
            label$54: {
              label$55: while (1) {
                $17_1 = ($14_1 + 1 | 0) & 2047 | 0;
                $9_1 = ($7_1 + 784 | 0) + ((($14_1 + -1 | 0) & 2047 | 0) << 2 | 0) | 0;
                label$56: while (1) {
                  $15_1 = ($16_1 | 0) > (45 | 0) ? 9 : 1;
                  label$57: {
                    label$58: while (1) {
                      $11_1 = $13_1;
                      $1_1 = 0;
                      label$59: {
                        label$60: {
                          label$61: while (1) {
                            $2_1 = ($1_1 + $11_1 | 0) & 2047 | 0;
                            if (($2_1 | 0) == ($14_1 | 0)) {
                              break label$60;
                            }
                            $2_1 = HEAP32[(($7_1 + 784 | 0) + ($2_1 << 2 | 0) | 0) >> 2] | 0;
                            $13_1 = HEAP32[(($1_1 << 2 | 0) + 66096 | 0) >> 2] | 0;
                            if ($2_1 >>> 0 < $13_1 >>> 0) {
                              break label$60;
                            }
                            if ($2_1 >>> 0 > $13_1 >>> 0) {
                              break label$59;
                            }
                            $1_1 = $1_1 + 1 | 0;
                            if (($1_1 | 0) != (4 | 0)) {
                              continue label$61;
                            }
                            break label$61;
                          };
                        }
                        if (($16_1 | 0) != (36 | 0)) {
                          break label$59;
                        }
                        i64toi32_i32$3 = 0;
                        $18_1 = 0;
                        $18$hi = i64toi32_i32$3;
                        $1_1 = 0;
                        i64toi32_i32$3 = 0;
                        $19_1 = 0;
                        $19$hi = i64toi32_i32$3;
                        label$62: while (1) {
                          label$63: {
                            $2_1 = ($1_1 + $11_1 | 0) & 2047 | 0;
                            if (($2_1 | 0) != ($14_1 | 0)) {
                              break label$63;
                            }
                            $14_1 = ($14_1 + 1 | 0) & 2047 | 0;
                            HEAP32[((($14_1 << 2 | 0) + ($7_1 + 784 | 0) | 0) + -4 | 0) >> 2] = 0;
                          }
                          $93($7_1 + 768 | 0 | 0, HEAP32[(($7_1 + 784 | 0) + ($2_1 << 2 | 0) | 0) >> 2] | 0 | 0);
                          i64toi32_i32$3 = $18$hi;
                          i64toi32_i32$3 = $19$hi;
                          i64toi32_i32$3 = $18$hi;
                          i64toi32_i32$1 = $19$hi;
                          i64toi32_i32$4 = 0;
                          i64toi32_i32$5 = 1075633366;
                          $97($7_1 + 752 | 0 | 0, $18_1 | 0, i64toi32_i32$3 | 0, $19_1 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$4 | 0, 1342177280 | 0, i64toi32_i32$5 | 0);
                          i64toi32_i32$1 = $7_1;
                          i64toi32_i32$5 = HEAP32[($7_1 + 752 | 0) >> 2] | 0;
                          i64toi32_i32$4 = HEAP32[($7_1 + 756 | 0) >> 2] | 0;
                          $738 = i64toi32_i32$5;
                          $738$hi = i64toi32_i32$4;
                          i64toi32_i32$1 = ($7_1 + 752 | 0) + 8 | 0;
                          i64toi32_i32$4 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                          i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                          $742 = i64toi32_i32$4;
                          $742$hi = i64toi32_i32$5;
                          i64toi32_i32$1 = $7_1;
                          i64toi32_i32$5 = HEAP32[($7_1 + 768 | 0) >> 2] | 0;
                          i64toi32_i32$4 = HEAP32[($7_1 + 772 | 0) >> 2] | 0;
                          $744 = i64toi32_i32$5;
                          $744$hi = i64toi32_i32$4;
                          i64toi32_i32$1 = ($7_1 + 768 | 0) + 8 | 0;
                          i64toi32_i32$4 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                          i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                          $748 = i64toi32_i32$4;
                          $748$hi = i64toi32_i32$5;
                          i64toi32_i32$5 = $738$hi;
                          i64toi32_i32$4 = $742$hi;
                          i64toi32_i32$1 = $744$hi;
                          i64toi32_i32$3 = $748$hi;
                          $85($7_1 + 736 | 0 | 0, $738 | 0, i64toi32_i32$5 | 0, $742 | 0, i64toi32_i32$4 | 0, $744 | 0, i64toi32_i32$1 | 0, $748 | 0, i64toi32_i32$3 | 0);
                          i64toi32_i32$4 = ($7_1 + 736 | 0) + 8 | 0;
                          i64toi32_i32$3 = HEAP32[i64toi32_i32$4 >> 2] | 0;
                          i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
                          $19_1 = i64toi32_i32$3;
                          $19$hi = i64toi32_i32$1;
                          i64toi32_i32$4 = $7_1;
                          i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 736 | 0) >> 2] | 0;
                          i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 740 | 0) >> 2] | 0;
                          $18_1 = i64toi32_i32$1;
                          $18$hi = i64toi32_i32$3;
                          $1_1 = $1_1 + 1 | 0;
                          if (($1_1 | 0) != (4 | 0)) {
                            continue label$62;
                          }
                          break label$62;
                        };
                        $92(i64toi32_i32$4 + 720 | 0 | 0, $5_1 | 0);
                        i64toi32_i32$3 = $19$hi;
                        i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 720 | 0) >> 2] | 0;
                        i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 724 | 0) >> 2] | 0;
                        $767 = i64toi32_i32$3;
                        $767$hi = i64toi32_i32$1;
                        i64toi32_i32$4 = (i64toi32_i32$4 + 720 | 0) + 8 | 0;
                        i64toi32_i32$1 = HEAP32[i64toi32_i32$4 >> 2] | 0;
                        i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
                        $771 = i64toi32_i32$1;
                        $771$hi = i64toi32_i32$3;
                        i64toi32_i32$3 = $18$hi;
                        i64toi32_i32$1 = $19$hi;
                        i64toi32_i32$4 = $767$hi;
                        i64toi32_i32$5 = $771$hi;
                        $97($7_1 + 704 | 0 | 0, $18_1 | 0, i64toi32_i32$3 | 0, $19_1 | 0, i64toi32_i32$1 | 0, $767 | 0, i64toi32_i32$4 | 0, $771 | 0, i64toi32_i32$5 | 0);
                        i64toi32_i32$1 = ($7_1 + 704 | 0) + 8 | 0;
                        i64toi32_i32$5 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                        i64toi32_i32$4 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                        $19_1 = i64toi32_i32$5;
                        $19$hi = i64toi32_i32$4;
                        i64toi32_i32$4 = 0;
                        $18_1 = 0;
                        $18$hi = i64toi32_i32$4;
                        i64toi32_i32$1 = $7_1;
                        i64toi32_i32$4 = HEAP32[($7_1 + 704 | 0) >> 2] | 0;
                        i64toi32_i32$5 = HEAP32[($7_1 + 708 | 0) >> 2] | 0;
                        $20_1 = i64toi32_i32$4;
                        $20$hi = i64toi32_i32$5;
                        $13_1 = $12_1 + 113 | 0;
                        $1_1 = $13_1 - $4_1 | 0;
                        $8_1 = ($1_1 | 0) < ($3_1 | 0);
                        $2_1 = $8_1 ? ($1_1 | 0) > (0 | 0) ? $1_1 : 0 : $3_1;
                        if (($2_1 | 0) <= (112 | 0)) {
                          break label$57;
                        }
                        i64toi32_i32$5 = 0;
                        $21_1 = 0;
                        $21$hi = i64toi32_i32$5;
                        i64toi32_i32$5 = 0;
                        $22_1 = 0;
                        $22$hi = i64toi32_i32$5;
                        i64toi32_i32$5 = 0;
                        $23_1 = 0;
                        $23$hi = i64toi32_i32$5;
                        break label$54;
                      }
                      $12_1 = $15_1 + $12_1 | 0;
                      $13_1 = $14_1;
                      if (($11_1 | 0) == ($14_1 | 0)) {
                        continue label$58;
                      }
                      break label$58;
                    };
                    $8_1 = 1e9 >>> $15_1 | 0;
                    $6_1 = (-1 << $15_1 | 0) ^ -1 | 0;
                    $1_1 = 0;
                    $13_1 = $11_1;
                    label$64: while (1) {
                      $2_1 = ($7_1 + 784 | 0) + ($11_1 << 2 | 0) | 0;
                      $813 = $2_1;
                      $2_1 = HEAP32[$2_1 >> 2] | 0;
                      $1_1 = ($2_1 >>> $15_1 | 0) + $1_1 | 0;
                      HEAP32[$813 >> 2] = $1_1;
                      $1_1 = ($11_1 | 0) == ($13_1 | 0) & !$1_1 | 0;
                      $13_1 = $1_1 ? ($13_1 + 1 | 0) & 2047 | 0 : $13_1;
                      $16_1 = $1_1 ? $16_1 + -9 | 0 : $16_1;
                      $1_1 = Math_imul($2_1 & $6_1 | 0, $8_1);
                      $11_1 = ($11_1 + 1 | 0) & 2047 | 0;
                      if (($11_1 | 0) != ($14_1 | 0)) {
                        continue label$64;
                      }
                      break label$64;
                    };
                    if (!$1_1) {
                      continue label$56;
                    }
                    label$65: {
                      if (($17_1 | 0) == ($13_1 | 0)) {
                        break label$65;
                      }
                      HEAP32[(($7_1 + 784 | 0) + ($14_1 << 2 | 0) | 0) >> 2] = $1_1;
                      $14_1 = $17_1;
                      continue label$55;
                    }
                    HEAP32[$9_1 >> 2] = HEAP32[$9_1 >> 2] | 0 | 1 | 0;
                    continue label$56;
                  }
                  break label$56;
                };
                break label$55;
              };
              $90($7_1 + 656 | 0 | 0, + +$50(+1.0, 225 - $2_1 | 0 | 0));
              i64toi32_i32$1 = $7_1;
              i64toi32_i32$5 = HEAP32[($7_1 + 656 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[($7_1 + 660 | 0) >> 2] | 0;
              $874 = i64toi32_i32$5;
              $874$hi = i64toi32_i32$4;
              i64toi32_i32$1 = ($7_1 + 656 | 0) + 8 | 0;
              i64toi32_i32$4 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $878 = i64toi32_i32$4;
              $878$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $20$hi;
              i64toi32_i32$5 = $19$hi;
              i64toi32_i32$5 = $874$hi;
              i64toi32_i32$4 = $878$hi;
              i64toi32_i32$1 = $20$hi;
              i64toi32_i32$3 = $19$hi;
              $51($7_1 + 688 | 0 | 0, $874 | 0, i64toi32_i32$5 | 0, $878 | 0, i64toi32_i32$4 | 0, $20_1 | 0, i64toi32_i32$1 | 0, $19_1 | 0, i64toi32_i32$3 | 0);
              i64toi32_i32$4 = ($7_1 + 688 | 0) + 8 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $23_1 = i64toi32_i32$3;
              $23$hi = i64toi32_i32$1;
              i64toi32_i32$4 = $7_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 688 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 692 | 0) >> 2] | 0;
              $22_1 = i64toi32_i32$1;
              $22$hi = i64toi32_i32$3;
              $90(i64toi32_i32$4 + 640 | 0 | 0, + +$50(+1.0, 113 - $2_1 | 0 | 0));
              i64toi32_i32$3 = $20$hi;
              i64toi32_i32$3 = $19$hi;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 640 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 644 | 0) >> 2] | 0;
              $897 = i64toi32_i32$3;
              $897$hi = i64toi32_i32$1;
              i64toi32_i32$4 = (i64toi32_i32$4 + 640 | 0) + 8 | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $901 = i64toi32_i32$1;
              $901$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $20$hi;
              i64toi32_i32$1 = $19$hi;
              i64toi32_i32$4 = $897$hi;
              i64toi32_i32$5 = $901$hi;
              $54($7_1 + 672 | 0 | 0, $20_1 | 0, i64toi32_i32$3 | 0, $19_1 | 0, i64toi32_i32$1 | 0, $897 | 0, i64toi32_i32$4 | 0, $901 | 0, i64toi32_i32$5 | 0);
              i64toi32_i32$5 = i64toi32_i32$3;
              i64toi32_i32$5 = i64toi32_i32$1;
              i64toi32_i32$1 = $7_1;
              i64toi32_i32$5 = HEAP32[($7_1 + 672 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[($7_1 + 676 | 0) >> 2] | 0;
              $18_1 = i64toi32_i32$5;
              $18$hi = i64toi32_i32$4;
              i64toi32_i32$1 = ($7_1 + 672 | 0) + 8 | 0;
              i64toi32_i32$4 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $21_1 = i64toi32_i32$4;
              $21$hi = i64toi32_i32$5;
              i64toi32_i32$5 = i64toi32_i32$3;
              i64toi32_i32$4 = $19$hi;
              i64toi32_i32$1 = $18$hi;
              i64toi32_i32$3 = $21$hi;
              $99($7_1 + 624 | 0 | 0, $20_1 | 0, i64toi32_i32$5 | 0, $19_1 | 0, i64toi32_i32$4 | 0, $18_1 | 0, i64toi32_i32$1 | 0, $21_1 | 0, i64toi32_i32$3 | 0);
              i64toi32_i32$3 = $22$hi;
              i64toi32_i32$3 = $23$hi;
              i64toi32_i32$4 = $7_1;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 624 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 628 | 0) >> 2] | 0;
              $919 = i64toi32_i32$3;
              $919$hi = i64toi32_i32$1;
              i64toi32_i32$4 = (i64toi32_i32$4 + 624 | 0) + 8 | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $923 = i64toi32_i32$1;
              $923$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $22$hi;
              i64toi32_i32$1 = $23$hi;
              i64toi32_i32$4 = $919$hi;
              i64toi32_i32$5 = $923$hi;
              $85($7_1 + 608 | 0 | 0, $22_1 | 0, i64toi32_i32$3 | 0, $23_1 | 0, i64toi32_i32$1 | 0, $919 | 0, i64toi32_i32$4 | 0, $923 | 0, i64toi32_i32$5 | 0);
              i64toi32_i32$1 = ($7_1 + 608 | 0) + 8 | 0;
              i64toi32_i32$5 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $19_1 = i64toi32_i32$5;
              $19$hi = i64toi32_i32$4;
              i64toi32_i32$1 = $7_1;
              i64toi32_i32$4 = HEAP32[($7_1 + 608 | 0) >> 2] | 0;
              i64toi32_i32$5 = HEAP32[($7_1 + 612 | 0) >> 2] | 0;
              $20_1 = i64toi32_i32$4;
              $20$hi = i64toi32_i32$5;
            }
            label$66: {
              $15_1 = ($11_1 + 4 | 0) & 2047 | 0;
              if (($15_1 | 0) == ($14_1 | 0)) {
                break label$66;
              }
              label$67: {
                label$68: {
                  $15_1 = HEAP32[(($7_1 + 784 | 0) + ($15_1 << 2 | 0) | 0) >> 2] | 0;
                  if ($15_1 >>> 0 > 499999999 >>> 0) {
                    break label$68;
                  }
                  label$69: {
                    if ($15_1) {
                      break label$69;
                    }
                    if ((($11_1 + 5 | 0) & 2047 | 0 | 0) == ($14_1 | 0)) {
                      break label$67;
                    }
                  }
                  $90($7_1 + 496 | 0 | 0, +(+($5_1 | 0) * .25));
                  i64toi32_i32$5 = $18$hi;
                  i64toi32_i32$5 = $21$hi;
                  i64toi32_i32$1 = $7_1;
                  i64toi32_i32$5 = HEAP32[($7_1 + 496 | 0) >> 2] | 0;
                  i64toi32_i32$4 = HEAP32[($7_1 + 500 | 0) >> 2] | 0;
                  $960 = i64toi32_i32$5;
                  $960$hi = i64toi32_i32$4;
                  i64toi32_i32$1 = ($7_1 + 496 | 0) + 8 | 0;
                  i64toi32_i32$4 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                  i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                  $964 = i64toi32_i32$4;
                  $964$hi = i64toi32_i32$5;
                  i64toi32_i32$5 = $18$hi;
                  i64toi32_i32$4 = $21$hi;
                  i64toi32_i32$1 = $960$hi;
                  i64toi32_i32$3 = $964$hi;
                  $85($7_1 + 480 | 0 | 0, $18_1 | 0, i64toi32_i32$5 | 0, $21_1 | 0, i64toi32_i32$4 | 0, $960 | 0, i64toi32_i32$1 | 0, $964 | 0, i64toi32_i32$3 | 0);
                  i64toi32_i32$4 = ($7_1 + 480 | 0) + 8 | 0;
                  i64toi32_i32$3 = HEAP32[i64toi32_i32$4 >> 2] | 0;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
                  $21_1 = i64toi32_i32$3;
                  $21$hi = i64toi32_i32$1;
                  i64toi32_i32$4 = $7_1;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 480 | 0) >> 2] | 0;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 484 | 0) >> 2] | 0;
                  $18_1 = i64toi32_i32$1;
                  $18$hi = i64toi32_i32$3;
                  break label$67;
                }
                label$70: {
                  if (($15_1 | 0) == (5e8 | 0)) {
                    break label$70;
                  }
                  $90($7_1 + 592 | 0 | 0, +(+($5_1 | 0) * .75));
                  i64toi32_i32$3 = $18$hi;
                  i64toi32_i32$3 = $21$hi;
                  i64toi32_i32$4 = $7_1;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 592 | 0) >> 2] | 0;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 596 | 0) >> 2] | 0;
                  $983 = i64toi32_i32$3;
                  $983$hi = i64toi32_i32$1;
                  i64toi32_i32$4 = (i64toi32_i32$4 + 592 | 0) + 8 | 0;
                  i64toi32_i32$1 = HEAP32[i64toi32_i32$4 >> 2] | 0;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
                  $987 = i64toi32_i32$1;
                  $987$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = $18$hi;
                  i64toi32_i32$1 = $21$hi;
                  i64toi32_i32$4 = $983$hi;
                  i64toi32_i32$5 = $987$hi;
                  $85($7_1 + 576 | 0 | 0, $18_1 | 0, i64toi32_i32$3 | 0, $21_1 | 0, i64toi32_i32$1 | 0, $983 | 0, i64toi32_i32$4 | 0, $987 | 0, i64toi32_i32$5 | 0);
                  i64toi32_i32$1 = ($7_1 + 576 | 0) + 8 | 0;
                  i64toi32_i32$5 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                  i64toi32_i32$4 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                  $21_1 = i64toi32_i32$5;
                  $21$hi = i64toi32_i32$4;
                  i64toi32_i32$1 = $7_1;
                  i64toi32_i32$4 = HEAP32[($7_1 + 576 | 0) >> 2] | 0;
                  i64toi32_i32$5 = HEAP32[($7_1 + 580 | 0) >> 2] | 0;
                  $18_1 = i64toi32_i32$4;
                  $18$hi = i64toi32_i32$5;
                  break label$67;
                }
                $24_1 = +($5_1 | 0);
                label$71: {
                  if ((($11_1 + 5 | 0) & 2047 | 0 | 0) != ($14_1 | 0)) {
                    break label$71;
                  }
                  $90($7_1 + 528 | 0 | 0, +($24_1 * .5));
                  i64toi32_i32$5 = $18$hi;
                  i64toi32_i32$5 = $21$hi;
                  i64toi32_i32$1 = $7_1;
                  i64toi32_i32$5 = HEAP32[($7_1 + 528 | 0) >> 2] | 0;
                  i64toi32_i32$4 = HEAP32[($7_1 + 532 | 0) >> 2] | 0;
                  $1010 = i64toi32_i32$5;
                  $1010$hi = i64toi32_i32$4;
                  i64toi32_i32$1 = ($7_1 + 528 | 0) + 8 | 0;
                  i64toi32_i32$4 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                  i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                  $1014 = i64toi32_i32$4;
                  $1014$hi = i64toi32_i32$5;
                  i64toi32_i32$5 = $18$hi;
                  i64toi32_i32$4 = $21$hi;
                  i64toi32_i32$1 = $1010$hi;
                  i64toi32_i32$3 = $1014$hi;
                  $85($7_1 + 512 | 0 | 0, $18_1 | 0, i64toi32_i32$5 | 0, $21_1 | 0, i64toi32_i32$4 | 0, $1010 | 0, i64toi32_i32$1 | 0, $1014 | 0, i64toi32_i32$3 | 0);
                  i64toi32_i32$4 = ($7_1 + 512 | 0) + 8 | 0;
                  i64toi32_i32$3 = HEAP32[i64toi32_i32$4 >> 2] | 0;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
                  $21_1 = i64toi32_i32$3;
                  $21$hi = i64toi32_i32$1;
                  i64toi32_i32$4 = $7_1;
                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 512 | 0) >> 2] | 0;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 516 | 0) >> 2] | 0;
                  $18_1 = i64toi32_i32$1;
                  $18$hi = i64toi32_i32$3;
                  break label$67;
                }
                $90($7_1 + 560 | 0 | 0, +($24_1 * .75));
                i64toi32_i32$3 = $18$hi;
                i64toi32_i32$3 = $21$hi;
                i64toi32_i32$4 = $7_1;
                i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 560 | 0) >> 2] | 0;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 564 | 0) >> 2] | 0;
                $1030 = i64toi32_i32$3;
                $1030$hi = i64toi32_i32$1;
                i64toi32_i32$4 = (i64toi32_i32$4 + 560 | 0) + 8 | 0;
                i64toi32_i32$1 = HEAP32[i64toi32_i32$4 >> 2] | 0;
                i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
                $1034 = i64toi32_i32$1;
                $1034$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $18$hi;
                i64toi32_i32$1 = $21$hi;
                i64toi32_i32$4 = $1030$hi;
                i64toi32_i32$5 = $1034$hi;
                $85($7_1 + 544 | 0 | 0, $18_1 | 0, i64toi32_i32$3 | 0, $21_1 | 0, i64toi32_i32$1 | 0, $1030 | 0, i64toi32_i32$4 | 0, $1034 | 0, i64toi32_i32$5 | 0);
                i64toi32_i32$1 = ($7_1 + 544 | 0) + 8 | 0;
                i64toi32_i32$5 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                i64toi32_i32$4 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                $21_1 = i64toi32_i32$5;
                $21$hi = i64toi32_i32$4;
                i64toi32_i32$1 = $7_1;
                i64toi32_i32$4 = HEAP32[($7_1 + 544 | 0) >> 2] | 0;
                i64toi32_i32$5 = HEAP32[($7_1 + 548 | 0) >> 2] | 0;
                $18_1 = i64toi32_i32$4;
                $18$hi = i64toi32_i32$5;
              }
              if (($2_1 | 0) > (111 | 0)) {
                break label$66;
              }
              i64toi32_i32$5 = $18$hi;
              i64toi32_i32$5 = $21$hi;
              i64toi32_i32$5 = $18$hi;
              i64toi32_i32$4 = $21$hi;
              i64toi32_i32$1 = 0;
              i64toi32_i32$3 = 1073676288;
              $54($7_1 + 464 | 0 | 0, $18_1 | 0, i64toi32_i32$5 | 0, $21_1 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$3 | 0);
              i64toi32_i32$4 = $7_1;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 464 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 468 | 0) >> 2] | 0;
              $1048 = i64toi32_i32$3;
              $1048$hi = i64toi32_i32$1;
              i64toi32_i32$4 = (i64toi32_i32$4 + 464 | 0) + 8 | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $1052 = i64toi32_i32$1;
              $1052$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $1048$hi;
              i64toi32_i32$1 = $1052$hi;
              i64toi32_i32$4 = 0;
              i64toi32_i32$5 = 0;
              if ($87($1048 | 0, i64toi32_i32$3 | 0, $1052 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$5 | 0) | 0) {
                break label$66;
              }
              i64toi32_i32$5 = $18$hi;
              i64toi32_i32$5 = $21$hi;
              i64toi32_i32$5 = $18$hi;
              i64toi32_i32$4 = $21$hi;
              i64toi32_i32$1 = 0;
              i64toi32_i32$3 = 1073676288;
              $85($7_1 + 448 | 0 | 0, $18_1 | 0, i64toi32_i32$5 | 0, $21_1 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$3 | 0);
              i64toi32_i32$4 = ($7_1 + 448 | 0) + 8 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $21_1 = i64toi32_i32$3;
              $21$hi = i64toi32_i32$1;
              i64toi32_i32$4 = $7_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 448 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 452 | 0) >> 2] | 0;
              $18_1 = i64toi32_i32$1;
              $18$hi = i64toi32_i32$3;
            }
            i64toi32_i32$3 = $20$hi;
            i64toi32_i32$3 = $19$hi;
            i64toi32_i32$3 = $18$hi;
            i64toi32_i32$3 = $21$hi;
            i64toi32_i32$3 = $20$hi;
            i64toi32_i32$1 = $19$hi;
            i64toi32_i32$4 = $18$hi;
            i64toi32_i32$5 = $21$hi;
            $85($7_1 + 432 | 0 | 0, $20_1 | 0, i64toi32_i32$3 | 0, $19_1 | 0, i64toi32_i32$1 | 0, $18_1 | 0, i64toi32_i32$4 | 0, $21_1 | 0, i64toi32_i32$5 | 0);
            i64toi32_i32$1 = $7_1;
            i64toi32_i32$5 = HEAP32[($7_1 + 432 | 0) >> 2] | 0;
            i64toi32_i32$4 = HEAP32[($7_1 + 436 | 0) >> 2] | 0;
            $1073 = i64toi32_i32$5;
            $1073$hi = i64toi32_i32$4;
            i64toi32_i32$1 = ($7_1 + 432 | 0) + 8 | 0;
            i64toi32_i32$4 = HEAP32[i64toi32_i32$1 >> 2] | 0;
            i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
            $1077 = i64toi32_i32$4;
            $1077$hi = i64toi32_i32$5;
            i64toi32_i32$5 = $22$hi;
            i64toi32_i32$5 = $23$hi;
            i64toi32_i32$5 = $1073$hi;
            i64toi32_i32$4 = $1077$hi;
            i64toi32_i32$1 = $22$hi;
            i64toi32_i32$3 = $23$hi;
            $99($7_1 + 416 | 0 | 0, $1073 | 0, i64toi32_i32$5 | 0, $1077 | 0, i64toi32_i32$4 | 0, $22_1 | 0, i64toi32_i32$1 | 0, $23_1 | 0, i64toi32_i32$3 | 0);
            i64toi32_i32$4 = ($7_1 + 416 | 0) + 8 | 0;
            i64toi32_i32$3 = HEAP32[i64toi32_i32$4 >> 2] | 0;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
            $19_1 = i64toi32_i32$3;
            $19$hi = i64toi32_i32$1;
            i64toi32_i32$4 = $7_1;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 416 | 0) >> 2] | 0;
            i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 420 | 0) >> 2] | 0;
            $20_1 = i64toi32_i32$1;
            $20$hi = i64toi32_i32$3;
            label$72: {
              if (($13_1 & 2147483647 | 0 | 0) <= ($10_1 + -2 | 0 | 0)) {
                break label$72;
              }
              i64toi32_i32$3 = $19$hi;
              i64toi32_i32$3 = $20$hi;
              i64toi32_i32$1 = $19$hi;
              $55(i64toi32_i32$4 + 400 | 0 | 0, $20_1 | 0, i64toi32_i32$3 | 0, $19_1 | 0, i64toi32_i32$1 | 0);
              i64toi32_i32$1 = i64toi32_i32$3;
              i64toi32_i32$1 = $19$hi;
              i64toi32_i32$1 = i64toi32_i32$3;
              i64toi32_i32$3 = $19$hi;
              i64toi32_i32$4 = 0;
              i64toi32_i32$5 = 1073610752;
              $97($7_1 + 384 | 0 | 0, $20_1 | 0, i64toi32_i32$1 | 0, $19_1 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$5 | 0);
              i64toi32_i32$3 = $7_1;
              i64toi32_i32$5 = HEAP32[($7_1 + 400 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[($7_1 + 404 | 0) >> 2] | 0;
              $1100 = i64toi32_i32$5;
              $1100$hi = i64toi32_i32$4;
              i64toi32_i32$3 = ($7_1 + 400 | 0) + 8 | 0;
              i64toi32_i32$4 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $1104 = i64toi32_i32$4;
              $1104$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $1100$hi;
              i64toi32_i32$4 = $1104$hi;
              i64toi32_i32$3 = 0;
              i64toi32_i32$1 = 1081081856;
              $13_1 = $88($1100 | 0, i64toi32_i32$5 | 0, $1104 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$1 | 0) | 0;
              i64toi32_i32$4 = ($7_1 + 384 | 0) + 8 | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $1109$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $19$hi;
              $14_1 = ($13_1 | 0) > (-1 | 0);
              i64toi32_i32$0 = $14_1;
              i64toi32_i32$3 = $1109$hi;
              $181 = i64toi32_i32$1;
              i64toi32_i32$1 = $19$hi;
              i64toi32_i32$5 = $14_1 ? $181 : $19_1;
              i64toi32_i32$4 = $14_1 ? i64toi32_i32$3 : i64toi32_i32$1;
              $19_1 = i64toi32_i32$5;
              $19$hi = i64toi32_i32$4;
              i64toi32_i32$0 = $7_1;
              i64toi32_i32$4 = HEAP32[($7_1 + 384 | 0) >> 2] | 0;
              i64toi32_i32$5 = HEAP32[($7_1 + 388 | 0) >> 2] | 0;
              $1116$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $20$hi;
              i64toi32_i32$1 = $14_1;
              i64toi32_i32$5 = $1116$hi;
              $182 = i64toi32_i32$4;
              i64toi32_i32$4 = $20$hi;
              i64toi32_i32$3 = i64toi32_i32$1 ? $182 : $20_1;
              i64toi32_i32$0 = i64toi32_i32$1 ? i64toi32_i32$5 : i64toi32_i32$4;
              $20_1 = i64toi32_i32$3;
              $20$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $18$hi;
              i64toi32_i32$0 = $21$hi;
              i64toi32_i32$0 = $18$hi;
              i64toi32_i32$3 = $21$hi;
              i64toi32_i32$1 = 0;
              i64toi32_i32$5 = 0;
              $11_1 = $87($18_1 | 0, $18$hi | 0, $21_1 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$5 | 0) | 0;
              label$73: {
                $12_1 = $12_1 + $14_1 | 0;
                if (($12_1 + 110 | 0 | 0) > ($10_1 | 0)) {
                  break label$73;
                }
                if (!(($8_1 & (($2_1 | 0) != ($1_1 | 0) | ($13_1 | 0) < (0 | 0) | 0) | 0) & ($11_1 | 0) != (0 | 0) | 0)) {
                  break label$72;
                }
              }
              (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 68), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
            }
            i64toi32_i32$5 = $20$hi;
            i64toi32_i32$5 = $19$hi;
            i64toi32_i32$5 = $20$hi;
            i64toi32_i32$1 = $19$hi;
            $52($7_1 + 368 | 0 | 0, $20_1 | 0, i64toi32_i32$5 | 0, $19_1 | 0, i64toi32_i32$1 | 0, $12_1 | 0);
            i64toi32_i32$3 = ($7_1 + 368 | 0) + 8 | 0;
            i64toi32_i32$1 = HEAP32[i64toi32_i32$3 >> 2] | 0;
            i64toi32_i32$5 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
            $18_1 = i64toi32_i32$1;
            $18$hi = i64toi32_i32$5;
            i64toi32_i32$3 = $7_1;
            i64toi32_i32$5 = HEAP32[($7_1 + 368 | 0) >> 2] | 0;
            i64toi32_i32$1 = HEAP32[($7_1 + 372 | 0) >> 2] | 0;
            $19_1 = i64toi32_i32$5;
            $19$hi = i64toi32_i32$1;
          }
          i64toi32_i32$1 = $18$hi;
          i64toi32_i32$5 = $0_1;
          HEAP32[(i64toi32_i32$5 + 8 | 0) >> 2] = $18_1;
          HEAP32[(i64toi32_i32$5 + 12 | 0) >> 2] = i64toi32_i32$1;
          i64toi32_i32$1 = $19$hi;
          HEAP32[i64toi32_i32$5 >> 2] = $19_1;
          HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] = i64toi32_i32$1;
          global$0 = $7_1 + 8976 | 0;
        }

        function $60($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var $2_1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$5 = 0,i64toi32_i32$1 = 0,i64toi32_i32$4 = 0,$3_1 = 0,$6$hi = 0,$6_1 = 0,$5_1 = 0,i64toi32_i32$3 = 0,$4_1 = 0,$18_1 = 0,$19_1 = 0,$20_1 = 0,$21_1 = 0,$22_1 = 0,$23_1 = 0,$24_1 = 0,$25_1 = 0,$26_1 = 0,$27_1 = 0,$28_1 = 0,$29_1 = 0,$88$hi = 0,$90_1 = 0,$90$hi = 0,$139$hi = 0;
          label$1: {
            label$2: {
              $2_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
              if (($2_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                break label$2;
              }
              HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
              $3_1 = HEAPU8[$2_1 >> 0] | 0;
              break label$1;
            }
            $3_1 = $49($0_1 | 0) | 0;
          }
          label$3: {
            label$4: {
              label$5: {
                label$6: {
                  switch ($3_1 + -43 | 0 | 0) {
                    case 0:
                    case 2:
                      label$8: {
                        label$9: {
                          $2_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                          if (($2_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                            break label$9;
                          }
                          HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                          $2_1 = HEAPU8[$2_1 >> 0] | 0;
                          break label$8;
                        }
                        $2_1 = $49($0_1 | 0) | 0;
                      }
                      $4_1 = ($3_1 | 0) == (45 | 0);
                      $5_1 = $2_1 + -58 | 0;
                      if (!$1_1) {
                        break label$5;
                      }
                      if ($5_1 >>> 0 > -11 >>> 0) {
                        break label$5;
                      }
                      i64toi32_i32$2 = $0_1;
                      i64toi32_i32$0 = HEAP32[($0_1 + 112 | 0) >> 2] | 0;
                      i64toi32_i32$1 = HEAP32[($0_1 + 116 | 0) >> 2] | 0;
                      i64toi32_i32$2 = i64toi32_i32$0;
                      i64toi32_i32$0 = 0;
                      i64toi32_i32$3 = 0;
                      if ((i64toi32_i32$1 | 0) < (i64toi32_i32$0 | 0)) {
                        $18_1 = 1;
                      } else {
                        if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$0 | 0)) {
                          if (i64toi32_i32$2 >>> 0 >= i64toi32_i32$3 >>> 0) {
                            $19_1 = 0;
                          } else {
                            $19_1 = 1;
                          }
                          $20_1 = $19_1;
                        } else {
                          $20_1 = 0;
                        }
                        $18_1 = $20_1;
                      }
                      if ($18_1) {
                        break label$4;
                      }
                      HEAP32[($0_1 + 4 | 0) >> 2] = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                      break label$4;
                    default:
                      break label$6;
                  };
                }
                $5_1 = $3_1 + -58 | 0;
                $4_1 = 0;
                $2_1 = $3_1;
              }
              if ($5_1 >>> 0 < -10 >>> 0) {
                break label$4;
              }
              i64toi32_i32$2 = 0;
              $6_1 = 0;
              $6$hi = i64toi32_i32$2;
              label$10: {
                if (($2_1 + -48 | 0) >>> 0 >= 10 >>> 0) {
                  break label$10;
                }
                $3_1 = 0;
                label$11: while (1) {
                  $3_1 = $2_1 + Math_imul($3_1, 10) | 0;
                  label$12: {
                    label$13: {
                      $2_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                      if (($2_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                        break label$13;
                      }
                      HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                      $2_1 = HEAPU8[$2_1 >> 0] | 0;
                      break label$12;
                    }
                    $2_1 = $49($0_1 | 0) | 0;
                  }
                  $3_1 = $3_1 + -48 | 0;
                  label$14: {
                    $5_1 = $2_1 + -48 | 0;
                    if ($5_1 >>> 0 > 9 >>> 0) {
                      break label$14;
                    }
                    if (($3_1 | 0) < (214748364 | 0)) {
                      continue label$11;
                    }
                  }
                  break label$11;
                };
                i64toi32_i32$1 = $3_1;
                i64toi32_i32$2 = i64toi32_i32$1 >> 31 | 0;
                $6_1 = i64toi32_i32$1;
                $6$hi = i64toi32_i32$2;
                if ($5_1 >>> 0 >= 10 >>> 0) {
                  break label$10;
                }
                label$15: while (1) {
                  i64toi32_i32$2 = 0;
                  $88$hi = i64toi32_i32$2;
                  i64toi32_i32$2 = $6$hi;
                  i64toi32_i32$1 = 0;
                  i64toi32_i32$1 = __wasm_i64_mul($6_1 | 0, i64toi32_i32$2 | 0, 10 | 0, i64toi32_i32$1 | 0) | 0;
                  i64toi32_i32$2 = i64toi32_i32$HIGH_BITS;
                  $90_1 = i64toi32_i32$1;
                  $90$hi = i64toi32_i32$2;
                  i64toi32_i32$2 = $88$hi;
                  i64toi32_i32$3 = $2_1;
                  i64toi32_i32$1 = $90$hi;
                  i64toi32_i32$0 = $90_1;
                  i64toi32_i32$4 = $2_1 + i64toi32_i32$0 | 0;
                  i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$1 | 0;
                  if (i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0) {
                    i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                  }
                  $6_1 = i64toi32_i32$4;
                  $6$hi = i64toi32_i32$5;
                  label$16: {
                    label$17: {
                      $2_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                      if (($2_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                        break label$17;
                      }
                      HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                      $2_1 = HEAPU8[$2_1 >> 0] | 0;
                      break label$16;
                    }
                    $2_1 = $49($0_1 | 0) | 0;
                  }
                  i64toi32_i32$5 = $6$hi;
                  i64toi32_i32$2 = $6_1;
                  i64toi32_i32$3 = -1;
                  i64toi32_i32$0 = -48;
                  i64toi32_i32$1 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
                  i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
                  if (i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0) {
                    i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                  }
                  $6_1 = i64toi32_i32$1;
                  $6$hi = i64toi32_i32$4;
                  label$18: {
                    $3_1 = $2_1 + -48 | 0;
                    if ($3_1 >>> 0 > 9 >>> 0) {
                      break label$18;
                    }
                    i64toi32_i32$5 = i64toi32_i32$1;
                    i64toi32_i32$2 = 21474836;
                    i64toi32_i32$0 = 2061584302;
                    if ((i64toi32_i32$4 | 0) < (i64toi32_i32$2 | 0)) {
                      $21_1 = 1;
                    } else {
                      if ((i64toi32_i32$4 | 0) <= (i64toi32_i32$2 | 0)) {
                        if (i64toi32_i32$5 >>> 0 >= i64toi32_i32$0 >>> 0) {
                          $22_1 = 0;
                        } else {
                          $22_1 = 1;
                        }
                        $23_1 = $22_1;
                      } else {
                        $23_1 = 0;
                      }
                      $21_1 = $23_1;
                    }
                    if ($21_1) {
                      continue label$15;
                    }
                  }
                  break label$15;
                };
                if ($3_1 >>> 0 >= 10 >>> 0) {
                  break label$10;
                }
                label$19: while (1) {
                  label$20: {
                    label$21: {
                      $2_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                      if (($2_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                        break label$21;
                      }
                      HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 + 1 | 0;
                      $2_1 = HEAPU8[$2_1 >> 0] | 0;
                      break label$20;
                    }
                    $2_1 = $49($0_1 | 0) | 0;
                  }
                  if (($2_1 + -48 | 0) >>> 0 < 10 >>> 0) {
                    continue label$19;
                  }
                  break label$19;
                };
              }
              label$22: {
                i64toi32_i32$0 = $0_1;
                i64toi32_i32$5 = HEAP32[($0_1 + 112 | 0) >> 2] | 0;
                i64toi32_i32$4 = HEAP32[($0_1 + 116 | 0) >> 2] | 0;
                i64toi32_i32$0 = i64toi32_i32$5;
                i64toi32_i32$5 = 0;
                i64toi32_i32$2 = 0;
                if ((i64toi32_i32$4 | 0) < (i64toi32_i32$5 | 0)) {
                  $24_1 = 1;
                } else {
                  if ((i64toi32_i32$4 | 0) <= (i64toi32_i32$5 | 0)) {
                    if (i64toi32_i32$0 >>> 0 >= i64toi32_i32$2 >>> 0) {
                      $25_1 = 0;
                    } else {
                      $25_1 = 1;
                    }
                    $26_1 = $25_1;
                  } else {
                    $26_1 = 0;
                  }
                  $24_1 = $26_1;
                }
                if ($24_1) {
                  break label$22;
                }
                HEAP32[($0_1 + 4 | 0) >> 2] = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) + -1 | 0;
              }
              i64toi32_i32$0 = $6$hi;
              i64toi32_i32$0 = 0;
              i64toi32_i32$2 = 0;
              i64toi32_i32$4 = $6$hi;
              i64toi32_i32$5 = $6_1;
              i64toi32_i32$3 = i64toi32_i32$2 - i64toi32_i32$5 | 0;
              i64toi32_i32$1 = (i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0) + i64toi32_i32$4 | 0;
              i64toi32_i32$1 = i64toi32_i32$0 - i64toi32_i32$1 | 0;
              $139$hi = i64toi32_i32$1;
              i64toi32_i32$1 = i64toi32_i32$4;
              i64toi32_i32$4 = $4_1;
              i64toi32_i32$1 = $139$hi;
              i64toi32_i32$2 = $6$hi;
              i64toi32_i32$5 = i64toi32_i32$4 ? i64toi32_i32$3 : i64toi32_i32$5;
              i64toi32_i32$0 = i64toi32_i32$4 ? i64toi32_i32$1 : i64toi32_i32$2;
              $6_1 = i64toi32_i32$5;
              $6$hi = i64toi32_i32$0;
              break label$3;
            }
            i64toi32_i32$0 = -2147483648;
            $6_1 = 0;
            $6$hi = i64toi32_i32$0;
            i64toi32_i32$4 = $0_1;
            i64toi32_i32$0 = HEAP32[($0_1 + 112 | 0) >> 2] | 0;
            i64toi32_i32$5 = HEAP32[($0_1 + 116 | 0) >> 2] | 0;
            i64toi32_i32$4 = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$1 = 0;
            if ((i64toi32_i32$5 | 0) < (i64toi32_i32$0 | 0)) {
              $27_1 = 1;
            } else {
              if ((i64toi32_i32$5 | 0) <= (i64toi32_i32$0 | 0)) {
                if (i64toi32_i32$4 >>> 0 >= i64toi32_i32$1 >>> 0) {
                  $28_1 = 0;
                } else {
                  $28_1 = 1;
                }
                $29_1 = $28_1;
              } else {
                $29_1 = 0;
              }
              $27_1 = $29_1;
            }
            if ($27_1) {
              break label$3;
            }
            HEAP32[($0_1 + 4 | 0) >> 2] = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) + -1 | 0;
            i64toi32_i32$4 = -2147483648;
            i64toi32_i32$5 = 0;
            i64toi32_i32$HIGH_BITS = i64toi32_i32$4;
            return i64toi32_i32$5 | 0;
          }
          i64toi32_i32$5 = $6$hi;
          i64toi32_i32$4 = $6_1;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$5;
          return i64toi32_i32$4 | 0;
        }

        function $61($0_1, $1_1, $2_1, $3_1, $3$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          $3$hi = $3$hi | 0;
          var i64toi32_i32$3 = 0,i64toi32_i32$2 = 0,$5_1 = 0,i64toi32_i32$5 = 0,i64toi32_i32$0 = 0,i64toi32_i32$4 = 0,i64toi32_i32$1 = 0,$9$hi = 0,$9_1 = 0,$7_1 = 0,$10$hi = 0,$11$hi = 0,$10_1 = 0,$11_1 = 0,$12$hi = 0,$6_1 = 0,$12_1 = 0,$4_1 = 0,$30_1 = 0,$31_1 = 0,$32_1 = 0,$33_1 = 0,$34_1 = 0,$35_1 = 0,$8_1 = 0,$36_1 = 0,$37_1 = 0,$38_1 = 0,$39_1 = 0,$40_1 = 0,$194 = 0,$194$hi = 0,$248 = 0,$248$hi = 0,$346$hi = 0,$413$hi = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $4_1 = global$0 - 16 | 0;
          global$0 = $4_1;
          label$1: {
            label$2: {
              label$3: {
                if ($1_1 >>> 0 > 36 >>> 0) {
                  break label$3;
                }
                if (($1_1 | 0) != (1 | 0)) {
                  break label$2;
                }
              }
              (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 28), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              i64toi32_i32$0 = 0;
              $3_1 = 0;
              $3$hi = i64toi32_i32$0;
              break label$1;
            }
            label$4: while (1) {
              label$5: {
                label$6: {
                  $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                  if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                    break label$6;
                  }
                  HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                  $5_1 = HEAPU8[$5_1 >> 0] | 0;
                  break label$5;
                }
                $5_1 = $49($0_1 | 0) | 0;
              }
              if ($62($5_1 | 0) | 0) {
                continue label$4;
              }
              break label$4;
            };
            $6_1 = 0;
            label$7: {
              label$8: {
                switch ($5_1 + -43 | 0 | 0) {
                  case 0:
                  case 2:
                    break label$8;
                  default:
                    break label$7;
                };
              }
              $6_1 = ($5_1 | 0) == (45 | 0) ? -1 : 0;
              label$9: {
                $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                  break label$9;
                }
                HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                $5_1 = HEAPU8[$5_1 >> 0] | 0;
                break label$7;
              }
              $5_1 = $49($0_1 | 0) | 0;
            }
            label$10: {
              label$11: {
                label$12: {
                  label$13: {
                    label$14: {
                      if (($1_1 | 0) != (0 | 0) & ($1_1 | 0) != (16 | 0) | 0) {
                        break label$14;
                      }
                      if (($5_1 | 0) != (48 | 0)) {
                        break label$14;
                      }
                      label$15: {
                        label$16: {
                          $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                          if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                            break label$16;
                          }
                          HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                          $5_1 = HEAPU8[$5_1 >> 0] | 0;
                          break label$15;
                        }
                        $5_1 = $49($0_1 | 0) | 0;
                      }
                      label$17: {
                        if (($5_1 & -33 | 0 | 0) != (88 | 0)) {
                          break label$17;
                        }
                        label$18: {
                          label$19: {
                            $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                            if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                              break label$19;
                            }
                            HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                            $5_1 = HEAPU8[$5_1 >> 0] | 0;
                            break label$18;
                          }
                          $5_1 = $49($0_1 | 0) | 0;
                        }
                        $1_1 = 16;
                        if ((HEAPU8[($5_1 + 66177 | 0) >> 0] | 0) >>> 0 < 16 >>> 0) {
                          break label$12;
                        }
                        i64toi32_i32$0 = 0;
                        $3_1 = 0;
                        $3$hi = i64toi32_i32$0;
                        label$20: {
                          label$21: {
                            i64toi32_i32$2 = $0_1;
                            i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 112 | 0) >> 2] | 0;
                            i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 116 | 0) >> 2] | 0;
                            i64toi32_i32$2 = i64toi32_i32$0;
                            i64toi32_i32$0 = 0;
                            i64toi32_i32$3 = 0;
                            if ((i64toi32_i32$1 | 0) < (i64toi32_i32$0 | 0)) {
                              $30_1 = 1;
                            } else {
                              if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$0 | 0)) {
                                if (i64toi32_i32$2 >>> 0 >= i64toi32_i32$3 >>> 0) {
                                  $31_1 = 0;
                                } else {
                                  $31_1 = 1;
                                }
                                $32_1 = $31_1;
                              } else {
                                $32_1 = 0;
                              }
                              $30_1 = $32_1;
                            }
                            if ($30_1) {
                              break label$21;
                            }
                            $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                            HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + -1 | 0;
                            if (!$2_1) {
                              break label$20;
                            }
                            HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + -2 | 0;
                            break label$1;
                          }
                          if ($2_1) {
                            break label$1;
                          }
                        }
                        i64toi32_i32$2 = 0;
                        $3_1 = 0;
                        $3$hi = i64toi32_i32$2;
                        i64toi32_i32$2 = 0;
                        $48($0_1 | 0, 0 | 0, i64toi32_i32$2 | 0);
                        break label$1;
                      }
                      if ($1_1) {
                        break label$13;
                      }
                      $1_1 = 8;
                      break label$12;
                    }
                    $1_1 = $1_1 ? $1_1 : 10;
                    if ($1_1 >>> 0 > (HEAPU8[($5_1 + 66177 | 0) >> 0] | 0) >>> 0) {
                      break label$13;
                    }
                    i64toi32_i32$2 = 0;
                    $3_1 = 0;
                    $3$hi = i64toi32_i32$2;
                    label$22: {
                      i64toi32_i32$3 = $0_1;
                      i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 112 | 0) >> 2] | 0;
                      i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 116 | 0) >> 2] | 0;
                      i64toi32_i32$3 = i64toi32_i32$2;
                      i64toi32_i32$2 = 0;
                      i64toi32_i32$0 = 0;
                      if ((i64toi32_i32$1 | 0) < (i64toi32_i32$2 | 0)) {
                        $33_1 = 1;
                      } else {
                        if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$2 | 0)) {
                          if (i64toi32_i32$3 >>> 0 >= i64toi32_i32$0 >>> 0) {
                            $34_1 = 0;
                          } else {
                            $34_1 = 1;
                          }
                          $35_1 = $34_1;
                        } else {
                          $35_1 = 0;
                        }
                        $33_1 = $35_1;
                      }
                      if ($33_1) {
                        break label$22;
                      }
                      HEAP32[($0_1 + 4 | 0) >> 2] = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                    }
                    i64toi32_i32$3 = 0;
                    $48($0_1 | 0, 0 | 0, i64toi32_i32$3 | 0);
                    (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 28), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
                    break label$1;
                  }
                  if (($1_1 | 0) != (10 | 0)) {
                    break label$12;
                  }
                  i64toi32_i32$3 = 0;
                  $9_1 = 0;
                  $9$hi = i64toi32_i32$3;
                  label$23: {
                    $2_1 = $5_1 + -48 | 0;
                    if ($2_1 >>> 0 > 9 >>> 0) {
                      break label$23;
                    }
                    $5_1 = 0;
                    label$24: while (1) {
                      label$25: {
                        label$26: {
                          $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                          if (($1_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                            break label$26;
                          }
                          HEAP32[($0_1 + 4 | 0) >> 2] = $1_1 + 1 | 0;
                          $1_1 = HEAPU8[$1_1 >> 0] | 0;
                          break label$25;
                        }
                        $1_1 = $49($0_1 | 0) | 0;
                      }
                      $5_1 = Math_imul($5_1, 10) + $2_1 | 0;
                      label$27: {
                        $2_1 = $1_1 + -48 | 0;
                        if ($2_1 >>> 0 > 9 >>> 0) {
                          break label$27;
                        }
                        if ($5_1 >>> 0 < 429496729 >>> 0) {
                          continue label$24;
                        }
                      }
                      break label$24;
                    };
                    i64toi32_i32$3 = 0;
                    $9_1 = $5_1;
                    $9$hi = i64toi32_i32$3;
                  }
                  if ($2_1 >>> 0 > 9 >>> 0) {
                    break label$10;
                  }
                  i64toi32_i32$3 = $9$hi;
                  i64toi32_i32$1 = 0;
                  i64toi32_i32$1 = __wasm_i64_mul($9_1 | 0, i64toi32_i32$3 | 0, 10 | 0, i64toi32_i32$1 | 0) | 0;
                  i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
                  $10_1 = i64toi32_i32$1;
                  $10$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = 0;
                  $11_1 = $2_1;
                  $11$hi = i64toi32_i32$3;
                  label$28: while (1) {
                    label$29: {
                      label$30: {
                        $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                        if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                          break label$30;
                        }
                        HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                        $5_1 = HEAPU8[$5_1 >> 0] | 0;
                        break label$29;
                      }
                      $5_1 = $49($0_1 | 0) | 0;
                    }
                    i64toi32_i32$3 = $10$hi;
                    i64toi32_i32$3 = $11$hi;
                    i64toi32_i32$3 = $10$hi;
                    i64toi32_i32$0 = $10_1;
                    i64toi32_i32$1 = $11$hi;
                    i64toi32_i32$2 = $11_1;
                    i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$2 | 0;
                    i64toi32_i32$5 = i64toi32_i32$3 + i64toi32_i32$1 | 0;
                    if (i64toi32_i32$4 >>> 0 < i64toi32_i32$2 >>> 0) {
                      i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                    }
                    $9_1 = i64toi32_i32$4;
                    $9$hi = i64toi32_i32$5;
                    label$31: {
                      label$32: {
                        $2_1 = $5_1 + -48 | 0;
                        if ($2_1 >>> 0 > 9 >>> 0) {
                          break label$32;
                        }
                        i64toi32_i32$3 = i64toi32_i32$4;
                        i64toi32_i32$0 = 429496729;
                        i64toi32_i32$2 = -1717986918;
                        if (i64toi32_i32$5 >>> 0 < i64toi32_i32$0 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0) {
                          break label$31;
                        }
                      }
                      $1_1 = 10;
                      if ($2_1 >>> 0 <= 9 >>> 0) {
                        break label$11;
                      }
                      break label$10;
                    }
                    i64toi32_i32$3 = $9$hi;
                    i64toi32_i32$5 = 0;
                    i64toi32_i32$5 = __wasm_i64_mul($9_1 | 0, i64toi32_i32$3 | 0, 10 | 0, i64toi32_i32$5 | 0) | 0;
                    i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
                    $10_1 = i64toi32_i32$5;
                    $10$hi = i64toi32_i32$3;
                    i64toi32_i32$3 = 0;
                    $11_1 = $2_1;
                    $11$hi = i64toi32_i32$3;
                    i64toi32_i32$2 = $2_1;
                    i64toi32_i32$5 = -1;
                    i64toi32_i32$0 = -1;
                    i64toi32_i32$5 = i64toi32_i32$3 ^ i64toi32_i32$5 | 0;
                    $194 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
                    $194$hi = i64toi32_i32$5;
                    i64toi32_i32$5 = $10$hi;
                    i64toi32_i32$3 = $10_1;
                    i64toi32_i32$2 = $194$hi;
                    i64toi32_i32$0 = $194;
                    if (i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$3 >>> 0 <= i64toi32_i32$0 >>> 0 | 0) | 0) {
                      continue label$28;
                    }
                    break label$28;
                  };
                  $1_1 = 10;
                  break label$11;
                }
                label$33: {
                  if (!($1_1 & ($1_1 + -1 | 0) | 0)) {
                    break label$33;
                  }
                  i64toi32_i32$3 = 0;
                  $9_1 = 0;
                  $9$hi = i64toi32_i32$3;
                  label$34: {
                    $7_1 = HEAPU8[($5_1 + 66177 | 0) >> 0] | 0;
                    if ($1_1 >>> 0 <= $7_1 >>> 0) {
                      break label$34;
                    }
                    $2_1 = 0;
                    label$35: while (1) {
                      label$36: {
                        label$37: {
                          $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                          if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                            break label$37;
                          }
                          HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                          $5_1 = HEAPU8[$5_1 >> 0] | 0;
                          break label$36;
                        }
                        $5_1 = $49($0_1 | 0) | 0;
                      }
                      $2_1 = $7_1 + Math_imul($2_1, $1_1) | 0;
                      label$38: {
                        $7_1 = HEAPU8[($5_1 + 66177 | 0) >> 0] | 0;
                        if ($1_1 >>> 0 <= $7_1 >>> 0) {
                          break label$38;
                        }
                        if ($2_1 >>> 0 < 119304647 >>> 0) {
                          continue label$35;
                        }
                      }
                      break label$35;
                    };
                    i64toi32_i32$3 = 0;
                    $9_1 = $2_1;
                    $9$hi = i64toi32_i32$3;
                  }
                  if ($1_1 >>> 0 <= $7_1 >>> 0) {
                    break label$11;
                  }
                  i64toi32_i32$3 = 0;
                  $10_1 = $1_1;
                  $10$hi = i64toi32_i32$3;
                  label$39: while (1) {
                    i64toi32_i32$3 = $9$hi;
                    i64toi32_i32$3 = $10$hi;
                    i64toi32_i32$3 = $9$hi;
                    i64toi32_i32$5 = $10$hi;
                    i64toi32_i32$5 = __wasm_i64_mul($9_1 | 0, i64toi32_i32$3 | 0, $10_1 | 0, i64toi32_i32$5 | 0) | 0;
                    i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
                    $11_1 = i64toi32_i32$5;
                    $11$hi = i64toi32_i32$3;
                    i64toi32_i32$3 = 0;
                    i64toi32_i32$0 = $7_1;
                    i64toi32_i32$5 = 0;
                    i64toi32_i32$2 = 255;
                    i64toi32_i32$5 = i64toi32_i32$3 & i64toi32_i32$5 | 0;
                    $12_1 = i64toi32_i32$0 & i64toi32_i32$2 | 0;
                    $12$hi = i64toi32_i32$5;
                    i64toi32_i32$3 = $12_1;
                    i64toi32_i32$0 = -1;
                    i64toi32_i32$2 = -1;
                    i64toi32_i32$0 = i64toi32_i32$5 ^ i64toi32_i32$0 | 0;
                    $248 = i64toi32_i32$3 ^ i64toi32_i32$2 | 0;
                    $248$hi = i64toi32_i32$0;
                    i64toi32_i32$0 = $11$hi;
                    i64toi32_i32$5 = $11_1;
                    i64toi32_i32$3 = $248$hi;
                    i64toi32_i32$2 = $248;
                    if (i64toi32_i32$0 >>> 0 > i64toi32_i32$3 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$5 >>> 0 > i64toi32_i32$2 >>> 0 | 0) | 0) {
                      break label$11;
                    }
                    label$40: {
                      label$41: {
                        $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                        if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                          break label$41;
                        }
                        HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                        $5_1 = HEAPU8[$5_1 >> 0] | 0;
                        break label$40;
                      }
                      $5_1 = $49($0_1 | 0) | 0;
                    }
                    i64toi32_i32$5 = $11$hi;
                    i64toi32_i32$5 = $12$hi;
                    i64toi32_i32$5 = $11$hi;
                    i64toi32_i32$2 = $11_1;
                    i64toi32_i32$0 = $12$hi;
                    i64toi32_i32$3 = $12_1;
                    i64toi32_i32$1 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
                    i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$0 | 0;
                    if (i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0) {
                      i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                    }
                    $9_1 = i64toi32_i32$1;
                    $9$hi = i64toi32_i32$4;
                    $7_1 = HEAPU8[($5_1 + 66177 | 0) >> 0] | 0;
                    if ($1_1 >>> 0 <= $7_1 >>> 0) {
                      break label$11;
                    }
                    i64toi32_i32$4 = $10$hi;
                    i64toi32_i32$4 = $9$hi;
                    i64toi32_i32$4 = $10$hi;
                    i64toi32_i32$2 = 0;
                    i64toi32_i32$5 = $9$hi;
                    i64toi32_i32$3 = 0;
                    $98($4_1 | 0, $10_1 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$2 | 0, i64toi32_i32$1 | 0, i64toi32_i32$5 | 0, 0 | 0, i64toi32_i32$3 | 0);
                    i64toi32_i32$2 = $4_1;
                    i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 8 | 0) >> 2] | 0;
                    i64toi32_i32$5 = HEAP32[(i64toi32_i32$2 + 12 | 0) >> 2] | 0;
                    i64toi32_i32$2 = i64toi32_i32$3;
                    i64toi32_i32$3 = 0;
                    i64toi32_i32$4 = 0;
                    if ((i64toi32_i32$2 | 0) != (i64toi32_i32$4 | 0) | (i64toi32_i32$5 | 0) != (i64toi32_i32$3 | 0) | 0) {
                      break label$11;
                    }
                    continue label$39;
                  };
                }
                $8_1 = HEAP8[(((Math_imul($1_1, 23) >>> 5 | 0) & 7 | 0) + 66433 | 0) >> 0] | 0;
                i64toi32_i32$2 = 0;
                $9_1 = 0;
                $9$hi = i64toi32_i32$2;
                label$42: {
                  $2_1 = HEAPU8[($5_1 + 66177 | 0) >> 0] | 0;
                  if ($1_1 >>> 0 <= $2_1 >>> 0) {
                    break label$42;
                  }
                  $7_1 = 0;
                  label$43: while (1) {
                    label$44: {
                      label$45: {
                        $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                        if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                          break label$45;
                        }
                        HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                        $5_1 = HEAPU8[$5_1 >> 0] | 0;
                        break label$44;
                      }
                      $5_1 = $49($0_1 | 0) | 0;
                    }
                    $7_1 = $2_1 | ($7_1 << $8_1 | 0) | 0;
                    label$46: {
                      $2_1 = HEAPU8[($5_1 + 66177 | 0) >> 0] | 0;
                      if ($1_1 >>> 0 <= $2_1 >>> 0) {
                        break label$46;
                      }
                      if ($7_1 >>> 0 < 134217728 >>> 0) {
                        continue label$43;
                      }
                    }
                    break label$43;
                  };
                  i64toi32_i32$2 = 0;
                  $9_1 = $7_1;
                  $9$hi = i64toi32_i32$2;
                }
                if ($1_1 >>> 0 <= $2_1 >>> 0) {
                  break label$11;
                }
                i64toi32_i32$2 = 0;
                $11_1 = $8_1;
                $11$hi = i64toi32_i32$2;
                i64toi32_i32$2 = -1;
                i64toi32_i32$4 = -1;
                i64toi32_i32$5 = $11$hi;
                i64toi32_i32$3 = $11_1;
                i64toi32_i32$0 = i64toi32_i32$3 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                  i64toi32_i32$5 = 0;
                  $36_1 = i64toi32_i32$2 >>> i64toi32_i32$0 | 0;
                } else {
                  i64toi32_i32$5 = i64toi32_i32$2 >>> i64toi32_i32$0 | 0;
                  $36_1 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$0 | 0) | 0;
                }
                $12_1 = $36_1;
                $12$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $9$hi;
                i64toi32_i32$5 = $12$hi;
                i64toi32_i32$2 = $12_1;
                i64toi32_i32$4 = $9$hi;
                i64toi32_i32$3 = $9_1;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0 | 0) | 0) {
                  break label$11;
                }
                label$47: while (1) {
                  i64toi32_i32$2 = 0;
                  i64toi32_i32$3 = $2_1;
                  i64toi32_i32$5 = 0;
                  i64toi32_i32$4 = 255;
                  i64toi32_i32$5 = i64toi32_i32$2 & i64toi32_i32$5 | 0;
                  $10_1 = i64toi32_i32$3 & i64toi32_i32$4 | 0;
                  $10$hi = i64toi32_i32$5;
                  label$48: {
                    label$49: {
                      $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                      if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                        break label$49;
                      }
                      HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                      $5_1 = HEAPU8[$5_1 >> 0] | 0;
                      break label$48;
                    }
                    $5_1 = $49($0_1 | 0) | 0;
                  }
                  i64toi32_i32$5 = $9$hi;
                  i64toi32_i32$5 = $11$hi;
                  i64toi32_i32$5 = $9$hi;
                  i64toi32_i32$2 = $9_1;
                  i64toi32_i32$3 = $11$hi;
                  i64toi32_i32$4 = $11_1;
                  i64toi32_i32$0 = i64toi32_i32$4 & 31 | 0;
                  if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                    i64toi32_i32$3 = i64toi32_i32$2 << i64toi32_i32$0 | 0;
                    $37_1 = 0;
                  } else {
                    i64toi32_i32$3 = ((1 << i64toi32_i32$0 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$0 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$0 | 0) | 0;
                    $37_1 = i64toi32_i32$2 << i64toi32_i32$0 | 0;
                  }
                  $346$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = $10$hi;
                  i64toi32_i32$3 = $346$hi;
                  i64toi32_i32$5 = $37_1;
                  i64toi32_i32$2 = $10$hi;
                  i64toi32_i32$4 = $10_1;
                  i64toi32_i32$2 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
                  $9_1 = i64toi32_i32$5 | i64toi32_i32$4 | 0;
                  $9$hi = i64toi32_i32$2;
                  $2_1 = HEAPU8[($5_1 + 66177 | 0) >> 0] | 0;
                  if ($1_1 >>> 0 <= $2_1 >>> 0) {
                    break label$11;
                  }
                  i64toi32_i32$2 = $12$hi;
                  i64toi32_i32$2 = $9$hi;
                  i64toi32_i32$3 = $9_1;
                  i64toi32_i32$5 = $12$hi;
                  i64toi32_i32$4 = $12_1;
                  if (i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$3 >>> 0 <= i64toi32_i32$4 >>> 0 | 0) | 0) {
                    continue label$47;
                  }
                  break label$47;
                };
              }
              if ($1_1 >>> 0 <= (HEAPU8[($5_1 + 66177 | 0) >> 0] | 0) >>> 0) {
                break label$10;
              }
              label$50: while (1) {
                label$51: {
                  label$52: {
                    $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                    if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                      break label$52;
                    }
                    HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                    $5_1 = HEAPU8[$5_1 >> 0] | 0;
                    break label$51;
                  }
                  $5_1 = $49($0_1 | 0) | 0;
                }
                if ($1_1 >>> 0 > (HEAPU8[($5_1 + 66177 | 0) >> 0] | 0) >>> 0) {
                  continue label$50;
                }
                break label$50;
              };
              (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 68), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              i64toi32_i32$3 = $3$hi;
              i64toi32_i32$4 = $3_1;
              i64toi32_i32$2 = 0;
              i64toi32_i32$5 = 1;
              i64toi32_i32$2 = i64toi32_i32$3 & i64toi32_i32$2 | 0;
              $6_1 = !(i64toi32_i32$4 & i64toi32_i32$5 | 0 | i64toi32_i32$2 | 0) ? $6_1 : 0;
              i64toi32_i32$2 = i64toi32_i32$3;
              i64toi32_i32$2 = i64toi32_i32$3;
              $9_1 = i64toi32_i32$4;
              $9$hi = i64toi32_i32$3;
            }
            label$53: {
              i64toi32_i32$3 = $0_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 112 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 116 | 0) >> 2] | 0;
              i64toi32_i32$3 = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              i64toi32_i32$5 = 0;
              if ((i64toi32_i32$4 | 0) < (i64toi32_i32$2 | 0)) {
                $38_1 = 1;
              } else {
                if ((i64toi32_i32$4 | 0) <= (i64toi32_i32$2 | 0)) {
                  if (i64toi32_i32$3 >>> 0 >= i64toi32_i32$5 >>> 0) {
                    $39_1 = 0;
                  } else {
                    $39_1 = 1;
                  }
                  $40_1 = $39_1;
                } else {
                  $40_1 = 0;
                }
                $38_1 = $40_1;
              }
              if ($38_1) {
                break label$53;
              }
              HEAP32[($0_1 + 4 | 0) >> 2] = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) + -1 | 0;
            }
            label$54: {
              i64toi32_i32$3 = $9$hi;
              i64toi32_i32$3 = $3$hi;
              i64toi32_i32$3 = $9$hi;
              i64toi32_i32$5 = $9_1;
              i64toi32_i32$4 = $3$hi;
              i64toi32_i32$2 = $3_1;
              if (i64toi32_i32$3 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0) {
                break label$54;
              }
              label$55: {
                i64toi32_i32$5 = i64toi32_i32$4;
                if (i64toi32_i32$2 & 1 | 0) {
                  break label$55;
                }
                if ($6_1) {
                  break label$55;
                }
                (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 68), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
                i64toi32_i32$3 = -1;
                i64toi32_i32$4 = -1;
                i64toi32_i32$0 = i64toi32_i32$2 + i64toi32_i32$4 | 0;
                i64toi32_i32$1 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
                }
                $3_1 = i64toi32_i32$0;
                $3$hi = i64toi32_i32$1;
                break label$1;
              }
              i64toi32_i32$1 = $9$hi;
              i64toi32_i32$1 = $3$hi;
              i64toi32_i32$1 = $9$hi;
              i64toi32_i32$5 = $9_1;
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$4 = $3_1;
              if (i64toi32_i32$1 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$5 >>> 0 <= i64toi32_i32$4 >>> 0 | 0) | 0) {
                break label$54;
              }
              (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 68), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              break label$1;
            }
            i64toi32_i32$5 = $9$hi;
            i64toi32_i32$1 = $6_1;
            i64toi32_i32$5 = i64toi32_i32$1 >> 31 | 0;
            $3_1 = i64toi32_i32$1;
            $3$hi = i64toi32_i32$5;
            i64toi32_i32$5 = $9$hi;
            i64toi32_i32$4 = $9_1;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$2 = $3_1;
            i64toi32_i32$1 = i64toi32_i32$5 ^ i64toi32_i32$1 | 0;
            $413$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$1 = $413$hi;
            i64toi32_i32$5 = i64toi32_i32$4 ^ i64toi32_i32$2 | 0;
            i64toi32_i32$4 = $3$hi;
            i64toi32_i32$3 = i64toi32_i32$5 - i64toi32_i32$2 | 0;
            i64toi32_i32$0 = (i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0) + i64toi32_i32$4 | 0;
            i64toi32_i32$0 = i64toi32_i32$1 - i64toi32_i32$0 | 0;
            $3_1 = i64toi32_i32$3;
            $3$hi = i64toi32_i32$0;
          }
          global$0 = $4_1 + 16 | 0;
          i64toi32_i32$0 = $3$hi;
          i64toi32_i32$5 = $3_1;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$0;
          return i64toi32_i32$5 | 0;
        }

        function $62($0_1) {
          $0_1 = $0_1 | 0;
          return ($0_1 | 0) == (32 | 0) | ($0_1 + -9 | 0) >>> 0 < 5 >>> 0 | 0 | 0;
        }

        function $63() {
          return 42 | 0;
        }

        function $64() {
          return $63() | 0 | 0;
        }

        function $65() {
          return 99496 | 0;
        }

        function $66() {
          var wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          HEAP32[(0 + 99592 | 0) >> 2] = 99472;
          (wasm2js_i32$0 = 0, wasm2js_i32$1 = $64() | 0), HEAP32[(wasm2js_i32$0 + 99520 | 0) >> 2] = wasm2js_i32$1;
        }

        function $67($0_1, $1_1, $2_1, $3_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $3_1 = $3_1 | 0;
          var $5_1 = 0,$4_1 = 0,$6_1 = 0,$7_1 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $4_1 = $3_1 ? $3_1 : 99628;
          $3_1 = HEAP32[$4_1 >> 2] | 0;
          label$1: {
            label$2: {
              label$3: {
                label$4: {
                  if ($1_1) {
                    break label$4;
                  }
                  if ($3_1) {
                    break label$3;
                  }
                  return 0 | 0;
                }
                $5_1 = -2;
                if (!$2_1) {
                  break label$2;
                }
                label$5: {
                  label$6: {
                    if (!$3_1) {
                      break label$6;
                    }
                    $5_1 = $2_1;
                    break label$5;
                  }
                  label$7: {
                    $5_1 = HEAPU8[$1_1 >> 0] | 0;
                    $3_1 = $5_1 << 24 >> 24;
                    if (($3_1 | 0) < (0 | 0)) {
                      break label$7;
                    }
                    label$8: {
                      if (!$0_1) {
                        break label$8;
                      }
                      HEAP32[$0_1 >> 2] = $5_1;
                    }
                    return ($3_1 | 0) != (0 | 0) | 0;
                  }
                  label$9: {
                    if (HEAP32[(HEAP32[(($65() | 0) + 96 | 0) >> 2] | 0) >> 2] | 0) {
                      break label$9;
                    }
                    $5_1 = 1;
                    if (!$0_1) {
                      break label$2;
                    }
                    HEAP32[$0_1 >> 2] = $3_1 & 57343 | 0;
                    return 1 | 0;
                  }
                  $3_1 = $5_1 + -194 | 0;
                  if ($3_1 >>> 0 > 50 >>> 0) {
                    break label$3;
                  }
                  $3_1 = HEAP32[(($3_1 << 2 | 0) + 66448 | 0) >> 2] | 0;
                  $5_1 = $2_1 + -1 | 0;
                  if (!$5_1) {
                    break label$1;
                  }
                  $1_1 = $1_1 + 1 | 0;
                }
                $6_1 = HEAPU8[$1_1 >> 0] | 0;
                $7_1 = $6_1 >>> 3 | 0;
                if (($7_1 + -16 | 0 | (($3_1 >> 26 | 0) + $7_1 | 0) | 0) >>> 0 > 7 >>> 0) {
                  break label$3;
                }
                label$10: while (1) {
                  $5_1 = $5_1 + -1 | 0;
                  label$11: {
                    $3_1 = ($6_1 & 255 | 0) + -128 | 0 | ($3_1 << 6 | 0) | 0;
                    if (($3_1 | 0) < (0 | 0)) {
                      break label$11;
                    }
                    HEAP32[$4_1 >> 2] = 0;
                    label$12: {
                      if (!$0_1) {
                        break label$12;
                      }
                      HEAP32[$0_1 >> 2] = $3_1;
                    }
                    return $2_1 - $5_1 | 0 | 0;
                  }
                  if (!$5_1) {
                    break label$1;
                  }
                  $1_1 = $1_1 + 1 | 0;
                  $6_1 = HEAPU8[$1_1 >> 0] | 0;
                  if (($6_1 & 192 | 0 | 0) == (128 | 0)) {
                    continue label$10;
                  }
                  break label$10;
                };
              }
              HEAP32[$4_1 >> 2] = 0;
              (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 25), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              $5_1 = -1;
            }
            return $5_1 | 0;
          }
          HEAP32[$4_1 >> 2] = $3_1;
          return -2 | 0;
        }

        function $68($0_1) {
          $0_1 = $0_1 | 0;
          label$1: {
            if ($0_1) {
              break label$1;
            }
            return 1 | 0;
          }
          return !(HEAP32[$0_1 >> 2] | 0) | 0;
        }

        function $69($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var i64toi32_i32$1 = 0,i64toi32_i32$4 = 0,i64toi32_i32$3 = 0,i64toi32_i32$0 = 0,$5_1 = 0,i64toi32_i32$2 = 0,$9_1 = 0,i64toi32_i32$5 = 0,$14_1 = 0,$3_1 = 0,$11_1 = 0,$8_1 = 0,$13_1 = 0,$19$hi = 0,$12_1 = 0,$15_1 = 0,$20$hi = 0,$17_1 = 0,$6_1 = 0,$19_1 = 0,$10_1 = 0,$20_1 = 0,$21$hi = 0,$16_1 = 0,$18_1 = 0,$21_1 = 0,i64toi32_i32$6 = 0,$4_1 = 0,$62_1 = 0,$63_1 = 0,$64_1 = 0,$65_1 = 0,$66_1 = 0,$67_1 = 0,$68_1 = 0,$69_1 = 0,$70_1 = 0,$71_1 = 0,$72_1 = 0,$73_1 = 0,$74_1 = 0,$75_1 = 0,$76_1 = 0,$77_1 = 0,$7_1 = 0,$80$hi = 0,$82$hi = 0,$87_1 = 0,$87$hi = 0,$146$hi = 0,$148$hi = 0,$154 = 0,$154$hi = 0,$282$hi = 0,$284$hi = 0,$289 = 0,$289$hi = 0,$329 = 0,$329$hi = 0,$335 = 0,$335$hi = 0,$336$hi = 0,$435 = 0,$435$hi = 0,$441 = 0,$441$hi = 0,$442$hi = 0,$653 = 0,$653$hi = 0,$658 = 0,$658$hi = 0,$686$hi = 0,$688$hi = 0,$694 = 0,$694$hi = 0,wasm2js_i32$0 = 0,wasm2js_f32$0 = Math_fround(0),wasm2js_f64$0 = 0.0;
          $3_1 = global$0 - 304 | 0;
          global$0 = $3_1;
          label$1: {
            label$2: {
              if ((HEAP32[($0_1 + 76 | 0) >> 2] | 0 | 0) >= (0 | 0)) {
                break label$2;
              }
              $4_1 = 1;
              break label$1;
            }
            $4_1 = !($18($0_1 | 0) | 0);
          }
          label$3: {
            label$4: {
              label$5: {
                if (HEAP32[($0_1 + 4 | 0) >> 2] | 0) {
                  break label$5;
                }
                $46($0_1 | 0) | 0;
                if (!(HEAP32[($0_1 + 4 | 0) >> 2] | 0)) {
                  break label$4;
                }
              }
              label$6: {
                $5_1 = HEAPU8[$1_1 >> 0] | 0;
                if ($5_1) {
                  break label$6;
                }
                $6_1 = 0;
                break label$3;
              }
              $7_1 = $3_1 + 16 | 0;
              i64toi32_i32$0 = 0;
              $19_1 = 0;
              $19$hi = i64toi32_i32$0;
              $6_1 = 0;
              label$7: {
                label$8: {
                  label$9: {
                    label$10: {
                      label$11: {
                        label$12: {
                          label$13: while (1) {
                            label$14: {
                              label$15: {
                                $5_1 = $5_1 & 255 | 0;
                                if (!($70($5_1 | 0) | 0)) {
                                  break label$15;
                                }
                                label$16: while (1) {
                                  $5_1 = $1_1;
                                  $1_1 = $1_1 + 1 | 0;
                                  if ($70(HEAPU8[($5_1 + 1 | 0) >> 0] | 0 | 0) | 0) {
                                    continue label$16;
                                  }
                                  break label$16;
                                };
                                i64toi32_i32$0 = 0;
                                $48($0_1 | 0, 0 | 0, i64toi32_i32$0 | 0);
                                label$17: while (1) {
                                  label$18: {
                                    label$19: {
                                      $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                      if (($1_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                                        break label$19;
                                      }
                                      HEAP32[($0_1 + 4 | 0) >> 2] = $1_1 + 1 | 0;
                                      $1_1 = HEAPU8[$1_1 >> 0] | 0;
                                      break label$18;
                                    }
                                    $1_1 = $49($0_1 | 0) | 0;
                                  }
                                  if ($70($1_1 | 0) | 0) {
                                    continue label$17;
                                  }
                                  break label$17;
                                };
                                $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                label$20: {
                                  i64toi32_i32$2 = $0_1;
                                  i64toi32_i32$0 = HEAP32[($0_1 + 112 | 0) >> 2] | 0;
                                  i64toi32_i32$1 = HEAP32[($0_1 + 116 | 0) >> 2] | 0;
                                  i64toi32_i32$2 = i64toi32_i32$0;
                                  i64toi32_i32$0 = 0;
                                  i64toi32_i32$3 = 0;
                                  if ((i64toi32_i32$1 | 0) < (i64toi32_i32$0 | 0)) {
                                    $62_1 = 1;
                                  } else {
                                    if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$0 | 0)) {
                                      if (i64toi32_i32$2 >>> 0 >= i64toi32_i32$3 >>> 0) {
                                        $63_1 = 0;
                                      } else {
                                        $63_1 = 1;
                                      }
                                      $64_1 = $63_1;
                                    } else {
                                      $64_1 = 0;
                                    }
                                    $62_1 = $64_1;
                                  }
                                  if ($62_1) {
                                    break label$20;
                                  }
                                  $1_1 = $1_1 + -1 | 0;
                                  HEAP32[($0_1 + 4 | 0) >> 2] = $1_1;
                                }
                                i64toi32_i32$3 = $0_1;
                                i64toi32_i32$2 = HEAP32[($0_1 + 120 | 0) >> 2] | 0;
                                i64toi32_i32$1 = HEAP32[($0_1 + 124 | 0) >> 2] | 0;
                                $80$hi = i64toi32_i32$1;
                                i64toi32_i32$1 = $19$hi;
                                i64toi32_i32$1 = $80$hi;
                                i64toi32_i32$3 = i64toi32_i32$2;
                                i64toi32_i32$2 = $19$hi;
                                i64toi32_i32$0 = $19_1;
                                i64toi32_i32$4 = i64toi32_i32$3 + i64toi32_i32$0 | 0;
                                i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
                                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0) {
                                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                                }
                                $82$hi = i64toi32_i32$5;
                                i64toi32_i32$3 = $1_1 - (HEAP32[($0_1 + 44 | 0) >> 2] | 0) | 0;
                                i64toi32_i32$5 = i64toi32_i32$3 >> 31 | 0;
                                $87_1 = i64toi32_i32$3;
                                $87$hi = i64toi32_i32$5;
                                i64toi32_i32$5 = $82$hi;
                                i64toi32_i32$1 = i64toi32_i32$4;
                                i64toi32_i32$3 = $87$hi;
                                i64toi32_i32$0 = $87_1;
                                i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$0 | 0;
                                i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
                                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$0 >>> 0) {
                                  i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                                }
                                $19_1 = i64toi32_i32$2;
                                $19$hi = i64toi32_i32$4;
                                break label$14;
                              }
                              label$21: {
                                label$22: {
                                  label$23: {
                                    label$24: {
                                      if (($5_1 | 0) != (37 | 0)) {
                                        break label$24;
                                      }
                                      $5_1 = HEAPU8[($1_1 + 1 | 0) >> 0] | 0;
                                      if (($5_1 | 0) == (42 | 0)) {
                                        break label$23;
                                      }
                                      if (($5_1 | 0) != (37 | 0)) {
                                        break label$22;
                                      }
                                    }
                                    i64toi32_i32$4 = 0;
                                    $48($0_1 | 0, 0 | 0, i64toi32_i32$4 | 0);
                                    label$25: {
                                      label$26: {
                                        if ((HEAPU8[$1_1 >> 0] | 0 | 0) != (37 | 0)) {
                                          break label$26;
                                        }
                                        label$27: while (1) {
                                          label$28: {
                                            label$29: {
                                              $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                              if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                                                break label$29;
                                              }
                                              HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                                              $5_1 = HEAPU8[$5_1 >> 0] | 0;
                                              break label$28;
                                            }
                                            $5_1 = $49($0_1 | 0) | 0;
                                          }
                                          if ($70($5_1 | 0) | 0) {
                                            continue label$27;
                                          }
                                          break label$27;
                                        };
                                        $1_1 = $1_1 + 1 | 0;
                                        break label$25;
                                      }
                                      label$30: {
                                        $5_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                        if (($5_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                                          break label$30;
                                        }
                                        HEAP32[($0_1 + 4 | 0) >> 2] = $5_1 + 1 | 0;
                                        $5_1 = HEAPU8[$5_1 >> 0] | 0;
                                        break label$25;
                                      }
                                      $5_1 = $49($0_1 | 0) | 0;
                                    }
                                    label$31: {
                                      if (($5_1 | 0) == (HEAPU8[$1_1 >> 0] | 0 | 0)) {
                                        break label$31;
                                      }
                                      label$32: {
                                        i64toi32_i32$5 = $0_1;
                                        i64toi32_i32$4 = HEAP32[($0_1 + 112 | 0) >> 2] | 0;
                                        i64toi32_i32$1 = HEAP32[($0_1 + 116 | 0) >> 2] | 0;
                                        i64toi32_i32$5 = i64toi32_i32$4;
                                        i64toi32_i32$4 = 0;
                                        i64toi32_i32$0 = 0;
                                        if ((i64toi32_i32$1 | 0) < (i64toi32_i32$4 | 0)) {
                                          $65_1 = 1;
                                        } else {
                                          if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$4 | 0)) {
                                            if (i64toi32_i32$5 >>> 0 >= i64toi32_i32$0 >>> 0) {
                                              $66_1 = 0;
                                            } else {
                                              $66_1 = 1;
                                            }
                                            $67_1 = $66_1;
                                          } else {
                                            $67_1 = 0;
                                          }
                                          $65_1 = $67_1;
                                        }
                                        if ($65_1) {
                                          break label$32;
                                        }
                                        HEAP32[($0_1 + 4 | 0) >> 2] = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                                      }
                                      if (($5_1 | 0) > (-1 | 0)) {
                                        break label$3;
                                      }
                                      if ($6_1) {
                                        break label$3;
                                      }
                                      break label$4;
                                    }
                                    i64toi32_i32$0 = $0_1;
                                    i64toi32_i32$5 = HEAP32[($0_1 + 120 | 0) >> 2] | 0;
                                    i64toi32_i32$1 = HEAP32[($0_1 + 124 | 0) >> 2] | 0;
                                    $146$hi = i64toi32_i32$1;
                                    i64toi32_i32$1 = $19$hi;
                                    i64toi32_i32$1 = $146$hi;
                                    i64toi32_i32$0 = i64toi32_i32$5;
                                    i64toi32_i32$5 = $19$hi;
                                    i64toi32_i32$4 = $19_1;
                                    i64toi32_i32$3 = i64toi32_i32$0 + i64toi32_i32$4 | 0;
                                    i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
                                    if (i64toi32_i32$3 >>> 0 < i64toi32_i32$4 >>> 0) {
                                      i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                                    }
                                    $148$hi = i64toi32_i32$2;
                                    i64toi32_i32$0 = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) - (HEAP32[($0_1 + 44 | 0) >> 2] | 0) | 0;
                                    i64toi32_i32$2 = i64toi32_i32$0 >> 31 | 0;
                                    $154 = i64toi32_i32$0;
                                    $154$hi = i64toi32_i32$2;
                                    i64toi32_i32$2 = $148$hi;
                                    i64toi32_i32$1 = i64toi32_i32$3;
                                    i64toi32_i32$0 = $154$hi;
                                    i64toi32_i32$4 = $154;
                                    i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$4 | 0;
                                    i64toi32_i32$3 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
                                    if (i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0) {
                                      i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                                    }
                                    $19_1 = i64toi32_i32$5;
                                    $19$hi = i64toi32_i32$3;
                                    $5_1 = $1_1;
                                    break label$14;
                                  }
                                  $5_1 = $1_1 + 2 | 0;
                                  $8_1 = 0;
                                  break label$21;
                                }
                                label$33: {
                                  $9_1 = $5_1 + -48 | 0;
                                  if ($9_1 >>> 0 > 9 >>> 0) {
                                    break label$33;
                                  }
                                  if ((HEAPU8[($1_1 + 2 | 0) >> 0] | 0 | 0) != (36 | 0)) {
                                    break label$33;
                                  }
                                  $5_1 = $1_1 + 3 | 0;
                                  $8_1 = $71($2_1 | 0, $9_1 | 0) | 0;
                                  break label$21;
                                }
                                $5_1 = $1_1 + 1 | 0;
                                $8_1 = HEAP32[$2_1 >> 2] | 0;
                                $2_1 = $2_1 + 4 | 0;
                              }
                              $10_1 = 0;
                              $9_1 = 0;
                              label$34: {
                                $1_1 = HEAPU8[$5_1 >> 0] | 0;
                                if (($1_1 + -48 | 0) >>> 0 > 9 >>> 0) {
                                  break label$34;
                                }
                                label$35: while (1) {
                                  $9_1 = (Math_imul($9_1, 10) + $1_1 | 0) + -48 | 0;
                                  $1_1 = HEAPU8[($5_1 + 1 | 0) >> 0] | 0;
                                  $5_1 = $5_1 + 1 | 0;
                                  if (($1_1 + -48 | 0) >>> 0 < 10 >>> 0) {
                                    continue label$35;
                                  }
                                  break label$35;
                                };
                              }
                              label$36: {
                                label$37: {
                                  if (($1_1 | 0) == (109 | 0)) {
                                    break label$37;
                                  }
                                  $11_1 = $5_1;
                                  break label$36;
                                }
                                $11_1 = $5_1 + 1 | 0;
                                $12_1 = 0;
                                $10_1 = ($8_1 | 0) != (0 | 0);
                                $1_1 = HEAPU8[($5_1 + 1 | 0) >> 0] | 0;
                                $13_1 = 0;
                              }
                              $5_1 = $11_1 + 1 | 0;
                              $14_1 = 3;
                              $15_1 = $10_1;
                              label$38: {
                                label$39: {
                                  switch (($1_1 & 255 | 0) + -65 | 0 | 0) {
                                    case 39:
                                      $1_1 = (HEAPU8[($11_1 + 1 | 0) >> 0] | 0 | 0) == (104 | 0);
                                      $5_1 = $1_1 ? $11_1 + 2 | 0 : $5_1;
                                      $14_1 = $1_1 ? -2 : -1;
                                      break label$38;
                                    case 43:
                                      $1_1 = (HEAPU8[($11_1 + 1 | 0) >> 0] | 0 | 0) == (108 | 0);
                                      $5_1 = $1_1 ? $11_1 + 2 | 0 : $5_1;
                                      $14_1 = $1_1 ? 3 : 1;
                                      break label$38;
                                    case 51:
                                    case 57:
                                      $14_1 = 1;
                                      break label$38;
                                    case 11:
                                      $14_1 = 2;
                                      break label$38;
                                    case 41:
                                      break label$38;
                                    case 0:
                                    case 2:
                                    case 4:
                                    case 5:
                                    case 6:
                                    case 18:
                                    case 23:
                                    case 26:
                                    case 32:
                                    case 34:
                                    case 35:
                                    case 36:
                                    case 37:
                                    case 38:
                                    case 40:
                                    case 45:
                                    case 46:
                                    case 47:
                                    case 50:
                                    case 52:
                                    case 55:
                                      break label$39;
                                    default:
                                      break label$8;
                                  };
                                }
                                $14_1 = 0;
                                $5_1 = $11_1;
                              }
                              $1_1 = HEAPU8[$5_1 >> 0] | 0;
                              $11_1 = ($1_1 & 47 | 0 | 0) == (3 | 0);
                              $16_1 = $11_1 ? 1 : $14_1;
                              label$44: {
                                $17_1 = $11_1 ? $1_1 | 32 | 0 : $1_1;
                                if (($17_1 | 0) == (91 | 0)) {
                                  break label$44;
                                }
                                label$45: {
                                  label$46: {
                                    if (($17_1 | 0) == (110 | 0)) {
                                      break label$46;
                                    }
                                    if (($17_1 | 0) != (99 | 0)) {
                                      break label$45;
                                    }
                                    $9_1 = ($9_1 | 0) > (1 | 0) ? $9_1 : 1;
                                    break label$44;
                                  }
                                  i64toi32_i32$3 = $19$hi;
                                  $72($8_1 | 0, $16_1 | 0, $19_1 | 0, i64toi32_i32$3 | 0);
                                  break label$14;
                                }
                                i64toi32_i32$3 = 0;
                                $48($0_1 | 0, 0 | 0, i64toi32_i32$3 | 0);
                                label$47: while (1) {
                                  label$48: {
                                    label$49: {
                                      $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                      if (($1_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                                        break label$49;
                                      }
                                      HEAP32[($0_1 + 4 | 0) >> 2] = $1_1 + 1 | 0;
                                      $1_1 = HEAPU8[$1_1 >> 0] | 0;
                                      break label$48;
                                    }
                                    $1_1 = $49($0_1 | 0) | 0;
                                  }
                                  if ($70($1_1 | 0) | 0) {
                                    continue label$47;
                                  }
                                  break label$47;
                                };
                                $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                label$50: {
                                  i64toi32_i32$2 = $0_1;
                                  i64toi32_i32$3 = HEAP32[($0_1 + 112 | 0) >> 2] | 0;
                                  i64toi32_i32$1 = HEAP32[($0_1 + 116 | 0) >> 2] | 0;
                                  i64toi32_i32$2 = i64toi32_i32$3;
                                  i64toi32_i32$3 = 0;
                                  i64toi32_i32$4 = 0;
                                  if ((i64toi32_i32$1 | 0) < (i64toi32_i32$3 | 0)) {
                                    $68_1 = 1;
                                  } else {
                                    if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$3 | 0)) {
                                      if (i64toi32_i32$2 >>> 0 >= i64toi32_i32$4 >>> 0) {
                                        $69_1 = 0;
                                      } else {
                                        $69_1 = 1;
                                      }
                                      $70_1 = $69_1;
                                    } else {
                                      $70_1 = 0;
                                    }
                                    $68_1 = $70_1;
                                  }
                                  if ($68_1) {
                                    break label$50;
                                  }
                                  $1_1 = $1_1 + -1 | 0;
                                  HEAP32[($0_1 + 4 | 0) >> 2] = $1_1;
                                }
                                i64toi32_i32$4 = $0_1;
                                i64toi32_i32$2 = HEAP32[($0_1 + 120 | 0) >> 2] | 0;
                                i64toi32_i32$1 = HEAP32[($0_1 + 124 | 0) >> 2] | 0;
                                $282$hi = i64toi32_i32$1;
                                i64toi32_i32$1 = $19$hi;
                                i64toi32_i32$1 = $282$hi;
                                i64toi32_i32$4 = i64toi32_i32$2;
                                i64toi32_i32$2 = $19$hi;
                                i64toi32_i32$3 = $19_1;
                                i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
                                i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
                                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$3 >>> 0) {
                                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                                }
                                $284$hi = i64toi32_i32$5;
                                i64toi32_i32$4 = $1_1 - (HEAP32[($0_1 + 44 | 0) >> 2] | 0) | 0;
                                i64toi32_i32$5 = i64toi32_i32$4 >> 31 | 0;
                                $289 = i64toi32_i32$4;
                                $289$hi = i64toi32_i32$5;
                                i64toi32_i32$5 = $284$hi;
                                i64toi32_i32$1 = i64toi32_i32$0;
                                i64toi32_i32$4 = $289$hi;
                                i64toi32_i32$3 = $289;
                                i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
                                i64toi32_i32$0 = i64toi32_i32$5 + i64toi32_i32$4 | 0;
                                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0) {
                                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                                }
                                $19_1 = i64toi32_i32$2;
                                $19$hi = i64toi32_i32$0;
                              }
                              i64toi32_i32$1 = $9_1;
                              i64toi32_i32$0 = i64toi32_i32$1 >> 31 | 0;
                              $20_1 = i64toi32_i32$1;
                              $20$hi = i64toi32_i32$0;
                              $48($0_1 | 0, i64toi32_i32$1 | 0, i64toi32_i32$0 | 0);
                              label$51: {
                                label$52: {
                                  $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                  if (($1_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                                    break label$52;
                                  }
                                  HEAP32[($0_1 + 4 | 0) >> 2] = $1_1 + 1 | 0;
                                  break label$51;
                                }
                                if (($49($0_1 | 0) | 0 | 0) < (0 | 0)) {
                                  break label$9;
                                }
                              }
                              label$53: {
                                i64toi32_i32$5 = $0_1;
                                i64toi32_i32$0 = HEAP32[($0_1 + 112 | 0) >> 2] | 0;
                                i64toi32_i32$1 = HEAP32[($0_1 + 116 | 0) >> 2] | 0;
                                i64toi32_i32$5 = i64toi32_i32$0;
                                i64toi32_i32$0 = 0;
                                i64toi32_i32$3 = 0;
                                if ((i64toi32_i32$1 | 0) < (i64toi32_i32$0 | 0)) {
                                  $71_1 = 1;
                                } else {
                                  if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$0 | 0)) {
                                    if (i64toi32_i32$5 >>> 0 >= i64toi32_i32$3 >>> 0) {
                                      $72_1 = 0;
                                    } else {
                                      $72_1 = 1;
                                    }
                                    $73_1 = $72_1;
                                  } else {
                                    $73_1 = 0;
                                  }
                                  $71_1 = $73_1;
                                }
                                if ($71_1) {
                                  break label$53;
                                }
                                HEAP32[($0_1 + 4 | 0) >> 2] = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) + -1 | 0;
                              }
                              $1_1 = 16;
                              label$54: {
                                label$55: {
                                  label$56: {
                                    label$57: {
                                      label$58: {
                                        switch ($17_1 + -88 | 0 | 0) {
                                          default:
                                            $1_1 = $17_1 + -65 | 0;
                                            if ($1_1 >>> 0 > 6 >>> 0) {
                                              break label$54;
                                            }
                                            if (!((1 << $1_1 | 0) & 113 | 0)) {
                                              break label$54;
                                            }
                                          case 9:
                                          case 13:
                                          case 14:
                                          case 15:
                                            $56($3_1 + 8 | 0 | 0, $0_1 | 0, $16_1 | 0, 0 | 0);
                                            i64toi32_i32$3 = $0_1;
                                            i64toi32_i32$5 = HEAP32[($0_1 + 120 | 0) >> 2] | 0;
                                            i64toi32_i32$1 = HEAP32[($0_1 + 124 | 0) >> 2] | 0;
                                            $329 = i64toi32_i32$5;
                                            $329$hi = i64toi32_i32$1;
                                            i64toi32_i32$5 = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) - (HEAP32[($0_1 + 44 | 0) >> 2] | 0) | 0;
                                            i64toi32_i32$1 = i64toi32_i32$5 >> 31 | 0;
                                            $335 = i64toi32_i32$5;
                                            $335$hi = i64toi32_i32$1;
                                            i64toi32_i32$1 = 0;
                                            i64toi32_i32$3 = 0;
                                            i64toi32_i32$5 = $335$hi;
                                            i64toi32_i32$0 = $335;
                                            i64toi32_i32$4 = i64toi32_i32$3 - i64toi32_i32$0 | 0;
                                            i64toi32_i32$6 = i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0;
                                            i64toi32_i32$2 = i64toi32_i32$6 + i64toi32_i32$5 | 0;
                                            i64toi32_i32$2 = i64toi32_i32$1 - i64toi32_i32$2 | 0;
                                            $336$hi = i64toi32_i32$2;
                                            i64toi32_i32$2 = $329$hi;
                                            i64toi32_i32$1 = $329;
                                            i64toi32_i32$3 = $336$hi;
                                            i64toi32_i32$0 = i64toi32_i32$4;
                                            if ((i64toi32_i32$1 | 0) != (i64toi32_i32$4 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$3 | 0) | 0) {
                                              break label$56;
                                            }
                                            break label$10;
                                          case 3:
                                          case 11:
                                          case 27:
                                            label$64: {
                                              if (($17_1 | 16 | 0 | 0) != (115 | 0)) {
                                                break label$64;
                                              }
                                              $16($3_1 + 32 | 0 | 0, -1 | 0, 257 | 0) | 0;
                                              HEAP8[($3_1 + 32 | 0) >> 0] = 0;
                                              if (($17_1 | 0) != (115 | 0)) {
                                                break label$55;
                                              }
                                              HEAP8[($3_1 + 65 | 0) >> 0] = 0;
                                              HEAP8[($3_1 + 46 | 0) >> 0] = 0;
                                              $74_1 = 0;
                                              HEAP16[($3_1 + 42 | 0) >> 1] = $74_1;
                                              HEAP16[($3_1 + 44 | 0) >> 1] = $74_1 >>> 16 | 0;
                                              break label$55;
                                            }
                                            $14_1 = HEAPU8[($5_1 + 1 | 0) >> 0] | 0;
                                            $1_1 = ($14_1 | 0) == (94 | 0);
                                            $16($3_1 + 32 | 0 | 0, $1_1 | 0, 257 | 0) | 0;
                                            HEAP8[($3_1 + 32 | 0) >> 0] = 0;
                                            $15_1 = $1_1 ? $5_1 + 2 | 0 : $5_1 + 1 | 0;
                                            label$65: {
                                              label$66: {
                                                label$67: {
                                                  label$68: {
                                                    $1_1 = HEAPU8[($5_1 + ($1_1 ? 2 : 1) | 0) >> 0] | 0;
                                                    if (($1_1 | 0) == (45 | 0)) {
                                                      break label$68;
                                                    }
                                                    if (($1_1 | 0) == (93 | 0)) {
                                                      break label$67;
                                                    }
                                                    $11_1 = ($14_1 | 0) != (94 | 0);
                                                    $5_1 = $15_1;
                                                    break label$65;
                                                  }
                                                  $11_1 = ($14_1 | 0) != (94 | 0);
                                                  HEAP8[($3_1 + 78 | 0) >> 0] = $11_1;
                                                  break label$66;
                                                }
                                                $11_1 = ($14_1 | 0) != (94 | 0);
                                                HEAP8[($3_1 + 126 | 0) >> 0] = $11_1;
                                              }
                                              $5_1 = $15_1 + 1 | 0;
                                            }
                                            label$69: while (1) {
                                              label$70: {
                                                label$71: {
                                                  $14_1 = HEAPU8[$5_1 >> 0] | 0;
                                                  if (($14_1 | 0) == (45 | 0)) {
                                                    break label$71;
                                                  }
                                                  if (!$14_1) {
                                                    break label$9;
                                                  }
                                                  if (($14_1 | 0) == (93 | 0)) {
                                                    break label$55;
                                                  }
                                                  break label$70;
                                                }
                                                $14_1 = 45;
                                                $18_1 = HEAPU8[($5_1 + 1 | 0) >> 0] | 0;
                                                if (!$18_1) {
                                                  break label$70;
                                                }
                                                if (($18_1 | 0) == (93 | 0)) {
                                                  break label$70;
                                                }
                                                $15_1 = $5_1 + 1 | 0;
                                                label$72: {
                                                  label$73: {
                                                    $1_1 = HEAPU8[($5_1 + -1 | 0) >> 0] | 0;
                                                    if ($1_1 >>> 0 < $18_1 >>> 0) {
                                                      break label$73;
                                                    }
                                                    $14_1 = $18_1;
                                                    break label$72;
                                                  }
                                                  label$74: while (1) {
                                                    $1_1 = $1_1 + 1 | 0;
                                                    HEAP8[(($3_1 + 32 | 0) + $1_1 | 0) >> 0] = $11_1;
                                                    $14_1 = HEAPU8[$15_1 >> 0] | 0;
                                                    if ($1_1 >>> 0 < $14_1 >>> 0) {
                                                      continue label$74;
                                                    }
                                                    break label$74;
                                                  };
                                                }
                                                $5_1 = $15_1;
                                              }
                                              HEAP8[(($14_1 + ($3_1 + 32 | 0) | 0) + 1 | 0) >> 0] = $11_1;
                                              $5_1 = $5_1 + 1 | 0;
                                              continue label$69;
                                            };
                                          case 23:
                                            $1_1 = 8;
                                            break label$57;
                                          case 12:
                                          case 29:
                                            $1_1 = 10;
                                            break label$57;
                                          case 1:
                                          case 2:
                                          case 4:
                                          case 5:
                                          case 6:
                                          case 7:
                                          case 8:
                                          case 10:
                                          case 16:
                                          case 18:
                                          case 19:
                                          case 20:
                                          case 21:
                                          case 22:
                                          case 25:
                                          case 26:
                                          case 28:
                                          case 30:
                                          case 31:
                                            break label$54;
                                          case 0:
                                          case 24:
                                          case 32:
                                            break label$57;
                                          case 17:
                                            break label$58;
                                        };
                                      }
                                      $1_1 = 0;
                                    }
                                    i64toi32_i32$1 = -1;
                                    i64toi32_i32$1 = $61($0_1 | 0, $1_1 | 0, 0 | 0, -1 | 0, i64toi32_i32$1 | 0) | 0;
                                    i64toi32_i32$2 = i64toi32_i32$HIGH_BITS;
                                    $20_1 = i64toi32_i32$1;
                                    $20$hi = i64toi32_i32$2;
                                    i64toi32_i32$0 = $0_1;
                                    i64toi32_i32$2 = HEAP32[($0_1 + 120 | 0) >> 2] | 0;
                                    i64toi32_i32$1 = HEAP32[($0_1 + 124 | 0) >> 2] | 0;
                                    $435 = i64toi32_i32$2;
                                    $435$hi = i64toi32_i32$1;
                                    i64toi32_i32$2 = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) - (HEAP32[($0_1 + 44 | 0) >> 2] | 0) | 0;
                                    i64toi32_i32$1 = i64toi32_i32$2 >> 31 | 0;
                                    $441 = i64toi32_i32$2;
                                    $441$hi = i64toi32_i32$1;
                                    i64toi32_i32$1 = 0;
                                    i64toi32_i32$0 = 0;
                                    i64toi32_i32$2 = $441$hi;
                                    i64toi32_i32$3 = $441;
                                    i64toi32_i32$5 = i64toi32_i32$0 - i64toi32_i32$3 | 0;
                                    i64toi32_i32$6 = i64toi32_i32$0 >>> 0 < i64toi32_i32$3 >>> 0;
                                    i64toi32_i32$4 = i64toi32_i32$6 + i64toi32_i32$2 | 0;
                                    i64toi32_i32$4 = i64toi32_i32$1 - i64toi32_i32$4 | 0;
                                    $442$hi = i64toi32_i32$4;
                                    i64toi32_i32$4 = $435$hi;
                                    i64toi32_i32$1 = $435;
                                    i64toi32_i32$0 = $442$hi;
                                    i64toi32_i32$3 = i64toi32_i32$5;
                                    if ((i64toi32_i32$1 | 0) == (i64toi32_i32$3 | 0) & (i64toi32_i32$4 | 0) == (i64toi32_i32$0 | 0) | 0) {
                                      break label$10;
                                    }
                                    label$75: {
                                      if (($17_1 | 0) != (112 | 0)) {
                                        break label$75;
                                      }
                                      if (!$8_1) {
                                        break label$75;
                                      }
                                      i64toi32_i32$1 = $20$hi;
                                      HEAP32[$8_1 >> 2] = $20_1;
                                      break label$54;
                                    }
                                    i64toi32_i32$1 = $20$hi;
                                    $72($8_1 | 0, $16_1 | 0, $20_1 | 0, i64toi32_i32$1 | 0);
                                    break label$54;
                                  }
                                  if (!$8_1) {
                                    break label$54;
                                  }
                                  i64toi32_i32$3 = $7_1;
                                  i64toi32_i32$1 = HEAP32[i64toi32_i32$3 >> 2] | 0;
                                  i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
                                  $20_1 = i64toi32_i32$1;
                                  $20$hi = i64toi32_i32$4;
                                  i64toi32_i32$3 = $3_1;
                                  i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 8 | 0) >> 2] | 0;
                                  i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 12 | 0) >> 2] | 0;
                                  $21_1 = i64toi32_i32$4;
                                  $21$hi = i64toi32_i32$1;
                                  label$76: {
                                    switch ($16_1 | 0) {
                                      case 0:
                                        i64toi32_i32$1 = $21$hi;
                                        i64toi32_i32$1 = $20$hi;
                                        i64toi32_i32$1 = $21$hi;
                                        i64toi32_i32$4 = $20$hi;
                                        (wasm2js_i32$0 = $8_1, wasm2js_f32$0 = Math_fround($101($21_1 | 0, i64toi32_i32$1 | 0, $20_1 | 0, i64toi32_i32$4 | 0))), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                                        break label$54;
                                      case 1:
                                        i64toi32_i32$4 = $21$hi;
                                        i64toi32_i32$4 = $20$hi;
                                        i64toi32_i32$4 = $21$hi;
                                        i64toi32_i32$1 = $20$hi;
                                        (wasm2js_i32$0 = $8_1, wasm2js_f64$0 = +$100($21_1 | 0, i64toi32_i32$4 | 0, $20_1 | 0, i64toi32_i32$1 | 0)), HEAPF64[wasm2js_i32$0 >> 3] = wasm2js_f64$0;
                                        break label$54;
                                      case 2:
                                        break label$76;
                                      default:
                                        break label$54;
                                    };
                                  }
                                  i64toi32_i32$1 = $21$hi;
                                  i64toi32_i32$4 = $8_1;
                                  HEAP32[i64toi32_i32$4 >> 2] = $21_1;
                                  HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] = i64toi32_i32$1;
                                  i64toi32_i32$1 = $20$hi;
                                  HEAP32[(i64toi32_i32$4 + 8 | 0) >> 2] = $20_1;
                                  HEAP32[(i64toi32_i32$4 + 12 | 0) >> 2] = i64toi32_i32$1;
                                  break label$54;
                                }
                                $11_1 = ($17_1 | 0) != (99 | 0);
                                $14_1 = $11_1 ? 31 : $9_1 + 1 | 0;
                                label$79: {
                                  label$80: {
                                    if (($16_1 | 0) != (1 | 0)) {
                                      break label$80;
                                    }
                                    $9_1 = $8_1;
                                    label$81: {
                                      if (!$10_1) {
                                        break label$81;
                                      }
                                      $9_1 = $79($14_1 << 2 | 0 | 0) | 0;
                                      if (!$9_1) {
                                        break label$11;
                                      }
                                    }
                                    i64toi32_i32$4 = $3_1;
                                    i64toi32_i32$1 = 0;
                                    HEAP32[(i64toi32_i32$4 + 296 | 0) >> 2] = 0;
                                    HEAP32[(i64toi32_i32$4 + 300 | 0) >> 2] = i64toi32_i32$1;
                                    $1_1 = 0;
                                    label$82: while (1) {
                                      $13_1 = $9_1;
                                      label$83: {
                                        label$84: while (1) {
                                          label$85: {
                                            label$86: {
                                              $9_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                              if (($9_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                                                break label$86;
                                              }
                                              HEAP32[($0_1 + 4 | 0) >> 2] = $9_1 + 1 | 0;
                                              $9_1 = HEAPU8[$9_1 >> 0] | 0;
                                              break label$85;
                                            }
                                            $9_1 = $49($0_1 | 0) | 0;
                                          }
                                          if (!(HEAPU8[(($9_1 + ($3_1 + 32 | 0) | 0) + 1 | 0) >> 0] | 0)) {
                                            break label$83;
                                          }
                                          HEAP8[($3_1 + 27 | 0) >> 0] = $9_1;
                                          $9_1 = $67($3_1 + 28 | 0 | 0, $3_1 + 27 | 0 | 0, 1 | 0, $3_1 + 296 | 0 | 0) | 0;
                                          if (($9_1 | 0) == (-2 | 0)) {
                                            continue label$84;
                                          }
                                          label$87: {
                                            if (($9_1 | 0) != (-1 | 0)) {
                                              break label$87;
                                            }
                                            $12_1 = 0;
                                            break label$9;
                                          }
                                          label$88: {
                                            if (!$13_1) {
                                              break label$88;
                                            }
                                            HEAP32[($13_1 + ($1_1 << 2 | 0) | 0) >> 2] = HEAP32[($3_1 + 28 | 0) >> 2] | 0;
                                            $1_1 = $1_1 + 1 | 0;
                                          }
                                          if (!$10_1) {
                                            continue label$84;
                                          }
                                          if (($1_1 | 0) != ($14_1 | 0)) {
                                            continue label$84;
                                          }
                                          break label$84;
                                        };
                                        $15_1 = 1;
                                        $12_1 = 0;
                                        $14_1 = $14_1 << 1 | 0 | 1 | 0;
                                        $9_1 = $82($13_1 | 0, $14_1 << 2 | 0 | 0) | 0;
                                        if ($9_1) {
                                          continue label$82;
                                        }
                                        break label$8;
                                      }
                                      break label$82;
                                    };
                                    $12_1 = 0;
                                    $14_1 = $13_1;
                                    if (!($68($3_1 + 296 | 0 | 0) | 0)) {
                                      break label$9;
                                    }
                                    break label$79;
                                  }
                                  label$89: {
                                    if (!$10_1) {
                                      break label$89;
                                    }
                                    $1_1 = 0;
                                    $9_1 = $79($14_1 | 0) | 0;
                                    if (!$9_1) {
                                      break label$11;
                                    }
                                    label$90: while (1) {
                                      $13_1 = $9_1;
                                      label$91: while (1) {
                                        label$92: {
                                          label$93: {
                                            $9_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                            if (($9_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                                              break label$93;
                                            }
                                            HEAP32[($0_1 + 4 | 0) >> 2] = $9_1 + 1 | 0;
                                            $9_1 = HEAPU8[$9_1 >> 0] | 0;
                                            break label$92;
                                          }
                                          $9_1 = $49($0_1 | 0) | 0;
                                        }
                                        label$94: {
                                          if (HEAPU8[(($9_1 + ($3_1 + 32 | 0) | 0) + 1 | 0) >> 0] | 0) {
                                            break label$94;
                                          }
                                          $14_1 = 0;
                                          $12_1 = $13_1;
                                          break label$79;
                                        }
                                        HEAP8[($13_1 + $1_1 | 0) >> 0] = $9_1;
                                        $1_1 = $1_1 + 1 | 0;
                                        if (($1_1 | 0) != ($14_1 | 0)) {
                                          continue label$91;
                                        }
                                        break label$91;
                                      };
                                      $15_1 = 1;
                                      $14_1 = $14_1 << 1 | 0 | 1 | 0;
                                      $9_1 = $82($13_1 | 0, $14_1 | 0) | 0;
                                      if ($9_1) {
                                        continue label$90;
                                      }
                                      break label$90;
                                    };
                                    $12_1 = $13_1;
                                    $13_1 = 0;
                                    break label$8;
                                  }
                                  $1_1 = 0;
                                  label$95: {
                                    if (!$8_1) {
                                      break label$95;
                                    }
                                    label$96: while (1) {
                                      label$97: {
                                        label$98: {
                                          $9_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                          if (($9_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                                            break label$98;
                                          }
                                          HEAP32[($0_1 + 4 | 0) >> 2] = $9_1 + 1 | 0;
                                          $9_1 = HEAPU8[$9_1 >> 0] | 0;
                                          break label$97;
                                        }
                                        $9_1 = $49($0_1 | 0) | 0;
                                      }
                                      label$99: {
                                        if (HEAPU8[(($9_1 + ($3_1 + 32 | 0) | 0) + 1 | 0) >> 0] | 0) {
                                          break label$99;
                                        }
                                        $14_1 = 0;
                                        $13_1 = $8_1;
                                        $12_1 = $8_1;
                                        break label$79;
                                      }
                                      HEAP8[($8_1 + $1_1 | 0) >> 0] = $9_1;
                                      $1_1 = $1_1 + 1 | 0;
                                      continue label$96;
                                    };
                                  }
                                  label$100: while (1) {
                                    label$101: {
                                      label$102: {
                                        $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                        if (($1_1 | 0) == (HEAP32[($0_1 + 104 | 0) >> 2] | 0 | 0)) {
                                          break label$102;
                                        }
                                        HEAP32[($0_1 + 4 | 0) >> 2] = $1_1 + 1 | 0;
                                        $1_1 = HEAPU8[$1_1 >> 0] | 0;
                                        break label$101;
                                      }
                                      $1_1 = $49($0_1 | 0) | 0;
                                    }
                                    if (HEAPU8[(($1_1 + ($3_1 + 32 | 0) | 0) + 1 | 0) >> 0] | 0) {
                                      continue label$100;
                                    }
                                    break label$100;
                                  };
                                  $13_1 = 0;
                                  $12_1 = 0;
                                  $14_1 = 0;
                                  $1_1 = 0;
                                }
                                $9_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                label$103: {
                                  i64toi32_i32$3 = $0_1;
                                  i64toi32_i32$1 = HEAP32[($0_1 + 112 | 0) >> 2] | 0;
                                  i64toi32_i32$4 = HEAP32[($0_1 + 116 | 0) >> 2] | 0;
                                  i64toi32_i32$3 = i64toi32_i32$1;
                                  i64toi32_i32$1 = 0;
                                  i64toi32_i32$0 = 0;
                                  if ((i64toi32_i32$4 | 0) < (i64toi32_i32$1 | 0)) {
                                    $75_1 = 1;
                                  } else {
                                    if ((i64toi32_i32$4 | 0) <= (i64toi32_i32$1 | 0)) {
                                      if (i64toi32_i32$3 >>> 0 >= i64toi32_i32$0 >>> 0) {
                                        $76_1 = 0;
                                      } else {
                                        $76_1 = 1;
                                      }
                                      $77_1 = $76_1;
                                    } else {
                                      $77_1 = 0;
                                    }
                                    $75_1 = $77_1;
                                  }
                                  if ($75_1) {
                                    break label$103;
                                  }
                                  $9_1 = $9_1 + -1 | 0;
                                  HEAP32[($0_1 + 4 | 0) >> 2] = $9_1;
                                }
                                i64toi32_i32$0 = $0_1;
                                i64toi32_i32$3 = HEAP32[($0_1 + 120 | 0) >> 2] | 0;
                                i64toi32_i32$4 = HEAP32[($0_1 + 124 | 0) >> 2] | 0;
                                $653 = i64toi32_i32$3;
                                $653$hi = i64toi32_i32$4;
                                i64toi32_i32$3 = $9_1 - (HEAP32[($0_1 + 44 | 0) >> 2] | 0) | 0;
                                i64toi32_i32$4 = i64toi32_i32$3 >> 31 | 0;
                                $658 = i64toi32_i32$3;
                                $658$hi = i64toi32_i32$4;
                                i64toi32_i32$4 = $653$hi;
                                i64toi32_i32$0 = $653;
                                i64toi32_i32$3 = $658$hi;
                                i64toi32_i32$1 = $658;
                                i64toi32_i32$2 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
                                i64toi32_i32$5 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
                                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0) {
                                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                                }
                                $21_1 = i64toi32_i32$2;
                                $21$hi = i64toi32_i32$5;
                                if (!(i64toi32_i32$2 | i64toi32_i32$5 | 0)) {
                                  break label$12;
                                }
                                i64toi32_i32$5 = $20$hi;
                                i64toi32_i32$5 = $21$hi;
                                i64toi32_i32$4 = i64toi32_i32$2;
                                i64toi32_i32$0 = $20$hi;
                                i64toi32_i32$1 = $20_1;
                                if (!($11_1 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$1 | 0) & (i64toi32_i32$5 | 0) == (i64toi32_i32$0 | 0) | 0) | 0)) {
                                  break label$12;
                                }
                                label$104: {
                                  if (!$10_1) {
                                    break label$104;
                                  }
                                  HEAP32[$8_1 >> 2] = $13_1;
                                }
                                label$105: {
                                  if (($17_1 | 0) == (99 | 0)) {
                                    break label$105;
                                  }
                                  label$106: {
                                    if (!$14_1) {
                                      break label$106;
                                    }
                                    HEAP32[($14_1 + ($1_1 << 2 | 0) | 0) >> 2] = 0;
                                  }
                                  label$107: {
                                    if ($12_1) {
                                      break label$107;
                                    }
                                    $12_1 = 0;
                                    break label$105;
                                  }
                                  HEAP8[($12_1 + $1_1 | 0) >> 0] = 0;
                                }
                                $13_1 = $14_1;
                              }
                              i64toi32_i32$1 = $0_1;
                              i64toi32_i32$4 = HEAP32[($0_1 + 120 | 0) >> 2] | 0;
                              i64toi32_i32$5 = HEAP32[($0_1 + 124 | 0) >> 2] | 0;
                              $686$hi = i64toi32_i32$5;
                              i64toi32_i32$5 = $19$hi;
                              i64toi32_i32$5 = $686$hi;
                              i64toi32_i32$1 = i64toi32_i32$4;
                              i64toi32_i32$4 = $19$hi;
                              i64toi32_i32$0 = $19_1;
                              i64toi32_i32$3 = i64toi32_i32$1 + i64toi32_i32$0 | 0;
                              i64toi32_i32$2 = i64toi32_i32$5 + i64toi32_i32$4 | 0;
                              if (i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0) {
                                i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                              }
                              $688$hi = i64toi32_i32$2;
                              i64toi32_i32$1 = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) - (HEAP32[($0_1 + 44 | 0) >> 2] | 0) | 0;
                              i64toi32_i32$2 = i64toi32_i32$1 >> 31 | 0;
                              $694 = i64toi32_i32$1;
                              $694$hi = i64toi32_i32$2;
                              i64toi32_i32$2 = $688$hi;
                              i64toi32_i32$5 = i64toi32_i32$3;
                              i64toi32_i32$1 = $694$hi;
                              i64toi32_i32$0 = $694;
                              i64toi32_i32$4 = i64toi32_i32$3 + i64toi32_i32$0 | 0;
                              i64toi32_i32$3 = i64toi32_i32$2 + i64toi32_i32$1 | 0;
                              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0) {
                                i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                              }
                              $19_1 = i64toi32_i32$4;
                              $19$hi = i64toi32_i32$3;
                              $6_1 = $6_1 + (($8_1 | 0) != (0 | 0)) | 0;
                            }
                            $1_1 = $5_1 + 1 | 0;
                            $5_1 = HEAPU8[($5_1 + 1 | 0) >> 0] | 0;
                            if ($5_1) {
                              continue label$13;
                            }
                            break label$3;
                          };
                        }
                        $13_1 = $14_1;
                        break label$10;
                      }
                      $15_1 = 1;
                      $12_1 = 0;
                      $13_1 = 0;
                      break label$8;
                    }
                    $15_1 = $10_1;
                    break label$7;
                  }
                  $15_1 = $10_1;
                }
                $6_1 = $6_1 ? $6_1 : -1;
              }
              if (!$15_1) {
                break label$3;
              }
              $81($12_1 | 0);
              $81($13_1 | 0);
              break label$3;
            }
            $6_1 = -1;
          }
          label$108: {
            if ($4_1) {
              break label$108;
            }
            $19($0_1 | 0);
          }
          global$0 = $3_1 + 304 | 0;
          return $6_1 | 0;
        }

        function $70($0_1) {
          $0_1 = $0_1 | 0;
          return ($0_1 | 0) == (32 | 0) | ($0_1 + -9 | 0) >>> 0 < 5 >>> 0 | 0 | 0;
        }

        function $71($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var $2_1 = 0;
          $2_1 = global$0 - 16 | 0;
          HEAP32[($2_1 + 12 | 0) >> 2] = $0_1;
          $0_1 = $1_1 >>> 0 > 1 >>> 0 ? ($0_1 + ($1_1 << 2 | 0) | 0) + -4 | 0 : $0_1;
          HEAP32[($2_1 + 8 | 0) >> 2] = $0_1 + 4 | 0;
          return HEAP32[$0_1 >> 2] | 0 | 0;
        }

        function $72($0_1, $1_1, $2_1, $2$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          var i64toi32_i32$0 = 0;
          label$1: {
            if (!$0_1) {
              break label$1;
            }
            label$2: {
              switch ($1_1 + 2 | 0 | 0) {
                case 0:
                  i64toi32_i32$0 = $2$hi;
                  HEAP8[$0_1 >> 0] = $2_1;
                  return;
                case 1:
                  i64toi32_i32$0 = $2$hi;
                  HEAP16[$0_1 >> 1] = $2_1;
                  return;
                case 2:
                case 3:
                  i64toi32_i32$0 = $2$hi;
                  HEAP32[$0_1 >> 2] = $2_1;
                  return;
                case 5:
                  break label$2;
                default:
                  break label$1;
              };
            }
            i64toi32_i32$0 = $2$hi;
            HEAP32[$0_1 >> 2] = $2_1;
            HEAP32[($0_1 + 4 | 0) >> 2] = i64toi32_i32$0;
          }
        }

        function $73($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $3_1 = 0;
          $3_1 = global$0 - 144 | 0;
          global$0 = $3_1;
          $3_1 = $16($3_1 | 0, 0 | 0, 144 | 0) | 0;
          HEAP32[($3_1 + 76 | 0) >> 2] = -1;
          HEAP32[($3_1 + 44 | 0) >> 2] = $0_1;
          HEAP32[($3_1 + 32 | 0) >> 2] = 4;
          HEAP32[($3_1 + 84 | 0) >> 2] = $0_1;
          $0_1 = $69($3_1 | 0, $1_1 | 0, $2_1 | 0) | 0;
          global$0 = $3_1 + 144 | 0;
          return $0_1 | 0;
        }

        function $74($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $4_1 = 0,$3_1 = 0,$5_1 = 0;
          $3_1 = HEAP32[($0_1 + 84 | 0) >> 2] | 0;
          $4_1 = $2_1 + 256 | 0;
          $5_1 = $25($3_1 | 0, 0 | 0, $4_1 | 0) | 0;
          $4_1 = $5_1 ? $5_1 - $3_1 | 0 : $4_1;
          $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $4_1 : $2_1;
          $28($1_1 | 0, $3_1 | 0, $2_1 | 0) | 0;
          $4_1 = $3_1 + $4_1 | 0;
          HEAP32[($0_1 + 84 | 0) >> 2] = $4_1;
          HEAP32[($0_1 + 8 | 0) >> 2] = $4_1;
          HEAP32[($0_1 + 4 | 0) >> 2] = $3_1 + $2_1 | 0;
          return $2_1 | 0;
        }

        function $75($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $3_1 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $3_1 = 1;
          label$1: {
            label$2: {
              if (!$0_1) {
                break label$2;
              }
              if ($1_1 >>> 0 <= 127 >>> 0) {
                break label$1;
              }
              label$3: {
                label$4: {
                  if (HEAP32[(HEAP32[(($65() | 0) + 96 | 0) >> 2] | 0) >> 2] | 0) {
                    break label$4;
                  }
                  if (($1_1 & -128 | 0 | 0) == (57216 | 0)) {
                    break label$1;
                  }
                  (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 25), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
                  break label$3;
                }
                label$5: {
                  if ($1_1 >>> 0 > 2047 >>> 0) {
                    break label$5;
                  }
                  HEAP8[($0_1 + 1 | 0) >> 0] = $1_1 & 63 | 0 | 128 | 0;
                  HEAP8[$0_1 >> 0] = $1_1 >>> 6 | 0 | 192 | 0;
                  return 2 | 0;
                }
                label$6: {
                  label$7: {
                    if ($1_1 >>> 0 < 55296 >>> 0) {
                      break label$7;
                    }
                    if (($1_1 & -8192 | 0 | 0) != (57344 | 0)) {
                      break label$6;
                    }
                  }
                  HEAP8[($0_1 + 2 | 0) >> 0] = $1_1 & 63 | 0 | 128 | 0;
                  HEAP8[$0_1 >> 0] = $1_1 >>> 12 | 0 | 224 | 0;
                  HEAP8[($0_1 + 1 | 0) >> 0] = ($1_1 >>> 6 | 0) & 63 | 0 | 128 | 0;
                  return 3 | 0;
                }
                label$8: {
                  if (($1_1 + -65536 | 0) >>> 0 > 1048575 >>> 0) {
                    break label$8;
                  }
                  HEAP8[($0_1 + 3 | 0) >> 0] = $1_1 & 63 | 0 | 128 | 0;
                  HEAP8[$0_1 >> 0] = $1_1 >>> 18 | 0 | 240 | 0;
                  HEAP8[($0_1 + 2 | 0) >> 0] = ($1_1 >>> 6 | 0) & 63 | 0 | 128 | 0;
                  HEAP8[($0_1 + 1 | 0) >> 0] = ($1_1 >>> 12 | 0) & 63 | 0 | 128 | 0;
                  return 4 | 0;
                }
                (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 25), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
              }
              $3_1 = -1;
            }
            return $3_1 | 0;
          }
          HEAP8[$0_1 >> 0] = $1_1;
          return 1 | 0;
        }

        function $76($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          label$1: {
            if ($0_1) {
              break label$1;
            }
            return 0 | 0;
          }
          return $75($0_1 | 0, $1_1 | 0, 0 | 0) | 0 | 0;
        }

        function $77() {
          return __wasm_memory_size() << 16 | 0 | 0;
        }

        function $78($0_1) {
          $0_1 = $0_1 | 0;
          var $1_1 = 0,$2_1 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $1_1 = HEAP32[(0 + 66652 | 0) >> 2] | 0;
          $2_1 = ($0_1 + 7 | 0) & -8 | 0;
          $0_1 = $1_1 + $2_1 | 0;
          label$1: {
            label$2: {
              label$3: {
                if (!$2_1) {
                  break label$3;
                }
                if ($0_1 >>> 0 <= $1_1 >>> 0) {
                  break label$2;
                }
              }
              if ($0_1 >>> 0 <= ($77() | 0) >>> 0) {
                break label$1;
              }
              if (fimport$1($0_1 | 0) | 0) {
                break label$1;
              }
            }
            (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 48), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
            return -1 | 0;
          }
          HEAP32[(0 + 66652 | 0) >> 2] = $0_1;
          return $1_1 | 0;
        }

        function $79($0_1) {
          $0_1 = $0_1 | 0;
          var $5_1 = 0,$4_1 = 0,$7_1 = 0,$8_1 = 0,$3_1 = 0,$2_1 = 0,$6_1 = 0,$10_1 = 0,$11_1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,i64toi32_i32$2 = 0,$1_1 = 0,$9_1 = 0,$79_1 = 0,$183 = 0,$782 = 0,$784 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $1_1 = global$0 - 16 | 0;
          global$0 = $1_1;
          label$1: {
            label$2: {
              label$3: {
                label$4: {
                  label$5: {
                    label$6: {
                      label$7: {
                        label$8: {
                          label$9: {
                            label$10: {
                              label$11: {
                                if ($0_1 >>> 0 > 244 >>> 0) {
                                  break label$11;
                                }
                                label$12: {
                                  $2_1 = HEAP32[(0 + 99632 | 0) >> 2] | 0;
                                  $3_1 = $0_1 >>> 0 < 11 >>> 0 ? 16 : ($0_1 + 11 | 0) & 504 | 0;
                                  $4_1 = $3_1 >>> 3 | 0;
                                  $0_1 = $2_1 >>> $4_1 | 0;
                                  if (!($0_1 & 3 | 0)) {
                                    break label$12;
                                  }
                                  label$13: {
                                    label$14: {
                                      $3_1 = (($0_1 ^ -1 | 0) & 1 | 0) + $4_1 | 0;
                                      $4_1 = $3_1 << 3 | 0;
                                      $0_1 = $4_1 + 99672 | 0;
                                      $4_1 = HEAP32[($4_1 + 99680 | 0) >> 2] | 0;
                                      $5_1 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;
                                      if (($0_1 | 0) != ($5_1 | 0)) {
                                        break label$14;
                                      }
                                      (wasm2js_i32$0 = 0, wasm2js_i32$1 = $2_1 & (__wasm_rotl_i32(-2 | 0, $3_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99632 | 0) >> 2] = wasm2js_i32$1;
                                      break label$13;
                                    }
                                    HEAP32[($5_1 + 12 | 0) >> 2] = $0_1;
                                    HEAP32[($0_1 + 8 | 0) >> 2] = $5_1;
                                  }
                                  $0_1 = $4_1 + 8 | 0;
                                  $3_1 = $3_1 << 3 | 0;
                                  HEAP32[($4_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;
                                  $4_1 = $4_1 + $3_1 | 0;
                                  HEAP32[($4_1 + 4 | 0) >> 2] = HEAP32[($4_1 + 4 | 0) >> 2] | 0 | 1 | 0;
                                  break label$1;
                                }
                                $6_1 = HEAP32[(0 + 99640 | 0) >> 2] | 0;
                                if ($3_1 >>> 0 <= $6_1 >>> 0) {
                                  break label$10;
                                }
                                label$15: {
                                  if (!$0_1) {
                                    break label$15;
                                  }
                                  label$16: {
                                    label$17: {
                                      $79_1 = $0_1 << $4_1 | 0;
                                      $0_1 = 2 << $4_1 | 0;
                                      $4_1 = __wasm_ctz_i32($79_1 & ($0_1 | (0 - $0_1 | 0) | 0) | 0 | 0) | 0;
                                      $0_1 = $4_1 << 3 | 0;
                                      $5_1 = $0_1 + 99672 | 0;
                                      $0_1 = HEAP32[($0_1 + 99680 | 0) >> 2] | 0;
                                      $7_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
                                      if (($5_1 | 0) != ($7_1 | 0)) {
                                        break label$17;
                                      }
                                      $2_1 = $2_1 & (__wasm_rotl_i32(-2 | 0, $4_1 | 0) | 0) | 0;
                                      HEAP32[(0 + 99632 | 0) >> 2] = $2_1;
                                      break label$16;
                                    }
                                    HEAP32[($7_1 + 12 | 0) >> 2] = $5_1;
                                    HEAP32[($5_1 + 8 | 0) >> 2] = $7_1;
                                  }
                                  HEAP32[($0_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;
                                  $7_1 = $0_1 + $3_1 | 0;
                                  $4_1 = $4_1 << 3 | 0;
                                  $3_1 = $4_1 - $3_1 | 0;
                                  HEAP32[($7_1 + 4 | 0) >> 2] = $3_1 | 1 | 0;
                                  HEAP32[($0_1 + $4_1 | 0) >> 2] = $3_1;
                                  label$18: {
                                    if (!$6_1) {
                                      break label$18;
                                    }
                                    $5_1 = ($6_1 & -8 | 0) + 99672 | 0;
                                    $4_1 = HEAP32[(0 + 99652 | 0) >> 2] | 0;
                                    label$19: {
                                      label$20: {
                                        $8_1 = 1 << ($6_1 >>> 3 | 0) | 0;
                                        if ($2_1 & $8_1 | 0) {
                                          break label$20;
                                        }
                                        HEAP32[(0 + 99632 | 0) >> 2] = $2_1 | $8_1 | 0;
                                        $8_1 = $5_1;
                                        break label$19;
                                      }
                                      $8_1 = HEAP32[($5_1 + 8 | 0) >> 2] | 0;
                                    }
                                    HEAP32[($5_1 + 8 | 0) >> 2] = $4_1;
                                    HEAP32[($8_1 + 12 | 0) >> 2] = $4_1;
                                    HEAP32[($4_1 + 12 | 0) >> 2] = $5_1;
                                    HEAP32[($4_1 + 8 | 0) >> 2] = $8_1;
                                  }
                                  $0_1 = $0_1 + 8 | 0;
                                  HEAP32[(0 + 99652 | 0) >> 2] = $7_1;
                                  HEAP32[(0 + 99640 | 0) >> 2] = $3_1;
                                  break label$1;
                                }
                                $9_1 = HEAP32[(0 + 99636 | 0) >> 2] | 0;
                                if (!$9_1) {
                                  break label$10;
                                }
                                $7_1 = HEAP32[(((__wasm_ctz_i32($9_1 | 0) | 0) << 2 | 0) + 99936 | 0) >> 2] | 0;
                                $4_1 = ((HEAP32[($7_1 + 4 | 0) >> 2] | 0) & -8 | 0) - $3_1 | 0;
                                $5_1 = $7_1;
                                label$21: {
                                  label$22: while (1) {
                                    label$23: {
                                      $0_1 = HEAP32[($5_1 + 16 | 0) >> 2] | 0;
                                      if ($0_1) {
                                        break label$23;
                                      }
                                      $0_1 = HEAP32[($5_1 + 20 | 0) >> 2] | 0;
                                      if (!$0_1) {
                                        break label$21;
                                      }
                                    }
                                    $5_1 = ((HEAP32[($0_1 + 4 | 0) >> 2] | 0) & -8 | 0) - $3_1 | 0;
                                    $183 = $5_1;
                                    $5_1 = $5_1 >>> 0 < $4_1 >>> 0;
                                    $4_1 = $5_1 ? $183 : $4_1;
                                    $7_1 = $5_1 ? $0_1 : $7_1;
                                    $5_1 = $0_1;
                                    continue label$22;
                                  };
                                }
                                $10_1 = HEAP32[($7_1 + 24 | 0) >> 2] | 0;
                                label$24: {
                                  $0_1 = HEAP32[($7_1 + 12 | 0) >> 2] | 0;
                                  if (($0_1 | 0) == ($7_1 | 0)) {
                                    break label$24;
                                  }
                                  $5_1 = HEAP32[($7_1 + 8 | 0) >> 2] | 0;
                                  HEAP32[(0 + 99648 | 0) >> 2] | 0;
                                  HEAP32[($5_1 + 12 | 0) >> 2] = $0_1;
                                  HEAP32[($0_1 + 8 | 0) >> 2] = $5_1;
                                  break label$2;
                                }
                                label$25: {
                                  label$26: {
                                    $5_1 = HEAP32[($7_1 + 20 | 0) >> 2] | 0;
                                    if (!$5_1) {
                                      break label$26;
                                    }
                                    $8_1 = $7_1 + 20 | 0;
                                    break label$25;
                                  }
                                  $5_1 = HEAP32[($7_1 + 16 | 0) >> 2] | 0;
                                  if (!$5_1) {
                                    break label$9;
                                  }
                                  $8_1 = $7_1 + 16 | 0;
                                }
                                label$27: while (1) {
                                  $11_1 = $8_1;
                                  $0_1 = $5_1;
                                  $8_1 = $0_1 + 20 | 0;
                                  $5_1 = HEAP32[($0_1 + 20 | 0) >> 2] | 0;
                                  if ($5_1) {
                                    continue label$27;
                                  }
                                  $8_1 = $0_1 + 16 | 0;
                                  $5_1 = HEAP32[($0_1 + 16 | 0) >> 2] | 0;
                                  if ($5_1) {
                                    continue label$27;
                                  }
                                  break label$27;
                                };
                                HEAP32[$11_1 >> 2] = 0;
                                break label$2;
                              }
                              $3_1 = -1;
                              if ($0_1 >>> 0 > -65 >>> 0) {
                                break label$10;
                              }
                              $0_1 = $0_1 + 11 | 0;
                              $3_1 = $0_1 & -8 | 0;
                              $10_1 = HEAP32[(0 + 99636 | 0) >> 2] | 0;
                              if (!$10_1) {
                                break label$10;
                              }
                              $6_1 = 0;
                              label$28: {
                                if ($3_1 >>> 0 < 256 >>> 0) {
                                  break label$28;
                                }
                                $6_1 = 31;
                                if ($3_1 >>> 0 > 16777215 >>> 0) {
                                  break label$28;
                                }
                                $0_1 = Math_clz32($0_1 >>> 8 | 0);
                                $6_1 = ((($3_1 >>> (38 - $0_1 | 0) | 0) & 1 | 0) - ($0_1 << 1 | 0) | 0) + 62 | 0;
                              }
                              $4_1 = 0 - $3_1 | 0;
                              label$29: {
                                label$30: {
                                  label$31: {
                                    label$32: {
                                      $5_1 = HEAP32[(($6_1 << 2 | 0) + 99936 | 0) >> 2] | 0;
                                      if ($5_1) {
                                        break label$32;
                                      }
                                      $0_1 = 0;
                                      $8_1 = 0;
                                      break label$31;
                                    }
                                    $0_1 = 0;
                                    $7_1 = $3_1 << (($6_1 | 0) == (31 | 0) ? 0 : 25 - ($6_1 >>> 1 | 0) | 0) | 0;
                                    $8_1 = 0;
                                    label$33: while (1) {
                                      label$34: {
                                        $2_1 = ((HEAP32[($5_1 + 4 | 0) >> 2] | 0) & -8 | 0) - $3_1 | 0;
                                        if ($2_1 >>> 0 >= $4_1 >>> 0) {
                                          break label$34;
                                        }
                                        $4_1 = $2_1;
                                        $8_1 = $5_1;
                                        if ($4_1) {
                                          break label$34;
                                        }
                                        $4_1 = 0;
                                        $8_1 = $5_1;
                                        $0_1 = $5_1;
                                        break label$30;
                                      }
                                      $2_1 = HEAP32[($5_1 + 20 | 0) >> 2] | 0;
                                      $11_1 = HEAP32[(($5_1 + (($7_1 >>> 29 | 0) & 4 | 0) | 0) + 16 | 0) >> 2] | 0;
                                      $0_1 = $2_1 ? ($2_1 | 0) == ($11_1 | 0) ? $0_1 : $2_1 : $0_1;
                                      $7_1 = $7_1 << 1 | 0;
                                      $5_1 = $11_1;
                                      if ($5_1) {
                                        continue label$33;
                                      }
                                      break label$33;
                                    };
                                  }
                                  label$35: {
                                    if ($0_1 | $8_1 | 0) {
                                      break label$35;
                                    }
                                    $8_1 = 0;
                                    $0_1 = 2 << $6_1 | 0;
                                    $0_1 = ($0_1 | (0 - $0_1 | 0) | 0) & $10_1 | 0;
                                    if (!$0_1) {
                                      break label$10;
                                    }
                                    $0_1 = HEAP32[(((__wasm_ctz_i32($0_1 | 0) | 0) << 2 | 0) + 99936 | 0) >> 2] | 0;
                                  }
                                  if (!$0_1) {
                                    break label$29;
                                  }
                                }
                                label$36: while (1) {
                                  $2_1 = ((HEAP32[($0_1 + 4 | 0) >> 2] | 0) & -8 | 0) - $3_1 | 0;
                                  $7_1 = $2_1 >>> 0 < $4_1 >>> 0;
                                  label$37: {
                                    $5_1 = HEAP32[($0_1 + 16 | 0) >> 2] | 0;
                                    if ($5_1) {
                                      break label$37;
                                    }
                                    $5_1 = HEAP32[($0_1 + 20 | 0) >> 2] | 0;
                                  }
                                  $4_1 = $7_1 ? $2_1 : $4_1;
                                  $8_1 = $7_1 ? $0_1 : $8_1;
                                  $0_1 = $5_1;
                                  if ($0_1) {
                                    continue label$36;
                                  }
                                  break label$36;
                                };
                              }
                              if (!$8_1) {
                                break label$10;
                              }
                              if ($4_1 >>> 0 >= ((HEAP32[(0 + 99640 | 0) >> 2] | 0) - $3_1 | 0) >>> 0) {
                                break label$10;
                              }
                              $11_1 = HEAP32[($8_1 + 24 | 0) >> 2] | 0;
                              label$38: {
                                $0_1 = HEAP32[($8_1 + 12 | 0) >> 2] | 0;
                                if (($0_1 | 0) == ($8_1 | 0)) {
                                  break label$38;
                                }
                                $5_1 = HEAP32[($8_1 + 8 | 0) >> 2] | 0;
                                HEAP32[(0 + 99648 | 0) >> 2] | 0;
                                HEAP32[($5_1 + 12 | 0) >> 2] = $0_1;
                                HEAP32[($0_1 + 8 | 0) >> 2] = $5_1;
                                break label$3;
                              }
                              label$39: {
                                label$40: {
                                  $5_1 = HEAP32[($8_1 + 20 | 0) >> 2] | 0;
                                  if (!$5_1) {
                                    break label$40;
                                  }
                                  $7_1 = $8_1 + 20 | 0;
                                  break label$39;
                                }
                                $5_1 = HEAP32[($8_1 + 16 | 0) >> 2] | 0;
                                if (!$5_1) {
                                  break label$8;
                                }
                                $7_1 = $8_1 + 16 | 0;
                              }
                              label$41: while (1) {
                                $2_1 = $7_1;
                                $0_1 = $5_1;
                                $7_1 = $0_1 + 20 | 0;
                                $5_1 = HEAP32[($0_1 + 20 | 0) >> 2] | 0;
                                if ($5_1) {
                                  continue label$41;
                                }
                                $7_1 = $0_1 + 16 | 0;
                                $5_1 = HEAP32[($0_1 + 16 | 0) >> 2] | 0;
                                if ($5_1) {
                                  continue label$41;
                                }
                                break label$41;
                              };
                              HEAP32[$2_1 >> 2] = 0;
                              break label$3;
                            }
                            label$42: {
                              $0_1 = HEAP32[(0 + 99640 | 0) >> 2] | 0;
                              if ($0_1 >>> 0 < $3_1 >>> 0) {
                                break label$42;
                              }
                              $4_1 = HEAP32[(0 + 99652 | 0) >> 2] | 0;
                              label$43: {
                                label$44: {
                                  $5_1 = $0_1 - $3_1 | 0;
                                  if ($5_1 >>> 0 < 16 >>> 0) {
                                    break label$44;
                                  }
                                  $7_1 = $4_1 + $3_1 | 0;
                                  HEAP32[($7_1 + 4 | 0) >> 2] = $5_1 | 1 | 0;
                                  HEAP32[($4_1 + $0_1 | 0) >> 2] = $5_1;
                                  HEAP32[($4_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;
                                  break label$43;
                                }
                                HEAP32[($4_1 + 4 | 0) >> 2] = $0_1 | 3 | 0;
                                $0_1 = $4_1 + $0_1 | 0;
                                HEAP32[($0_1 + 4 | 0) >> 2] = HEAP32[($0_1 + 4 | 0) >> 2] | 0 | 1 | 0;
                                $7_1 = 0;
                                $5_1 = 0;
                              }
                              HEAP32[(0 + 99640 | 0) >> 2] = $5_1;
                              HEAP32[(0 + 99652 | 0) >> 2] = $7_1;
                              $0_1 = $4_1 + 8 | 0;
                              break label$1;
                            }
                            label$45: {
                              $7_1 = HEAP32[(0 + 99644 | 0) >> 2] | 0;
                              if ($7_1 >>> 0 <= $3_1 >>> 0) {
                                break label$45;
                              }
                              $4_1 = $7_1 - $3_1 | 0;
                              HEAP32[(0 + 99644 | 0) >> 2] = $4_1;
                              $0_1 = HEAP32[(0 + 99656 | 0) >> 2] | 0;
                              $5_1 = $0_1 + $3_1 | 0;
                              HEAP32[(0 + 99656 | 0) >> 2] = $5_1;
                              HEAP32[($5_1 + 4 | 0) >> 2] = $4_1 | 1 | 0;
                              HEAP32[($0_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;
                              $0_1 = $0_1 + 8 | 0;
                              break label$1;
                            }
                            label$46: {
                              label$47: {
                                if (!(HEAP32[(0 + 100104 | 0) >> 2] | 0)) {
                                  break label$47;
                                }
                                $4_1 = HEAP32[(0 + 100112 | 0) >> 2] | 0;
                                break label$46;
                              }
                              i64toi32_i32$1 = 0;
                              i64toi32_i32$0 = -1;
                              HEAP32[(i64toi32_i32$1 + 100116 | 0) >> 2] = -1;
                              HEAP32[(i64toi32_i32$1 + 100120 | 0) >> 2] = i64toi32_i32$0;
                              i64toi32_i32$1 = 0;
                              i64toi32_i32$0 = 4096;
                              HEAP32[(i64toi32_i32$1 + 100108 | 0) >> 2] = 4096;
                              HEAP32[(i64toi32_i32$1 + 100112 | 0) >> 2] = i64toi32_i32$0;
                              HEAP32[(0 + 100104 | 0) >> 2] = (($1_1 + 12 | 0) & -16 | 0) ^ 1431655768 | 0;
                              HEAP32[(0 + 100124 | 0) >> 2] = 0;
                              HEAP32[(0 + 100076 | 0) >> 2] = 0;
                              $4_1 = 4096;
                            }
                            $0_1 = 0;
                            $6_1 = $3_1 + 47 | 0;
                            $2_1 = $4_1 + $6_1 | 0;
                            $11_1 = 0 - $4_1 | 0;
                            $8_1 = $2_1 & $11_1 | 0;
                            if ($8_1 >>> 0 <= $3_1 >>> 0) {
                              break label$1;
                            }
                            $0_1 = 0;
                            label$48: {
                              $4_1 = HEAP32[(0 + 100072 | 0) >> 2] | 0;
                              if (!$4_1) {
                                break label$48;
                              }
                              $5_1 = HEAP32[(0 + 100064 | 0) >> 2] | 0;
                              $10_1 = $5_1 + $8_1 | 0;
                              if ($10_1 >>> 0 <= $5_1 >>> 0) {
                                break label$1;
                              }
                              if ($10_1 >>> 0 > $4_1 >>> 0) {
                                break label$1;
                              }
                            }
                            label$49: {
                              label$50: {
                                if ((HEAPU8[(0 + 100076 | 0) >> 0] | 0) & 4 | 0) {
                                  break label$50;
                                }
                                label$51: {
                                  label$52: {
                                    label$53: {
                                      label$54: {
                                        label$55: {
                                          $4_1 = HEAP32[(0 + 99656 | 0) >> 2] | 0;
                                          if (!$4_1) {
                                            break label$55;
                                          }
                                          $0_1 = 100080;
                                          label$56: while (1) {
                                            label$57: {
                                              $5_1 = HEAP32[$0_1 >> 2] | 0;
                                              if ($5_1 >>> 0 > $4_1 >>> 0) {
                                                break label$57;
                                              }
                                              if (($5_1 + (HEAP32[($0_1 + 4 | 0) >> 2] | 0) | 0) >>> 0 > $4_1 >>> 0) {
                                                break label$54;
                                              }
                                            }
                                            $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
                                            if ($0_1) {
                                              continue label$56;
                                            }
                                            break label$56;
                                          };
                                        }
                                        $7_1 = $78(0 | 0) | 0;
                                        if (($7_1 | 0) == (-1 | 0)) {
                                          break label$51;
                                        }
                                        $2_1 = $8_1;
                                        label$58: {
                                          $0_1 = HEAP32[(0 + 100108 | 0) >> 2] | 0;
                                          $4_1 = $0_1 + -1 | 0;
                                          if (!($4_1 & $7_1 | 0)) {
                                            break label$58;
                                          }
                                          $2_1 = ($8_1 - $7_1 | 0) + (($4_1 + $7_1 | 0) & (0 - $0_1 | 0) | 0) | 0;
                                        }
                                        if ($2_1 >>> 0 <= $3_1 >>> 0) {
                                          break label$51;
                                        }
                                        label$59: {
                                          $0_1 = HEAP32[(0 + 100072 | 0) >> 2] | 0;
                                          if (!$0_1) {
                                            break label$59;
                                          }
                                          $4_1 = HEAP32[(0 + 100064 | 0) >> 2] | 0;
                                          $5_1 = $4_1 + $2_1 | 0;
                                          if ($5_1 >>> 0 <= $4_1 >>> 0) {
                                            break label$51;
                                          }
                                          if ($5_1 >>> 0 > $0_1 >>> 0) {
                                            break label$51;
                                          }
                                        }
                                        $0_1 = $78($2_1 | 0) | 0;
                                        if (($0_1 | 0) != ($7_1 | 0)) {
                                          break label$53;
                                        }
                                        break label$49;
                                      }
                                      $2_1 = ($2_1 - $7_1 | 0) & $11_1 | 0;
                                      $7_1 = $78($2_1 | 0) | 0;
                                      if (($7_1 | 0) == ((HEAP32[$0_1 >> 2] | 0) + (HEAP32[($0_1 + 4 | 0) >> 2] | 0) | 0 | 0)) {
                                        break label$52;
                                      }
                                      $0_1 = $7_1;
                                    }
                                    if (($0_1 | 0) == (-1 | 0)) {
                                      break label$51;
                                    }
                                    label$60: {
                                      if ($2_1 >>> 0 < ($3_1 + 48 | 0) >>> 0) {
                                        break label$60;
                                      }
                                      $7_1 = $0_1;
                                      break label$49;
                                    }
                                    $4_1 = HEAP32[(0 + 100112 | 0) >> 2] | 0;
                                    $4_1 = (($6_1 - $2_1 | 0) + $4_1 | 0) & (0 - $4_1 | 0) | 0;
                                    if (($78($4_1 | 0) | 0 | 0) == (-1 | 0)) {
                                      break label$51;
                                    }
                                    $2_1 = $4_1 + $2_1 | 0;
                                    $7_1 = $0_1;
                                    break label$49;
                                  }
                                  if (($7_1 | 0) != (-1 | 0)) {
                                    break label$49;
                                  }
                                }
                                HEAP32[(0 + 100076 | 0) >> 2] = HEAP32[(0 + 100076 | 0) >> 2] | 0 | 4 | 0;
                              }
                              $7_1 = $78($8_1 | 0) | 0;
                              $0_1 = $78(0 | 0) | 0;
                              if (($7_1 | 0) == (-1 | 0)) {
                                break label$5;
                              }
                              if (($0_1 | 0) == (-1 | 0)) {
                                break label$5;
                              }
                              if ($7_1 >>> 0 >= $0_1 >>> 0) {
                                break label$5;
                              }
                              $2_1 = $0_1 - $7_1 | 0;
                              if ($2_1 >>> 0 <= ($3_1 + 40 | 0) >>> 0) {
                                break label$5;
                              }
                            }
                            $0_1 = (HEAP32[(0 + 100064 | 0) >> 2] | 0) + $2_1 | 0;
                            HEAP32[(0 + 100064 | 0) >> 2] = $0_1;
                            label$61: {
                              if ($0_1 >>> 0 <= (HEAP32[(0 + 100068 | 0) >> 2] | 0) >>> 0) {
                                break label$61;
                              }
                              HEAP32[(0 + 100068 | 0) >> 2] = $0_1;
                            }
                            label$62: {
                              label$63: {
                                $4_1 = HEAP32[(0 + 99656 | 0) >> 2] | 0;
                                if (!$4_1) {
                                  break label$63;
                                }
                                $0_1 = 100080;
                                label$64: while (1) {
                                  $5_1 = HEAP32[$0_1 >> 2] | 0;
                                  $8_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                                  if (($7_1 | 0) == ($5_1 + $8_1 | 0 | 0)) {
                                    break label$62;
                                  }
                                  $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
                                  if ($0_1) {
                                    continue label$64;
                                  }
                                  break label$7;
                                };
                              }
                              label$65: {
                                label$66: {
                                  $0_1 = HEAP32[(0 + 99648 | 0) >> 2] | 0;
                                  if (!$0_1) {
                                    break label$66;
                                  }
                                  if ($7_1 >>> 0 >= $0_1 >>> 0) {
                                    break label$65;
                                  }
                                }
                                HEAP32[(0 + 99648 | 0) >> 2] = $7_1;
                              }
                              $0_1 = 0;
                              HEAP32[(0 + 100084 | 0) >> 2] = $2_1;
                              HEAP32[(0 + 100080 | 0) >> 2] = $7_1;
                              HEAP32[(0 + 99664 | 0) >> 2] = -1;
                              HEAP32[(0 + 99668 | 0) >> 2] = HEAP32[(0 + 100104 | 0) >> 2] | 0;
                              HEAP32[(0 + 100092 | 0) >> 2] = 0;
                              label$67: while (1) {
                                $4_1 = $0_1 << 3 | 0;
                                $5_1 = $4_1 + 99672 | 0;
                                HEAP32[($4_1 + 99680 | 0) >> 2] = $5_1;
                                HEAP32[($4_1 + 99684 | 0) >> 2] = $5_1;
                                $0_1 = $0_1 + 1 | 0;
                                if (($0_1 | 0) != (32 | 0)) {
                                  continue label$67;
                                }
                                break label$67;
                              };
                              $0_1 = $2_1 + -40 | 0;
                              $4_1 = (-8 - $7_1 | 0) & 7 | 0;
                              $5_1 = $0_1 - $4_1 | 0;
                              HEAP32[(0 + 99644 | 0) >> 2] = $5_1;
                              $4_1 = $7_1 + $4_1 | 0;
                              HEAP32[(0 + 99656 | 0) >> 2] = $4_1;
                              HEAP32[($4_1 + 4 | 0) >> 2] = $5_1 | 1 | 0;
                              HEAP32[(($7_1 + $0_1 | 0) + 4 | 0) >> 2] = 40;
                              HEAP32[(0 + 99660 | 0) >> 2] = HEAP32[(0 + 100120 | 0) >> 2] | 0;
                              break label$6;
                            }
                            if ($4_1 >>> 0 >= $7_1 >>> 0) {
                              break label$7;
                            }
                            if ($4_1 >>> 0 < $5_1 >>> 0) {
                              break label$7;
                            }
                            if ((HEAP32[($0_1 + 12 | 0) >> 2] | 0) & 8 | 0) {
                              break label$7;
                            }
                            HEAP32[($0_1 + 4 | 0) >> 2] = $8_1 + $2_1 | 0;
                            $0_1 = (-8 - $4_1 | 0) & 7 | 0;
                            $5_1 = $4_1 + $0_1 | 0;
                            HEAP32[(0 + 99656 | 0) >> 2] = $5_1;
                            $7_1 = (HEAP32[(0 + 99644 | 0) >> 2] | 0) + $2_1 | 0;
                            $0_1 = $7_1 - $0_1 | 0;
                            HEAP32[(0 + 99644 | 0) >> 2] = $0_1;
                            HEAP32[($5_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;
                            HEAP32[(($4_1 + $7_1 | 0) + 4 | 0) >> 2] = 40;
                            HEAP32[(0 + 99660 | 0) >> 2] = HEAP32[(0 + 100120 | 0) >> 2] | 0;
                            break label$6;
                          }
                          $0_1 = 0;
                          break label$2;
                        }
                        $0_1 = 0;
                        break label$3;
                      }
                      label$68: {
                        if ($7_1 >>> 0 >= (HEAP32[(0 + 99648 | 0) >> 2] | 0) >>> 0) {
                          break label$68;
                        }
                        HEAP32[(0 + 99648 | 0) >> 2] = $7_1;
                      }
                      $5_1 = $7_1 + $2_1 | 0;
                      $0_1 = 100080;
                      label$69: {
                        label$70: {
                          label$71: while (1) {
                            if ((HEAP32[$0_1 >> 2] | 0 | 0) == ($5_1 | 0)) {
                              break label$70;
                            }
                            $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
                            if ($0_1) {
                              continue label$71;
                            }
                            break label$69;
                          };
                        }
                        if (!((HEAPU8[($0_1 + 12 | 0) >> 0] | 0) & 8 | 0)) {
                          break label$4;
                        }
                      }
                      $0_1 = 100080;
                      label$72: {
                        label$73: while (1) {
                          label$74: {
                            $5_1 = HEAP32[$0_1 >> 2] | 0;
                            if ($5_1 >>> 0 > $4_1 >>> 0) {
                              break label$74;
                            }
                            $5_1 = $5_1 + (HEAP32[($0_1 + 4 | 0) >> 2] | 0) | 0;
                            if ($5_1 >>> 0 > $4_1 >>> 0) {
                              break label$72;
                            }
                          }
                          $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
                          continue label$73;
                        };
                      }
                      $0_1 = $2_1 + -40 | 0;
                      $8_1 = (-8 - $7_1 | 0) & 7 | 0;
                      $11_1 = $0_1 - $8_1 | 0;
                      HEAP32[(0 + 99644 | 0) >> 2] = $11_1;
                      $8_1 = $7_1 + $8_1 | 0;
                      HEAP32[(0 + 99656 | 0) >> 2] = $8_1;
                      HEAP32[($8_1 + 4 | 0) >> 2] = $11_1 | 1 | 0;
                      HEAP32[(($7_1 + $0_1 | 0) + 4 | 0) >> 2] = 40;
                      HEAP32[(0 + 99660 | 0) >> 2] = HEAP32[(0 + 100120 | 0) >> 2] | 0;
                      $0_1 = ($5_1 + ((39 - $5_1 | 0) & 7 | 0) | 0) + -47 | 0;
                      $8_1 = $0_1 >>> 0 < ($4_1 + 16 | 0) >>> 0 ? $4_1 : $0_1;
                      HEAP32[($8_1 + 4 | 0) >> 2] = 27;
                      i64toi32_i32$2 = 0;
                      i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 100088 | 0) >> 2] | 0;
                      i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 100092 | 0) >> 2] | 0;
                      $782 = i64toi32_i32$0;
                      i64toi32_i32$0 = $8_1 + 16 | 0;
                      HEAP32[i64toi32_i32$0 >> 2] = $782;
                      HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;
                      i64toi32_i32$2 = 0;
                      i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 100080 | 0) >> 2] | 0;
                      i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 100084 | 0) >> 2] | 0;
                      $784 = i64toi32_i32$1;
                      i64toi32_i32$1 = $8_1;
                      HEAP32[($8_1 + 8 | 0) >> 2] = $784;
                      HEAP32[($8_1 + 12 | 0) >> 2] = i64toi32_i32$0;
                      HEAP32[(0 + 100088 | 0) >> 2] = $8_1 + 8 | 0;
                      HEAP32[(0 + 100084 | 0) >> 2] = $2_1;
                      HEAP32[(0 + 100080 | 0) >> 2] = $7_1;
                      HEAP32[(0 + 100092 | 0) >> 2] = 0;
                      $0_1 = $8_1 + 24 | 0;
                      label$75: while (1) {
                        HEAP32[($0_1 + 4 | 0) >> 2] = 7;
                        $7_1 = $0_1 + 8 | 0;
                        $0_1 = $0_1 + 4 | 0;
                        if ($7_1 >>> 0 < $5_1 >>> 0) {
                          continue label$75;
                        }
                        break label$75;
                      };
                      if (($8_1 | 0) == ($4_1 | 0)) {
                        break label$6;
                      }
                      HEAP32[($8_1 + 4 | 0) >> 2] = (HEAP32[($8_1 + 4 | 0) >> 2] | 0) & -2 | 0;
                      $7_1 = $8_1 - $4_1 | 0;
                      HEAP32[($4_1 + 4 | 0) >> 2] = $7_1 | 1 | 0;
                      HEAP32[$8_1 >> 2] = $7_1;
                      label$76: {
                        label$77: {
                          if ($7_1 >>> 0 > 255 >>> 0) {
                            break label$77;
                          }
                          $0_1 = ($7_1 & -8 | 0) + 99672 | 0;
                          label$78: {
                            label$79: {
                              $5_1 = HEAP32[(0 + 99632 | 0) >> 2] | 0;
                              $7_1 = 1 << ($7_1 >>> 3 | 0) | 0;
                              if ($5_1 & $7_1 | 0) {
                                break label$79;
                              }
                              HEAP32[(0 + 99632 | 0) >> 2] = $5_1 | $7_1 | 0;
                              $5_1 = $0_1;
                              break label$78;
                            }
                            $5_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
                          }
                          HEAP32[($0_1 + 8 | 0) >> 2] = $4_1;
                          HEAP32[($5_1 + 12 | 0) >> 2] = $4_1;
                          $7_1 = 12;
                          $8_1 = 8;
                          break label$76;
                        }
                        $0_1 = 31;
                        label$80: {
                          if ($7_1 >>> 0 > 16777215 >>> 0) {
                            break label$80;
                          }
                          $0_1 = Math_clz32($7_1 >>> 8 | 0);
                          $0_1 = ((($7_1 >>> (38 - $0_1 | 0) | 0) & 1 | 0) - ($0_1 << 1 | 0) | 0) + 62 | 0;
                        }
                        HEAP32[($4_1 + 28 | 0) >> 2] = $0_1;
                        i64toi32_i32$1 = $4_1;
                        i64toi32_i32$0 = 0;
                        HEAP32[($4_1 + 16 | 0) >> 2] = 0;
                        HEAP32[($4_1 + 20 | 0) >> 2] = i64toi32_i32$0;
                        $5_1 = ($0_1 << 2 | 0) + 99936 | 0;
                        label$81: {
                          label$82: {
                            label$83: {
                              $8_1 = HEAP32[(0 + 99636 | 0) >> 2] | 0;
                              $2_1 = 1 << $0_1 | 0;
                              if ($8_1 & $2_1 | 0) {
                                break label$83;
                              }
                              HEAP32[(0 + 99636 | 0) >> 2] = $8_1 | $2_1 | 0;
                              HEAP32[$5_1 >> 2] = $4_1;
                              HEAP32[($4_1 + 24 | 0) >> 2] = $5_1;
                              break label$82;
                            }
                            $0_1 = $7_1 << (($0_1 | 0) == (31 | 0) ? 0 : 25 - ($0_1 >>> 1 | 0) | 0) | 0;
                            $8_1 = HEAP32[$5_1 >> 2] | 0;
                            label$84: while (1) {
                              $5_1 = $8_1;
                              if (((HEAP32[($5_1 + 4 | 0) >> 2] | 0) & -8 | 0 | 0) == ($7_1 | 0)) {
                                break label$81;
                              }
                              $8_1 = $0_1 >>> 29 | 0;
                              $0_1 = $0_1 << 1 | 0;
                              $2_1 = ($5_1 + ($8_1 & 4 | 0) | 0) + 16 | 0;
                              $8_1 = HEAP32[$2_1 >> 2] | 0;
                              if ($8_1) {
                                continue label$84;
                              }
                              break label$84;
                            };
                            HEAP32[$2_1 >> 2] = $4_1;
                            HEAP32[($4_1 + 24 | 0) >> 2] = $5_1;
                          }
                          $7_1 = 8;
                          $8_1 = 12;
                          $5_1 = $4_1;
                          $0_1 = $4_1;
                          break label$76;
                        }
                        $0_1 = HEAP32[($5_1 + 8 | 0) >> 2] | 0;
                        HEAP32[($0_1 + 12 | 0) >> 2] = $4_1;
                        HEAP32[($5_1 + 8 | 0) >> 2] = $4_1;
                        HEAP32[($4_1 + 8 | 0) >> 2] = $0_1;
                        $0_1 = 0;
                        $7_1 = 24;
                        $8_1 = 12;
                      }
                      HEAP32[($4_1 + $8_1 | 0) >> 2] = $5_1;
                      HEAP32[($4_1 + $7_1 | 0) >> 2] = $0_1;
                    }
                    $0_1 = HEAP32[(0 + 99644 | 0) >> 2] | 0;
                    if ($0_1 >>> 0 <= $3_1 >>> 0) {
                      break label$5;
                    }
                    $4_1 = $0_1 - $3_1 | 0;
                    HEAP32[(0 + 99644 | 0) >> 2] = $4_1;
                    $0_1 = HEAP32[(0 + 99656 | 0) >> 2] | 0;
                    $5_1 = $0_1 + $3_1 | 0;
                    HEAP32[(0 + 99656 | 0) >> 2] = $5_1;
                    HEAP32[($5_1 + 4 | 0) >> 2] = $4_1 | 1 | 0;
                    HEAP32[($0_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;
                    $0_1 = $0_1 + 8 | 0;
                    break label$1;
                  }
                  (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 48), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
                  $0_1 = 0;
                  break label$1;
                }
                HEAP32[$0_1 >> 2] = $7_1;
                HEAP32[($0_1 + 4 | 0) >> 2] = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) + $2_1 | 0;
                $0_1 = $80($7_1 | 0, $5_1 | 0, $3_1 | 0) | 0;
                break label$1;
              }
              label$85: {
                if (!$11_1) {
                  break label$85;
                }
                label$86: {
                  label$87: {
                    $7_1 = HEAP32[($8_1 + 28 | 0) >> 2] | 0;
                    $5_1 = ($7_1 << 2 | 0) + 99936 | 0;
                    if (($8_1 | 0) != (HEAP32[$5_1 >> 2] | 0 | 0)) {
                      break label$87;
                    }
                    HEAP32[$5_1 >> 2] = $0_1;
                    if ($0_1) {
                      break label$86;
                    }
                    $10_1 = $10_1 & (__wasm_rotl_i32(-2 | 0, $7_1 | 0) | 0) | 0;
                    HEAP32[(0 + 99636 | 0) >> 2] = $10_1;
                    break label$85;
                  }
                  HEAP32[($11_1 + ((HEAP32[($11_1 + 16 | 0) >> 2] | 0 | 0) == ($8_1 | 0) ? 16 : 20) | 0) >> 2] = $0_1;
                  if (!$0_1) {
                    break label$85;
                  }
                }
                HEAP32[($0_1 + 24 | 0) >> 2] = $11_1;
                label$88: {
                  $5_1 = HEAP32[($8_1 + 16 | 0) >> 2] | 0;
                  if (!$5_1) {
                    break label$88;
                  }
                  HEAP32[($0_1 + 16 | 0) >> 2] = $5_1;
                  HEAP32[($5_1 + 24 | 0) >> 2] = $0_1;
                }
                $5_1 = HEAP32[($8_1 + 20 | 0) >> 2] | 0;
                if (!$5_1) {
                  break label$85;
                }
                HEAP32[($0_1 + 20 | 0) >> 2] = $5_1;
                HEAP32[($5_1 + 24 | 0) >> 2] = $0_1;
              }
              label$89: {
                label$90: {
                  if ($4_1 >>> 0 > 15 >>> 0) {
                    break label$90;
                  }
                  $0_1 = $4_1 + $3_1 | 0;
                  HEAP32[($8_1 + 4 | 0) >> 2] = $0_1 | 3 | 0;
                  $0_1 = $8_1 + $0_1 | 0;
                  HEAP32[($0_1 + 4 | 0) >> 2] = HEAP32[($0_1 + 4 | 0) >> 2] | 0 | 1 | 0;
                  break label$89;
                }
                HEAP32[($8_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;
                $7_1 = $8_1 + $3_1 | 0;
                HEAP32[($7_1 + 4 | 0) >> 2] = $4_1 | 1 | 0;
                HEAP32[($7_1 + $4_1 | 0) >> 2] = $4_1;
                label$91: {
                  if ($4_1 >>> 0 > 255 >>> 0) {
                    break label$91;
                  }
                  $0_1 = ($4_1 & -8 | 0) + 99672 | 0;
                  label$92: {
                    label$93: {
                      $3_1 = HEAP32[(0 + 99632 | 0) >> 2] | 0;
                      $4_1 = 1 << ($4_1 >>> 3 | 0) | 0;
                      if ($3_1 & $4_1 | 0) {
                        break label$93;
                      }
                      HEAP32[(0 + 99632 | 0) >> 2] = $3_1 | $4_1 | 0;
                      $4_1 = $0_1;
                      break label$92;
                    }
                    $4_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
                  }
                  HEAP32[($0_1 + 8 | 0) >> 2] = $7_1;
                  HEAP32[($4_1 + 12 | 0) >> 2] = $7_1;
                  HEAP32[($7_1 + 12 | 0) >> 2] = $0_1;
                  HEAP32[($7_1 + 8 | 0) >> 2] = $4_1;
                  break label$89;
                }
                $0_1 = 31;
                label$94: {
                  if ($4_1 >>> 0 > 16777215 >>> 0) {
                    break label$94;
                  }
                  $0_1 = Math_clz32($4_1 >>> 8 | 0);
                  $0_1 = ((($4_1 >>> (38 - $0_1 | 0) | 0) & 1 | 0) - ($0_1 << 1 | 0) | 0) + 62 | 0;
                }
                HEAP32[($7_1 + 28 | 0) >> 2] = $0_1;
                i64toi32_i32$1 = $7_1;
                i64toi32_i32$0 = 0;
                HEAP32[($7_1 + 16 | 0) >> 2] = 0;
                HEAP32[($7_1 + 20 | 0) >> 2] = i64toi32_i32$0;
                $3_1 = ($0_1 << 2 | 0) + 99936 | 0;
                label$95: {
                  label$96: {
                    label$97: {
                      $5_1 = 1 << $0_1 | 0;
                      if ($10_1 & $5_1 | 0) {
                        break label$97;
                      }
                      HEAP32[(0 + 99636 | 0) >> 2] = $10_1 | $5_1 | 0;
                      HEAP32[$3_1 >> 2] = $7_1;
                      HEAP32[($7_1 + 24 | 0) >> 2] = $3_1;
                      break label$96;
                    }
                    $0_1 = $4_1 << (($0_1 | 0) == (31 | 0) ? 0 : 25 - ($0_1 >>> 1 | 0) | 0) | 0;
                    $5_1 = HEAP32[$3_1 >> 2] | 0;
                    label$98: while (1) {
                      $3_1 = $5_1;
                      if (((HEAP32[($5_1 + 4 | 0) >> 2] | 0) & -8 | 0 | 0) == ($4_1 | 0)) {
                        break label$95;
                      }
                      $5_1 = $0_1 >>> 29 | 0;
                      $0_1 = $0_1 << 1 | 0;
                      $2_1 = ($3_1 + ($5_1 & 4 | 0) | 0) + 16 | 0;
                      $5_1 = HEAP32[$2_1 >> 2] | 0;
                      if ($5_1) {
                        continue label$98;
                      }
                      break label$98;
                    };
                    HEAP32[$2_1 >> 2] = $7_1;
                    HEAP32[($7_1 + 24 | 0) >> 2] = $3_1;
                  }
                  HEAP32[($7_1 + 12 | 0) >> 2] = $7_1;
                  HEAP32[($7_1 + 8 | 0) >> 2] = $7_1;
                  break label$89;
                }
                $0_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;
                HEAP32[($0_1 + 12 | 0) >> 2] = $7_1;
                HEAP32[($3_1 + 8 | 0) >> 2] = $7_1;
                HEAP32[($7_1 + 24 | 0) >> 2] = 0;
                HEAP32[($7_1 + 12 | 0) >> 2] = $3_1;
                HEAP32[($7_1 + 8 | 0) >> 2] = $0_1;
              }
              $0_1 = $8_1 + 8 | 0;
              break label$1;
            }
            label$99: {
              if (!$10_1) {
                break label$99;
              }
              label$100: {
                label$101: {
                  $8_1 = HEAP32[($7_1 + 28 | 0) >> 2] | 0;
                  $5_1 = ($8_1 << 2 | 0) + 99936 | 0;
                  if (($7_1 | 0) != (HEAP32[$5_1 >> 2] | 0 | 0)) {
                    break label$101;
                  }
                  HEAP32[$5_1 >> 2] = $0_1;
                  if ($0_1) {
                    break label$100;
                  }
                  (wasm2js_i32$0 = 0, wasm2js_i32$1 = $9_1 & (__wasm_rotl_i32(-2 | 0, $8_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99636 | 0) >> 2] = wasm2js_i32$1;
                  break label$99;
                }
                HEAP32[($10_1 + ((HEAP32[($10_1 + 16 | 0) >> 2] | 0 | 0) == ($7_1 | 0) ? 16 : 20) | 0) >> 2] = $0_1;
                if (!$0_1) {
                  break label$99;
                }
              }
              HEAP32[($0_1 + 24 | 0) >> 2] = $10_1;
              label$102: {
                $5_1 = HEAP32[($7_1 + 16 | 0) >> 2] | 0;
                if (!$5_1) {
                  break label$102;
                }
                HEAP32[($0_1 + 16 | 0) >> 2] = $5_1;
                HEAP32[($5_1 + 24 | 0) >> 2] = $0_1;
              }
              $5_1 = HEAP32[($7_1 + 20 | 0) >> 2] | 0;
              if (!$5_1) {
                break label$99;
              }
              HEAP32[($0_1 + 20 | 0) >> 2] = $5_1;
              HEAP32[($5_1 + 24 | 0) >> 2] = $0_1;
            }
            label$103: {
              label$104: {
                if ($4_1 >>> 0 > 15 >>> 0) {
                  break label$104;
                }
                $0_1 = $4_1 + $3_1 | 0;
                HEAP32[($7_1 + 4 | 0) >> 2] = $0_1 | 3 | 0;
                $0_1 = $7_1 + $0_1 | 0;
                HEAP32[($0_1 + 4 | 0) >> 2] = HEAP32[($0_1 + 4 | 0) >> 2] | 0 | 1 | 0;
                break label$103;
              }
              HEAP32[($7_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;
              $3_1 = $7_1 + $3_1 | 0;
              HEAP32[($3_1 + 4 | 0) >> 2] = $4_1 | 1 | 0;
              HEAP32[($3_1 + $4_1 | 0) >> 2] = $4_1;
              label$105: {
                if (!$6_1) {
                  break label$105;
                }
                $5_1 = ($6_1 & -8 | 0) + 99672 | 0;
                $0_1 = HEAP32[(0 + 99652 | 0) >> 2] | 0;
                label$106: {
                  label$107: {
                    $8_1 = 1 << ($6_1 >>> 3 | 0) | 0;
                    if ($8_1 & $2_1 | 0) {
                      break label$107;
                    }
                    HEAP32[(0 + 99632 | 0) >> 2] = $8_1 | $2_1 | 0;
                    $8_1 = $5_1;
                    break label$106;
                  }
                  $8_1 = HEAP32[($5_1 + 8 | 0) >> 2] | 0;
                }
                HEAP32[($5_1 + 8 | 0) >> 2] = $0_1;
                HEAP32[($8_1 + 12 | 0) >> 2] = $0_1;
                HEAP32[($0_1 + 12 | 0) >> 2] = $5_1;
                HEAP32[($0_1 + 8 | 0) >> 2] = $8_1;
              }
              HEAP32[(0 + 99652 | 0) >> 2] = $3_1;
              HEAP32[(0 + 99640 | 0) >> 2] = $4_1;
            }
            $0_1 = $7_1 + 8 | 0;
          }
          global$0 = $1_1 + 16 | 0;
          return $0_1 | 0;
        }

        function $80($0_1, $1_1, $2_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $2_1 = $2_1 | 0;
          var $4_1 = 0,$5_1 = 0,$7_1 = 0,$8_1 = 0,$9_1 = 0,$3_1 = 0,$6_1 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $3_1 = $0_1 + ((-8 - $0_1 | 0) & 7 | 0) | 0;
          HEAP32[($3_1 + 4 | 0) >> 2] = $2_1 | 3 | 0;
          $4_1 = $1_1 + ((-8 - $1_1 | 0) & 7 | 0) | 0;
          $5_1 = $3_1 + $2_1 | 0;
          $0_1 = $4_1 - $5_1 | 0;
          label$1: {
            label$2: {
              if (($4_1 | 0) != (HEAP32[(0 + 99656 | 0) >> 2] | 0 | 0)) {
                break label$2;
              }
              HEAP32[(0 + 99656 | 0) >> 2] = $5_1;
              $2_1 = (HEAP32[(0 + 99644 | 0) >> 2] | 0) + $0_1 | 0;
              HEAP32[(0 + 99644 | 0) >> 2] = $2_1;
              HEAP32[($5_1 + 4 | 0) >> 2] = $2_1 | 1 | 0;
              break label$1;
            }
            label$3: {
              if (($4_1 | 0) != (HEAP32[(0 + 99652 | 0) >> 2] | 0 | 0)) {
                break label$3;
              }
              HEAP32[(0 + 99652 | 0) >> 2] = $5_1;
              $2_1 = (HEAP32[(0 + 99640 | 0) >> 2] | 0) + $0_1 | 0;
              HEAP32[(0 + 99640 | 0) >> 2] = $2_1;
              HEAP32[($5_1 + 4 | 0) >> 2] = $2_1 | 1 | 0;
              HEAP32[($5_1 + $2_1 | 0) >> 2] = $2_1;
              break label$1;
            }
            label$4: {
              $1_1 = HEAP32[($4_1 + 4 | 0) >> 2] | 0;
              if (($1_1 & 3 | 0 | 0) != (1 | 0)) {
                break label$4;
              }
              $6_1 = $1_1 & -8 | 0;
              $2_1 = HEAP32[($4_1 + 12 | 0) >> 2] | 0;
              label$5: {
                label$6: {
                  if ($1_1 >>> 0 > 255 >>> 0) {
                    break label$6;
                  }
                  $7_1 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;
                  $8_1 = $1_1 >>> 3 | 0;
                  $1_1 = ($8_1 << 3 | 0) + 99672 | 0;
                  label$7: {
                    if (($2_1 | 0) != ($7_1 | 0)) {
                      break label$7;
                    }
                    (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99632 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $8_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99632 | 0) >> 2] = wasm2js_i32$1;
                    break label$5;
                  }
                  HEAP32[($7_1 + 12 | 0) >> 2] = $2_1;
                  HEAP32[($2_1 + 8 | 0) >> 2] = $7_1;
                  break label$5;
                }
                $9_1 = HEAP32[($4_1 + 24 | 0) >> 2] | 0;
                label$8: {
                  label$9: {
                    if (($2_1 | 0) == ($4_1 | 0)) {
                      break label$9;
                    }
                    $1_1 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;
                    HEAP32[(0 + 99648 | 0) >> 2] | 0;
                    HEAP32[($1_1 + 12 | 0) >> 2] = $2_1;
                    HEAP32[($2_1 + 8 | 0) >> 2] = $1_1;
                    break label$8;
                  }
                  label$10: {
                    label$11: {
                      label$12: {
                        $1_1 = HEAP32[($4_1 + 20 | 0) >> 2] | 0;
                        if (!$1_1) {
                          break label$12;
                        }
                        $7_1 = $4_1 + 20 | 0;
                        break label$11;
                      }
                      $1_1 = HEAP32[($4_1 + 16 | 0) >> 2] | 0;
                      if (!$1_1) {
                        break label$10;
                      }
                      $7_1 = $4_1 + 16 | 0;
                    }
                    label$13: while (1) {
                      $8_1 = $7_1;
                      $2_1 = $1_1;
                      $7_1 = $2_1 + 20 | 0;
                      $1_1 = HEAP32[($2_1 + 20 | 0) >> 2] | 0;
                      if ($1_1) {
                        continue label$13;
                      }
                      $7_1 = $2_1 + 16 | 0;
                      $1_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;
                      if ($1_1) {
                        continue label$13;
                      }
                      break label$13;
                    };
                    HEAP32[$8_1 >> 2] = 0;
                    break label$8;
                  }
                  $2_1 = 0;
                }
                if (!$9_1) {
                  break label$5;
                }
                label$14: {
                  label$15: {
                    $7_1 = HEAP32[($4_1 + 28 | 0) >> 2] | 0;
                    $1_1 = ($7_1 << 2 | 0) + 99936 | 0;
                    if (($4_1 | 0) != (HEAP32[$1_1 >> 2] | 0 | 0)) {
                      break label$15;
                    }
                    HEAP32[$1_1 >> 2] = $2_1;
                    if ($2_1) {
                      break label$14;
                    }
                    (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99636 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $7_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99636 | 0) >> 2] = wasm2js_i32$1;
                    break label$5;
                  }
                  HEAP32[($9_1 + ((HEAP32[($9_1 + 16 | 0) >> 2] | 0 | 0) == ($4_1 | 0) ? 16 : 20) | 0) >> 2] = $2_1;
                  if (!$2_1) {
                    break label$5;
                  }
                }
                HEAP32[($2_1 + 24 | 0) >> 2] = $9_1;
                label$16: {
                  $1_1 = HEAP32[($4_1 + 16 | 0) >> 2] | 0;
                  if (!$1_1) {
                    break label$16;
                  }
                  HEAP32[($2_1 + 16 | 0) >> 2] = $1_1;
                  HEAP32[($1_1 + 24 | 0) >> 2] = $2_1;
                }
                $1_1 = HEAP32[($4_1 + 20 | 0) >> 2] | 0;
                if (!$1_1) {
                  break label$5;
                }
                HEAP32[($2_1 + 20 | 0) >> 2] = $1_1;
                HEAP32[($1_1 + 24 | 0) >> 2] = $2_1;
              }
              $0_1 = $6_1 + $0_1 | 0;
              $4_1 = $4_1 + $6_1 | 0;
              $1_1 = HEAP32[($4_1 + 4 | 0) >> 2] | 0;
            }
            HEAP32[($4_1 + 4 | 0) >> 2] = $1_1 & -2 | 0;
            HEAP32[($5_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;
            HEAP32[($5_1 + $0_1 | 0) >> 2] = $0_1;
            label$17: {
              if ($0_1 >>> 0 > 255 >>> 0) {
                break label$17;
              }
              $2_1 = ($0_1 & -8 | 0) + 99672 | 0;
              label$18: {
                label$19: {
                  $1_1 = HEAP32[(0 + 99632 | 0) >> 2] | 0;
                  $0_1 = 1 << ($0_1 >>> 3 | 0) | 0;
                  if ($1_1 & $0_1 | 0) {
                    break label$19;
                  }
                  HEAP32[(0 + 99632 | 0) >> 2] = $1_1 | $0_1 | 0;
                  $0_1 = $2_1;
                  break label$18;
                }
                $0_1 = HEAP32[($2_1 + 8 | 0) >> 2] | 0;
              }
              HEAP32[($2_1 + 8 | 0) >> 2] = $5_1;
              HEAP32[($0_1 + 12 | 0) >> 2] = $5_1;
              HEAP32[($5_1 + 12 | 0) >> 2] = $2_1;
              HEAP32[($5_1 + 8 | 0) >> 2] = $0_1;
              break label$1;
            }
            $2_1 = 31;
            label$20: {
              if ($0_1 >>> 0 > 16777215 >>> 0) {
                break label$20;
              }
              $2_1 = Math_clz32($0_1 >>> 8 | 0);
              $2_1 = ((($0_1 >>> (38 - $2_1 | 0) | 0) & 1 | 0) - ($2_1 << 1 | 0) | 0) + 62 | 0;
            }
            HEAP32[($5_1 + 28 | 0) >> 2] = $2_1;
            HEAP32[($5_1 + 16 | 0) >> 2] = 0;
            HEAP32[($5_1 + 20 | 0) >> 2] = 0;
            $1_1 = ($2_1 << 2 | 0) + 99936 | 0;
            label$21: {
              label$22: {
                label$23: {
                  $7_1 = HEAP32[(0 + 99636 | 0) >> 2] | 0;
                  $4_1 = 1 << $2_1 | 0;
                  if ($7_1 & $4_1 | 0) {
                    break label$23;
                  }
                  HEAP32[(0 + 99636 | 0) >> 2] = $7_1 | $4_1 | 0;
                  HEAP32[$1_1 >> 2] = $5_1;
                  HEAP32[($5_1 + 24 | 0) >> 2] = $1_1;
                  break label$22;
                }
                $2_1 = $0_1 << (($2_1 | 0) == (31 | 0) ? 0 : 25 - ($2_1 >>> 1 | 0) | 0) | 0;
                $7_1 = HEAP32[$1_1 >> 2] | 0;
                label$24: while (1) {
                  $1_1 = $7_1;
                  if (((HEAP32[($1_1 + 4 | 0) >> 2] | 0) & -8 | 0 | 0) == ($0_1 | 0)) {
                    break label$21;
                  }
                  $7_1 = $2_1 >>> 29 | 0;
                  $2_1 = $2_1 << 1 | 0;
                  $4_1 = ($1_1 + ($7_1 & 4 | 0) | 0) + 16 | 0;
                  $7_1 = HEAP32[$4_1 >> 2] | 0;
                  if ($7_1) {
                    continue label$24;
                  }
                  break label$24;
                };
                HEAP32[$4_1 >> 2] = $5_1;
                HEAP32[($5_1 + 24 | 0) >> 2] = $1_1;
              }
              HEAP32[($5_1 + 12 | 0) >> 2] = $5_1;
              HEAP32[($5_1 + 8 | 0) >> 2] = $5_1;
              break label$1;
            }
            $2_1 = HEAP32[($1_1 + 8 | 0) >> 2] | 0;
            HEAP32[($2_1 + 12 | 0) >> 2] = $5_1;
            HEAP32[($1_1 + 8 | 0) >> 2] = $5_1;
            HEAP32[($5_1 + 24 | 0) >> 2] = 0;
            HEAP32[($5_1 + 12 | 0) >> 2] = $1_1;
            HEAP32[($5_1 + 8 | 0) >> 2] = $2_1;
          }
          return $3_1 + 8 | 0 | 0;
        }

        function $81($0_1) {
          $0_1 = $0_1 | 0;
          var $4_1 = 0,$2_1 = 0,$1_1 = 0,$5_1 = 0,$3_1 = 0,$6_1 = 0,$7_1 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          label$1: {
            if (!$0_1) {
              break label$1;
            }
            $1_1 = $0_1 + -8 | 0;
            $2_1 = HEAP32[($0_1 + -4 | 0) >> 2] | 0;
            $0_1 = $2_1 & -8 | 0;
            $3_1 = $1_1 + $0_1 | 0;
            label$2: {
              if ($2_1 & 1 | 0) {
                break label$2;
              }
              if (!($2_1 & 2 | 0)) {
                break label$1;
              }
              $4_1 = HEAP32[$1_1 >> 2] | 0;
              $1_1 = $1_1 - $4_1 | 0;
              $5_1 = HEAP32[(0 + 99648 | 0) >> 2] | 0;
              if ($1_1 >>> 0 < $5_1 >>> 0) {
                break label$1;
              }
              $0_1 = $4_1 + $0_1 | 0;
              label$3: {
                label$4: {
                  label$5: {
                    if (($1_1 | 0) == (HEAP32[(0 + 99652 | 0) >> 2] | 0 | 0)) {
                      break label$5;
                    }
                    $2_1 = HEAP32[($1_1 + 12 | 0) >> 2] | 0;
                    label$6: {
                      if ($4_1 >>> 0 > 255 >>> 0) {
                        break label$6;
                      }
                      $5_1 = HEAP32[($1_1 + 8 | 0) >> 2] | 0;
                      $6_1 = $4_1 >>> 3 | 0;
                      $4_1 = ($6_1 << 3 | 0) + 99672 | 0;
                      label$7: {
                        if (($2_1 | 0) != ($5_1 | 0)) {
                          break label$7;
                        }
                        (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99632 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $6_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99632 | 0) >> 2] = wasm2js_i32$1;
                        break label$2;
                      }
                      HEAP32[($5_1 + 12 | 0) >> 2] = $2_1;
                      HEAP32[($2_1 + 8 | 0) >> 2] = $5_1;
                      break label$2;
                    }
                    $7_1 = HEAP32[($1_1 + 24 | 0) >> 2] | 0;
                    label$8: {
                      if (($2_1 | 0) == ($1_1 | 0)) {
                        break label$8;
                      }
                      $4_1 = HEAP32[($1_1 + 8 | 0) >> 2] | 0;
                      HEAP32[($4_1 + 12 | 0) >> 2] = $2_1;
                      HEAP32[($2_1 + 8 | 0) >> 2] = $4_1;
                      break label$3;
                    }
                    label$9: {
                      label$10: {
                        $4_1 = HEAP32[($1_1 + 20 | 0) >> 2] | 0;
                        if (!$4_1) {
                          break label$10;
                        }
                        $5_1 = $1_1 + 20 | 0;
                        break label$9;
                      }
                      $4_1 = HEAP32[($1_1 + 16 | 0) >> 2] | 0;
                      if (!$4_1) {
                        break label$4;
                      }
                      $5_1 = $1_1 + 16 | 0;
                    }
                    label$11: while (1) {
                      $6_1 = $5_1;
                      $2_1 = $4_1;
                      $5_1 = $2_1 + 20 | 0;
                      $4_1 = HEAP32[($2_1 + 20 | 0) >> 2] | 0;
                      if ($4_1) {
                        continue label$11;
                      }
                      $5_1 = $2_1 + 16 | 0;
                      $4_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;
                      if ($4_1) {
                        continue label$11;
                      }
                      break label$11;
                    };
                    HEAP32[$6_1 >> 2] = 0;
                    break label$3;
                  }
                  $2_1 = HEAP32[($3_1 + 4 | 0) >> 2] | 0;
                  if (($2_1 & 3 | 0 | 0) != (3 | 0)) {
                    break label$2;
                  }
                  HEAP32[(0 + 99640 | 0) >> 2] = $0_1;
                  HEAP32[($3_1 + 4 | 0) >> 2] = $2_1 & -2 | 0;
                  HEAP32[($1_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;
                  HEAP32[$3_1 >> 2] = $0_1;
                  return;
                }
                $2_1 = 0;
              }
              if (!$7_1) {
                break label$2;
              }
              label$12: {
                label$13: {
                  $5_1 = HEAP32[($1_1 + 28 | 0) >> 2] | 0;
                  $4_1 = ($5_1 << 2 | 0) + 99936 | 0;
                  if (($1_1 | 0) != (HEAP32[$4_1 >> 2] | 0 | 0)) {
                    break label$13;
                  }
                  HEAP32[$4_1 >> 2] = $2_1;
                  if ($2_1) {
                    break label$12;
                  }
                  (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99636 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $5_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99636 | 0) >> 2] = wasm2js_i32$1;
                  break label$2;
                }
                HEAP32[($7_1 + ((HEAP32[($7_1 + 16 | 0) >> 2] | 0 | 0) == ($1_1 | 0) ? 16 : 20) | 0) >> 2] = $2_1;
                if (!$2_1) {
                  break label$2;
                }
              }
              HEAP32[($2_1 + 24 | 0) >> 2] = $7_1;
              label$14: {
                $4_1 = HEAP32[($1_1 + 16 | 0) >> 2] | 0;
                if (!$4_1) {
                  break label$14;
                }
                HEAP32[($2_1 + 16 | 0) >> 2] = $4_1;
                HEAP32[($4_1 + 24 | 0) >> 2] = $2_1;
              }
              $4_1 = HEAP32[($1_1 + 20 | 0) >> 2] | 0;
              if (!$4_1) {
                break label$2;
              }
              HEAP32[($2_1 + 20 | 0) >> 2] = $4_1;
              HEAP32[($4_1 + 24 | 0) >> 2] = $2_1;
            }
            if ($1_1 >>> 0 >= $3_1 >>> 0) {
              break label$1;
            }
            $4_1 = HEAP32[($3_1 + 4 | 0) >> 2] | 0;
            if (!($4_1 & 1 | 0)) {
              break label$1;
            }
            label$15: {
              label$16: {
                label$17: {
                  label$18: {
                    label$19: {
                      if ($4_1 & 2 | 0) {
                        break label$19;
                      }
                      label$20: {
                        if (($3_1 | 0) != (HEAP32[(0 + 99656 | 0) >> 2] | 0 | 0)) {
                          break label$20;
                        }
                        HEAP32[(0 + 99656 | 0) >> 2] = $1_1;
                        $0_1 = (HEAP32[(0 + 99644 | 0) >> 2] | 0) + $0_1 | 0;
                        HEAP32[(0 + 99644 | 0) >> 2] = $0_1;
                        HEAP32[($1_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;
                        if (($1_1 | 0) != (HEAP32[(0 + 99652 | 0) >> 2] | 0 | 0)) {
                          break label$1;
                        }
                        HEAP32[(0 + 99640 | 0) >> 2] = 0;
                        HEAP32[(0 + 99652 | 0) >> 2] = 0;
                        return;
                      }
                      label$21: {
                        if (($3_1 | 0) != (HEAP32[(0 + 99652 | 0) >> 2] | 0 | 0)) {
                          break label$21;
                        }
                        HEAP32[(0 + 99652 | 0) >> 2] = $1_1;
                        $0_1 = (HEAP32[(0 + 99640 | 0) >> 2] | 0) + $0_1 | 0;
                        HEAP32[(0 + 99640 | 0) >> 2] = $0_1;
                        HEAP32[($1_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;
                        HEAP32[($1_1 + $0_1 | 0) >> 2] = $0_1;
                        return;
                      }
                      $0_1 = ($4_1 & -8 | 0) + $0_1 | 0;
                      $2_1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;
                      label$22: {
                        if ($4_1 >>> 0 > 255 >>> 0) {
                          break label$22;
                        }
                        $5_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;
                        $3_1 = $4_1 >>> 3 | 0;
                        $4_1 = ($3_1 << 3 | 0) + 99672 | 0;
                        label$23: {
                          if (($2_1 | 0) != ($5_1 | 0)) {
                            break label$23;
                          }
                          (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99632 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $3_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99632 | 0) >> 2] = wasm2js_i32$1;
                          break label$16;
                        }
                        HEAP32[($5_1 + 12 | 0) >> 2] = $2_1;
                        HEAP32[($2_1 + 8 | 0) >> 2] = $5_1;
                        break label$16;
                      }
                      $7_1 = HEAP32[($3_1 + 24 | 0) >> 2] | 0;
                      label$24: {
                        if (($2_1 | 0) == ($3_1 | 0)) {
                          break label$24;
                        }
                        $4_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;
                        HEAP32[(0 + 99648 | 0) >> 2] | 0;
                        HEAP32[($4_1 + 12 | 0) >> 2] = $2_1;
                        HEAP32[($2_1 + 8 | 0) >> 2] = $4_1;
                        break label$17;
                      }
                      label$25: {
                        label$26: {
                          $4_1 = HEAP32[($3_1 + 20 | 0) >> 2] | 0;
                          if (!$4_1) {
                            break label$26;
                          }
                          $5_1 = $3_1 + 20 | 0;
                          break label$25;
                        }
                        $4_1 = HEAP32[($3_1 + 16 | 0) >> 2] | 0;
                        if (!$4_1) {
                          break label$18;
                        }
                        $5_1 = $3_1 + 16 | 0;
                      }
                      label$27: while (1) {
                        $6_1 = $5_1;
                        $2_1 = $4_1;
                        $5_1 = $2_1 + 20 | 0;
                        $4_1 = HEAP32[($2_1 + 20 | 0) >> 2] | 0;
                        if ($4_1) {
                          continue label$27;
                        }
                        $5_1 = $2_1 + 16 | 0;
                        $4_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;
                        if ($4_1) {
                          continue label$27;
                        }
                        break label$27;
                      };
                      HEAP32[$6_1 >> 2] = 0;
                      break label$17;
                    }
                    HEAP32[($3_1 + 4 | 0) >> 2] = $4_1 & -2 | 0;
                    HEAP32[($1_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;
                    HEAP32[($1_1 + $0_1 | 0) >> 2] = $0_1;
                    break label$15;
                  }
                  $2_1 = 0;
                }
                if (!$7_1) {
                  break label$16;
                }
                label$28: {
                  label$29: {
                    $5_1 = HEAP32[($3_1 + 28 | 0) >> 2] | 0;
                    $4_1 = ($5_1 << 2 | 0) + 99936 | 0;
                    if (($3_1 | 0) != (HEAP32[$4_1 >> 2] | 0 | 0)) {
                      break label$29;
                    }
                    HEAP32[$4_1 >> 2] = $2_1;
                    if ($2_1) {
                      break label$28;
                    }
                    (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99636 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $5_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99636 | 0) >> 2] = wasm2js_i32$1;
                    break label$16;
                  }
                  HEAP32[($7_1 + ((HEAP32[($7_1 + 16 | 0) >> 2] | 0 | 0) == ($3_1 | 0) ? 16 : 20) | 0) >> 2] = $2_1;
                  if (!$2_1) {
                    break label$16;
                  }
                }
                HEAP32[($2_1 + 24 | 0) >> 2] = $7_1;
                label$30: {
                  $4_1 = HEAP32[($3_1 + 16 | 0) >> 2] | 0;
                  if (!$4_1) {
                    break label$30;
                  }
                  HEAP32[($2_1 + 16 | 0) >> 2] = $4_1;
                  HEAP32[($4_1 + 24 | 0) >> 2] = $2_1;
                }
                $4_1 = HEAP32[($3_1 + 20 | 0) >> 2] | 0;
                if (!$4_1) {
                  break label$16;
                }
                HEAP32[($2_1 + 20 | 0) >> 2] = $4_1;
                HEAP32[($4_1 + 24 | 0) >> 2] = $2_1;
              }
              HEAP32[($1_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;
              HEAP32[($1_1 + $0_1 | 0) >> 2] = $0_1;
              if (($1_1 | 0) != (HEAP32[(0 + 99652 | 0) >> 2] | 0 | 0)) {
                break label$15;
              }
              HEAP32[(0 + 99640 | 0) >> 2] = $0_1;
              return;
            }
            label$31: {
              if ($0_1 >>> 0 > 255 >>> 0) {
                break label$31;
              }
              $2_1 = ($0_1 & -8 | 0) + 99672 | 0;
              label$32: {
                label$33: {
                  $4_1 = HEAP32[(0 + 99632 | 0) >> 2] | 0;
                  $0_1 = 1 << ($0_1 >>> 3 | 0) | 0;
                  if ($4_1 & $0_1 | 0) {
                    break label$33;
                  }
                  HEAP32[(0 + 99632 | 0) >> 2] = $4_1 | $0_1 | 0;
                  $0_1 = $2_1;
                  break label$32;
                }
                $0_1 = HEAP32[($2_1 + 8 | 0) >> 2] | 0;
              }
              HEAP32[($2_1 + 8 | 0) >> 2] = $1_1;
              HEAP32[($0_1 + 12 | 0) >> 2] = $1_1;
              HEAP32[($1_1 + 12 | 0) >> 2] = $2_1;
              HEAP32[($1_1 + 8 | 0) >> 2] = $0_1;
              return;
            }
            $2_1 = 31;
            label$34: {
              if ($0_1 >>> 0 > 16777215 >>> 0) {
                break label$34;
              }
              $2_1 = Math_clz32($0_1 >>> 8 | 0);
              $2_1 = ((($0_1 >>> (38 - $2_1 | 0) | 0) & 1 | 0) - ($2_1 << 1 | 0) | 0) + 62 | 0;
            }
            HEAP32[($1_1 + 28 | 0) >> 2] = $2_1;
            HEAP32[($1_1 + 16 | 0) >> 2] = 0;
            HEAP32[($1_1 + 20 | 0) >> 2] = 0;
            $3_1 = ($2_1 << 2 | 0) + 99936 | 0;
            label$35: {
              label$36: {
                label$37: {
                  label$38: {
                    $4_1 = HEAP32[(0 + 99636 | 0) >> 2] | 0;
                    $5_1 = 1 << $2_1 | 0;
                    if ($4_1 & $5_1 | 0) {
                      break label$38;
                    }
                    HEAP32[(0 + 99636 | 0) >> 2] = $4_1 | $5_1 | 0;
                    $0_1 = 8;
                    $2_1 = 24;
                    $5_1 = $3_1;
                    break label$37;
                  }
                  $2_1 = $0_1 << (($2_1 | 0) == (31 | 0) ? 0 : 25 - ($2_1 >>> 1 | 0) | 0) | 0;
                  $5_1 = HEAP32[$3_1 >> 2] | 0;
                  label$39: while (1) {
                    $4_1 = $5_1;
                    if (((HEAP32[($4_1 + 4 | 0) >> 2] | 0) & -8 | 0 | 0) == ($0_1 | 0)) {
                      break label$36;
                    }
                    $5_1 = $2_1 >>> 29 | 0;
                    $2_1 = $2_1 << 1 | 0;
                    $3_1 = ($4_1 + ($5_1 & 4 | 0) | 0) + 16 | 0;
                    $5_1 = HEAP32[$3_1 >> 2] | 0;
                    if ($5_1) {
                      continue label$39;
                    }
                    break label$39;
                  };
                  $0_1 = 8;
                  $2_1 = 24;
                  $5_1 = $4_1;
                }
                $4_1 = $1_1;
                $6_1 = $4_1;
                break label$35;
              }
              $5_1 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;
              HEAP32[($5_1 + 12 | 0) >> 2] = $1_1;
              $2_1 = 8;
              $3_1 = $4_1 + 8 | 0;
              $6_1 = 0;
              $0_1 = 24;
            }
            HEAP32[$3_1 >> 2] = $1_1;
            HEAP32[($1_1 + $2_1 | 0) >> 2] = $5_1;
            HEAP32[($1_1 + 12 | 0) >> 2] = $4_1;
            HEAP32[($1_1 + $0_1 | 0) >> 2] = $6_1;
            $1_1 = (HEAP32[(0 + 99664 | 0) >> 2] | 0) + -1 | 0;
            HEAP32[(0 + 99664 | 0) >> 2] = $1_1 ? $1_1 : -1;
          }
        }

        function $82($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var $2_1 = 0,$3_1 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          label$1: {
            if ($0_1) {
              break label$1;
            }
            return $79($1_1 | 0) | 0 | 0;
          }
          label$2: {
            if ($1_1 >>> 0 < -64 >>> 0) {
              break label$2;
            }
            (wasm2js_i32$0 = $17() | 0, wasm2js_i32$1 = 48), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
            return 0 | 0;
          }
          label$3: {
            $2_1 = $83($0_1 + -8 | 0 | 0, ($1_1 >>> 0 < 11 >>> 0 ? 16 : ($1_1 + 11 | 0) & -8 | 0) | 0) | 0;
            if (!$2_1) {
              break label$3;
            }
            return $2_1 + 8 | 0 | 0;
          }
          label$4: {
            $2_1 = $79($1_1 | 0) | 0;
            if ($2_1) {
              break label$4;
            }
            return 0 | 0;
          }
          $3_1 = HEAP32[($0_1 + -4 | 0) >> 2] | 0;
          $3_1 = ($3_1 & 3 | 0 ? -4 : -8) + ($3_1 & -8 | 0) | 0;
          $28($2_1 | 0, $0_1 | 0, ($3_1 >>> 0 < $1_1 >>> 0 ? $3_1 : $1_1) | 0) | 0;
          $81($0_1 | 0);
          return $2_1 | 0;
        }

        function $83($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var $3_1 = 0,$4_1 = 0,$5_1 = 0,$6_1 = 0,$2_1 = 0,$7_1 = 0,$9_1 = 0,$8_1 = 0,$10_1 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $2_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
          $3_1 = $2_1 & -8 | 0;
          label$1: {
            label$2: {
              if ($2_1 & 3 | 0) {
                break label$2;
              }
              label$3: {
                if ($1_1 >>> 0 >= 256 >>> 0) {
                  break label$3;
                }
                return 0 | 0;
              }
              label$4: {
                if ($3_1 >>> 0 < ($1_1 + 4 | 0) >>> 0) {
                  break label$4;
                }
                $4_1 = $0_1;
                if (($3_1 - $1_1 | 0) >>> 0 <= ((HEAP32[(0 + 100112 | 0) >> 2] | 0) << 1 | 0) >>> 0) {
                  break label$1;
                }
              }
              return 0 | 0;
            }
            $5_1 = $0_1 + $3_1 | 0;
            label$5: {
              label$6: {
                if ($3_1 >>> 0 < $1_1 >>> 0) {
                  break label$6;
                }
                $3_1 = $3_1 - $1_1 | 0;
                if ($3_1 >>> 0 < 16 >>> 0) {
                  break label$5;
                }
                HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 & 1 | 0 | $1_1 | 0 | 2 | 0;
                $1_1 = $0_1 + $1_1 | 0;
                HEAP32[($1_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;
                HEAP32[($5_1 + 4 | 0) >> 2] = HEAP32[($5_1 + 4 | 0) >> 2] | 0 | 1 | 0;
                $84($1_1 | 0, $3_1 | 0);
                break label$5;
              }
              $4_1 = 0;
              label$7: {
                if (($5_1 | 0) != (HEAP32[(0 + 99656 | 0) >> 2] | 0 | 0)) {
                  break label$7;
                }
                $3_1 = (HEAP32[(0 + 99644 | 0) >> 2] | 0) + $3_1 | 0;
                if ($3_1 >>> 0 <= $1_1 >>> 0) {
                  break label$1;
                }
                HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 & 1 | 0 | $1_1 | 0 | 2 | 0;
                $2_1 = $0_1 + $1_1 | 0;
                $1_1 = $3_1 - $1_1 | 0;
                HEAP32[($2_1 + 4 | 0) >> 2] = $1_1 | 1 | 0;
                HEAP32[(0 + 99644 | 0) >> 2] = $1_1;
                HEAP32[(0 + 99656 | 0) >> 2] = $2_1;
                break label$5;
              }
              label$8: {
                if (($5_1 | 0) != (HEAP32[(0 + 99652 | 0) >> 2] | 0 | 0)) {
                  break label$8;
                }
                $4_1 = 0;
                $3_1 = (HEAP32[(0 + 99640 | 0) >> 2] | 0) + $3_1 | 0;
                if ($3_1 >>> 0 < $1_1 >>> 0) {
                  break label$1;
                }
                label$9: {
                  label$10: {
                    $4_1 = $3_1 - $1_1 | 0;
                    if ($4_1 >>> 0 < 16 >>> 0) {
                      break label$10;
                    }
                    HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 & 1 | 0 | $1_1 | 0 | 2 | 0;
                    $1_1 = $0_1 + $1_1 | 0;
                    HEAP32[($1_1 + 4 | 0) >> 2] = $4_1 | 1 | 0;
                    $3_1 = $0_1 + $3_1 | 0;
                    HEAP32[$3_1 >> 2] = $4_1;
                    HEAP32[($3_1 + 4 | 0) >> 2] = (HEAP32[($3_1 + 4 | 0) >> 2] | 0) & -2 | 0;
                    break label$9;
                  }
                  HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 & 1 | 0 | $3_1 | 0 | 2 | 0;
                  $1_1 = $0_1 + $3_1 | 0;
                  HEAP32[($1_1 + 4 | 0) >> 2] = HEAP32[($1_1 + 4 | 0) >> 2] | 0 | 1 | 0;
                  $4_1 = 0;
                  $1_1 = 0;
                }
                HEAP32[(0 + 99652 | 0) >> 2] = $1_1;
                HEAP32[(0 + 99640 | 0) >> 2] = $4_1;
                break label$5;
              }
              $4_1 = 0;
              $6_1 = HEAP32[($5_1 + 4 | 0) >> 2] | 0;
              if ($6_1 & 2 | 0) {
                break label$1;
              }
              $7_1 = ($6_1 & -8 | 0) + $3_1 | 0;
              if ($7_1 >>> 0 < $1_1 >>> 0) {
                break label$1;
              }
              $8_1 = $7_1 - $1_1 | 0;
              $3_1 = HEAP32[($5_1 + 12 | 0) >> 2] | 0;
              label$11: {
                label$12: {
                  if ($6_1 >>> 0 > 255 >>> 0) {
                    break label$12;
                  }
                  $4_1 = HEAP32[($5_1 + 8 | 0) >> 2] | 0;
                  $6_1 = $6_1 >>> 3 | 0;
                  $5_1 = ($6_1 << 3 | 0) + 99672 | 0;
                  label$13: {
                    if (($3_1 | 0) != ($4_1 | 0)) {
                      break label$13;
                    }
                    (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99632 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $6_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99632 | 0) >> 2] = wasm2js_i32$1;
                    break label$11;
                  }
                  HEAP32[($4_1 + 12 | 0) >> 2] = $3_1;
                  HEAP32[($3_1 + 8 | 0) >> 2] = $4_1;
                  break label$11;
                }
                $9_1 = HEAP32[($5_1 + 24 | 0) >> 2] | 0;
                label$14: {
                  label$15: {
                    if (($3_1 | 0) == ($5_1 | 0)) {
                      break label$15;
                    }
                    $4_1 = HEAP32[($5_1 + 8 | 0) >> 2] | 0;
                    HEAP32[(0 + 99648 | 0) >> 2] | 0;
                    HEAP32[($4_1 + 12 | 0) >> 2] = $3_1;
                    HEAP32[($3_1 + 8 | 0) >> 2] = $4_1;
                    break label$14;
                  }
                  label$16: {
                    label$17: {
                      label$18: {
                        $4_1 = HEAP32[($5_1 + 20 | 0) >> 2] | 0;
                        if (!$4_1) {
                          break label$18;
                        }
                        $6_1 = $5_1 + 20 | 0;
                        break label$17;
                      }
                      $4_1 = HEAP32[($5_1 + 16 | 0) >> 2] | 0;
                      if (!$4_1) {
                        break label$16;
                      }
                      $6_1 = $5_1 + 16 | 0;
                    }
                    label$19: while (1) {
                      $10_1 = $6_1;
                      $3_1 = $4_1;
                      $6_1 = $3_1 + 20 | 0;
                      $4_1 = HEAP32[($3_1 + 20 | 0) >> 2] | 0;
                      if ($4_1) {
                        continue label$19;
                      }
                      $6_1 = $3_1 + 16 | 0;
                      $4_1 = HEAP32[($3_1 + 16 | 0) >> 2] | 0;
                      if ($4_1) {
                        continue label$19;
                      }
                      break label$19;
                    };
                    HEAP32[$10_1 >> 2] = 0;
                    break label$14;
                  }
                  $3_1 = 0;
                }
                if (!$9_1) {
                  break label$11;
                }
                label$20: {
                  label$21: {
                    $6_1 = HEAP32[($5_1 + 28 | 0) >> 2] | 0;
                    $4_1 = ($6_1 << 2 | 0) + 99936 | 0;
                    if (($5_1 | 0) != (HEAP32[$4_1 >> 2] | 0 | 0)) {
                      break label$21;
                    }
                    HEAP32[$4_1 >> 2] = $3_1;
                    if ($3_1) {
                      break label$20;
                    }
                    (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99636 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $6_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99636 | 0) >> 2] = wasm2js_i32$1;
                    break label$11;
                  }
                  HEAP32[($9_1 + ((HEAP32[($9_1 + 16 | 0) >> 2] | 0 | 0) == ($5_1 | 0) ? 16 : 20) | 0) >> 2] = $3_1;
                  if (!$3_1) {
                    break label$11;
                  }
                }
                HEAP32[($3_1 + 24 | 0) >> 2] = $9_1;
                label$22: {
                  $4_1 = HEAP32[($5_1 + 16 | 0) >> 2] | 0;
                  if (!$4_1) {
                    break label$22;
                  }
                  HEAP32[($3_1 + 16 | 0) >> 2] = $4_1;
                  HEAP32[($4_1 + 24 | 0) >> 2] = $3_1;
                }
                $4_1 = HEAP32[($5_1 + 20 | 0) >> 2] | 0;
                if (!$4_1) {
                  break label$11;
                }
                HEAP32[($3_1 + 20 | 0) >> 2] = $4_1;
                HEAP32[($4_1 + 24 | 0) >> 2] = $3_1;
              }
              label$23: {
                if ($8_1 >>> 0 > 15 >>> 0) {
                  break label$23;
                }
                HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 & 1 | 0 | $7_1 | 0 | 2 | 0;
                $1_1 = $0_1 + $7_1 | 0;
                HEAP32[($1_1 + 4 | 0) >> 2] = HEAP32[($1_1 + 4 | 0) >> 2] | 0 | 1 | 0;
                break label$5;
              }
              HEAP32[($0_1 + 4 | 0) >> 2] = $2_1 & 1 | 0 | $1_1 | 0 | 2 | 0;
              $1_1 = $0_1 + $1_1 | 0;
              HEAP32[($1_1 + 4 | 0) >> 2] = $8_1 | 3 | 0;
              $3_1 = $0_1 + $7_1 | 0;
              HEAP32[($3_1 + 4 | 0) >> 2] = HEAP32[($3_1 + 4 | 0) >> 2] | 0 | 1 | 0;
              $84($1_1 | 0, $8_1 | 0);
            }
            $4_1 = $0_1;
          }
          return $4_1 | 0;
        }

        function $84($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var $4_1 = 0,$3_1 = 0,$5_1 = 0,$2_1 = 0,$7_1 = 0,$6_1 = 0,wasm2js_i32$0 = 0,wasm2js_i32$1 = 0;
          $2_1 = $0_1 + $1_1 | 0;
          label$1: {
            label$2: {
              $3_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
              if ($3_1 & 1 | 0) {
                break label$2;
              }
              if (!($3_1 & 2 | 0)) {
                break label$1;
              }
              $4_1 = HEAP32[$0_1 >> 2] | 0;
              $1_1 = $4_1 + $1_1 | 0;
              label$3: {
                label$4: {
                  label$5: {
                    label$6: {
                      $0_1 = $0_1 - $4_1 | 0;
                      if (($0_1 | 0) == (HEAP32[(0 + 99652 | 0) >> 2] | 0 | 0)) {
                        break label$6;
                      }
                      $3_1 = HEAP32[($0_1 + 12 | 0) >> 2] | 0;
                      label$7: {
                        if ($4_1 >>> 0 > 255 >>> 0) {
                          break label$7;
                        }
                        $5_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
                        $6_1 = $4_1 >>> 3 | 0;
                        $4_1 = ($6_1 << 3 | 0) + 99672 | 0;
                        if (($3_1 | 0) != ($5_1 | 0)) {
                          break label$5;
                        }
                        (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99632 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $6_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99632 | 0) >> 2] = wasm2js_i32$1;
                        break label$2;
                      }
                      $7_1 = HEAP32[($0_1 + 24 | 0) >> 2] | 0;
                      label$8: {
                        if (($3_1 | 0) == ($0_1 | 0)) {
                          break label$8;
                        }
                        $4_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
                        HEAP32[(0 + 99648 | 0) >> 2] | 0;
                        HEAP32[($4_1 + 12 | 0) >> 2] = $3_1;
                        HEAP32[($3_1 + 8 | 0) >> 2] = $4_1;
                        break label$3;
                      }
                      label$9: {
                        label$10: {
                          $4_1 = HEAP32[($0_1 + 20 | 0) >> 2] | 0;
                          if (!$4_1) {
                            break label$10;
                          }
                          $5_1 = $0_1 + 20 | 0;
                          break label$9;
                        }
                        $4_1 = HEAP32[($0_1 + 16 | 0) >> 2] | 0;
                        if (!$4_1) {
                          break label$4;
                        }
                        $5_1 = $0_1 + 16 | 0;
                      }
                      label$11: while (1) {
                        $6_1 = $5_1;
                        $3_1 = $4_1;
                        $5_1 = $3_1 + 20 | 0;
                        $4_1 = HEAP32[($3_1 + 20 | 0) >> 2] | 0;
                        if ($4_1) {
                          continue label$11;
                        }
                        $5_1 = $3_1 + 16 | 0;
                        $4_1 = HEAP32[($3_1 + 16 | 0) >> 2] | 0;
                        if ($4_1) {
                          continue label$11;
                        }
                        break label$11;
                      };
                      HEAP32[$6_1 >> 2] = 0;
                      break label$3;
                    }
                    $3_1 = HEAP32[($2_1 + 4 | 0) >> 2] | 0;
                    if (($3_1 & 3 | 0 | 0) != (3 | 0)) {
                      break label$2;
                    }
                    HEAP32[(0 + 99640 | 0) >> 2] = $1_1;
                    HEAP32[($2_1 + 4 | 0) >> 2] = $3_1 & -2 | 0;
                    HEAP32[($0_1 + 4 | 0) >> 2] = $1_1 | 1 | 0;
                    HEAP32[$2_1 >> 2] = $1_1;
                    return;
                  }
                  HEAP32[($5_1 + 12 | 0) >> 2] = $3_1;
                  HEAP32[($3_1 + 8 | 0) >> 2] = $5_1;
                  break label$2;
                }
                $3_1 = 0;
              }
              if (!$7_1) {
                break label$2;
              }
              label$12: {
                label$13: {
                  $5_1 = HEAP32[($0_1 + 28 | 0) >> 2] | 0;
                  $4_1 = ($5_1 << 2 | 0) + 99936 | 0;
                  if (($0_1 | 0) != (HEAP32[$4_1 >> 2] | 0 | 0)) {
                    break label$13;
                  }
                  HEAP32[$4_1 >> 2] = $3_1;
                  if ($3_1) {
                    break label$12;
                  }
                  (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99636 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $5_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99636 | 0) >> 2] = wasm2js_i32$1;
                  break label$2;
                }
                HEAP32[($7_1 + ((HEAP32[($7_1 + 16 | 0) >> 2] | 0 | 0) == ($0_1 | 0) ? 16 : 20) | 0) >> 2] = $3_1;
                if (!$3_1) {
                  break label$2;
                }
              }
              HEAP32[($3_1 + 24 | 0) >> 2] = $7_1;
              label$14: {
                $4_1 = HEAP32[($0_1 + 16 | 0) >> 2] | 0;
                if (!$4_1) {
                  break label$14;
                }
                HEAP32[($3_1 + 16 | 0) >> 2] = $4_1;
                HEAP32[($4_1 + 24 | 0) >> 2] = $3_1;
              }
              $4_1 = HEAP32[($0_1 + 20 | 0) >> 2] | 0;
              if (!$4_1) {
                break label$2;
              }
              HEAP32[($3_1 + 20 | 0) >> 2] = $4_1;
              HEAP32[($4_1 + 24 | 0) >> 2] = $3_1;
            }
            label$15: {
              label$16: {
                label$17: {
                  label$18: {
                    label$19: {
                      $4_1 = HEAP32[($2_1 + 4 | 0) >> 2] | 0;
                      if ($4_1 & 2 | 0) {
                        break label$19;
                      }
                      label$20: {
                        if (($2_1 | 0) != (HEAP32[(0 + 99656 | 0) >> 2] | 0 | 0)) {
                          break label$20;
                        }
                        HEAP32[(0 + 99656 | 0) >> 2] = $0_1;
                        $1_1 = (HEAP32[(0 + 99644 | 0) >> 2] | 0) + $1_1 | 0;
                        HEAP32[(0 + 99644 | 0) >> 2] = $1_1;
                        HEAP32[($0_1 + 4 | 0) >> 2] = $1_1 | 1 | 0;
                        if (($0_1 | 0) != (HEAP32[(0 + 99652 | 0) >> 2] | 0 | 0)) {
                          break label$1;
                        }
                        HEAP32[(0 + 99640 | 0) >> 2] = 0;
                        HEAP32[(0 + 99652 | 0) >> 2] = 0;
                        return;
                      }
                      label$21: {
                        if (($2_1 | 0) != (HEAP32[(0 + 99652 | 0) >> 2] | 0 | 0)) {
                          break label$21;
                        }
                        HEAP32[(0 + 99652 | 0) >> 2] = $0_1;
                        $1_1 = (HEAP32[(0 + 99640 | 0) >> 2] | 0) + $1_1 | 0;
                        HEAP32[(0 + 99640 | 0) >> 2] = $1_1;
                        HEAP32[($0_1 + 4 | 0) >> 2] = $1_1 | 1 | 0;
                        HEAP32[($0_1 + $1_1 | 0) >> 2] = $1_1;
                        return;
                      }
                      $1_1 = ($4_1 & -8 | 0) + $1_1 | 0;
                      $3_1 = HEAP32[($2_1 + 12 | 0) >> 2] | 0;
                      label$22: {
                        if ($4_1 >>> 0 > 255 >>> 0) {
                          break label$22;
                        }
                        $5_1 = HEAP32[($2_1 + 8 | 0) >> 2] | 0;
                        $2_1 = $4_1 >>> 3 | 0;
                        $4_1 = ($2_1 << 3 | 0) + 99672 | 0;
                        label$23: {
                          if (($3_1 | 0) != ($5_1 | 0)) {
                            break label$23;
                          }
                          (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99632 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $2_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99632 | 0) >> 2] = wasm2js_i32$1;
                          break label$16;
                        }
                        HEAP32[($5_1 + 12 | 0) >> 2] = $3_1;
                        HEAP32[($3_1 + 8 | 0) >> 2] = $5_1;
                        break label$16;
                      }
                      $7_1 = HEAP32[($2_1 + 24 | 0) >> 2] | 0;
                      label$24: {
                        if (($3_1 | 0) == ($2_1 | 0)) {
                          break label$24;
                        }
                        $4_1 = HEAP32[($2_1 + 8 | 0) >> 2] | 0;
                        HEAP32[(0 + 99648 | 0) >> 2] | 0;
                        HEAP32[($4_1 + 12 | 0) >> 2] = $3_1;
                        HEAP32[($3_1 + 8 | 0) >> 2] = $4_1;
                        break label$17;
                      }
                      label$25: {
                        label$26: {
                          $4_1 = HEAP32[($2_1 + 20 | 0) >> 2] | 0;
                          if (!$4_1) {
                            break label$26;
                          }
                          $5_1 = $2_1 + 20 | 0;
                          break label$25;
                        }
                        $4_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;
                        if (!$4_1) {
                          break label$18;
                        }
                        $5_1 = $2_1 + 16 | 0;
                      }
                      label$27: while (1) {
                        $6_1 = $5_1;
                        $3_1 = $4_1;
                        $5_1 = $3_1 + 20 | 0;
                        $4_1 = HEAP32[($3_1 + 20 | 0) >> 2] | 0;
                        if ($4_1) {
                          continue label$27;
                        }
                        $5_1 = $3_1 + 16 | 0;
                        $4_1 = HEAP32[($3_1 + 16 | 0) >> 2] | 0;
                        if ($4_1) {
                          continue label$27;
                        }
                        break label$27;
                      };
                      HEAP32[$6_1 >> 2] = 0;
                      break label$17;
                    }
                    HEAP32[($2_1 + 4 | 0) >> 2] = $4_1 & -2 | 0;
                    HEAP32[($0_1 + 4 | 0) >> 2] = $1_1 | 1 | 0;
                    HEAP32[($0_1 + $1_1 | 0) >> 2] = $1_1;
                    break label$15;
                  }
                  $3_1 = 0;
                }
                if (!$7_1) {
                  break label$16;
                }
                label$28: {
                  label$29: {
                    $5_1 = HEAP32[($2_1 + 28 | 0) >> 2] | 0;
                    $4_1 = ($5_1 << 2 | 0) + 99936 | 0;
                    if (($2_1 | 0) != (HEAP32[$4_1 >> 2] | 0 | 0)) {
                      break label$29;
                    }
                    HEAP32[$4_1 >> 2] = $3_1;
                    if ($3_1) {
                      break label$28;
                    }
                    (wasm2js_i32$0 = 0, wasm2js_i32$1 = (HEAP32[(0 + 99636 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $5_1 | 0) | 0) | 0), HEAP32[(wasm2js_i32$0 + 99636 | 0) >> 2] = wasm2js_i32$1;
                    break label$16;
                  }
                  HEAP32[($7_1 + ((HEAP32[($7_1 + 16 | 0) >> 2] | 0 | 0) == ($2_1 | 0) ? 16 : 20) | 0) >> 2] = $3_1;
                  if (!$3_1) {
                    break label$16;
                  }
                }
                HEAP32[($3_1 + 24 | 0) >> 2] = $7_1;
                label$30: {
                  $4_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;
                  if (!$4_1) {
                    break label$30;
                  }
                  HEAP32[($3_1 + 16 | 0) >> 2] = $4_1;
                  HEAP32[($4_1 + 24 | 0) >> 2] = $3_1;
                }
                $4_1 = HEAP32[($2_1 + 20 | 0) >> 2] | 0;
                if (!$4_1) {
                  break label$16;
                }
                HEAP32[($3_1 + 20 | 0) >> 2] = $4_1;
                HEAP32[($4_1 + 24 | 0) >> 2] = $3_1;
              }
              HEAP32[($0_1 + 4 | 0) >> 2] = $1_1 | 1 | 0;
              HEAP32[($0_1 + $1_1 | 0) >> 2] = $1_1;
              if (($0_1 | 0) != (HEAP32[(0 + 99652 | 0) >> 2] | 0 | 0)) {
                break label$15;
              }
              HEAP32[(0 + 99640 | 0) >> 2] = $1_1;
              return;
            }
            label$31: {
              if ($1_1 >>> 0 > 255 >>> 0) {
                break label$31;
              }
              $3_1 = ($1_1 & -8 | 0) + 99672 | 0;
              label$32: {
                label$33: {
                  $4_1 = HEAP32[(0 + 99632 | 0) >> 2] | 0;
                  $1_1 = 1 << ($1_1 >>> 3 | 0) | 0;
                  if ($4_1 & $1_1 | 0) {
                    break label$33;
                  }
                  HEAP32[(0 + 99632 | 0) >> 2] = $4_1 | $1_1 | 0;
                  $1_1 = $3_1;
                  break label$32;
                }
                $1_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;
              }
              HEAP32[($3_1 + 8 | 0) >> 2] = $0_1;
              HEAP32[($1_1 + 12 | 0) >> 2] = $0_1;
              HEAP32[($0_1 + 12 | 0) >> 2] = $3_1;
              HEAP32[($0_1 + 8 | 0) >> 2] = $1_1;
              return;
            }
            $3_1 = 31;
            label$34: {
              if ($1_1 >>> 0 > 16777215 >>> 0) {
                break label$34;
              }
              $3_1 = Math_clz32($1_1 >>> 8 | 0);
              $3_1 = ((($1_1 >>> (38 - $3_1 | 0) | 0) & 1 | 0) - ($3_1 << 1 | 0) | 0) + 62 | 0;
            }
            HEAP32[($0_1 + 28 | 0) >> 2] = $3_1;
            HEAP32[($0_1 + 16 | 0) >> 2] = 0;
            HEAP32[($0_1 + 20 | 0) >> 2] = 0;
            $4_1 = ($3_1 << 2 | 0) + 99936 | 0;
            label$35: {
              label$36: {
                label$37: {
                  $5_1 = HEAP32[(0 + 99636 | 0) >> 2] | 0;
                  $2_1 = 1 << $3_1 | 0;
                  if ($5_1 & $2_1 | 0) {
                    break label$37;
                  }
                  HEAP32[(0 + 99636 | 0) >> 2] = $5_1 | $2_1 | 0;
                  HEAP32[$4_1 >> 2] = $0_1;
                  HEAP32[($0_1 + 24 | 0) >> 2] = $4_1;
                  break label$36;
                }
                $3_1 = $1_1 << (($3_1 | 0) == (31 | 0) ? 0 : 25 - ($3_1 >>> 1 | 0) | 0) | 0;
                $5_1 = HEAP32[$4_1 >> 2] | 0;
                label$38: while (1) {
                  $4_1 = $5_1;
                  if (((HEAP32[($4_1 + 4 | 0) >> 2] | 0) & -8 | 0 | 0) == ($1_1 | 0)) {
                    break label$35;
                  }
                  $5_1 = $3_1 >>> 29 | 0;
                  $3_1 = $3_1 << 1 | 0;
                  $2_1 = ($4_1 + ($5_1 & 4 | 0) | 0) + 16 | 0;
                  $5_1 = HEAP32[$2_1 >> 2] | 0;
                  if ($5_1) {
                    continue label$38;
                  }
                  break label$38;
                };
                HEAP32[$2_1 >> 2] = $0_1;
                HEAP32[($0_1 + 24 | 0) >> 2] = $4_1;
              }
              HEAP32[($0_1 + 12 | 0) >> 2] = $0_1;
              HEAP32[($0_1 + 8 | 0) >> 2] = $0_1;
              return;
            }
            $1_1 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;
            HEAP32[($1_1 + 12 | 0) >> 2] = $0_1;
            HEAP32[($4_1 + 8 | 0) >> 2] = $0_1;
            HEAP32[($0_1 + 24 | 0) >> 2] = 0;
            HEAP32[($0_1 + 12 | 0) >> 2] = $4_1;
            HEAP32[($0_1 + 8 | 0) >> 2] = $1_1;
          }
        }

        function $85($0_1, $1_1, $1$hi, $2_1, $2$hi, $3_1, $3$hi, $4_1, $4$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          $3$hi = $3$hi | 0;
          $4_1 = $4_1 | 0;
          $4$hi = $4$hi | 0;
          var i64toi32_i32$5 = 0,i64toi32_i32$1 = 0,i64toi32_i32$2 = 0,i64toi32_i32$4 = 0,i64toi32_i32$3 = 0,i64toi32_i32$0 = 0,$10$hi = 0,$10_1 = 0,$6_1 = 0,$9$hi = 0,$7_1 = 0,$5_1 = 0,$9_1 = 0,$12$hi = 0,$12_1 = 0,i64toi32_i32$6 = 0,$8_1 = 0,$11_1 = 0,$11$hi = 0,$139 = 0,$140 = 0,$141 = 0,$142 = 0,$143 = 0,$144 = 0,$145 = 0,$146 = 0,$147 = 0,$148 = 0,$149 = 0,$150 = 0,$151 = 0,$152 = 0,$153 = 0,$154 = 0,$155 = 0,$156 = 0,$157 = 0,$158 = 0,$159 = 0,$20_1 = 0,$25_1 = 0,$30_1 = 0,$34_1 = 0,$40_1 = 0,$48_1 = 0,$50_1 = 0,$58_1 = 0,$58$hi = 0,$64_1 = 0,$64$hi = 0,$68_1 = 0,$68$hi = 0,$78_1 = 0,$78$hi = 0,$106_1 = 0,$109_1 = 0,$136 = 0,$137 = 0,$137$hi = 0,$138 = 0,$138$hi = 0,$145$hi = 0,$148$hi = 0,$168 = 0,$169 = 0,$169$hi = 0,$170 = 0,$170$hi = 0,$177$hi = 0,$180$hi = 0,$193 = 0,$193$hi = 0,$195$hi = 0,$199 = 0,$199$hi = 0,$201$hi = 0,$228 = 0,$228$hi = 0,$230 = 0,$230$hi = 0,$234 = 0,$234$hi = 0,$236 = 0,$237$hi = 0,$251 = 0,$251$hi = 0,$254 = 0,$254$hi = 0,$262$hi = 0,$265 = 0,$266$hi = 0,$271 = 0,$272 = 0,$272$hi = 0,$273 = 0,$273$hi = 0,$280$hi = 0,$283$hi = 0,$298 = 0,$298$hi = 0,$304 = 0,$305$hi = 0,$311 = 0,$311$hi = 0,$313$hi = 0,$314 = 0,$314$hi = 0,$316 = 0,$316$hi = 0,$343 = 0,$343$hi = 0,$345 = 0,$345$hi = 0,$349 = 0,$349$hi = 0,$351 = 0,$352$hi = 0,$358 = 0,$358$hi = 0,$360$hi = 0,$364 = 0,$364$hi = 0,$367 = 0,$367$hi = 0,$368$hi = 0,$377 = 0,$377$hi = 0,$381$hi = 0,$385 = 0,$386$hi = 0,$389 = 0,$389$hi = 0,$392 = 0,$392$hi = 0,$396 = 0,$397$hi = 0,$400 = 0,$400$hi = 0,$406 = 0,$407$hi = 0,$411 = 0,$412$hi = 0,$415 = 0,$415$hi = 0,$421 = 0,$422$hi = 0,$426 = 0,$427$hi = 0;
          $5_1 = global$0 - 112 | 0;
          global$0 = $5_1;
          i64toi32_i32$0 = $4$hi;
          i64toi32_i32$2 = $4_1;
          i64toi32_i32$1 = 2147483647;
          i64toi32_i32$3 = -1;
          i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
          $9_1 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
          $9$hi = i64toi32_i32$1;
          label$1: {
            label$2: {
              label$3: {
                i64toi32_i32$1 = $1$hi;
                $6_1 = !($1_1 | i64toi32_i32$1 | 0);
                $20_1 = $6_1;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$0 = $2_1;
                i64toi32_i32$2 = 2147483647;
                i64toi32_i32$3 = -1;
                i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
                $10_1 = i64toi32_i32$0 & i64toi32_i32$3 | 0;
                $10$hi = i64toi32_i32$2;
                i64toi32_i32$1 = $10_1;
                i64toi32_i32$0 = -2147418112;
                i64toi32_i32$3 = 0;
                i64toi32_i32$4 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
                i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                i64toi32_i32$2 = i64toi32_i32$4;
                i64toi32_i32$1 = -2147418112;
                i64toi32_i32$3 = 0;
                $25_1 = i64toi32_i32$5 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0 | 0) | 0;
                i64toi32_i32$2 = $10$hi;
                if (!($10_1 | i64toi32_i32$2 | 0) ? $20_1 : $25_1) {
                  break label$3;
                }
                i64toi32_i32$2 = $3$hi;
                i64toi32_i32$3 = $3_1;
                i64toi32_i32$5 = 0;
                i64toi32_i32$1 = 0;
                $30_1 = (i64toi32_i32$3 | 0) != (i64toi32_i32$1 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$5 | 0) | 0;
                i64toi32_i32$3 = $9$hi;
                i64toi32_i32$1 = $9_1;
                i64toi32_i32$2 = -2147418112;
                i64toi32_i32$5 = 0;
                i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
                i64toi32_i32$4 = i64toi32_i32$3 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$5 >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                }
                $11_1 = i64toi32_i32$0;
                $11$hi = i64toi32_i32$4;
                i64toi32_i32$3 = i64toi32_i32$0;
                i64toi32_i32$1 = -2147418112;
                i64toi32_i32$5 = 0;
                $34_1 = i64toi32_i32$4 >>> 0 > i64toi32_i32$1 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$3 >>> 0 > i64toi32_i32$5 >>> 0 | 0) | 0;
                i64toi32_i32$3 = i64toi32_i32$4;
                i64toi32_i32$3 = i64toi32_i32$4;
                i64toi32_i32$5 = i64toi32_i32$0;
                i64toi32_i32$4 = -2147418112;
                i64toi32_i32$1 = 0;
                if ((i64toi32_i32$5 | 0) == (i64toi32_i32$1 | 0) & (i64toi32_i32$3 | 0) == (i64toi32_i32$4 | 0) | 0 ? $30_1 : $34_1) {
                  break label$2;
                }
              }
              label$4: {
                i64toi32_i32$5 = $10$hi;
                i64toi32_i32$1 = $10_1;
                i64toi32_i32$3 = 2147418112;
                i64toi32_i32$4 = 0;
                $40_1 = i64toi32_i32$5 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$4 >>> 0 | 0) | 0;
                i64toi32_i32$1 = i64toi32_i32$5;
                i64toi32_i32$1 = i64toi32_i32$5;
                i64toi32_i32$4 = $10_1;
                i64toi32_i32$5 = 2147418112;
                i64toi32_i32$3 = 0;
                if ((i64toi32_i32$4 | 0) == (i64toi32_i32$3 | 0) & (i64toi32_i32$1 | 0) == (i64toi32_i32$5 | 0) | 0 ? $6_1 : $40_1) {
                  break label$4;
                }
                i64toi32_i32$4 = $2$hi;
                i64toi32_i32$3 = $2_1;
                i64toi32_i32$1 = 32768;
                i64toi32_i32$5 = 0;
                i64toi32_i32$1 = i64toi32_i32$4 | i64toi32_i32$1 | 0;
                $4_1 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
                $4$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $1$hi;
                $3_1 = $1_1;
                $3$hi = i64toi32_i32$1;
                break label$1;
              }
              label$5: {
                i64toi32_i32$1 = $3$hi;
                $48_1 = !($3_1 | i64toi32_i32$1 | 0);
                i64toi32_i32$1 = $9$hi;
                i64toi32_i32$4 = $9_1;
                i64toi32_i32$3 = 2147418112;
                i64toi32_i32$5 = 0;
                $50_1 = i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$4 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
                i64toi32_i32$4 = i64toi32_i32$1;
                i64toi32_i32$4 = i64toi32_i32$1;
                i64toi32_i32$5 = $9_1;
                i64toi32_i32$1 = 2147418112;
                i64toi32_i32$3 = 0;
                if ((i64toi32_i32$5 | 0) == (i64toi32_i32$3 | 0) & (i64toi32_i32$4 | 0) == (i64toi32_i32$1 | 0) | 0 ? $48_1 : $50_1) {
                  break label$5;
                }
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$3 = $4_1;
                i64toi32_i32$4 = 32768;
                i64toi32_i32$1 = 0;
                i64toi32_i32$4 = i64toi32_i32$5 | i64toi32_i32$4 | 0;
                $4_1 = i64toi32_i32$3 | i64toi32_i32$1 | 0;
                $4$hi = i64toi32_i32$4;
                break label$1;
              }
              label$6: {
                i64toi32_i32$4 = $1$hi;
                i64toi32_i32$4 = $10$hi;
                i64toi32_i32$5 = $10_1;
                i64toi32_i32$3 = 2147418112;
                i64toi32_i32$1 = 0;
                i64toi32_i32$3 = i64toi32_i32$4 ^ i64toi32_i32$3 | 0;
                $58_1 = i64toi32_i32$5 ^ i64toi32_i32$1 | 0;
                $58$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $1$hi;
                i64toi32_i32$4 = $1_1;
                i64toi32_i32$5 = $58$hi;
                i64toi32_i32$1 = $58_1;
                i64toi32_i32$5 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
                i64toi32_i32$3 = i64toi32_i32$4 | i64toi32_i32$1 | 0;
                i64toi32_i32$4 = 0;
                i64toi32_i32$1 = 0;
                if ((i64toi32_i32$3 | 0) != (i64toi32_i32$1 | 0) | (i64toi32_i32$5 | 0) != (i64toi32_i32$4 | 0) | 0) {
                  break label$6;
                }
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$3 = $3$hi;
                i64toi32_i32$3 = $1$hi;
                i64toi32_i32$3 = $3$hi;
                i64toi32_i32$1 = $3_1;
                i64toi32_i32$5 = $1$hi;
                i64toi32_i32$4 = $1_1;
                i64toi32_i32$5 = i64toi32_i32$3 ^ i64toi32_i32$5 | 0;
                $64_1 = i64toi32_i32$1 ^ i64toi32_i32$4 | 0;
                $64$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$5 = $2$hi;
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$3 = $4_1;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$4 = $2_1;
                i64toi32_i32$1 = i64toi32_i32$5 ^ i64toi32_i32$1 | 0;
                i64toi32_i32$5 = i64toi32_i32$3 ^ i64toi32_i32$4 | 0;
                i64toi32_i32$3 = -2147483648;
                i64toi32_i32$4 = 0;
                i64toi32_i32$3 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
                $68_1 = i64toi32_i32$5 ^ i64toi32_i32$4 | 0;
                $68$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $64$hi;
                i64toi32_i32$1 = $64_1;
                i64toi32_i32$5 = $68$hi;
                i64toi32_i32$4 = $68_1;
                i64toi32_i32$5 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
                $6_1 = !(i64toi32_i32$1 | i64toi32_i32$4 | 0 | i64toi32_i32$5 | 0);
                i64toi32_i32$2 = $6_1;
                i64toi32_i32$5 = 2147450880;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$4 = i64toi32_i32$2 ? 0 : $2_1;
                i64toi32_i32$3 = i64toi32_i32$2 ? i64toi32_i32$5 : i64toi32_i32$1;
                $4_1 = i64toi32_i32$4;
                $4$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $1$hi;
                i64toi32_i32$1 = i64toi32_i32$2;
                i64toi32_i32$3 = 0;
                i64toi32_i32$4 = $1$hi;
                i64toi32_i32$5 = i64toi32_i32$2 ? 0 : $1_1;
                i64toi32_i32$2 = i64toi32_i32$2 ? i64toi32_i32$3 : i64toi32_i32$4;
                $3_1 = i64toi32_i32$5;
                $3$hi = i64toi32_i32$2;
                break label$1;
              }
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$2 = $9$hi;
              i64toi32_i32$1 = $9_1;
              i64toi32_i32$5 = 2147418112;
              i64toi32_i32$3 = 0;
              i64toi32_i32$5 = i64toi32_i32$2 ^ i64toi32_i32$5 | 0;
              $78_1 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
              $78$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $3$hi;
              i64toi32_i32$2 = $3_1;
              i64toi32_i32$1 = $78$hi;
              i64toi32_i32$3 = $78_1;
              i64toi32_i32$1 = i64toi32_i32$5 | i64toi32_i32$1 | 0;
              if (!(i64toi32_i32$2 | i64toi32_i32$3 | 0 | i64toi32_i32$1 | 0)) {
                break label$1;
              }
              label$7: {
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$1 = $10$hi;
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$5 = $1_1;
                i64toi32_i32$2 = $10$hi;
                i64toi32_i32$3 = $10_1;
                i64toi32_i32$2 = i64toi32_i32$1 | i64toi32_i32$2 | 0;
                i64toi32_i32$1 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
                i64toi32_i32$5 = 0;
                i64toi32_i32$3 = 0;
                if ((i64toi32_i32$1 | 0) != (i64toi32_i32$3 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$5 | 0) | 0) {
                  break label$7;
                }
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$1 = $9$hi;
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$3 = $3_1;
                i64toi32_i32$2 = $9$hi;
                i64toi32_i32$5 = $9_1;
                i64toi32_i32$2 = i64toi32_i32$1 | i64toi32_i32$2 | 0;
                i64toi32_i32$1 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
                i64toi32_i32$3 = 0;
                i64toi32_i32$5 = 0;
                if ((i64toi32_i32$1 | 0) != (i64toi32_i32$5 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$3 | 0) | 0) {
                  break label$1;
                }
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$5 = $3_1;
                i64toi32_i32$2 = $1$hi;
                i64toi32_i32$3 = $1_1;
                i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
                $3_1 = i64toi32_i32$5 & i64toi32_i32$3 | 0;
                $3$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $4$hi;
                i64toi32_i32$2 = $2$hi;
                i64toi32_i32$2 = $4$hi;
                i64toi32_i32$1 = $4_1;
                i64toi32_i32$5 = $2$hi;
                i64toi32_i32$3 = $2_1;
                i64toi32_i32$5 = i64toi32_i32$2 & i64toi32_i32$5 | 0;
                $4_1 = i64toi32_i32$1 & i64toi32_i32$3 | 0;
                $4$hi = i64toi32_i32$5;
                break label$1;
              }
              i64toi32_i32$5 = $3$hi;
              i64toi32_i32$5 = $9$hi;
              i64toi32_i32$5 = $3$hi;
              i64toi32_i32$2 = $3_1;
              i64toi32_i32$1 = $9$hi;
              i64toi32_i32$3 = $9_1;
              i64toi32_i32$1 = i64toi32_i32$5 | i64toi32_i32$1 | 0;
              if (!!(i64toi32_i32$2 | i64toi32_i32$3 | 0 | i64toi32_i32$1 | 0)) {
                break label$2;
              }
              i64toi32_i32$1 = $1$hi;
              $3_1 = $1_1;
              $3$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $2$hi;
              $4_1 = $2_1;
              $4$hi = i64toi32_i32$1;
              break label$1;
            }
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$5 = $3_1;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$3 = $1_1;
            $106_1 = i64toi32_i32$1 >>> 0 > i64toi32_i32$2 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$5 >>> 0 > i64toi32_i32$3 >>> 0 | 0) | 0;
            i64toi32_i32$5 = $9$hi;
            i64toi32_i32$5 = $10$hi;
            i64toi32_i32$5 = $9$hi;
            i64toi32_i32$3 = $9_1;
            i64toi32_i32$1 = $10$hi;
            i64toi32_i32$2 = $10_1;
            $109_1 = i64toi32_i32$5 >>> 0 > i64toi32_i32$1 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$3 >>> 0 > i64toi32_i32$2 >>> 0 | 0) | 0;
            i64toi32_i32$3 = i64toi32_i32$5;
            i64toi32_i32$3 = i64toi32_i32$1;
            i64toi32_i32$3 = i64toi32_i32$5;
            i64toi32_i32$2 = $9_1;
            i64toi32_i32$5 = i64toi32_i32$1;
            i64toi32_i32$1 = $10_1;
            $7_1 = (i64toi32_i32$2 | 0) == (i64toi32_i32$1 | 0) & (i64toi32_i32$3 | 0) == (i64toi32_i32$5 | 0) | 0 ? $106_1 : $109_1;
            i64toi32_i32$4 = $7_1;
            i64toi32_i32$2 = $3$hi;
            i64toi32_i32$3 = $1$hi;
            i64toi32_i32$5 = i64toi32_i32$4 ? $3_1 : $1_1;
            i64toi32_i32$1 = i64toi32_i32$4 ? i64toi32_i32$2 : i64toi32_i32$3;
            $9_1 = i64toi32_i32$5;
            $9$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$3 = i64toi32_i32$4;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$5 = $2$hi;
            i64toi32_i32$2 = i64toi32_i32$4 ? $4_1 : $2_1;
            i64toi32_i32$4 = i64toi32_i32$4 ? i64toi32_i32$1 : i64toi32_i32$5;
            $11_1 = i64toi32_i32$2;
            $11$hi = i64toi32_i32$4;
            i64toi32_i32$3 = i64toi32_i32$2;
            i64toi32_i32$2 = 65535;
            i64toi32_i32$1 = -1;
            i64toi32_i32$2 = i64toi32_i32$4 & i64toi32_i32$2 | 0;
            $10_1 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
            $10$hi = i64toi32_i32$2;
            i64toi32_i32$2 = i64toi32_i32$5;
            i64toi32_i32$2 = $4$hi;
            i64toi32_i32$5 = $7_1;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$3 = $4$hi;
            i64toi32_i32$1 = i64toi32_i32$5 ? $2_1 : $4_1;
            i64toi32_i32$4 = i64toi32_i32$5 ? i64toi32_i32$2 : i64toi32_i32$3;
            $12_1 = i64toi32_i32$1;
            $12$hi = i64toi32_i32$4;
            i64toi32_i32$5 = i64toi32_i32$1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$2 = 48;
            i64toi32_i32$3 = i64toi32_i32$2 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = 0;
              $139 = i64toi32_i32$4 >>> i64toi32_i32$3 | 0;
            } else {
              i64toi32_i32$1 = i64toi32_i32$4 >>> i64toi32_i32$3 | 0;
              $139 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$4 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$3 | 0) | 0;
            }
            $8_1 = $139 & 32767 | 0;
            label$8: {
              i64toi32_i32$1 = $11$hi;
              i64toi32_i32$4 = $11_1;
              i64toi32_i32$5 = 0;
              i64toi32_i32$2 = 48;
              i64toi32_i32$3 = i64toi32_i32$2 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                i64toi32_i32$5 = 0;
                $140 = i64toi32_i32$1 >>> i64toi32_i32$3 | 0;
              } else {
                i64toi32_i32$5 = i64toi32_i32$1 >>> i64toi32_i32$3 | 0;
                $140 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$3 | 0) | 0;
              }
              $6_1 = $140 & 32767 | 0;
              if ($6_1) {
                break label$8;
              }
              $136 = $5_1 + 96 | 0;
              i64toi32_i32$5 = $9$hi;
              $137 = $9_1;
              $137$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $10$hi;
              $138 = $10_1;
              $138$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $9$hi;
              i64toi32_i32$5 = $10$hi;
              $6_1 = !($10_1 | i64toi32_i32$5 | 0);
              i64toi32_i32$3 = $6_1;
              i64toi32_i32$5 = $9$hi;
              i64toi32_i32$4 = $10$hi;
              i64toi32_i32$2 = i64toi32_i32$3 ? $9_1 : $10_1;
              i64toi32_i32$1 = i64toi32_i32$3 ? i64toi32_i32$5 : i64toi32_i32$4;
              i64toi32_i32$5 = Math_clz32(i64toi32_i32$1);
              i64toi32_i32$3 = 0;
              if ((i64toi32_i32$5 | 0) == (32 | 0)) {
                $141 = Math_clz32(i64toi32_i32$2) + 32 | 0;
              } else {
                $141 = i64toi32_i32$5;
              }
              $145$hi = i64toi32_i32$3;
              i64toi32_i32$3 = 0;
              $148$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $145$hi;
              i64toi32_i32$2 = $141;
              i64toi32_i32$1 = $148$hi;
              i64toi32_i32$5 = $6_1 << 6 | 0;
              i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
              i64toi32_i32$0 = i64toi32_i32$3 + i64toi32_i32$1 | 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$5 >>> 0) {
                i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
              }
              $6_1 = i64toi32_i32$4;
              i64toi32_i32$0 = $137$hi;
              i64toi32_i32$2 = $138$hi;
              $86($136 | 0, $137 | 0, i64toi32_i32$0 | 0, $138 | 0, i64toi32_i32$2 | 0, i64toi32_i32$4 + -15 | 0 | 0);
              $6_1 = 16 - i64toi32_i32$4 | 0;
              i64toi32_i32$3 = $5_1 + 104 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $10_1 = i64toi32_i32$2;
              $10$hi = i64toi32_i32$0;
              i64toi32_i32$3 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 96 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 100 | 0) >> 2] | 0;
              $9_1 = i64toi32_i32$0;
              $9$hi = i64toi32_i32$2;
            }
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$2 = $3$hi;
            i64toi32_i32$1 = $7_1;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$0 = $3$hi;
            i64toi32_i32$5 = i64toi32_i32$1 ? $1_1 : $3_1;
            i64toi32_i32$3 = i64toi32_i32$1 ? i64toi32_i32$2 : i64toi32_i32$0;
            $3_1 = i64toi32_i32$5;
            $3$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $12$hi;
            i64toi32_i32$1 = $12_1;
            i64toi32_i32$5 = 65535;
            i64toi32_i32$2 = -1;
            i64toi32_i32$5 = i64toi32_i32$3 & i64toi32_i32$5 | 0;
            $1_1 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
            $1$hi = i64toi32_i32$5;
            label$9: {
              if ($8_1) {
                break label$9;
              }
              $168 = $5_1 + 80 | 0;
              i64toi32_i32$5 = $3$hi;
              $169 = $3_1;
              $169$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $1$hi;
              $170 = $1_1;
              $170$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $3$hi;
              i64toi32_i32$5 = $1$hi;
              $7_1 = !($1_1 | i64toi32_i32$5 | 0);
              i64toi32_i32$0 = $7_1;
              i64toi32_i32$5 = $3$hi;
              i64toi32_i32$1 = $1$hi;
              i64toi32_i32$2 = i64toi32_i32$0 ? $3_1 : $1_1;
              i64toi32_i32$3 = i64toi32_i32$0 ? i64toi32_i32$5 : i64toi32_i32$1;
              i64toi32_i32$5 = Math_clz32(i64toi32_i32$3);
              i64toi32_i32$0 = 0;
              if ((i64toi32_i32$5 | 0) == (32 | 0)) {
                $142 = Math_clz32(i64toi32_i32$2) + 32 | 0;
              } else {
                $142 = i64toi32_i32$5;
              }
              $177$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $180$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $177$hi;
              i64toi32_i32$2 = $142;
              i64toi32_i32$3 = $180$hi;
              i64toi32_i32$5 = $7_1 << 6 | 0;
              i64toi32_i32$1 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
              i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
              if (i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0) {
                i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
              }
              $7_1 = i64toi32_i32$1;
              i64toi32_i32$4 = $169$hi;
              i64toi32_i32$2 = $170$hi;
              $86($168 | 0, $169 | 0, i64toi32_i32$4 | 0, $170 | 0, i64toi32_i32$2 | 0, i64toi32_i32$1 + -15 | 0 | 0);
              $8_1 = 16 - i64toi32_i32$1 | 0;
              i64toi32_i32$0 = $5_1 + 88 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $1_1 = i64toi32_i32$2;
              $1$hi = i64toi32_i32$4;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 80 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 84 | 0) >> 2] | 0;
              $3_1 = i64toi32_i32$4;
              $3$hi = i64toi32_i32$2;
            }
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$0 = $1_1;
            i64toi32_i32$4 = 0;
            i64toi32_i32$5 = 3;
            i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$4 = i64toi32_i32$0 << i64toi32_i32$3 | 0;
              $143 = 0;
            } else {
              i64toi32_i32$4 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$3 | 0) | 0;
              $143 = i64toi32_i32$0 << i64toi32_i32$3 | 0;
            }
            $193 = $143;
            $193$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $3$hi;
            i64toi32_i32$2 = $3_1;
            i64toi32_i32$0 = 0;
            i64toi32_i32$5 = 61;
            i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = 0;
              $144 = i64toi32_i32$4 >>> i64toi32_i32$3 | 0;
            } else {
              i64toi32_i32$0 = i64toi32_i32$4 >>> i64toi32_i32$3 | 0;
              $144 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$4 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$3 | 0) | 0;
            }
            $195$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $193$hi;
            i64toi32_i32$4 = $193;
            i64toi32_i32$2 = $195$hi;
            i64toi32_i32$5 = $144;
            i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
            i64toi32_i32$0 = i64toi32_i32$4 | i64toi32_i32$5 | 0;
            i64toi32_i32$4 = 524288;
            i64toi32_i32$5 = 0;
            i64toi32_i32$4 = i64toi32_i32$2 | i64toi32_i32$4 | 0;
            $1_1 = i64toi32_i32$0 | i64toi32_i32$5 | 0;
            $1$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $10$hi;
            i64toi32_i32$2 = $10_1;
            i64toi32_i32$0 = 0;
            i64toi32_i32$5 = 3;
            i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
              $145 = 0;
            } else {
              i64toi32_i32$0 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$3 | 0) | 0;
              $145 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
            }
            $199 = $145;
            $199$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $9$hi;
            i64toi32_i32$4 = $9_1;
            i64toi32_i32$2 = 0;
            i64toi32_i32$5 = 61;
            i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = 0;
              $146 = i64toi32_i32$0 >>> i64toi32_i32$3 | 0;
            } else {
              i64toi32_i32$2 = i64toi32_i32$0 >>> i64toi32_i32$3 | 0;
              $146 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$3 | 0) | 0;
            }
            $201$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $199$hi;
            i64toi32_i32$0 = $199;
            i64toi32_i32$4 = $201$hi;
            i64toi32_i32$5 = $146;
            i64toi32_i32$4 = i64toi32_i32$2 | i64toi32_i32$4 | 0;
            $12_1 = i64toi32_i32$0 | i64toi32_i32$5 | 0;
            $12$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $3$hi;
            i64toi32_i32$2 = $3_1;
            i64toi32_i32$0 = 0;
            i64toi32_i32$5 = 3;
            i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
              $147 = 0;
            } else {
              i64toi32_i32$0 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$3 | 0) | 0;
              $147 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
            }
            $10_1 = $147;
            $10$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$4 = $4_1;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$5 = $2_1;
            i64toi32_i32$2 = i64toi32_i32$0 ^ i64toi32_i32$2 | 0;
            $3_1 = i64toi32_i32$4 ^ i64toi32_i32$5 | 0;
            $3$hi = i64toi32_i32$2;
            label$10: {
              if (($6_1 | 0) == ($8_1 | 0)) {
                break label$10;
              }
              label$11: {
                $7_1 = $6_1 - $8_1 | 0;
                if ($7_1 >>> 0 <= 127 >>> 0) {
                  break label$11;
                }
                i64toi32_i32$2 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$2;
                i64toi32_i32$2 = 0;
                $10_1 = 1;
                $10$hi = i64toi32_i32$2;
                break label$10;
              }
              i64toi32_i32$2 = $10$hi;
              i64toi32_i32$2 = $1$hi;
              i64toi32_i32$2 = $10$hi;
              i64toi32_i32$4 = $1$hi;
              $86($5_1 + 64 | 0 | 0, $10_1 | 0, i64toi32_i32$2 | 0, $1_1 | 0, i64toi32_i32$4 | 0, 128 - $7_1 | 0 | 0);
              i64toi32_i32$4 = i64toi32_i32$2;
              i64toi32_i32$4 = $1$hi;
              i64toi32_i32$4 = i64toi32_i32$2;
              i64toi32_i32$2 = $1$hi;
              $96($5_1 + 48 | 0 | 0, $10_1 | 0, i64toi32_i32$4 | 0, $1_1 | 0, i64toi32_i32$2 | 0, $7_1 | 0);
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 48 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 52 | 0) >> 2] | 0;
              $228 = i64toi32_i32$2;
              $228$hi = i64toi32_i32$4;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 64 | 0) >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 68 | 0) >> 2] | 0;
              $230 = i64toi32_i32$4;
              $230$hi = i64toi32_i32$2;
              i64toi32_i32$0 = (i64toi32_i32$0 + 64 | 0) + 8 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $234 = i64toi32_i32$2;
              $234$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $230$hi;
              i64toi32_i32$0 = $230;
              i64toi32_i32$2 = $234$hi;
              i64toi32_i32$5 = $234;
              i64toi32_i32$2 = i64toi32_i32$4 | i64toi32_i32$2 | 0;
              i64toi32_i32$4 = i64toi32_i32$0 | i64toi32_i32$5 | 0;
              i64toi32_i32$0 = 0;
              i64toi32_i32$5 = 0;
              $236 = (i64toi32_i32$4 | 0) != (i64toi32_i32$5 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$0 | 0) | 0;
              i64toi32_i32$4 = 0;
              $237$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $228$hi;
              i64toi32_i32$5 = $228;
              i64toi32_i32$2 = $237$hi;
              i64toi32_i32$0 = $236;
              i64toi32_i32$2 = i64toi32_i32$4 | i64toi32_i32$2 | 0;
              $10_1 = i64toi32_i32$5 | i64toi32_i32$0 | 0;
              $10$hi = i64toi32_i32$2;
              i64toi32_i32$4 = ($5_1 + 48 | 0) + 8 | 0;
              i64toi32_i32$2 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $1_1 = i64toi32_i32$2;
              $1$hi = i64toi32_i32$5;
            }
            i64toi32_i32$5 = $12$hi;
            i64toi32_i32$4 = $12_1;
            i64toi32_i32$2 = 524288;
            i64toi32_i32$0 = 0;
            i64toi32_i32$2 = i64toi32_i32$5 | i64toi32_i32$2 | 0;
            $12_1 = i64toi32_i32$4 | i64toi32_i32$0 | 0;
            $12$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $9$hi;
            i64toi32_i32$5 = $9_1;
            i64toi32_i32$4 = 0;
            i64toi32_i32$0 = 3;
            i64toi32_i32$3 = i64toi32_i32$0 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
              i64toi32_i32$4 = i64toi32_i32$5 << i64toi32_i32$3 | 0;
              $148 = 0;
            } else {
              i64toi32_i32$4 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$3 | 0) | 0;
              $148 = i64toi32_i32$5 << i64toi32_i32$3 | 0;
            }
            $9_1 = $148;
            $9$hi = i64toi32_i32$4;
            label$12: {
              label$13: {
                i64toi32_i32$4 = $3$hi;
                i64toi32_i32$2 = $3_1;
                i64toi32_i32$5 = -1;
                i64toi32_i32$0 = -1;
                if ((i64toi32_i32$4 | 0) > (i64toi32_i32$5 | 0)) {
                  $149 = 1;
                } else {
                  if ((i64toi32_i32$4 | 0) >= (i64toi32_i32$5 | 0)) {
                    if (i64toi32_i32$2 >>> 0 <= i64toi32_i32$0 >>> 0) {
                      $150 = 0;
                    } else {
                      $150 = 1;
                    }
                    $151 = $150;
                  } else {
                    $151 = 0;
                  }
                  $149 = $151;
                }
                if ($149) {
                  break label$13;
                }
                i64toi32_i32$2 = 0;
                $3_1 = 0;
                $3$hi = i64toi32_i32$2;
                i64toi32_i32$2 = 0;
                $4_1 = 0;
                $4$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $9$hi;
                i64toi32_i32$2 = $10$hi;
                i64toi32_i32$2 = $9$hi;
                i64toi32_i32$0 = $9_1;
                i64toi32_i32$4 = $10$hi;
                i64toi32_i32$5 = $10_1;
                i64toi32_i32$4 = i64toi32_i32$2 ^ i64toi32_i32$4 | 0;
                $251 = i64toi32_i32$0 ^ i64toi32_i32$5 | 0;
                $251$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $12$hi;
                i64toi32_i32$4 = $1$hi;
                i64toi32_i32$4 = $12$hi;
                i64toi32_i32$2 = $12_1;
                i64toi32_i32$0 = $1$hi;
                i64toi32_i32$5 = $1_1;
                i64toi32_i32$0 = i64toi32_i32$4 ^ i64toi32_i32$0 | 0;
                $254 = i64toi32_i32$2 ^ i64toi32_i32$5 | 0;
                $254$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $251$hi;
                i64toi32_i32$4 = $251;
                i64toi32_i32$2 = $254$hi;
                i64toi32_i32$5 = $254;
                i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
                if (!(i64toi32_i32$4 | i64toi32_i32$5 | 0 | i64toi32_i32$2 | 0)) {
                  break label$1;
                }
                i64toi32_i32$2 = $9$hi;
                i64toi32_i32$2 = $10$hi;
                i64toi32_i32$2 = $9$hi;
                i64toi32_i32$0 = $9_1;
                i64toi32_i32$4 = $10$hi;
                i64toi32_i32$5 = $10_1;
                i64toi32_i32$3 = i64toi32_i32$0 - i64toi32_i32$5 | 0;
                i64toi32_i32$6 = i64toi32_i32$0 >>> 0 < i64toi32_i32$5 >>> 0;
                i64toi32_i32$1 = i64toi32_i32$6 + i64toi32_i32$4 | 0;
                i64toi32_i32$1 = i64toi32_i32$2 - i64toi32_i32$1 | 0;
                $2_1 = i64toi32_i32$3;
                $2$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $12$hi;
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$1 = $12$hi;
                i64toi32_i32$2 = $12_1;
                i64toi32_i32$0 = $1$hi;
                i64toi32_i32$5 = $1_1;
                i64toi32_i32$4 = i64toi32_i32$2 - i64toi32_i32$5 | 0;
                i64toi32_i32$6 = i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0;
                i64toi32_i32$3 = i64toi32_i32$6 + i64toi32_i32$0 | 0;
                i64toi32_i32$3 = i64toi32_i32$1 - i64toi32_i32$3 | 0;
                $262$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $9$hi;
                i64toi32_i32$3 = $10$hi;
                i64toi32_i32$3 = $9$hi;
                i64toi32_i32$1 = $9_1;
                i64toi32_i32$2 = $10$hi;
                i64toi32_i32$5 = $10_1;
                $265 = i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
                i64toi32_i32$1 = 0;
                $266$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $262$hi;
                i64toi32_i32$5 = i64toi32_i32$4;
                i64toi32_i32$3 = $266$hi;
                i64toi32_i32$2 = $265;
                i64toi32_i32$0 = i64toi32_i32$5 - i64toi32_i32$2 | 0;
                i64toi32_i32$6 = i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0;
                i64toi32_i32$4 = i64toi32_i32$6 + i64toi32_i32$3 | 0;
                i64toi32_i32$4 = i64toi32_i32$1 - i64toi32_i32$4 | 0;
                $4_1 = i64toi32_i32$0;
                $4$hi = i64toi32_i32$4;
                i64toi32_i32$1 = i64toi32_i32$0;
                i64toi32_i32$5 = 524287;
                i64toi32_i32$2 = -1;
                if (i64toi32_i32$4 >>> 0 > i64toi32_i32$5 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$1 >>> 0 > i64toi32_i32$2 >>> 0 | 0) | 0) {
                  break label$12;
                }
                $271 = $5_1 + 32 | 0;
                i64toi32_i32$1 = $2$hi;
                $272 = $2_1;
                $272$hi = i64toi32_i32$1;
                i64toi32_i32$1 = i64toi32_i32$4;
                $273 = i64toi32_i32$0;
                $273$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$1 = i64toi32_i32$4;
                $7_1 = !(i64toi32_i32$0 | i64toi32_i32$1 | 0);
                i64toi32_i32$3 = $7_1;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$5 = i64toi32_i32$3 ? $2_1 : i64toi32_i32$0;
                i64toi32_i32$2 = i64toi32_i32$3 ? i64toi32_i32$1 : i64toi32_i32$4;
                i64toi32_i32$1 = Math_clz32(i64toi32_i32$2);
                i64toi32_i32$3 = 0;
                if ((i64toi32_i32$1 | 0) == (32 | 0)) {
                  $152 = Math_clz32(i64toi32_i32$5) + 32 | 0;
                } else {
                  $152 = i64toi32_i32$1;
                }
                $280$hi = i64toi32_i32$3;
                i64toi32_i32$3 = 0;
                $283$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $280$hi;
                i64toi32_i32$5 = $152;
                i64toi32_i32$2 = $283$hi;
                i64toi32_i32$1 = $7_1 << 6 | 0;
                i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$1 | 0;
                i64toi32_i32$0 = i64toi32_i32$3 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                $7_1 = i64toi32_i32$4 + -12 | 0;
                i64toi32_i32$0 = $272$hi;
                i64toi32_i32$5 = $273$hi;
                $86($271 | 0, $272 | 0, i64toi32_i32$0 | 0, $273 | 0, i64toi32_i32$5 | 0, $7_1 | 0);
                $6_1 = $6_1 - $7_1 | 0;
                i64toi32_i32$3 = $5_1 + 40 | 0;
                i64toi32_i32$5 = HEAP32[i64toi32_i32$3 >> 2] | 0;
                i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
                $4_1 = i64toi32_i32$5;
                $4$hi = i64toi32_i32$0;
                i64toi32_i32$3 = $5_1;
                i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 32 | 0) >> 2] | 0;
                i64toi32_i32$5 = HEAP32[(i64toi32_i32$3 + 36 | 0) >> 2] | 0;
                $2_1 = i64toi32_i32$0;
                $2$hi = i64toi32_i32$5;
                break label$12;
              }
              i64toi32_i32$5 = $1$hi;
              i64toi32_i32$5 = $12$hi;
              i64toi32_i32$5 = $1$hi;
              i64toi32_i32$3 = $1_1;
              i64toi32_i32$0 = $12$hi;
              i64toi32_i32$1 = $12_1;
              i64toi32_i32$2 = i64toi32_i32$3 + i64toi32_i32$1 | 0;
              i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$0 | 0;
              if (i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0) {
                i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
              }
              $298 = i64toi32_i32$2;
              $298$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $10$hi;
              i64toi32_i32$4 = $9$hi;
              i64toi32_i32$4 = $10$hi;
              i64toi32_i32$5 = $10_1;
              i64toi32_i32$3 = $9$hi;
              i64toi32_i32$1 = $9_1;
              i64toi32_i32$0 = i64toi32_i32$5 + i64toi32_i32$1 | 0;
              i64toi32_i32$2 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
              if (i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0) {
                i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
              }
              $2_1 = i64toi32_i32$0;
              $2$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $10$hi;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$4 = i64toi32_i32$0;
              i64toi32_i32$5 = $10$hi;
              i64toi32_i32$1 = $10_1;
              $304 = i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
              i64toi32_i32$4 = 0;
              $305$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $298$hi;
              i64toi32_i32$1 = $298;
              i64toi32_i32$2 = $305$hi;
              i64toi32_i32$5 = $304;
              i64toi32_i32$3 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
              i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
              if (i64toi32_i32$3 >>> 0 < i64toi32_i32$5 >>> 0) {
                i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
              }
              $4_1 = i64toi32_i32$3;
              $4$hi = i64toi32_i32$0;
              i64toi32_i32$4 = i64toi32_i32$3;
              i64toi32_i32$1 = 1048576;
              i64toi32_i32$5 = 0;
              i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
              if (!(i64toi32_i32$4 & i64toi32_i32$5 | 0 | i64toi32_i32$1 | 0)) {
                break label$12;
              }
              i64toi32_i32$1 = $2$hi;
              i64toi32_i32$0 = $2_1;
              i64toi32_i32$4 = 0;
              i64toi32_i32$5 = 1;
              i64toi32_i32$2 = i64toi32_i32$5 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                i64toi32_i32$4 = 0;
                $153 = i64toi32_i32$1 >>> i64toi32_i32$2 | 0;
              } else {
                i64toi32_i32$4 = i64toi32_i32$1 >>> i64toi32_i32$2 | 0;
                $153 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$2 | 0) | 0;
              }
              $311 = $153;
              $311$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $4$hi;
              i64toi32_i32$1 = $4_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$5 = 63;
              i64toi32_i32$2 = i64toi32_i32$5 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = i64toi32_i32$1 << i64toi32_i32$2 | 0;
                $154 = 0;
              } else {
                i64toi32_i32$0 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$2 | 0) | 0;
                $154 = i64toi32_i32$1 << i64toi32_i32$2 | 0;
              }
              $313$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $311$hi;
              i64toi32_i32$4 = $311;
              i64toi32_i32$1 = $313$hi;
              i64toi32_i32$5 = $154;
              i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
              $314 = i64toi32_i32$4 | i64toi32_i32$5 | 0;
              $314$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $10$hi;
              i64toi32_i32$0 = $10_1;
              i64toi32_i32$4 = 0;
              i64toi32_i32$5 = 1;
              i64toi32_i32$4 = i64toi32_i32$1 & i64toi32_i32$4 | 0;
              $316 = i64toi32_i32$0 & i64toi32_i32$5 | 0;
              $316$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $314$hi;
              i64toi32_i32$1 = $314;
              i64toi32_i32$0 = $316$hi;
              i64toi32_i32$5 = $316;
              i64toi32_i32$0 = i64toi32_i32$4 | i64toi32_i32$0 | 0;
              $2_1 = i64toi32_i32$1 | i64toi32_i32$5 | 0;
              $2$hi = i64toi32_i32$0;
              $6_1 = $6_1 + 1 | 0;
              i64toi32_i32$0 = $4$hi;
              i64toi32_i32$4 = $4_1;
              i64toi32_i32$1 = 0;
              i64toi32_i32$5 = 1;
              i64toi32_i32$2 = i64toi32_i32$5 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $155 = i64toi32_i32$0 >>> i64toi32_i32$2 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$2 | 0;
                $155 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$2 | 0) | 0;
              }
              $4_1 = $155;
              $4$hi = i64toi32_i32$1;
            }
            i64toi32_i32$1 = $11$hi;
            i64toi32_i32$0 = $11_1;
            i64toi32_i32$4 = -2147483648;
            i64toi32_i32$5 = 0;
            i64toi32_i32$4 = i64toi32_i32$1 & i64toi32_i32$4 | 0;
            $10_1 = i64toi32_i32$0 & i64toi32_i32$5 | 0;
            $10$hi = i64toi32_i32$4;
            label$14: {
              if (($6_1 | 0) < (32767 | 0)) {
                break label$14;
              }
              i64toi32_i32$1 = $10_1;
              i64toi32_i32$0 = 2147418112;
              i64toi32_i32$5 = 0;
              i64toi32_i32$0 = i64toi32_i32$4 | i64toi32_i32$0 | 0;
              $4_1 = i64toi32_i32$1 | i64toi32_i32$5 | 0;
              $4$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $3_1 = 0;
              $3$hi = i64toi32_i32$0;
              break label$1;
            }
            $7_1 = 0;
            label$15: {
              label$16: {
                if (($6_1 | 0) <= (0 | 0)) {
                  break label$16;
                }
                $7_1 = $6_1;
                break label$15;
              }
              i64toi32_i32$0 = $2$hi;
              i64toi32_i32$0 = $4$hi;
              i64toi32_i32$0 = $2$hi;
              i64toi32_i32$1 = $4$hi;
              $86($5_1 + 16 | 0 | 0, $2_1 | 0, i64toi32_i32$0 | 0, $4_1 | 0, i64toi32_i32$1 | 0, $6_1 + 127 | 0 | 0);
              i64toi32_i32$1 = i64toi32_i32$0;
              i64toi32_i32$1 = $4$hi;
              i64toi32_i32$1 = i64toi32_i32$0;
              i64toi32_i32$0 = $4$hi;
              $96($5_1 | 0, $2_1 | 0, i64toi32_i32$1 | 0, $4_1 | 0, i64toi32_i32$0 | 0, 1 - $6_1 | 0 | 0);
              i64toi32_i32$4 = $5_1;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $343 = i64toi32_i32$0;
              $343$hi = i64toi32_i32$1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 16 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 20 | 0) >> 2] | 0;
              $345 = i64toi32_i32$1;
              $345$hi = i64toi32_i32$0;
              i64toi32_i32$4 = (i64toi32_i32$4 + 16 | 0) + 8 | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $349 = i64toi32_i32$0;
              $349$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $345$hi;
              i64toi32_i32$4 = $345;
              i64toi32_i32$0 = $349$hi;
              i64toi32_i32$5 = $349;
              i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
              i64toi32_i32$1 = i64toi32_i32$4 | i64toi32_i32$5 | 0;
              i64toi32_i32$4 = 0;
              i64toi32_i32$5 = 0;
              $351 = (i64toi32_i32$1 | 0) != (i64toi32_i32$5 | 0) | (i64toi32_i32$0 | 0) != (i64toi32_i32$4 | 0) | 0;
              i64toi32_i32$1 = 0;
              $352$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $343$hi;
              i64toi32_i32$5 = $343;
              i64toi32_i32$0 = $352$hi;
              i64toi32_i32$4 = $351;
              i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
              $2_1 = i64toi32_i32$5 | i64toi32_i32$4 | 0;
              $2$hi = i64toi32_i32$0;
              i64toi32_i32$1 = $5_1 + 8 | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$1 >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
              $4_1 = i64toi32_i32$0;
              $4$hi = i64toi32_i32$5;
            }
            i64toi32_i32$5 = $2$hi;
            i64toi32_i32$1 = $2_1;
            i64toi32_i32$0 = 0;
            i64toi32_i32$4 = 3;
            i64toi32_i32$2 = i64toi32_i32$4 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = 0;
              $156 = i64toi32_i32$5 >>> i64toi32_i32$2 | 0;
            } else {
              i64toi32_i32$0 = i64toi32_i32$5 >>> i64toi32_i32$2 | 0;
              $156 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$2 | 0) | 0;
            }
            $358 = $156;
            $358$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$5 = $4_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$4 = 61;
            i64toi32_i32$2 = i64toi32_i32$4 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = i64toi32_i32$5 << i64toi32_i32$2 | 0;
              $157 = 0;
            } else {
              i64toi32_i32$1 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$2 | 0) | 0;
              $157 = i64toi32_i32$5 << i64toi32_i32$2 | 0;
            }
            $360$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $358$hi;
            i64toi32_i32$0 = $358;
            i64toi32_i32$5 = $360$hi;
            i64toi32_i32$4 = $157;
            i64toi32_i32$5 = i64toi32_i32$1 | i64toi32_i32$5 | 0;
            $3_1 = i64toi32_i32$0 | i64toi32_i32$4 | 0;
            $3$hi = i64toi32_i32$5;
            i64toi32_i32$5 = 0;
            i64toi32_i32$1 = $7_1;
            i64toi32_i32$0 = 0;
            i64toi32_i32$4 = 48;
            i64toi32_i32$2 = i64toi32_i32$4 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$1 << i64toi32_i32$2 | 0;
              $158 = 0;
            } else {
              i64toi32_i32$0 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$2 | 0) | 0;
              $158 = i64toi32_i32$1 << i64toi32_i32$2 | 0;
            }
            $364 = $158;
            $364$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$5 = $4_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$4 = 3;
            i64toi32_i32$2 = i64toi32_i32$4 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = 0;
              $159 = i64toi32_i32$0 >>> i64toi32_i32$2 | 0;
            } else {
              i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$2 | 0;
              $159 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$2 | 0) | 0;
            }
            i64toi32_i32$0 = $159;
            i64toi32_i32$5 = 65535;
            i64toi32_i32$4 = -1;
            i64toi32_i32$5 = i64toi32_i32$1 & i64toi32_i32$5 | 0;
            $367 = i64toi32_i32$0 & i64toi32_i32$4 | 0;
            $367$hi = i64toi32_i32$5;
            i64toi32_i32$5 = $364$hi;
            i64toi32_i32$1 = $364;
            i64toi32_i32$0 = $367$hi;
            i64toi32_i32$4 = $367;
            i64toi32_i32$0 = i64toi32_i32$5 | i64toi32_i32$0 | 0;
            $368$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $10$hi;
            i64toi32_i32$0 = $368$hi;
            i64toi32_i32$5 = i64toi32_i32$1 | i64toi32_i32$4 | 0;
            i64toi32_i32$1 = $10$hi;
            i64toi32_i32$4 = $10_1;
            i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
            $4_1 = i64toi32_i32$5 | i64toi32_i32$4 | 0;
            $4$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $2$hi;
            $6_1 = $2_1 & 7 | 0;
            label$17: {
              label$18: {
                label$19: {
                  switch ($94() | 0 | 0) {
                    case 0:
                      label$22: {
                        if (($6_1 | 0) == (4 | 0)) {
                          break label$22;
                        }
                        i64toi32_i32$1 = $4$hi;
                        $377 = $4_1;
                        $377$hi = i64toi32_i32$1;
                        i64toi32_i32$1 = $3$hi;
                        i64toi32_i32$1 = 0;
                        $381$hi = i64toi32_i32$1;
                        i64toi32_i32$1 = $3$hi;
                        i64toi32_i32$0 = $3_1;
                        i64toi32_i32$5 = $381$hi;
                        i64toi32_i32$4 = $6_1 >>> 0 > 4 >>> 0;
                        i64toi32_i32$2 = i64toi32_i32$0 + i64toi32_i32$4 | 0;
                        i64toi32_i32$3 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
                        if (i64toi32_i32$2 >>> 0 < i64toi32_i32$4 >>> 0) {
                          i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                        }
                        $10_1 = i64toi32_i32$2;
                        $10$hi = i64toi32_i32$3;
                        i64toi32_i32$3 = $3$hi;
                        i64toi32_i32$3 = $10$hi;
                        i64toi32_i32$1 = i64toi32_i32$2;
                        i64toi32_i32$0 = $3$hi;
                        i64toi32_i32$4 = $3_1;
                        $385 = i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$4 >>> 0 | 0) | 0;
                        i64toi32_i32$1 = 0;
                        $386$hi = i64toi32_i32$1;
                        i64toi32_i32$1 = $377$hi;
                        i64toi32_i32$4 = $377;
                        i64toi32_i32$3 = $386$hi;
                        i64toi32_i32$0 = $385;
                        i64toi32_i32$5 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
                        i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
                        if (i64toi32_i32$5 >>> 0 < i64toi32_i32$0 >>> 0) {
                          i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                        }
                        $4_1 = i64toi32_i32$5;
                        $4$hi = i64toi32_i32$2;
                        i64toi32_i32$2 = $10$hi;
                        $3_1 = $10_1;
                        $3$hi = i64toi32_i32$2;
                        break label$18;
                      }
                      i64toi32_i32$2 = $4$hi;
                      $389 = $4_1;
                      $389$hi = i64toi32_i32$2;
                      i64toi32_i32$2 = $3$hi;
                      i64toi32_i32$1 = $3_1;
                      i64toi32_i32$4 = 0;
                      i64toi32_i32$0 = 1;
                      i64toi32_i32$4 = i64toi32_i32$2 & i64toi32_i32$4 | 0;
                      $392 = i64toi32_i32$1 & i64toi32_i32$0 | 0;
                      $392$hi = i64toi32_i32$4;
                      i64toi32_i32$4 = i64toi32_i32$2;
                      i64toi32_i32$2 = i64toi32_i32$1;
                      i64toi32_i32$1 = $392$hi;
                      i64toi32_i32$0 = $392;
                      i64toi32_i32$3 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
                      i64toi32_i32$5 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
                      if (i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0) {
                        i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                      }
                      $10_1 = i64toi32_i32$3;
                      $10$hi = i64toi32_i32$5;
                      i64toi32_i32$5 = $3$hi;
                      i64toi32_i32$5 = $10$hi;
                      i64toi32_i32$4 = i64toi32_i32$3;
                      i64toi32_i32$2 = $3$hi;
                      i64toi32_i32$0 = $3_1;
                      $396 = i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0;
                      i64toi32_i32$4 = 0;
                      $397$hi = i64toi32_i32$4;
                      i64toi32_i32$4 = $389$hi;
                      i64toi32_i32$0 = $389;
                      i64toi32_i32$5 = $397$hi;
                      i64toi32_i32$2 = $396;
                      i64toi32_i32$1 = i64toi32_i32$0 + i64toi32_i32$2 | 0;
                      i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$5 | 0;
                      if (i64toi32_i32$1 >>> 0 < i64toi32_i32$2 >>> 0) {
                        i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                      }
                      $4_1 = i64toi32_i32$1;
                      $4$hi = i64toi32_i32$3;
                      i64toi32_i32$3 = $10$hi;
                      $3_1 = $10_1;
                      $3$hi = i64toi32_i32$3;
                      break label$17;
                    case 1:
                      i64toi32_i32$3 = $4$hi;
                      $400 = $4_1;
                      $400$hi = i64toi32_i32$3;
                      i64toi32_i32$3 = $3$hi;
                      i64toi32_i32$3 = $10$hi;
                      i64toi32_i32$4 = $10_1;
                      i64toi32_i32$0 = 0;
                      i64toi32_i32$2 = 0;
                      $406 = ((i64toi32_i32$4 | 0) != (i64toi32_i32$2 | 0) | (i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | 0) & ($6_1 | 0) != (0 | 0) | 0;
                      i64toi32_i32$4 = 0;
                      $407$hi = i64toi32_i32$4;
                      i64toi32_i32$4 = $3$hi;
                      i64toi32_i32$2 = $3_1;
                      i64toi32_i32$3 = $407$hi;
                      i64toi32_i32$0 = $406;
                      i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
                      i64toi32_i32$1 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
                      if (i64toi32_i32$5 >>> 0 < i64toi32_i32$0 >>> 0) {
                        i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
                      }
                      $10_1 = i64toi32_i32$5;
                      $10$hi = i64toi32_i32$1;
                      i64toi32_i32$1 = $3$hi;
                      i64toi32_i32$1 = $10$hi;
                      i64toi32_i32$4 = i64toi32_i32$5;
                      i64toi32_i32$2 = $3$hi;
                      i64toi32_i32$0 = $3_1;
                      $411 = i64toi32_i32$1 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$5 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0;
                      i64toi32_i32$4 = 0;
                      $412$hi = i64toi32_i32$4;
                      i64toi32_i32$4 = $400$hi;
                      i64toi32_i32$0 = $400;
                      i64toi32_i32$1 = $412$hi;
                      i64toi32_i32$2 = $411;
                      i64toi32_i32$3 = i64toi32_i32$0 + i64toi32_i32$2 | 0;
                      i64toi32_i32$5 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
                      if (i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0) {
                        i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                      }
                      $4_1 = i64toi32_i32$3;
                      $4$hi = i64toi32_i32$5;
                      i64toi32_i32$5 = $10$hi;
                      $3_1 = $10_1;
                      $3$hi = i64toi32_i32$5;
                      break label$18;
                    case 2:
                      break label$19;
                    default:
                      break label$18;
                  };
                }
                i64toi32_i32$5 = $4$hi;
                $415 = $4_1;
                $415$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $3$hi;
                i64toi32_i32$5 = $10$hi;
                $421 = !($10_1 | i64toi32_i32$5 | 0) & ($6_1 | 0) != (0 | 0) | 0;
                i64toi32_i32$5 = 0;
                $422$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $3$hi;
                i64toi32_i32$4 = $3_1;
                i64toi32_i32$0 = $422$hi;
                i64toi32_i32$2 = $421;
                i64toi32_i32$1 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
                i64toi32_i32$3 = i64toi32_i32$5 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$1 >>> 0 < i64toi32_i32$2 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $10_1 = i64toi32_i32$1;
                $10$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $3$hi;
                i64toi32_i32$3 = $10$hi;
                i64toi32_i32$5 = i64toi32_i32$1;
                i64toi32_i32$4 = $3$hi;
                i64toi32_i32$2 = $3_1;
                $426 = i64toi32_i32$3 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
                i64toi32_i32$5 = 0;
                $427$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $415$hi;
                i64toi32_i32$2 = $415;
                i64toi32_i32$3 = $427$hi;
                i64toi32_i32$4 = $426;
                i64toi32_i32$0 = i64toi32_i32$2 + i64toi32_i32$4 | 0;
                i64toi32_i32$1 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
                }
                $4_1 = i64toi32_i32$0;
                $4$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $10$hi;
                $3_1 = $10_1;
                $3$hi = i64toi32_i32$1;
              }
              if (!$6_1) {
                break label$1;
              }
            }
            $95() | 0;
          }
          i64toi32_i32$1 = $3$hi;
          i64toi32_i32$2 = $0_1;
          HEAP32[i64toi32_i32$2 >> 2] = $3_1;
          HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] = i64toi32_i32$1;
          i64toi32_i32$1 = $4$hi;
          HEAP32[(i64toi32_i32$2 + 8 | 0) >> 2] = $4_1;
          HEAP32[(i64toi32_i32$2 + 12 | 0) >> 2] = i64toi32_i32$1;
          global$0 = $5_1 + 112 | 0;
        }

        function $86($0_1, $1_1, $1$hi, $2_1, $2$hi, $3_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          var i64toi32_i32$1 = 0,i64toi32_i32$4 = 0,i64toi32_i32$2 = 0,i64toi32_i32$0 = 0,i64toi32_i32$3 = 0,$4$hi = 0,$18_1 = 0,$20_1 = 0,$21_1 = 0,$22_1 = 0,$11$hi = 0,$18$hi = 0,$19_1 = 0,$19$hi = 0,$4_1 = 0,$24$hi = 0;
          label$1: {
            label$2: {
              if (!($3_1 & 64 | 0)) {
                break label$2;
              }
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$0 = 0;
              $11$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$2 = $1_1;
              i64toi32_i32$1 = $11$hi;
              i64toi32_i32$3 = $3_1 + -64 | 0;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                $18_1 = 0;
              } else {
                i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$4 | 0) | 0;
                $18_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
              }
              $2_1 = $18_1;
              $2$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $1_1 = 0;
              $1$hi = i64toi32_i32$1;
              break label$1;
            }
            if (!$3_1) {
              break label$1;
            }
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$1 = 0;
            $18$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$0 = $1_1;
            i64toi32_i32$2 = $18$hi;
            i64toi32_i32$3 = 64 - $3_1 | 0;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = 0;
              $20_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
            } else {
              i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
              $20_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
            }
            $19_1 = $20_1;
            $19$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$2 = 0;
            $4_1 = $3_1;
            $4$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$1 = $2_1;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$3 = $3_1;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
              $21_1 = 0;
            } else {
              i64toi32_i32$0 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$4 | 0) | 0;
              $21_1 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
            }
            $24$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $19$hi;
            i64toi32_i32$2 = $19_1;
            i64toi32_i32$1 = $24$hi;
            i64toi32_i32$3 = $21_1;
            i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
            $2_1 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
            $2$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$0 = $1_1;
            i64toi32_i32$2 = $4$hi;
            i64toi32_i32$3 = $4_1;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
              $22_1 = 0;
            } else {
              i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
              $22_1 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
            }
            $1_1 = $22_1;
            $1$hi = i64toi32_i32$2;
          }
          i64toi32_i32$2 = $1$hi;
          i64toi32_i32$0 = $0_1;
          HEAP32[i64toi32_i32$0 >> 2] = $1_1;
          HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$2;
          i64toi32_i32$2 = $2$hi;
          HEAP32[(i64toi32_i32$0 + 8 | 0) >> 2] = $2_1;
          HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] = i64toi32_i32$2;
        }

        function $87($0_1, $0$hi, $1_1, $1$hi, $2_1, $2$hi, $3_1, $3$hi) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          $3$hi = $3$hi | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$3 = 0,i64toi32_i32$1 = 0,$4_1 = 0,$5_1 = 0,$6_1 = 0,$5$hi = 0,$6$hi = 0,$35_1 = 0,$36_1 = 0,$37_1 = 0,$38_1 = 0,$39_1 = 0,$41_1 = 0,$42_1 = 0,$43_1 = 0,$44_1 = 0,$8_1 = 0,$12_1 = 0,$17_1 = 0,$21_1 = 0,$27_1 = 0,$27$hi = 0,$30_1 = 0,$30$hi = 0,$40_1 = 0,$50_1 = 0,$50$hi = 0,$53_1 = 0,$53$hi = 0,$58_1 = 0,$68_1 = 0,$68$hi = 0,$71_1 = 0,$71$hi = 0;
          $4_1 = 1;
          label$1: {
            i64toi32_i32$0 = $0$hi;
            i64toi32_i32$2 = $0_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$3 = 0;
            $8_1 = (i64toi32_i32$2 | 0) != (i64toi32_i32$3 | 0) | (i64toi32_i32$0 | 0) != (i64toi32_i32$1 | 0) | 0;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$3 = $1_1;
            i64toi32_i32$0 = 2147483647;
            i64toi32_i32$1 = -1;
            i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
            $5_1 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
            $5$hi = i64toi32_i32$0;
            i64toi32_i32$2 = $5_1;
            i64toi32_i32$3 = 2147418112;
            i64toi32_i32$1 = 0;
            $12_1 = i64toi32_i32$0 >>> 0 > i64toi32_i32$3 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$2 >>> 0 > i64toi32_i32$1 >>> 0 | 0) | 0;
            i64toi32_i32$2 = i64toi32_i32$0;
            i64toi32_i32$2 = i64toi32_i32$0;
            i64toi32_i32$1 = $5_1;
            i64toi32_i32$0 = 2147418112;
            i64toi32_i32$3 = 0;
            if ((i64toi32_i32$1 | 0) == (i64toi32_i32$3 | 0) & (i64toi32_i32$2 | 0) == (i64toi32_i32$0 | 0) | 0 ? $8_1 : $12_1) {
              break label$1;
            }
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$3 = $2_1;
            i64toi32_i32$2 = 0;
            i64toi32_i32$0 = 0;
            $17_1 = (i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | (i64toi32_i32$1 | 0) != (i64toi32_i32$2 | 0) | 0;
            i64toi32_i32$3 = $3$hi;
            i64toi32_i32$0 = $3_1;
            i64toi32_i32$1 = 2147483647;
            i64toi32_i32$2 = -1;
            i64toi32_i32$1 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
            $6_1 = i64toi32_i32$0 & i64toi32_i32$2 | 0;
            $6$hi = i64toi32_i32$1;
            i64toi32_i32$3 = $6_1;
            i64toi32_i32$0 = 2147418112;
            i64toi32_i32$2 = 0;
            $21_1 = i64toi32_i32$1 >>> 0 > i64toi32_i32$0 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$3 >>> 0 > i64toi32_i32$2 >>> 0 | 0) | 0;
            i64toi32_i32$3 = i64toi32_i32$1;
            i64toi32_i32$2 = $6_1;
            i64toi32_i32$1 = 2147418112;
            i64toi32_i32$0 = 0;
            if ((i64toi32_i32$2 | 0) == (i64toi32_i32$0 | 0) & (i64toi32_i32$3 | 0) == (i64toi32_i32$1 | 0) | 0 ? $17_1 : $21_1) {
              break label$1;
            }
            label$2: {
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$2 = $0$hi;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$0 = $2_1;
              i64toi32_i32$3 = $0$hi;
              i64toi32_i32$1 = $0_1;
              i64toi32_i32$3 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
              $27_1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
              $27$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $6$hi;
              i64toi32_i32$3 = $5$hi;
              i64toi32_i32$3 = $6$hi;
              i64toi32_i32$2 = $6_1;
              i64toi32_i32$0 = $5$hi;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$0 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
              $30_1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
              $30$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $27$hi;
              i64toi32_i32$3 = $27_1;
              i64toi32_i32$2 = $30$hi;
              i64toi32_i32$1 = $30_1;
              i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
              if (!!(i64toi32_i32$3 | i64toi32_i32$1 | 0 | i64toi32_i32$2 | 0)) {
                break label$2;
              }
              return 0 | 0;
            }
            label$3: {
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$2 = $1$hi;
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$0 = $3_1;
              i64toi32_i32$3 = $1$hi;
              i64toi32_i32$1 = $1_1;
              i64toi32_i32$3 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
              i64toi32_i32$2 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
              i64toi32_i32$0 = 0;
              i64toi32_i32$1 = 0;
              if ((i64toi32_i32$3 | 0) < (i64toi32_i32$0 | 0)) {
                $35_1 = 1;
              } else {
                if ((i64toi32_i32$3 | 0) <= (i64toi32_i32$0 | 0)) {
                  if (i64toi32_i32$2 >>> 0 >= i64toi32_i32$1 >>> 0) {
                    $36_1 = 0;
                  } else {
                    $36_1 = 1;
                  }
                  $37_1 = $36_1;
                } else {
                  $37_1 = 0;
                }
                $35_1 = $37_1;
              }
              if ($35_1) {
                break label$3;
              }
              $4_1 = -1;
              i64toi32_i32$2 = $0$hi;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$2 = $0$hi;
              i64toi32_i32$1 = $0_1;
              i64toi32_i32$3 = $2$hi;
              i64toi32_i32$0 = $2_1;
              $40_1 = i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0;
              i64toi32_i32$1 = $1$hi;
              i64toi32_i32$1 = $3$hi;
              i64toi32_i32$1 = $1$hi;
              i64toi32_i32$0 = $1_1;
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$3 = $3_1;
              if ((i64toi32_i32$1 | 0) < (i64toi32_i32$2 | 0)) {
                $38_1 = 1;
              } else {
                if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$2 | 0)) {
                  if (i64toi32_i32$0 >>> 0 >= i64toi32_i32$3 >>> 0) {
                    $39_1 = 0;
                  } else {
                    $39_1 = 1;
                  }
                  $41_1 = $39_1;
                } else {
                  $41_1 = 0;
                }
                $38_1 = $41_1;
              }
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$0 = $3$hi;
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$3 = $1_1;
              i64toi32_i32$1 = $3$hi;
              i64toi32_i32$2 = $3_1;
              if ((i64toi32_i32$3 | 0) == (i64toi32_i32$2 | 0) & (i64toi32_i32$0 | 0) == (i64toi32_i32$1 | 0) | 0 ? $40_1 : $38_1) {
                break label$1;
              }
              i64toi32_i32$3 = $0$hi;
              i64toi32_i32$3 = $2$hi;
              i64toi32_i32$3 = $0$hi;
              i64toi32_i32$2 = $0_1;
              i64toi32_i32$0 = $2$hi;
              i64toi32_i32$1 = $2_1;
              i64toi32_i32$0 = i64toi32_i32$3 ^ i64toi32_i32$0 | 0;
              $50_1 = i64toi32_i32$2 ^ i64toi32_i32$1 | 0;
              $50$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$0 = $3$hi;
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$3 = $1_1;
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$1 = $3_1;
              i64toi32_i32$2 = i64toi32_i32$0 ^ i64toi32_i32$2 | 0;
              $53_1 = i64toi32_i32$3 ^ i64toi32_i32$1 | 0;
              $53$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $50$hi;
              i64toi32_i32$0 = $50_1;
              i64toi32_i32$3 = $53$hi;
              i64toi32_i32$1 = $53_1;
              i64toi32_i32$3 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
              i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
              i64toi32_i32$0 = 0;
              i64toi32_i32$1 = 0;
              return (i64toi32_i32$2 | 0) != (i64toi32_i32$1 | 0) | (i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | 0 | 0;
            }
            $4_1 = -1;
            i64toi32_i32$2 = $0$hi;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$2 = $0$hi;
            i64toi32_i32$1 = $0_1;
            i64toi32_i32$3 = $2$hi;
            i64toi32_i32$0 = $2_1;
            $58_1 = i64toi32_i32$2 >>> 0 > i64toi32_i32$3 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$1 >>> 0 > i64toi32_i32$0 >>> 0 | 0) | 0;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$0 = $1_1;
            i64toi32_i32$2 = $3$hi;
            i64toi32_i32$3 = $3_1;
            if ((i64toi32_i32$1 | 0) > (i64toi32_i32$2 | 0)) {
              $42_1 = 1;
            } else {
              if ((i64toi32_i32$1 | 0) >= (i64toi32_i32$2 | 0)) {
                if (i64toi32_i32$0 >>> 0 <= i64toi32_i32$3 >>> 0) {
                  $43_1 = 0;
                } else {
                  $43_1 = 1;
                }
                $44_1 = $43_1;
              } else {
                $44_1 = 0;
              }
              $42_1 = $44_1;
            }
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$0 = $3$hi;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$3 = $1_1;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$2 = $3_1;
            if ((i64toi32_i32$3 | 0) == (i64toi32_i32$2 | 0) & (i64toi32_i32$0 | 0) == (i64toi32_i32$1 | 0) | 0 ? $58_1 : $42_1) {
              break label$1;
            }
            i64toi32_i32$3 = $0$hi;
            i64toi32_i32$3 = $2$hi;
            i64toi32_i32$3 = $0$hi;
            i64toi32_i32$2 = $0_1;
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$1 = $2_1;
            i64toi32_i32$0 = i64toi32_i32$3 ^ i64toi32_i32$0 | 0;
            $68_1 = i64toi32_i32$2 ^ i64toi32_i32$1 | 0;
            $68$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$0 = $3$hi;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$3 = $1_1;
            i64toi32_i32$2 = $3$hi;
            i64toi32_i32$1 = $3_1;
            i64toi32_i32$2 = i64toi32_i32$0 ^ i64toi32_i32$2 | 0;
            $71_1 = i64toi32_i32$3 ^ i64toi32_i32$1 | 0;
            $71$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $68$hi;
            i64toi32_i32$0 = $68_1;
            i64toi32_i32$3 = $71$hi;
            i64toi32_i32$1 = $71_1;
            i64toi32_i32$3 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
            i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$1 = 0;
            $4_1 = (i64toi32_i32$2 | 0) != (i64toi32_i32$1 | 0) | (i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | 0;
          }
          return $4_1 | 0;
        }

        function $88($0_1, $0$hi, $1_1, $1$hi, $2_1, $2$hi, $3_1, $3$hi) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          $3$hi = $3$hi | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$3 = 0,i64toi32_i32$1 = 0,$5_1 = 0,$6_1 = 0,$4_1 = 0,$5$hi = 0,$6$hi = 0,$35_1 = 0,$36_1 = 0,$37_1 = 0,$38_1 = 0,$39_1 = 0,$41_1 = 0,$42_1 = 0,$43_1 = 0,$44_1 = 0,$8_1 = 0,$12_1 = 0,$17_1 = 0,$21_1 = 0,$27_1 = 0,$27$hi = 0,$30_1 = 0,$30$hi = 0,$40_1 = 0,$50_1 = 0,$50$hi = 0,$53_1 = 0,$53$hi = 0,$58_1 = 0,$68_1 = 0,$68$hi = 0,$71_1 = 0,$71$hi = 0;
          $4_1 = -1;
          label$1: {
            i64toi32_i32$0 = $0$hi;
            i64toi32_i32$2 = $0_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$3 = 0;
            $8_1 = (i64toi32_i32$2 | 0) != (i64toi32_i32$3 | 0) | (i64toi32_i32$0 | 0) != (i64toi32_i32$1 | 0) | 0;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$3 = $1_1;
            i64toi32_i32$0 = 2147483647;
            i64toi32_i32$1 = -1;
            i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
            $5_1 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
            $5$hi = i64toi32_i32$0;
            i64toi32_i32$2 = $5_1;
            i64toi32_i32$3 = 2147418112;
            i64toi32_i32$1 = 0;
            $12_1 = i64toi32_i32$0 >>> 0 > i64toi32_i32$3 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$2 >>> 0 > i64toi32_i32$1 >>> 0 | 0) | 0;
            i64toi32_i32$2 = i64toi32_i32$0;
            i64toi32_i32$2 = i64toi32_i32$0;
            i64toi32_i32$1 = $5_1;
            i64toi32_i32$0 = 2147418112;
            i64toi32_i32$3 = 0;
            if ((i64toi32_i32$1 | 0) == (i64toi32_i32$3 | 0) & (i64toi32_i32$2 | 0) == (i64toi32_i32$0 | 0) | 0 ? $8_1 : $12_1) {
              break label$1;
            }
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$3 = $2_1;
            i64toi32_i32$2 = 0;
            i64toi32_i32$0 = 0;
            $17_1 = (i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | (i64toi32_i32$1 | 0) != (i64toi32_i32$2 | 0) | 0;
            i64toi32_i32$3 = $3$hi;
            i64toi32_i32$0 = $3_1;
            i64toi32_i32$1 = 2147483647;
            i64toi32_i32$2 = -1;
            i64toi32_i32$1 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
            $6_1 = i64toi32_i32$0 & i64toi32_i32$2 | 0;
            $6$hi = i64toi32_i32$1;
            i64toi32_i32$3 = $6_1;
            i64toi32_i32$0 = 2147418112;
            i64toi32_i32$2 = 0;
            $21_1 = i64toi32_i32$1 >>> 0 > i64toi32_i32$0 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$3 >>> 0 > i64toi32_i32$2 >>> 0 | 0) | 0;
            i64toi32_i32$3 = i64toi32_i32$1;
            i64toi32_i32$2 = $6_1;
            i64toi32_i32$1 = 2147418112;
            i64toi32_i32$0 = 0;
            if ((i64toi32_i32$2 | 0) == (i64toi32_i32$0 | 0) & (i64toi32_i32$3 | 0) == (i64toi32_i32$1 | 0) | 0 ? $17_1 : $21_1) {
              break label$1;
            }
            label$2: {
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$2 = $0$hi;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$0 = $2_1;
              i64toi32_i32$3 = $0$hi;
              i64toi32_i32$1 = $0_1;
              i64toi32_i32$3 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
              $27_1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
              $27$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $6$hi;
              i64toi32_i32$3 = $5$hi;
              i64toi32_i32$3 = $6$hi;
              i64toi32_i32$2 = $6_1;
              i64toi32_i32$0 = $5$hi;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$0 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
              $30_1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
              $30$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $27$hi;
              i64toi32_i32$3 = $27_1;
              i64toi32_i32$2 = $30$hi;
              i64toi32_i32$1 = $30_1;
              i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
              if (!!(i64toi32_i32$3 | i64toi32_i32$1 | 0 | i64toi32_i32$2 | 0)) {
                break label$2;
              }
              return 0 | 0;
            }
            label$3: {
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$2 = $1$hi;
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$0 = $3_1;
              i64toi32_i32$3 = $1$hi;
              i64toi32_i32$1 = $1_1;
              i64toi32_i32$3 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
              i64toi32_i32$2 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
              i64toi32_i32$0 = 0;
              i64toi32_i32$1 = 0;
              if ((i64toi32_i32$3 | 0) < (i64toi32_i32$0 | 0)) {
                $35_1 = 1;
              } else {
                if ((i64toi32_i32$3 | 0) <= (i64toi32_i32$0 | 0)) {
                  if (i64toi32_i32$2 >>> 0 >= i64toi32_i32$1 >>> 0) {
                    $36_1 = 0;
                  } else {
                    $36_1 = 1;
                  }
                  $37_1 = $36_1;
                } else {
                  $37_1 = 0;
                }
                $35_1 = $37_1;
              }
              if ($35_1) {
                break label$3;
              }
              i64toi32_i32$2 = $0$hi;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$2 = $0$hi;
              i64toi32_i32$1 = $0_1;
              i64toi32_i32$3 = $2$hi;
              i64toi32_i32$0 = $2_1;
              $40_1 = i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0;
              i64toi32_i32$1 = $1$hi;
              i64toi32_i32$1 = $3$hi;
              i64toi32_i32$1 = $1$hi;
              i64toi32_i32$0 = $1_1;
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$3 = $3_1;
              if ((i64toi32_i32$1 | 0) < (i64toi32_i32$2 | 0)) {
                $38_1 = 1;
              } else {
                if ((i64toi32_i32$1 | 0) <= (i64toi32_i32$2 | 0)) {
                  if (i64toi32_i32$0 >>> 0 >= i64toi32_i32$3 >>> 0) {
                    $39_1 = 0;
                  } else {
                    $39_1 = 1;
                  }
                  $41_1 = $39_1;
                } else {
                  $41_1 = 0;
                }
                $38_1 = $41_1;
              }
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$0 = $3$hi;
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$3 = $1_1;
              i64toi32_i32$1 = $3$hi;
              i64toi32_i32$2 = $3_1;
              if ((i64toi32_i32$3 | 0) == (i64toi32_i32$2 | 0) & (i64toi32_i32$0 | 0) == (i64toi32_i32$1 | 0) | 0 ? $40_1 : $38_1) {
                break label$1;
              }
              i64toi32_i32$3 = $0$hi;
              i64toi32_i32$3 = $2$hi;
              i64toi32_i32$3 = $0$hi;
              i64toi32_i32$2 = $0_1;
              i64toi32_i32$0 = $2$hi;
              i64toi32_i32$1 = $2_1;
              i64toi32_i32$0 = i64toi32_i32$3 ^ i64toi32_i32$0 | 0;
              $50_1 = i64toi32_i32$2 ^ i64toi32_i32$1 | 0;
              $50$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$0 = $3$hi;
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$3 = $1_1;
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$1 = $3_1;
              i64toi32_i32$2 = i64toi32_i32$0 ^ i64toi32_i32$2 | 0;
              $53_1 = i64toi32_i32$3 ^ i64toi32_i32$1 | 0;
              $53$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $50$hi;
              i64toi32_i32$0 = $50_1;
              i64toi32_i32$3 = $53$hi;
              i64toi32_i32$1 = $53_1;
              i64toi32_i32$3 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
              i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
              i64toi32_i32$0 = 0;
              i64toi32_i32$1 = 0;
              return (i64toi32_i32$2 | 0) != (i64toi32_i32$1 | 0) | (i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | 0 | 0;
            }
            i64toi32_i32$2 = $0$hi;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$2 = $0$hi;
            i64toi32_i32$1 = $0_1;
            i64toi32_i32$3 = $2$hi;
            i64toi32_i32$0 = $2_1;
            $58_1 = i64toi32_i32$2 >>> 0 > i64toi32_i32$3 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$1 >>> 0 > i64toi32_i32$0 >>> 0 | 0) | 0;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$0 = $1_1;
            i64toi32_i32$2 = $3$hi;
            i64toi32_i32$3 = $3_1;
            if ((i64toi32_i32$1 | 0) > (i64toi32_i32$2 | 0)) {
              $42_1 = 1;
            } else {
              if ((i64toi32_i32$1 | 0) >= (i64toi32_i32$2 | 0)) {
                if (i64toi32_i32$0 >>> 0 <= i64toi32_i32$3 >>> 0) {
                  $43_1 = 0;
                } else {
                  $43_1 = 1;
                }
                $44_1 = $43_1;
              } else {
                $44_1 = 0;
              }
              $42_1 = $44_1;
            }
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$0 = $3$hi;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$3 = $1_1;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$2 = $3_1;
            if ((i64toi32_i32$3 | 0) == (i64toi32_i32$2 | 0) & (i64toi32_i32$0 | 0) == (i64toi32_i32$1 | 0) | 0 ? $58_1 : $42_1) {
              break label$1;
            }
            i64toi32_i32$3 = $0$hi;
            i64toi32_i32$3 = $2$hi;
            i64toi32_i32$3 = $0$hi;
            i64toi32_i32$2 = $0_1;
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$1 = $2_1;
            i64toi32_i32$0 = i64toi32_i32$3 ^ i64toi32_i32$0 | 0;
            $68_1 = i64toi32_i32$2 ^ i64toi32_i32$1 | 0;
            $68$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$0 = $3$hi;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$3 = $1_1;
            i64toi32_i32$2 = $3$hi;
            i64toi32_i32$1 = $3_1;
            i64toi32_i32$2 = i64toi32_i32$0 ^ i64toi32_i32$2 | 0;
            $71_1 = i64toi32_i32$3 ^ i64toi32_i32$1 | 0;
            $71$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $68$hi;
            i64toi32_i32$0 = $68_1;
            i64toi32_i32$3 = $71$hi;
            i64toi32_i32$1 = $71_1;
            i64toi32_i32$3 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
            i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$1 = 0;
            $4_1 = (i64toi32_i32$2 | 0) != (i64toi32_i32$1 | 0) | (i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | 0;
          }
          return $4_1 | 0;
        }

        function $89($0_1, $1_1, $1$hi, $2_1, $2$hi, $3_1, $3$hi, $4_1, $4$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          $3$hi = $3$hi | 0;
          $4_1 = $4_1 | 0;
          $4$hi = $4$hi | 0;
          var i64toi32_i32$3 = 0,i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$5 = 0,i64toi32_i32$4 = 0,$5_1 = 0,$11$hi = 0,i64toi32_i32$6 = 0,$11_1 = 0,$10$hi = 0,$13$hi = 0,$10_1 = 0,$16$hi = 0,$12$hi = 0,$13_1 = 0,$17$hi = 0,$21$hi = 0,$12_1 = 0,$6_1 = 0,$16_1 = 0,$21_1 = 0,$14$hi = 0,$15$hi = 0,$8_1 = 0,$17_1 = 0,$18$hi = 0,$14_1 = 0,$15_1 = 0,$18_1 = 0,$22_1 = 0,$22$hi = 0,$24$hi = 0,$9_1 = 0,$19_1 = 0,$19$hi = 0,$322 = 0,$323 = 0,$7_1 = 0,$324 = 0,$325 = 0,$326 = 0,$327 = 0,$328 = 0,$329 = 0,$331 = 0,$332 = 0,$333 = 0,$334 = 0,$336 = 0,$337 = 0,$338 = 0,$339 = 0,$341 = 0,$342 = 0,$344 = 0,$345 = 0,$20_1 = 0,$20$hi = 0,$346 = 0,$347 = 0,$348 = 0,$350 = 0,$351 = 0,$352 = 0,$353 = 0,$355 = 0,$23_1 = 0,$23$hi = 0,$356 = 0,$357 = 0,$358 = 0,$359 = 0,$24_1 = 0,$360 = 0,$362 = 0,$363 = 0,$364 = 0,$365 = 0,$368 = 0,$369 = 0,$371 = 0,$372 = 0,$374 = 0,$375 = 0,$376 = 0,$377 = 0,$378 = 0,$380 = 0,$381 = 0,$382 = 0,$51_1 = 0,$55_1 = 0,$62_1 = 0,$66_1 = 0,$75_1 = 0,$75$hi = 0,$80_1 = 0,$80$hi = 0,$88_1 = 0,$88$hi = 0,$110_1 = 0,$111_1 = 0,$111$hi = 0,$112_1 = 0,$112$hi = 0,$119$hi = 0,$122$hi = 0,$137 = 0,$138 = 0,$138$hi = 0,$139 = 0,$139$hi = 0,$146$hi = 0,$149$hi = 0,$164 = 0,$166 = 0,$166$hi = 0,$170$hi = 0,$181 = 0,$181$hi = 0,$182$hi = 0,$185 = 0,$188 = 0,$188$hi = 0,$193$hi = 0,$203 = 0,$203$hi = 0,$204$hi = 0,$206 = 0,$209 = 0,$209$hi = 0,$214$hi = 0,$224 = 0,$224$hi = 0,$225$hi = 0,$227 = 0,$230 = 0,$230$hi = 0,$235$hi = 0,$245 = 0,$245$hi = 0,$246$hi = 0,$248 = 0,$249 = 0,$249$hi = 0,$252 = 0,$252$hi = 0,$257$hi = 0,$262 = 0,$264$hi = 0,$267 = 0,$268 = 0,$268$hi = 0,$272 = 0,$272$hi = 0,$279 = 0,$279$hi = 0,$283 = 0,$284$hi = 0,$285$hi = 0,$287 = 0,$288$hi = 0,$289$hi = 0,$290$hi = 0,$294$hi = 0,$305 = 0,$305$hi = 0,$308 = 0,$308$hi = 0,$314$hi = 0,$315 = 0,$315$hi = 0,$321 = 0,$321$hi = 0,$330 = 0,$330$hi = 0,$335 = 0,$335$hi = 0,$340 = 0,$340$hi = 0,$342$hi = 0,$343 = 0,$343$hi = 0,$345$hi = 0,$346$hi = 0,$349 = 0,$350$hi = 0,$351$hi = 0,$354 = 0,$355$hi = 0,$361 = 0,$361$hi = 0,$366 = 0,$366$hi = 0,$367 = 0,$367$hi = 0,$370 = 0,$370$hi = 0,$373 = 0,$373$hi = 0,$375$hi = 0,$379 = 0,$379$hi = 0,$383 = 0,$384$hi = 0,$385$hi = 0,$388 = 0,$388$hi = 0,$389 = 0,$389$hi = 0,$396 = 0,$396$hi = 0,$402 = 0,$402$hi = 0,$404$hi = 0,$405 = 0,$405$hi = 0,$406 = 0,$406$hi = 0,$407 = 0,$407$hi = 0,$409$hi = 0,$413 = 0,$414$hi = 0,$415 = 0,$415$hi = 0,$416 = 0,$416$hi = 0,$425 = 0,$425$hi = 0,$429 = 0,$430 = 0,$430$hi = 0,$436 = 0,$436$hi = 0,$440 = 0,$441$hi = 0,$442$hi = 0,$446 = 0,$447$hi = 0,$448 = 0,$448$hi = 0,$449 = 0,$449$hi = 0,$456 = 0,$456$hi = 0,$461 = 0,$461$hi = 0,$466 = 0,$466$hi = 0,$469 = 0,$469$hi = 0,$472 = 0,$473$hi = 0,$476 = 0,$477$hi = 0,$478$hi = 0,$481 = 0,$482$hi = 0,$484$hi = 0,$485 = 0,$485$hi = 0,$489 = 0,$490$hi = 0,$491 = 0,$491$hi = 0,$492 = 0,$492$hi = 0,$493 = 0,$493$hi = 0,$500 = 0,$500$hi = 0,$503 = 0,$503$hi = 0,$506 = 0,$508$hi = 0,$509 = 0,$509$hi = 0,$514 = 0,$514$hi = 0,$515 = 0,$515$hi = 0,$517$hi = 0,$518$hi = 0,$520 = 0,$521$hi = 0,$522$hi = 0,$526 = 0,$527$hi = 0,$541$hi = 0,$545 = 0,$545$hi = 0,$546$hi = 0,$550 = 0,$551$hi = 0,$558 = 0,$560 = 0,$560$hi = 0,$562$hi = 0,$564 = 0,$564$hi = 0,$571$hi = 0,$575 = 0,$575$hi = 0,$576$hi = 0,$580 = 0,$581$hi = 0,$595 = 0,$595$hi = 0,$597$hi = 0,$601$hi = 0,$603 = 0,$603$hi = 0,$636 = 0,$636$hi = 0,$641 = 0,$641$hi = 0,$645$hi = 0,$646 = 0,$646$hi = 0,$647 = 0,$647$hi = 0,$650 = 0,$650$hi = 0,$654 = 0,$655$hi = 0,$667 = 0,$667$hi = 0,$668 = 0,$668$hi = 0,$676 = 0,$680 = 0,$681$hi = 0,$685 = 0,$689 = 0,$690$hi = 0,$694 = 0,$695$hi = 0,$697 = 0,$697$hi = 0,$700 = 0,$703 = 0,$703$hi = 0,$704 = 0,$711 = 0,$716 = 0,$717$hi = 0,$721 = 0,$722$hi = 0,$724 = 0,$724$hi = 0,$727 = 0,$730 = 0,$730$hi = 0,$731 = 0,$737 = 0,$742 = 0,$743$hi = 0,$747 = 0,$748$hi = 0,$749$hi = 0;
          $5_1 = global$0 - 336 | 0;
          global$0 = $5_1;
          i64toi32_i32$0 = $4$hi;
          i64toi32_i32$2 = $4_1;
          i64toi32_i32$1 = 65535;
          i64toi32_i32$3 = -1;
          i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
          $10_1 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
          $10$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $2$hi;
          i64toi32_i32$0 = $2_1;
          i64toi32_i32$2 = 65535;
          i64toi32_i32$3 = -1;
          i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
          $11_1 = i64toi32_i32$0 & i64toi32_i32$3 | 0;
          $11$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $4$hi;
          i64toi32_i32$2 = i64toi32_i32$1;
          i64toi32_i32$2 = $4$hi;
          i64toi32_i32$1 = $4_1;
          i64toi32_i32$0 = $2$hi;
          i64toi32_i32$3 = $2_1;
          i64toi32_i32$0 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
          i64toi32_i32$2 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
          i64toi32_i32$1 = -2147483648;
          i64toi32_i32$3 = 0;
          i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
          $12_1 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
          $12$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $4$hi;
          i64toi32_i32$0 = $4_1;
          i64toi32_i32$2 = 0;
          i64toi32_i32$3 = 48;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$2 = 0;
            $322 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
          } else {
            i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
            $322 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
          }
          $6_1 = $322 & 32767 | 0;
          label$1: {
            label$2: {
              label$3: {
                i64toi32_i32$2 = $2$hi;
                i64toi32_i32$1 = $2_1;
                i64toi32_i32$0 = 0;
                i64toi32_i32$3 = 48;
                i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                  i64toi32_i32$0 = 0;
                  $323 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                } else {
                  i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                  $323 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
                }
                $7_1 = $323 & 32767 | 0;
                if (($7_1 + -32767 | 0) >>> 0 < -32766 >>> 0) {
                  break label$3;
                }
                $8_1 = 0;
                if (($6_1 + -32767 | 0) >>> 0 > -32767 >>> 0) {
                  break label$2;
                }
              }
              label$4: {
                i64toi32_i32$0 = $1$hi;
                $51_1 = !($1_1 | i64toi32_i32$0 | 0);
                i64toi32_i32$0 = $2$hi;
                i64toi32_i32$2 = $2_1;
                i64toi32_i32$1 = 2147483647;
                i64toi32_i32$3 = -1;
                i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
                $13_1 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
                $13$hi = i64toi32_i32$1;
                i64toi32_i32$0 = $13_1;
                i64toi32_i32$2 = 2147418112;
                i64toi32_i32$3 = 0;
                $55_1 = i64toi32_i32$1 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$0 >>> 0 < i64toi32_i32$3 >>> 0 | 0) | 0;
                i64toi32_i32$0 = i64toi32_i32$1;
                i64toi32_i32$3 = $13_1;
                i64toi32_i32$1 = 2147418112;
                i64toi32_i32$2 = 0;
                if ((i64toi32_i32$3 | 0) == (i64toi32_i32$2 | 0) & (i64toi32_i32$0 | 0) == (i64toi32_i32$1 | 0) | 0 ? $51_1 : $55_1) {
                  break label$4;
                }
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$2 = $2_1;
                i64toi32_i32$0 = 32768;
                i64toi32_i32$1 = 0;
                i64toi32_i32$0 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
                $12_1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
                $12$hi = i64toi32_i32$0;
                break label$1;
              }
              label$5: {
                i64toi32_i32$0 = $3$hi;
                $62_1 = !($3_1 | i64toi32_i32$0 | 0);
                i64toi32_i32$0 = $4$hi;
                i64toi32_i32$3 = $4_1;
                i64toi32_i32$2 = 2147483647;
                i64toi32_i32$1 = -1;
                i64toi32_i32$2 = i64toi32_i32$0 & i64toi32_i32$2 | 0;
                $2_1 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
                $2$hi = i64toi32_i32$2;
                i64toi32_i32$0 = $2_1;
                i64toi32_i32$3 = 2147418112;
                i64toi32_i32$1 = 0;
                $66_1 = i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$0 = i64toi32_i32$2;
                i64toi32_i32$1 = $2_1;
                i64toi32_i32$2 = 2147418112;
                i64toi32_i32$3 = 0;
                if ((i64toi32_i32$1 | 0) == (i64toi32_i32$3 | 0) & (i64toi32_i32$0 | 0) == (i64toi32_i32$2 | 0) | 0 ? $62_1 : $66_1) {
                  break label$5;
                }
                i64toi32_i32$1 = $4$hi;
                i64toi32_i32$3 = $4_1;
                i64toi32_i32$0 = 32768;
                i64toi32_i32$2 = 0;
                i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
                $12_1 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
                $12$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $3$hi;
                $1_1 = $3_1;
                $1$hi = i64toi32_i32$0;
                break label$1;
              }
              label$6: {
                i64toi32_i32$0 = $1$hi;
                i64toi32_i32$0 = $13$hi;
                i64toi32_i32$1 = $13_1;
                i64toi32_i32$3 = 2147418112;
                i64toi32_i32$2 = 0;
                i64toi32_i32$3 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
                $75_1 = i64toi32_i32$1 ^ i64toi32_i32$2 | 0;
                $75$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $1$hi;
                i64toi32_i32$0 = $1_1;
                i64toi32_i32$1 = $75$hi;
                i64toi32_i32$2 = $75_1;
                i64toi32_i32$1 = i64toi32_i32$3 | i64toi32_i32$1 | 0;
                i64toi32_i32$3 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
                i64toi32_i32$0 = 0;
                i64toi32_i32$2 = 0;
                if ((i64toi32_i32$3 | 0) != (i64toi32_i32$2 | 0) | (i64toi32_i32$1 | 0) != (i64toi32_i32$0 | 0) | 0) {
                  break label$6;
                }
                label$7: {
                  i64toi32_i32$3 = $3$hi;
                  i64toi32_i32$3 = $2$hi;
                  i64toi32_i32$2 = $2_1;
                  i64toi32_i32$1 = 2147418112;
                  i64toi32_i32$0 = 0;
                  i64toi32_i32$1 = i64toi32_i32$3 ^ i64toi32_i32$1 | 0;
                  $80_1 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
                  $80$hi = i64toi32_i32$1;
                  i64toi32_i32$1 = $3$hi;
                  i64toi32_i32$3 = $3_1;
                  i64toi32_i32$2 = $80$hi;
                  i64toi32_i32$0 = $80_1;
                  i64toi32_i32$2 = i64toi32_i32$1 | i64toi32_i32$2 | 0;
                  if (!!(i64toi32_i32$3 | i64toi32_i32$0 | 0 | i64toi32_i32$2 | 0)) {
                    break label$7;
                  }
                  i64toi32_i32$2 = 0;
                  $1_1 = 0;
                  $1$hi = i64toi32_i32$2;
                  i64toi32_i32$2 = 2147450880;
                  $12_1 = 0;
                  $12$hi = i64toi32_i32$2;
                  break label$1;
                }
                i64toi32_i32$2 = $12$hi;
                i64toi32_i32$1 = $12_1;
                i64toi32_i32$3 = 2147418112;
                i64toi32_i32$0 = 0;
                i64toi32_i32$3 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
                $12_1 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
                $12$hi = i64toi32_i32$3;
                i64toi32_i32$3 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$3;
                break label$1;
              }
              label$8: {
                i64toi32_i32$3 = $3$hi;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$2 = $2_1;
                i64toi32_i32$1 = 2147418112;
                i64toi32_i32$0 = 0;
                i64toi32_i32$1 = i64toi32_i32$3 ^ i64toi32_i32$1 | 0;
                $88_1 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
                $88$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$3 = $3_1;
                i64toi32_i32$2 = $88$hi;
                i64toi32_i32$0 = $88_1;
                i64toi32_i32$2 = i64toi32_i32$1 | i64toi32_i32$2 | 0;
                i64toi32_i32$1 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
                i64toi32_i32$3 = 0;
                i64toi32_i32$0 = 0;
                if ((i64toi32_i32$1 | 0) != (i64toi32_i32$0 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$3 | 0) | 0) {
                  break label$8;
                }
                i64toi32_i32$1 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$1;
                break label$1;
              }
              label$9: {
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$1 = $13$hi;
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$0 = $1_1;
                i64toi32_i32$2 = $13$hi;
                i64toi32_i32$3 = $13_1;
                i64toi32_i32$2 = i64toi32_i32$1 | i64toi32_i32$2 | 0;
                i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$3 | 0;
                i64toi32_i32$0 = 0;
                i64toi32_i32$3 = 0;
                if ((i64toi32_i32$1 | 0) != (i64toi32_i32$3 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$0 | 0) | 0) {
                  break label$9;
                }
                i64toi32_i32$1 = $12$hi;
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$3 = $3_1;
                i64toi32_i32$2 = $2$hi;
                i64toi32_i32$0 = $2_1;
                i64toi32_i32$2 = i64toi32_i32$1 | i64toi32_i32$2 | 0;
                i64toi32_i32$4 = !(i64toi32_i32$3 | i64toi32_i32$0 | 0 | i64toi32_i32$2 | 0);
                i64toi32_i32$2 = 2147450880;
                i64toi32_i32$3 = $12$hi;
                i64toi32_i32$0 = i64toi32_i32$4 ? 0 : $12_1;
                i64toi32_i32$1 = i64toi32_i32$4 ? i64toi32_i32$2 : i64toi32_i32$3;
                $12_1 = i64toi32_i32$0;
                $12$hi = i64toi32_i32$1;
                i64toi32_i32$1 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$1;
                break label$1;
              }
              label$10: {
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$4 = $3_1;
                i64toi32_i32$0 = $2$hi;
                i64toi32_i32$2 = $2_1;
                i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
                i64toi32_i32$1 = i64toi32_i32$4 | i64toi32_i32$2 | 0;
                i64toi32_i32$4 = 0;
                i64toi32_i32$2 = 0;
                if ((i64toi32_i32$1 | 0) != (i64toi32_i32$2 | 0) | (i64toi32_i32$0 | 0) != (i64toi32_i32$4 | 0) | 0) {
                  break label$10;
                }
                i64toi32_i32$1 = $12$hi;
                i64toi32_i32$2 = $12_1;
                i64toi32_i32$0 = 2147418112;
                i64toi32_i32$4 = 0;
                i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
                $12_1 = i64toi32_i32$2 | i64toi32_i32$4 | 0;
                $12$hi = i64toi32_i32$0;
                i64toi32_i32$0 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$0;
                break label$1;
              }
              $8_1 = 0;
              label$11: {
                i64toi32_i32$0 = $13$hi;
                i64toi32_i32$1 = $13_1;
                i64toi32_i32$2 = 65535;
                i64toi32_i32$4 = -1;
                if (i64toi32_i32$0 >>> 0 > i64toi32_i32$2 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$1 >>> 0 > i64toi32_i32$4 >>> 0 | 0) | 0) {
                  break label$11;
                }
                $110_1 = $5_1 + 320 | 0;
                i64toi32_i32$1 = $1$hi;
                $111_1 = $1_1;
                $111$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $11$hi;
                $112_1 = $11_1;
                $112$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$1 = $11$hi;
                $8_1 = !($11_1 | i64toi32_i32$1 | 0);
                i64toi32_i32$3 = $8_1;
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$0 = $11$hi;
                i64toi32_i32$2 = i64toi32_i32$3 ? $1_1 : $11_1;
                i64toi32_i32$4 = i64toi32_i32$3 ? i64toi32_i32$1 : i64toi32_i32$0;
                i64toi32_i32$1 = Math_clz32(i64toi32_i32$4);
                i64toi32_i32$3 = 0;
                if ((i64toi32_i32$1 | 0) == (32 | 0)) {
                  $324 = Math_clz32(i64toi32_i32$2) + 32 | 0;
                } else {
                  $324 = i64toi32_i32$1;
                }
                $119$hi = i64toi32_i32$3;
                i64toi32_i32$3 = 0;
                $122$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $119$hi;
                i64toi32_i32$2 = $324;
                i64toi32_i32$4 = $122$hi;
                i64toi32_i32$1 = $8_1 << 6 | 0;
                i64toi32_i32$0 = i64toi32_i32$2 + i64toi32_i32$1 | 0;
                i64toi32_i32$5 = i64toi32_i32$3 + i64toi32_i32$4 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $8_1 = i64toi32_i32$0;
                i64toi32_i32$5 = $111$hi;
                i64toi32_i32$2 = $112$hi;
                $86($110_1 | 0, $111_1 | 0, i64toi32_i32$5 | 0, $112_1 | 0, i64toi32_i32$2 | 0, i64toi32_i32$0 + -15 | 0 | 0);
                $8_1 = 16 - i64toi32_i32$0 | 0;
                i64toi32_i32$3 = $5_1 + 328 | 0;
                i64toi32_i32$2 = HEAP32[i64toi32_i32$3 >> 2] | 0;
                i64toi32_i32$5 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
                $11_1 = i64toi32_i32$2;
                $11$hi = i64toi32_i32$5;
                i64toi32_i32$3 = $5_1;
                i64toi32_i32$5 = HEAP32[(i64toi32_i32$3 + 320 | 0) >> 2] | 0;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 324 | 0) >> 2] | 0;
                $1_1 = i64toi32_i32$5;
                $1$hi = i64toi32_i32$2;
              }
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$3 = $2_1;
              i64toi32_i32$5 = 65535;
              i64toi32_i32$1 = -1;
              if (i64toi32_i32$2 >>> 0 > i64toi32_i32$5 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$3 >>> 0 > i64toi32_i32$1 >>> 0 | 0) | 0) {
                break label$2;
              }
              $137 = $5_1 + 304 | 0;
              i64toi32_i32$3 = $3$hi;
              $138 = $3_1;
              $138$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $10$hi;
              $139 = $10_1;
              $139$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $3$hi;
              i64toi32_i32$3 = $10$hi;
              $9_1 = !($10_1 | i64toi32_i32$3 | 0);
              i64toi32_i32$4 = $9_1;
              i64toi32_i32$3 = $3$hi;
              i64toi32_i32$2 = $10$hi;
              i64toi32_i32$5 = i64toi32_i32$4 ? $3_1 : $10_1;
              i64toi32_i32$1 = i64toi32_i32$4 ? i64toi32_i32$3 : i64toi32_i32$2;
              i64toi32_i32$3 = Math_clz32(i64toi32_i32$1);
              i64toi32_i32$4 = 0;
              if ((i64toi32_i32$3 | 0) == (32 | 0)) {
                $325 = Math_clz32(i64toi32_i32$5) + 32 | 0;
              } else {
                $325 = i64toi32_i32$3;
              }
              $146$hi = i64toi32_i32$4;
              i64toi32_i32$4 = 0;
              $149$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $146$hi;
              i64toi32_i32$5 = $325;
              i64toi32_i32$1 = $149$hi;
              i64toi32_i32$3 = $9_1 << 6 | 0;
              i64toi32_i32$2 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
              i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
              if (i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
              }
              $9_1 = i64toi32_i32$2;
              i64toi32_i32$0 = $138$hi;
              i64toi32_i32$5 = $139$hi;
              $86($137 | 0, $138 | 0, i64toi32_i32$0 | 0, $139 | 0, i64toi32_i32$5 | 0, i64toi32_i32$2 + -15 | 0 | 0);
              $8_1 = (i64toi32_i32$2 + $8_1 | 0) + -16 | 0;
              i64toi32_i32$4 = $5_1 + 312 | 0;
              i64toi32_i32$5 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $10_1 = i64toi32_i32$5;
              $10$hi = i64toi32_i32$0;
              i64toi32_i32$4 = $5_1;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$4 + 304 | 0) >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$4 + 308 | 0) >> 2] | 0;
              $3_1 = i64toi32_i32$0;
              $3$hi = i64toi32_i32$5;
            }
            $164 = $5_1 + 288 | 0;
            i64toi32_i32$5 = $3$hi;
            i64toi32_i32$4 = $3_1;
            i64toi32_i32$0 = 0;
            i64toi32_i32$3 = 49;
            i64toi32_i32$1 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = 0;
              $326 = i64toi32_i32$5 >>> i64toi32_i32$1 | 0;
            } else {
              i64toi32_i32$0 = i64toi32_i32$5 >>> i64toi32_i32$1 | 0;
              $326 = (((1 << i64toi32_i32$1 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$1 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$1 | 0) | 0;
            }
            $166 = $326;
            $166$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $10$hi;
            i64toi32_i32$5 = $10_1;
            i64toi32_i32$4 = 65536;
            i64toi32_i32$3 = 0;
            i64toi32_i32$4 = i64toi32_i32$0 | i64toi32_i32$4 | 0;
            $14_1 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
            $14$hi = i64toi32_i32$4;
            i64toi32_i32$0 = $14_1;
            i64toi32_i32$5 = 0;
            i64toi32_i32$3 = 15;
            i64toi32_i32$1 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$5 = i64toi32_i32$0 << i64toi32_i32$1 | 0;
              $327 = 0;
            } else {
              i64toi32_i32$5 = ((1 << i64toi32_i32$1 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$1 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$1 | 0) | 0;
              $327 = i64toi32_i32$0 << i64toi32_i32$1 | 0;
            }
            $170$hi = i64toi32_i32$5;
            i64toi32_i32$5 = $166$hi;
            i64toi32_i32$4 = $166;
            i64toi32_i32$0 = $170$hi;
            i64toi32_i32$3 = $327;
            i64toi32_i32$0 = i64toi32_i32$5 | i64toi32_i32$0 | 0;
            $2_1 = i64toi32_i32$4 | i64toi32_i32$3 | 0;
            $2$hi = i64toi32_i32$0;
            i64toi32_i32$0 = 1963258675;
            i64toi32_i32$5 = 0;
            i64toi32_i32$4 = $2$hi;
            i64toi32_i32$3 = $2_1;
            i64toi32_i32$1 = i64toi32_i32$5 - i64toi32_i32$3 | 0;
            i64toi32_i32$6 = i64toi32_i32$5 >>> 0 < i64toi32_i32$3 >>> 0;
            i64toi32_i32$2 = i64toi32_i32$6 + i64toi32_i32$4 | 0;
            i64toi32_i32$2 = i64toi32_i32$0 - i64toi32_i32$2 | 0;
            $4_1 = i64toi32_i32$1;
            $4$hi = i64toi32_i32$2;
            i64toi32_i32$2 = i64toi32_i32$4;
            i64toi32_i32$5 = 0;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$3 = 0;
            $98($164 | 0, $2_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$5 | 0, i64toi32_i32$1 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$3 | 0);
            i64toi32_i32$5 = ($5_1 + 288 | 0) + 8 | 0;
            i64toi32_i32$3 = HEAP32[i64toi32_i32$5 >> 2] | 0;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
            $181 = i64toi32_i32$3;
            $181$hi = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$5 = 0;
            i64toi32_i32$3 = $181$hi;
            i64toi32_i32$2 = $181;
            i64toi32_i32$4 = i64toi32_i32$5 - i64toi32_i32$2 | 0;
            i64toi32_i32$6 = i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0;
            i64toi32_i32$1 = i64toi32_i32$6 + i64toi32_i32$3 | 0;
            i64toi32_i32$1 = i64toi32_i32$0 - i64toi32_i32$1 | 0;
            $182$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$1 = $182$hi;
            i64toi32_i32$5 = 0;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$2 = 0;
            $98($5_1 + 272 | 0 | 0, i64toi32_i32$4 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$5 | 0, $4_1 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$2 | 0);
            $185 = $5_1 + 256 | 0;
            i64toi32_i32$5 = $5_1;
            i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 272 | 0) >> 2] | 0;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$5 + 276 | 0) >> 2] | 0;
            i64toi32_i32$5 = i64toi32_i32$2;
            i64toi32_i32$2 = 0;
            i64toi32_i32$1 = 63;
            i64toi32_i32$3 = i64toi32_i32$1 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = 0;
              $328 = i64toi32_i32$0 >>> i64toi32_i32$3 | 0;
            } else {
              i64toi32_i32$2 = i64toi32_i32$0 >>> i64toi32_i32$3 | 0;
              $328 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$3 | 0) | 0;
            }
            $188 = $328;
            $188$hi = i64toi32_i32$2;
            i64toi32_i32$0 = ($5_1 + 272 | 0) + 8 | 0;
            i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
            i64toi32_i32$5 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
            i64toi32_i32$0 = i64toi32_i32$2;
            i64toi32_i32$2 = 0;
            i64toi32_i32$1 = 1;
            i64toi32_i32$3 = i64toi32_i32$1 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$0 << i64toi32_i32$3 | 0;
              $329 = 0;
            } else {
              i64toi32_i32$2 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$3 | 0) | 0;
              $329 = i64toi32_i32$0 << i64toi32_i32$3 | 0;
            }
            $193$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $188$hi;
            i64toi32_i32$5 = $188;
            i64toi32_i32$0 = $193$hi;
            i64toi32_i32$1 = $329;
            i64toi32_i32$0 = i64toi32_i32$2 | i64toi32_i32$0 | 0;
            $4_1 = i64toi32_i32$5 | i64toi32_i32$1 | 0;
            $4$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$5 = 0;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$1 = 0;
            $98($185 | 0, $4_1 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$5 | 0, $2_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$1 | 0);
            i64toi32_i32$1 = i64toi32_i32$0;
            i64toi32_i32$5 = ($5_1 + 256 | 0) + 8 | 0;
            i64toi32_i32$1 = HEAP32[i64toi32_i32$5 >> 2] | 0;
            i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
            $203 = i64toi32_i32$1;
            $203$hi = i64toi32_i32$2;
            i64toi32_i32$2 = 0;
            i64toi32_i32$5 = 0;
            i64toi32_i32$1 = $203$hi;
            i64toi32_i32$0 = $203;
            i64toi32_i32$3 = i64toi32_i32$5 - i64toi32_i32$0 | 0;
            i64toi32_i32$6 = i64toi32_i32$5 >>> 0 < i64toi32_i32$0 >>> 0;
            i64toi32_i32$4 = i64toi32_i32$6 + i64toi32_i32$1 | 0;
            i64toi32_i32$4 = i64toi32_i32$2 - i64toi32_i32$4 | 0;
            $204$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $4$hi;
            i64toi32_i32$5 = 0;
            i64toi32_i32$2 = $204$hi;
            i64toi32_i32$0 = 0;
            $98($5_1 + 240 | 0 | 0, $4_1 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$5 | 0, i64toi32_i32$3 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$0 | 0);
            $206 = $5_1 + 224 | 0;
            i64toi32_i32$5 = $5_1;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$5 + 240 | 0) >> 2] | 0;
            i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 244 | 0) >> 2] | 0;
            i64toi32_i32$5 = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$4 = 63;
            i64toi32_i32$1 = i64toi32_i32$4 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = 0;
              $331 = i64toi32_i32$2 >>> i64toi32_i32$1 | 0;
            } else {
              i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$1 | 0;
              $331 = (((1 << i64toi32_i32$1 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$1 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$1 | 0) | 0;
            }
            $209 = $331;
            $209$hi = i64toi32_i32$0;
            i64toi32_i32$2 = ($5_1 + 240 | 0) + 8 | 0;
            i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
            i64toi32_i32$5 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
            i64toi32_i32$2 = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$4 = 1;
            i64toi32_i32$1 = i64toi32_i32$4 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$2 << i64toi32_i32$1 | 0;
              $332 = 0;
            } else {
              i64toi32_i32$0 = ((1 << i64toi32_i32$1 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$1 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$1 | 0) | 0;
              $332 = i64toi32_i32$2 << i64toi32_i32$1 | 0;
            }
            $214$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $209$hi;
            i64toi32_i32$5 = $209;
            i64toi32_i32$2 = $214$hi;
            i64toi32_i32$4 = $332;
            i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
            $4_1 = i64toi32_i32$5 | i64toi32_i32$4 | 0;
            $4$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$2 = $4$hi;
            i64toi32_i32$5 = 0;
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$4 = 0;
            $98($206 | 0, $4_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$5 | 0, $2_1 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$4 | 0);
            i64toi32_i32$4 = i64toi32_i32$2;
            i64toi32_i32$5 = ($5_1 + 224 | 0) + 8 | 0;
            i64toi32_i32$4 = HEAP32[i64toi32_i32$5 >> 2] | 0;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
            $224 = i64toi32_i32$4;
            $224$hi = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$5 = 0;
            i64toi32_i32$4 = $224$hi;
            i64toi32_i32$2 = $224;
            i64toi32_i32$1 = i64toi32_i32$5 - i64toi32_i32$2 | 0;
            i64toi32_i32$6 = i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0;
            i64toi32_i32$3 = i64toi32_i32$6 + i64toi32_i32$4 | 0;
            i64toi32_i32$3 = i64toi32_i32$0 - i64toi32_i32$3 | 0;
            $225$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $4$hi;
            i64toi32_i32$5 = 0;
            i64toi32_i32$0 = $225$hi;
            i64toi32_i32$2 = 0;
            $98($5_1 + 208 | 0 | 0, $4_1 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$5 | 0, i64toi32_i32$1 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$2 | 0);
            $227 = $5_1 + 192 | 0;
            i64toi32_i32$5 = $5_1;
            i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 208 | 0) >> 2] | 0;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$5 + 212 | 0) >> 2] | 0;
            i64toi32_i32$5 = i64toi32_i32$2;
            i64toi32_i32$2 = 0;
            i64toi32_i32$3 = 63;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = 0;
              $333 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
            } else {
              i64toi32_i32$2 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              $333 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$4 | 0) | 0;
            }
            $230 = $333;
            $230$hi = i64toi32_i32$2;
            i64toi32_i32$0 = ($5_1 + 208 | 0) + 8 | 0;
            i64toi32_i32$2 = HEAP32[i64toi32_i32$0 >> 2] | 0;
            i64toi32_i32$5 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
            i64toi32_i32$0 = i64toi32_i32$2;
            i64toi32_i32$2 = 0;
            i64toi32_i32$3 = 1;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
              $334 = 0;
            } else {
              i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$4 | 0) | 0;
              $334 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
            }
            $235$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $230$hi;
            i64toi32_i32$5 = $230;
            i64toi32_i32$0 = $235$hi;
            i64toi32_i32$3 = $334;
            i64toi32_i32$0 = i64toi32_i32$2 | i64toi32_i32$0 | 0;
            $4_1 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
            $4$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$5 = 0;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$3 = 0;
            $98($227 | 0, $4_1 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$5 | 0, $2_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$3 | 0);
            i64toi32_i32$3 = i64toi32_i32$0;
            i64toi32_i32$5 = ($5_1 + 192 | 0) + 8 | 0;
            i64toi32_i32$3 = HEAP32[i64toi32_i32$5 >> 2] | 0;
            i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
            $245 = i64toi32_i32$3;
            $245$hi = i64toi32_i32$2;
            i64toi32_i32$2 = 0;
            i64toi32_i32$5 = 0;
            i64toi32_i32$3 = $245$hi;
            i64toi32_i32$0 = $245;
            i64toi32_i32$4 = i64toi32_i32$5 - i64toi32_i32$0 | 0;
            i64toi32_i32$6 = i64toi32_i32$5 >>> 0 < i64toi32_i32$0 >>> 0;
            i64toi32_i32$1 = i64toi32_i32$6 + i64toi32_i32$3 | 0;
            i64toi32_i32$1 = i64toi32_i32$2 - i64toi32_i32$1 | 0;
            $246$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$5 = 0;
            i64toi32_i32$2 = $246$hi;
            i64toi32_i32$0 = 0;
            $98($5_1 + 176 | 0 | 0, $4_1 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$5 | 0, i64toi32_i32$4 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$0 | 0);
            $248 = $5_1 + 160 | 0;
            i64toi32_i32$0 = $2$hi;
            $249 = $2_1;
            $249$hi = i64toi32_i32$0;
            i64toi32_i32$5 = $5_1;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$5 + 176 | 0) >> 2] | 0;
            i64toi32_i32$2 = HEAP32[(i64toi32_i32$5 + 180 | 0) >> 2] | 0;
            i64toi32_i32$5 = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$1 = 63;
            i64toi32_i32$3 = i64toi32_i32$1 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = 0;
              $336 = i64toi32_i32$2 >>> i64toi32_i32$3 | 0;
            } else {
              i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$3 | 0;
              $336 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$3 | 0) | 0;
            }
            $252 = $336;
            $252$hi = i64toi32_i32$0;
            i64toi32_i32$2 = ($5_1 + 176 | 0) + 8 | 0;
            i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
            i64toi32_i32$5 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
            i64toi32_i32$2 = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$1 = 1;
            i64toi32_i32$3 = i64toi32_i32$1 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
              $337 = 0;
            } else {
              i64toi32_i32$0 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$3 | 0) | 0;
              $337 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
            }
            $257$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $252$hi;
            i64toi32_i32$5 = $252;
            i64toi32_i32$2 = $257$hi;
            i64toi32_i32$1 = $337;
            i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
            i64toi32_i32$0 = i64toi32_i32$5 | i64toi32_i32$1 | 0;
            i64toi32_i32$5 = -1;
            i64toi32_i32$1 = -1;
            i64toi32_i32$3 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
            i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
            if (i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0) {
              i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
            }
            $4_1 = i64toi32_i32$3;
            $4$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $249$hi;
            i64toi32_i32$0 = 0;
            i64toi32_i32$2 = $4$hi;
            i64toi32_i32$1 = 0;
            $98($248 | 0, $249 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$0 | 0, i64toi32_i32$3 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$1 | 0);
            $262 = $5_1 + 144 | 0;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$0 = $3_1;
            i64toi32_i32$2 = 0;
            i64toi32_i32$4 = 15;
            i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$0 << i64toi32_i32$5 | 0;
              $338 = 0;
            } else {
              i64toi32_i32$2 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$5 | 0) | 0;
              $338 = i64toi32_i32$0 << i64toi32_i32$5 | 0;
            }
            $264$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $4$hi;
            i64toi32_i32$2 = $264$hi;
            i64toi32_i32$0 = 0;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$4 = 0;
            $98($262 | 0, $338 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$0 | 0, $4_1 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$4 | 0);
            $267 = $5_1 + 112 | 0;
            i64toi32_i32$4 = i64toi32_i32$1;
            $268 = $4_1;
            $268$hi = i64toi32_i32$1;
            i64toi32_i32$0 = ($5_1 + 160 | 0) + 8 | 0;
            i64toi32_i32$4 = HEAP32[i64toi32_i32$0 >> 2] | 0;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
            $272 = i64toi32_i32$4;
            $272$hi = i64toi32_i32$1;
            i64toi32_i32$0 = $5_1;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 160 | 0) >> 2] | 0;
            i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 164 | 0) >> 2] | 0;
            $10_1 = i64toi32_i32$1;
            $10$hi = i64toi32_i32$4;
            i64toi32_i32$0 = (i64toi32_i32$0 + 144 | 0) + 8 | 0;
            i64toi32_i32$4 = HEAP32[i64toi32_i32$0 >> 2] | 0;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
            $279 = i64toi32_i32$4;
            $279$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $10$hi;
            i64toi32_i32$0 = $10_1;
            i64toi32_i32$4 = $279$hi;
            i64toi32_i32$2 = $279;
            i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$2 | 0;
            i64toi32_i32$3 = i64toi32_i32$1 + i64toi32_i32$4 | 0;
            if (i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0) {
              i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
            }
            $2_1 = i64toi32_i32$5;
            $2$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $10$hi;
            i64toi32_i32$3 = $2$hi;
            i64toi32_i32$1 = i64toi32_i32$5;
            i64toi32_i32$0 = $10$hi;
            i64toi32_i32$2 = $10_1;
            $283 = i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
            i64toi32_i32$1 = 0;
            $284$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $272$hi;
            i64toi32_i32$2 = $272;
            i64toi32_i32$3 = $284$hi;
            i64toi32_i32$0 = $283;
            i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
            i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
            if (i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0) {
              i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
            }
            $285$hi = i64toi32_i32$5;
            i64toi32_i32$5 = $2$hi;
            i64toi32_i32$1 = $2_1;
            i64toi32_i32$2 = 0;
            i64toi32_i32$0 = 1;
            $287 = i64toi32_i32$5 >>> 0 > i64toi32_i32$2 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$1 >>> 0 > i64toi32_i32$0 >>> 0 | 0) | 0;
            i64toi32_i32$1 = 0;
            $288$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $285$hi;
            i64toi32_i32$0 = i64toi32_i32$4;
            i64toi32_i32$5 = $288$hi;
            i64toi32_i32$2 = $287;
            i64toi32_i32$3 = i64toi32_i32$0 + i64toi32_i32$2 | 0;
            i64toi32_i32$4 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
            if (i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0) {
              i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
            }
            $289$hi = i64toi32_i32$4;
            i64toi32_i32$4 = 0;
            i64toi32_i32$1 = 0;
            i64toi32_i32$0 = $289$hi;
            i64toi32_i32$2 = i64toi32_i32$3;
            i64toi32_i32$5 = i64toi32_i32$1 - i64toi32_i32$3 | 0;
            i64toi32_i32$6 = i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0;
            i64toi32_i32$3 = i64toi32_i32$6 + i64toi32_i32$0 | 0;
            i64toi32_i32$3 = i64toi32_i32$4 - i64toi32_i32$3 | 0;
            $290$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $268$hi;
            i64toi32_i32$1 = 0;
            i64toi32_i32$4 = $290$hi;
            i64toi32_i32$2 = 0;
            $98($267 | 0, $268 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$1 | 0, i64toi32_i32$5 | 0, i64toi32_i32$4 | 0, 0 | 0, i64toi32_i32$2 | 0);
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$2 = 0;
            i64toi32_i32$1 = 1;
            i64toi32_i32$4 = $2$hi;
            i64toi32_i32$3 = $2_1;
            i64toi32_i32$0 = i64toi32_i32$1 - i64toi32_i32$3 | 0;
            i64toi32_i32$6 = i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0;
            i64toi32_i32$5 = i64toi32_i32$6 + i64toi32_i32$4 | 0;
            i64toi32_i32$5 = i64toi32_i32$2 - i64toi32_i32$5 | 0;
            $294$hi = i64toi32_i32$5;
            i64toi32_i32$5 = $4$hi;
            i64toi32_i32$5 = $294$hi;
            i64toi32_i32$1 = 0;
            i64toi32_i32$2 = $4$hi;
            i64toi32_i32$3 = 0;
            $98($5_1 + 128 | 0 | 0, i64toi32_i32$0 | 0, i64toi32_i32$5 | 0, 0 | 0, i64toi32_i32$1 | 0, $4_1 | 0, i64toi32_i32$2 | 0, 0 | 0, i64toi32_i32$3 | 0);
            $6_1 = $8_1 + ($7_1 - $6_1 | 0) | 0;
            label$12: {
              label$13: {
                i64toi32_i32$1 = $5_1;
                i64toi32_i32$3 = HEAP32[(i64toi32_i32$1 + 112 | 0) >> 2] | 0;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 116 | 0) >> 2] | 0;
                $15_1 = i64toi32_i32$3;
                $15$hi = i64toi32_i32$2;
                i64toi32_i32$1 = i64toi32_i32$3;
                i64toi32_i32$3 = 0;
                i64toi32_i32$5 = 1;
                i64toi32_i32$4 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
                  $339 = 0;
                } else {
                  i64toi32_i32$3 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$4 | 0) | 0;
                  $339 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
                }
                $16_1 = $339;
                $16$hi = i64toi32_i32$3;
                $305 = $16_1;
                $305$hi = i64toi32_i32$3;
                i64toi32_i32$2 = $5_1;
                i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 128 | 0) >> 2] | 0;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 132 | 0) >> 2] | 0;
                i64toi32_i32$2 = i64toi32_i32$3;
                i64toi32_i32$3 = 0;
                i64toi32_i32$5 = 63;
                i64toi32_i32$4 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$3 = 0;
                  $341 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                } else {
                  i64toi32_i32$3 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                  $341 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
                }
                $308 = $341;
                $308$hi = i64toi32_i32$3;
                i64toi32_i32$1 = ($5_1 + 128 | 0) + 8 | 0;
                i64toi32_i32$3 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                i64toi32_i32$2 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                $17_1 = i64toi32_i32$3;
                $17$hi = i64toi32_i32$2;
                i64toi32_i32$1 = i64toi32_i32$3;
                i64toi32_i32$3 = 0;
                i64toi32_i32$5 = 1;
                i64toi32_i32$4 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
                  $342 = 0;
                } else {
                  i64toi32_i32$3 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$4 | 0) | 0;
                  $342 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
                }
                $314$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $308$hi;
                i64toi32_i32$2 = $308;
                i64toi32_i32$1 = $314$hi;
                i64toi32_i32$5 = $342;
                i64toi32_i32$1 = i64toi32_i32$3 | i64toi32_i32$1 | 0;
                $315 = i64toi32_i32$2 | i64toi32_i32$5 | 0;
                $315$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $305$hi;
                i64toi32_i32$3 = $305;
                i64toi32_i32$2 = $315$hi;
                i64toi32_i32$5 = $315;
                i64toi32_i32$4 = i64toi32_i32$3 + i64toi32_i32$5 | 0;
                i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$5 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                $13_1 = i64toi32_i32$4;
                $13$hi = i64toi32_i32$0;
                i64toi32_i32$1 = i64toi32_i32$4;
                i64toi32_i32$3 = -1;
                i64toi32_i32$5 = -13927;
                i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
                i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                }
                $18_1 = i64toi32_i32$2;
                $18$hi = i64toi32_i32$4;
                i64toi32_i32$0 = i64toi32_i32$2;
                i64toi32_i32$1 = 0;
                i64toi32_i32$5 = 32;
                i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$1 = 0;
                  $344 = i64toi32_i32$4 >>> i64toi32_i32$3 | 0;
                } else {
                  i64toi32_i32$1 = i64toi32_i32$4 >>> i64toi32_i32$3 | 0;
                  $344 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$4 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$3 | 0) | 0;
                }
                $2_1 = $344;
                $2$hi = i64toi32_i32$1;
                $321 = $2_1;
                $321$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $11$hi;
                i64toi32_i32$4 = $11_1;
                i64toi32_i32$0 = 65536;
                i64toi32_i32$5 = 0;
                i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
                $19_1 = i64toi32_i32$4 | i64toi32_i32$5 | 0;
                $19$hi = i64toi32_i32$0;
                i64toi32_i32$1 = $19_1;
                i64toi32_i32$4 = 0;
                i64toi32_i32$5 = 1;
                i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$1 << i64toi32_i32$3 | 0;
                  $345 = 0;
                } else {
                  i64toi32_i32$4 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$3 | 0) | 0;
                  $345 = i64toi32_i32$1 << i64toi32_i32$3 | 0;
                }
                $20_1 = $345;
                $20$hi = i64toi32_i32$4;
                i64toi32_i32$0 = $20_1;
                i64toi32_i32$1 = 0;
                i64toi32_i32$5 = 32;
                i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$1 = 0;
                  $346 = i64toi32_i32$4 >>> i64toi32_i32$3 | 0;
                } else {
                  i64toi32_i32$1 = i64toi32_i32$4 >>> i64toi32_i32$3 | 0;
                  $346 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$4 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$3 | 0) | 0;
                }
                $4_1 = $346;
                $4$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $321$hi;
                i64toi32_i32$0 = $4$hi;
                i64toi32_i32$0 = __wasm_i64_mul($321 | 0, i64toi32_i32$1 | 0, $4_1 | 0, i64toi32_i32$0 | 0) | 0;
                i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
                $21_1 = i64toi32_i32$0;
                $21$hi = i64toi32_i32$1;
                $330 = i64toi32_i32$0;
                $330$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$4 = $1_1;
                i64toi32_i32$0 = 0;
                i64toi32_i32$5 = 1;
                i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$4 << i64toi32_i32$3 | 0;
                  $347 = 0;
                } else {
                  i64toi32_i32$0 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$4 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$3 | 0) | 0;
                  $347 = i64toi32_i32$4 << i64toi32_i32$3 | 0;
                }
                $22_1 = $347;
                $22$hi = i64toi32_i32$0;
                i64toi32_i32$1 = $22_1;
                i64toi32_i32$4 = 0;
                i64toi32_i32$5 = 32;
                i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$4 = 0;
                  $348 = i64toi32_i32$0 >>> i64toi32_i32$3 | 0;
                } else {
                  i64toi32_i32$4 = i64toi32_i32$0 >>> i64toi32_i32$3 | 0;
                  $348 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$3 | 0) | 0;
                }
                $10_1 = $348;
                $10$hi = i64toi32_i32$4;
                $335 = $10_1;
                $335$hi = i64toi32_i32$4;
                i64toi32_i32$0 = ($5_1 + 112 | 0) + 8 | 0;
                i64toi32_i32$4 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                i64toi32_i32$0 = i64toi32_i32$4;
                i64toi32_i32$4 = 0;
                i64toi32_i32$5 = 1;
                i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$0 << i64toi32_i32$3 | 0;
                  $350 = 0;
                } else {
                  i64toi32_i32$4 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$3 | 0) | 0;
                  $350 = i64toi32_i32$0 << i64toi32_i32$3 | 0;
                }
                $340 = $350;
                $340$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $15$hi;
                i64toi32_i32$1 = $15_1;
                i64toi32_i32$0 = 0;
                i64toi32_i32$5 = 63;
                i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$0 = 0;
                  $351 = i64toi32_i32$4 >>> i64toi32_i32$3 | 0;
                } else {
                  i64toi32_i32$0 = i64toi32_i32$4 >>> i64toi32_i32$3 | 0;
                  $351 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$4 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$3 | 0) | 0;
                }
                $342$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $340$hi;
                i64toi32_i32$4 = $340;
                i64toi32_i32$1 = $342$hi;
                i64toi32_i32$5 = $351;
                i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
                $343 = i64toi32_i32$4 | i64toi32_i32$5 | 0;
                $343$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $17$hi;
                i64toi32_i32$0 = $17_1;
                i64toi32_i32$4 = 0;
                i64toi32_i32$5 = 63;
                i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$4 = 0;
                  $352 = i64toi32_i32$1 >>> i64toi32_i32$3 | 0;
                } else {
                  i64toi32_i32$4 = i64toi32_i32$1 >>> i64toi32_i32$3 | 0;
                  $352 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$3 | 0) | 0;
                }
                $345$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $343$hi;
                i64toi32_i32$1 = $343;
                i64toi32_i32$0 = $345$hi;
                i64toi32_i32$5 = $352;
                i64toi32_i32$3 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
                i64toi32_i32$2 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$5 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $346$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $13$hi;
                i64toi32_i32$2 = $16$hi;
                i64toi32_i32$2 = $13$hi;
                i64toi32_i32$4 = $13_1;
                i64toi32_i32$1 = $16$hi;
                i64toi32_i32$5 = $16_1;
                $349 = i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$4 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
                i64toi32_i32$4 = 0;
                $350$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $346$hi;
                i64toi32_i32$5 = i64toi32_i32$3;
                i64toi32_i32$2 = $350$hi;
                i64toi32_i32$1 = $349;
                i64toi32_i32$0 = i64toi32_i32$3 + i64toi32_i32$1 | 0;
                i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $351$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $18$hi;
                i64toi32_i32$3 = $13$hi;
                i64toi32_i32$3 = $18$hi;
                i64toi32_i32$4 = $18_1;
                i64toi32_i32$5 = $13$hi;
                i64toi32_i32$1 = $13_1;
                $354 = i64toi32_i32$3 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$4 = 0;
                $355$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $351$hi;
                i64toi32_i32$1 = i64toi32_i32$0;
                i64toi32_i32$3 = $355$hi;
                i64toi32_i32$5 = $354;
                i64toi32_i32$2 = i64toi32_i32$0 + i64toi32_i32$5 | 0;
                i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                i64toi32_i32$4 = i64toi32_i32$2;
                i64toi32_i32$1 = -1;
                i64toi32_i32$5 = -1;
                i64toi32_i32$3 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
                i64toi32_i32$2 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$5 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $15_1 = i64toi32_i32$3;
                $15$hi = i64toi32_i32$2;
                i64toi32_i32$0 = i64toi32_i32$3;
                i64toi32_i32$4 = 0;
                i64toi32_i32$5 = 32;
                i64toi32_i32$1 = i64toi32_i32$5 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                  i64toi32_i32$4 = 0;
                  $353 = i64toi32_i32$2 >>> i64toi32_i32$1 | 0;
                } else {
                  i64toi32_i32$4 = i64toi32_i32$2 >>> i64toi32_i32$1 | 0;
                  $353 = (((1 << i64toi32_i32$1 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$1 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$1 | 0) | 0;
                }
                $13_1 = $353;
                $13$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $335$hi;
                i64toi32_i32$0 = $13$hi;
                i64toi32_i32$0 = __wasm_i64_mul($335 | 0, i64toi32_i32$4 | 0, $13_1 | 0, i64toi32_i32$0 | 0) | 0;
                i64toi32_i32$4 = i64toi32_i32$HIGH_BITS;
                $361 = i64toi32_i32$0;
                $361$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $330$hi;
                i64toi32_i32$2 = $330;
                i64toi32_i32$0 = $361$hi;
                i64toi32_i32$5 = $361;
                i64toi32_i32$1 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
                i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $16_1 = i64toi32_i32$1;
                $16$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $21$hi;
                i64toi32_i32$3 = $16$hi;
                i64toi32_i32$4 = i64toi32_i32$1;
                i64toi32_i32$2 = $21$hi;
                i64toi32_i32$5 = $21_1;
                i64toi32_i32$4 = 0;
                $366 = i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
                $366$hi = i64toi32_i32$4;
                i64toi32_i32$4 = i64toi32_i32$3;
                $367 = i64toi32_i32$1;
                $367$hi = i64toi32_i32$3;
                i64toi32_i32$4 = $15$hi;
                i64toi32_i32$5 = $15_1;
                i64toi32_i32$3 = 0;
                i64toi32_i32$2 = -1;
                i64toi32_i32$3 = i64toi32_i32$4 & i64toi32_i32$3 | 0;
                $15_1 = i64toi32_i32$5 & i64toi32_i32$2 | 0;
                $15$hi = i64toi32_i32$3;
                $370 = $15_1;
                $370$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $1$hi;
                i64toi32_i32$4 = $1_1;
                i64toi32_i32$5 = 0;
                i64toi32_i32$2 = 63;
                i64toi32_i32$0 = i64toi32_i32$2 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                  i64toi32_i32$5 = 0;
                  $355 = i64toi32_i32$3 >>> i64toi32_i32$0 | 0;
                } else {
                  i64toi32_i32$5 = i64toi32_i32$3 >>> i64toi32_i32$0 | 0;
                  $355 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$3 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$0 | 0) | 0;
                }
                $23_1 = $355;
                $23$hi = i64toi32_i32$5;
                $373 = $23_1;
                $373$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $11$hi;
                i64toi32_i32$3 = $11_1;
                i64toi32_i32$4 = 0;
                i64toi32_i32$2 = 1;
                i64toi32_i32$0 = i64toi32_i32$2 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$3 << i64toi32_i32$0 | 0;
                  $356 = 0;
                } else {
                  i64toi32_i32$4 = ((1 << i64toi32_i32$0 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$0 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$0 | 0) | 0;
                  $356 = i64toi32_i32$3 << i64toi32_i32$0 | 0;
                }
                $375$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $373$hi;
                i64toi32_i32$5 = $373;
                i64toi32_i32$3 = $375$hi;
                i64toi32_i32$2 = $356;
                i64toi32_i32$3 = i64toi32_i32$4 | i64toi32_i32$3 | 0;
                i64toi32_i32$4 = i64toi32_i32$5 | i64toi32_i32$2 | 0;
                i64toi32_i32$5 = 0;
                i64toi32_i32$2 = -1;
                i64toi32_i32$5 = i64toi32_i32$3 & i64toi32_i32$5 | 0;
                $11_1 = i64toi32_i32$4 & i64toi32_i32$2 | 0;
                $11$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $370$hi;
                i64toi32_i32$4 = $11$hi;
                i64toi32_i32$4 = __wasm_i64_mul($370 | 0, i64toi32_i32$5 | 0, $11_1 | 0, i64toi32_i32$4 | 0) | 0;
                i64toi32_i32$5 = i64toi32_i32$HIGH_BITS;
                $379 = i64toi32_i32$4;
                $379$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $367$hi;
                i64toi32_i32$3 = $367;
                i64toi32_i32$4 = $379$hi;
                i64toi32_i32$2 = $379;
                i64toi32_i32$0 = i64toi32_i32$3 + i64toi32_i32$2 | 0;
                i64toi32_i32$1 = i64toi32_i32$5 + i64toi32_i32$4 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$2 >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
                }
                $17_1 = i64toi32_i32$0;
                $17$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $16$hi;
                i64toi32_i32$1 = $17$hi;
                i64toi32_i32$5 = i64toi32_i32$0;
                i64toi32_i32$3 = $16$hi;
                i64toi32_i32$2 = $16_1;
                $383 = i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$0 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
                i64toi32_i32$5 = 0;
                $384$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $366$hi;
                i64toi32_i32$2 = $366;
                i64toi32_i32$1 = $384$hi;
                i64toi32_i32$3 = $383;
                i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
                i64toi32_i32$0 = i64toi32_i32$5 + i64toi32_i32$1 | 0;
                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                $385$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $13$hi;
                i64toi32_i32$0 = $4$hi;
                i64toi32_i32$0 = $13$hi;
                i64toi32_i32$2 = $4$hi;
                i64toi32_i32$2 = __wasm_i64_mul($13_1 | 0, i64toi32_i32$0 | 0, $4_1 | 0, i64toi32_i32$2 | 0) | 0;
                i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
                $388 = i64toi32_i32$2;
                $388$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $385$hi;
                i64toi32_i32$5 = i64toi32_i32$4;
                i64toi32_i32$2 = $388$hi;
                i64toi32_i32$3 = $388;
                i64toi32_i32$1 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
                i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                }
                $389 = i64toi32_i32$1;
                $389$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $15$hi;
                i64toi32_i32$4 = $4$hi;
                i64toi32_i32$4 = $15$hi;
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$5 = __wasm_i64_mul($15_1 | 0, i64toi32_i32$4 | 0, $4_1 | 0, i64toi32_i32$5 | 0) | 0;
                i64toi32_i32$4 = i64toi32_i32$HIGH_BITS;
                $21_1 = i64toi32_i32$5;
                $21$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $11$hi;
                i64toi32_i32$4 = $13$hi;
                i64toi32_i32$4 = $11$hi;
                i64toi32_i32$5 = $13$hi;
                i64toi32_i32$5 = __wasm_i64_mul($11_1 | 0, i64toi32_i32$4 | 0, $13_1 | 0, i64toi32_i32$5 | 0) | 0;
                i64toi32_i32$4 = i64toi32_i32$HIGH_BITS;
                $396 = i64toi32_i32$5;
                $396$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $21$hi;
                i64toi32_i32$0 = $21_1;
                i64toi32_i32$5 = $396$hi;
                i64toi32_i32$3 = $396;
                i64toi32_i32$2 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
                i64toi32_i32$1 = i64toi32_i32$4 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
                }
                $16_1 = i64toi32_i32$2;
                $16$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $21$hi;
                i64toi32_i32$1 = $16$hi;
                i64toi32_i32$4 = i64toi32_i32$2;
                i64toi32_i32$0 = $21$hi;
                i64toi32_i32$3 = $21_1;
                i64toi32_i32$4 = 0;
                i64toi32_i32$3 = i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0 | 0) | 0;
                i64toi32_i32$1 = 0;
                i64toi32_i32$0 = 32;
                i64toi32_i32$5 = i64toi32_i32$0 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
                  $357 = 0;
                } else {
                  i64toi32_i32$1 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$5 | 0) | 0;
                  $357 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
                }
                $402 = $357;
                $402$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $16$hi;
                i64toi32_i32$4 = $16_1;
                i64toi32_i32$3 = 0;
                i64toi32_i32$0 = 32;
                i64toi32_i32$5 = i64toi32_i32$0 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                  i64toi32_i32$3 = 0;
                  $358 = i64toi32_i32$1 >>> i64toi32_i32$5 | 0;
                } else {
                  i64toi32_i32$3 = i64toi32_i32$1 >>> i64toi32_i32$5 | 0;
                  $358 = (((1 << i64toi32_i32$5 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$5 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$5 | 0) | 0;
                }
                $404$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $402$hi;
                i64toi32_i32$1 = $402;
                i64toi32_i32$4 = $404$hi;
                i64toi32_i32$0 = $358;
                i64toi32_i32$4 = i64toi32_i32$3 | i64toi32_i32$4 | 0;
                $405 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
                $405$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $389$hi;
                i64toi32_i32$3 = $389;
                i64toi32_i32$1 = $405$hi;
                i64toi32_i32$0 = $405;
                i64toi32_i32$5 = i64toi32_i32$3 + i64toi32_i32$0 | 0;
                i64toi32_i32$2 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$0 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $406 = i64toi32_i32$5;
                $406$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $17$hi;
                $407 = $17_1;
                $407$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $16$hi;
                i64toi32_i32$4 = $16_1;
                i64toi32_i32$3 = 0;
                i64toi32_i32$0 = 32;
                i64toi32_i32$1 = i64toi32_i32$0 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$4 << i64toi32_i32$1 | 0;
                  $359 = 0;
                } else {
                  i64toi32_i32$3 = ((1 << i64toi32_i32$1 | 0) - 1 | 0) & (i64toi32_i32$4 >>> (32 - i64toi32_i32$1 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$1 | 0) | 0;
                  $359 = i64toi32_i32$4 << i64toi32_i32$1 | 0;
                }
                $409$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $407$hi;
                i64toi32_i32$2 = $407;
                i64toi32_i32$4 = $409$hi;
                i64toi32_i32$0 = $359;
                i64toi32_i32$1 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
                i64toi32_i32$5 = i64toi32_i32$3 + i64toi32_i32$4 | 0;
                if (i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $16_1 = i64toi32_i32$1;
                $16$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $17$hi;
                i64toi32_i32$5 = $16$hi;
                i64toi32_i32$3 = i64toi32_i32$1;
                i64toi32_i32$2 = $17$hi;
                i64toi32_i32$0 = $17_1;
                $413 = i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0;
                i64toi32_i32$3 = 0;
                $414$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $406$hi;
                i64toi32_i32$0 = $406;
                i64toi32_i32$5 = $414$hi;
                i64toi32_i32$2 = $413;
                i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$2 | 0;
                i64toi32_i32$1 = i64toi32_i32$3 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$2 >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
                }
                $415 = i64toi32_i32$4;
                $415$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $16$hi;
                $416 = $16_1;
                $416$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $18$hi;
                i64toi32_i32$3 = $18_1;
                i64toi32_i32$0 = 0;
                i64toi32_i32$2 = -1;
                i64toi32_i32$0 = i64toi32_i32$1 & i64toi32_i32$0 | 0;
                $18_1 = i64toi32_i32$3 & i64toi32_i32$2 | 0;
                $18$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $11$hi;
                i64toi32_i32$0 = $18$hi;
                i64toi32_i32$3 = $11$hi;
                i64toi32_i32$3 = __wasm_i64_mul($18_1 | 0, i64toi32_i32$0 | 0, $11_1 | 0, i64toi32_i32$3 | 0) | 0;
                i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
                $21_1 = i64toi32_i32$3;
                $21$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $2$hi;
                i64toi32_i32$0 = $10$hi;
                i64toi32_i32$0 = $2$hi;
                i64toi32_i32$3 = $10$hi;
                i64toi32_i32$3 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$0 | 0, $10_1 | 0, i64toi32_i32$3 | 0) | 0;
                i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
                $425 = i64toi32_i32$3;
                $425$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $21$hi;
                i64toi32_i32$1 = $21_1;
                i64toi32_i32$3 = $425$hi;
                i64toi32_i32$2 = $425;
                i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
                i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                }
                $17_1 = i64toi32_i32$5;
                $17$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $21$hi;
                i64toi32_i32$4 = $17$hi;
                i64toi32_i32$0 = i64toi32_i32$5;
                i64toi32_i32$1 = $21$hi;
                i64toi32_i32$2 = $21_1;
                $429 = i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$0 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
                i64toi32_i32$0 = 0;
                $430 = $429;
                $430$hi = i64toi32_i32$0;
                i64toi32_i32$0 = i64toi32_i32$4;
                i64toi32_i32$0 = $15$hi;
                i64toi32_i32$0 = $22$hi;
                i64toi32_i32$2 = $22_1;
                i64toi32_i32$4 = 0;
                i64toi32_i32$1 = -2;
                i64toi32_i32$4 = i64toi32_i32$0 & i64toi32_i32$4 | 0;
                $21_1 = i64toi32_i32$2 & i64toi32_i32$1 | 0;
                $21$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $15$hi;
                i64toi32_i32$2 = $21$hi;
                i64toi32_i32$2 = __wasm_i64_mul($15_1 | 0, i64toi32_i32$4 | 0, $21_1 | 0, i64toi32_i32$2 | 0) | 0;
                i64toi32_i32$4 = i64toi32_i32$HIGH_BITS;
                $436 = i64toi32_i32$2;
                $436$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $17$hi;
                i64toi32_i32$0 = i64toi32_i32$5;
                i64toi32_i32$2 = $436$hi;
                i64toi32_i32$1 = $436;
                i64toi32_i32$3 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
                i64toi32_i32$5 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $24_1 = i64toi32_i32$3;
                $24$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $17$hi;
                i64toi32_i32$5 = $24$hi;
                i64toi32_i32$4 = i64toi32_i32$3;
                i64toi32_i32$0 = $17$hi;
                i64toi32_i32$1 = $17_1;
                $440 = i64toi32_i32$5 >>> 0 < i64toi32_i32$0 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$4 = 0;
                $441$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $430$hi;
                i64toi32_i32$1 = $430;
                i64toi32_i32$5 = $441$hi;
                i64toi32_i32$0 = $440;
                i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$0 | 0;
                i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$0 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $442$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $416$hi;
                i64toi32_i32$4 = $416;
                i64toi32_i32$1 = $442$hi;
                i64toi32_i32$0 = i64toi32_i32$2;
                i64toi32_i32$5 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
                i64toi32_i32$2 = i64toi32_i32$3 + i64toi32_i32$1 | 0;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$0 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $17_1 = i64toi32_i32$5;
                $17$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $16$hi;
                i64toi32_i32$2 = $17$hi;
                i64toi32_i32$3 = i64toi32_i32$5;
                i64toi32_i32$4 = $16$hi;
                i64toi32_i32$0 = $16_1;
                $446 = i64toi32_i32$2 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0;
                i64toi32_i32$3 = 0;
                $447$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $415$hi;
                i64toi32_i32$0 = $415;
                i64toi32_i32$2 = $447$hi;
                i64toi32_i32$4 = $446;
                i64toi32_i32$1 = i64toi32_i32$0 + i64toi32_i32$4 | 0;
                i64toi32_i32$5 = i64toi32_i32$3 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$1 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $448 = i64toi32_i32$1;
                $448$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $17$hi;
                $449 = $17_1;
                $449$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $18$hi;
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$5 = $18$hi;
                i64toi32_i32$0 = $4$hi;
                i64toi32_i32$0 = __wasm_i64_mul($18_1 | 0, i64toi32_i32$5 | 0, $4_1 | 0, i64toi32_i32$0 | 0) | 0;
                i64toi32_i32$5 = i64toi32_i32$HIGH_BITS;
                $16_1 = i64toi32_i32$0;
                $16$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $21$hi;
                i64toi32_i32$5 = $13$hi;
                i64toi32_i32$5 = $21$hi;
                i64toi32_i32$0 = $13$hi;
                i64toi32_i32$0 = __wasm_i64_mul($21_1 | 0, i64toi32_i32$5 | 0, $13_1 | 0, i64toi32_i32$0 | 0) | 0;
                i64toi32_i32$5 = i64toi32_i32$HIGH_BITS;
                $456 = i64toi32_i32$0;
                $456$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $16$hi;
                i64toi32_i32$3 = $16_1;
                i64toi32_i32$0 = $456$hi;
                i64toi32_i32$4 = $456;
                i64toi32_i32$2 = i64toi32_i32$3 + i64toi32_i32$4 | 0;
                i64toi32_i32$1 = i64toi32_i32$5 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
                }
                $4_1 = i64toi32_i32$2;
                $4$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$1 = $11$hi;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$3 = $11$hi;
                i64toi32_i32$3 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$1 | 0, $11_1 | 0, i64toi32_i32$3 | 0) | 0;
                i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
                $461 = i64toi32_i32$3;
                $461$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $4$hi;
                i64toi32_i32$5 = i64toi32_i32$2;
                i64toi32_i32$3 = $461$hi;
                i64toi32_i32$4 = $461;
                i64toi32_i32$0 = i64toi32_i32$2 + i64toi32_i32$4 | 0;
                i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $11_1 = i64toi32_i32$0;
                $11$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $15$hi;
                i64toi32_i32$2 = $10$hi;
                i64toi32_i32$2 = $15$hi;
                i64toi32_i32$5 = $10$hi;
                i64toi32_i32$5 = __wasm_i64_mul($15_1 | 0, i64toi32_i32$2 | 0, $10_1 | 0, i64toi32_i32$5 | 0) | 0;
                i64toi32_i32$2 = i64toi32_i32$HIGH_BITS;
                $466 = i64toi32_i32$5;
                $466$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $11$hi;
                i64toi32_i32$1 = i64toi32_i32$0;
                i64toi32_i32$5 = $466$hi;
                i64toi32_i32$4 = $466;
                i64toi32_i32$3 = i64toi32_i32$0 + i64toi32_i32$4 | 0;
                i64toi32_i32$0 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                $13_1 = i64toi32_i32$3;
                $13$hi = i64toi32_i32$0;
                i64toi32_i32$2 = i64toi32_i32$3;
                i64toi32_i32$1 = 0;
                i64toi32_i32$4 = 32;
                i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                  i64toi32_i32$1 = 0;
                  $360 = i64toi32_i32$0 >>> i64toi32_i32$5 | 0;
                } else {
                  i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$5 | 0;
                  $360 = (((1 << i64toi32_i32$5 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$5 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$5 | 0) | 0;
                }
                $469 = $360;
                $469$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $4$hi;
                i64toi32_i32$1 = $16$hi;
                i64toi32_i32$1 = $4$hi;
                i64toi32_i32$0 = $4_1;
                i64toi32_i32$2 = $16$hi;
                i64toi32_i32$4 = $16_1;
                $472 = i64toi32_i32$1 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0 | 0) | 0;
                i64toi32_i32$0 = 0;
                $473$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $11$hi;
                i64toi32_i32$0 = i64toi32_i32$1;
                i64toi32_i32$0 = $11$hi;
                i64toi32_i32$4 = $11_1;
                i64toi32_i32$2 = $4_1;
                $476 = i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$4 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
                i64toi32_i32$4 = 0;
                $477$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $473$hi;
                i64toi32_i32$2 = $472;
                i64toi32_i32$0 = $477$hi;
                i64toi32_i32$1 = $476;
                i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$1 | 0;
                i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $478$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $13$hi;
                i64toi32_i32$3 = $11$hi;
                i64toi32_i32$3 = $13$hi;
                i64toi32_i32$4 = $13_1;
                i64toi32_i32$2 = $11$hi;
                i64toi32_i32$1 = $11_1;
                $481 = i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$4 = 0;
                $482$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $478$hi;
                i64toi32_i32$1 = i64toi32_i32$5;
                i64toi32_i32$3 = $482$hi;
                i64toi32_i32$2 = $481;
                i64toi32_i32$0 = i64toi32_i32$5 + i64toi32_i32$2 | 0;
                i64toi32_i32$5 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$2 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                i64toi32_i32$4 = i64toi32_i32$0;
                i64toi32_i32$1 = 0;
                i64toi32_i32$2 = 32;
                i64toi32_i32$3 = i64toi32_i32$2 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$0 << i64toi32_i32$3 | 0;
                  $362 = 0;
                } else {
                  i64toi32_i32$1 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$4 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$3 | 0) | 0;
                  $362 = i64toi32_i32$4 << i64toi32_i32$3 | 0;
                }
                $484$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $469$hi;
                i64toi32_i32$5 = $469;
                i64toi32_i32$4 = $484$hi;
                i64toi32_i32$2 = $362;
                i64toi32_i32$4 = i64toi32_i32$1 | i64toi32_i32$4 | 0;
                $485 = i64toi32_i32$5 | i64toi32_i32$2 | 0;
                $485$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $449$hi;
                i64toi32_i32$1 = $449;
                i64toi32_i32$5 = $485$hi;
                i64toi32_i32$2 = $485;
                i64toi32_i32$3 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
                i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                $4_1 = i64toi32_i32$3;
                $4$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $17$hi;
                i64toi32_i32$0 = $4$hi;
                i64toi32_i32$4 = i64toi32_i32$3;
                i64toi32_i32$1 = $17$hi;
                i64toi32_i32$2 = $17_1;
                $489 = i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
                i64toi32_i32$4 = 0;
                $490$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $448$hi;
                i64toi32_i32$2 = $448;
                i64toi32_i32$0 = $490$hi;
                i64toi32_i32$1 = $489;
                i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$1 | 0;
                i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $491 = i64toi32_i32$5;
                $491$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $4$hi;
                $492 = $4_1;
                $492$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $24$hi;
                $493 = $24_1;
                $493$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$3 = $21$hi;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$2 = $21$hi;
                i64toi32_i32$2 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$3 | 0, $21_1 | 0, i64toi32_i32$2 | 0) | 0;
                i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
                $2_1 = i64toi32_i32$2;
                $2$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $18$hi;
                i64toi32_i32$3 = $10$hi;
                i64toi32_i32$3 = $18$hi;
                i64toi32_i32$2 = $10$hi;
                i64toi32_i32$2 = __wasm_i64_mul($18_1 | 0, i64toi32_i32$3 | 0, $10_1 | 0, i64toi32_i32$2 | 0) | 0;
                i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
                $500 = i64toi32_i32$2;
                $500$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$4 = $2_1;
                i64toi32_i32$2 = $500$hi;
                i64toi32_i32$1 = $500;
                i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
                i64toi32_i32$5 = i64toi32_i32$3 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $11_1 = i64toi32_i32$0;
                $11$hi = i64toi32_i32$5;
                i64toi32_i32$3 = i64toi32_i32$0;
                i64toi32_i32$4 = 0;
                i64toi32_i32$1 = 32;
                i64toi32_i32$2 = i64toi32_i32$1 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                  i64toi32_i32$4 = 0;
                  $363 = i64toi32_i32$5 >>> i64toi32_i32$2 | 0;
                } else {
                  i64toi32_i32$4 = i64toi32_i32$5 >>> i64toi32_i32$2 | 0;
                  $363 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$2 | 0) | 0;
                }
                $503 = $363;
                $503$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $11$hi;
                i64toi32_i32$4 = $2$hi;
                i64toi32_i32$4 = $11$hi;
                i64toi32_i32$5 = $11_1;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$1 = $2_1;
                $506 = i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$5 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$5 = 0;
                i64toi32_i32$1 = $506;
                i64toi32_i32$4 = 0;
                i64toi32_i32$3 = 32;
                i64toi32_i32$2 = i64toi32_i32$3 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$1 << i64toi32_i32$2 | 0;
                  $364 = 0;
                } else {
                  i64toi32_i32$4 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$2 | 0) | 0;
                  $364 = i64toi32_i32$1 << i64toi32_i32$2 | 0;
                }
                $508$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $503$hi;
                i64toi32_i32$5 = $503;
                i64toi32_i32$1 = $508$hi;
                i64toi32_i32$3 = $364;
                i64toi32_i32$1 = i64toi32_i32$4 | i64toi32_i32$1 | 0;
                $509 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
                $509$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $493$hi;
                i64toi32_i32$4 = $493;
                i64toi32_i32$5 = $509$hi;
                i64toi32_i32$3 = $509;
                i64toi32_i32$2 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
                i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                $2_1 = i64toi32_i32$2;
                $2$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $24$hi;
                i64toi32_i32$0 = $2$hi;
                i64toi32_i32$1 = i64toi32_i32$2;
                i64toi32_i32$4 = $24$hi;
                i64toi32_i32$3 = $24_1;
                i64toi32_i32$1 = 0;
                $514 = i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0 | 0) | 0;
                $514$hi = i64toi32_i32$1;
                i64toi32_i32$1 = i64toi32_i32$0;
                $515 = i64toi32_i32$2;
                $515$hi = i64toi32_i32$0;
                i64toi32_i32$1 = $13$hi;
                i64toi32_i32$3 = $13_1;
                i64toi32_i32$0 = 0;
                i64toi32_i32$4 = 32;
                i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
                  $365 = 0;
                } else {
                  i64toi32_i32$0 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$5 | 0) | 0;
                  $365 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
                }
                $517$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $515$hi;
                i64toi32_i32$1 = $515;
                i64toi32_i32$3 = $517$hi;
                i64toi32_i32$4 = $365;
                i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$4 | 0;
                i64toi32_i32$2 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $518$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $2$hi;
                i64toi32_i32$2 = $518$hi;
                i64toi32_i32$0 = i64toi32_i32$5;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$4 = $2_1;
                $520 = i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0 | 0) | 0;
                i64toi32_i32$0 = 0;
                $521$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $514$hi;
                i64toi32_i32$4 = $514;
                i64toi32_i32$2 = $521$hi;
                i64toi32_i32$1 = $520;
                i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
                i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $522$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $492$hi;
                i64toi32_i32$0 = $492;
                i64toi32_i32$4 = $522$hi;
                i64toi32_i32$1 = i64toi32_i32$3;
                i64toi32_i32$2 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
                i64toi32_i32$3 = i64toi32_i32$5 + i64toi32_i32$4 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $2_1 = i64toi32_i32$2;
                $2$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $4$hi;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$5 = i64toi32_i32$2;
                i64toi32_i32$0 = $4$hi;
                i64toi32_i32$1 = $4_1;
                $526 = i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$5 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$5 = 0;
                $527$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $491$hi;
                i64toi32_i32$1 = $491;
                i64toi32_i32$3 = $527$hi;
                i64toi32_i32$0 = $526;
                i64toi32_i32$4 = i64toi32_i32$1 + i64toi32_i32$0 | 0;
                i64toi32_i32$2 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $4_1 = i64toi32_i32$4;
                $4$hi = i64toi32_i32$2;
                i64toi32_i32$5 = i64toi32_i32$4;
                i64toi32_i32$1 = 131071;
                i64toi32_i32$0 = -1;
                if (i64toi32_i32$2 >>> 0 > i64toi32_i32$1 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$5 >>> 0 > i64toi32_i32$0 >>> 0 | 0) | 0) {
                  break label$13;
                }
                i64toi32_i32$5 = $20$hi;
                i64toi32_i32$5 = $23$hi;
                i64toi32_i32$5 = $20$hi;
                i64toi32_i32$0 = $20_1;
                i64toi32_i32$2 = $23$hi;
                i64toi32_i32$1 = $23_1;
                i64toi32_i32$2 = i64toi32_i32$5 | i64toi32_i32$2 | 0;
                $19_1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
                $19$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $2$hi;
                i64toi32_i32$2 = $4$hi;
                i64toi32_i32$2 = $3$hi;
                i64toi32_i32$2 = $14$hi;
                i64toi32_i32$2 = $2$hi;
                i64toi32_i32$0 = $4$hi;
                i64toi32_i32$5 = $3$hi;
                i64toi32_i32$1 = $14$hi;
                $98($5_1 + 80 | 0 | 0, $2_1 | 0, i64toi32_i32$2 | 0, i64toi32_i32$4 | 0, i64toi32_i32$0 | 0, $3_1 | 0, i64toi32_i32$5 | 0, $14_1 | 0, i64toi32_i32$1 | 0);
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$0 = $1_1;
                i64toi32_i32$5 = 0;
                i64toi32_i32$2 = 49;
                i64toi32_i32$3 = i64toi32_i32$2 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$0 << i64toi32_i32$3 | 0;
                  $368 = 0;
                } else {
                  i64toi32_i32$5 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$3 | 0) | 0;
                  $368 = i64toi32_i32$0 << i64toi32_i32$3 | 0;
                }
                $541$hi = i64toi32_i32$5;
                i64toi32_i32$1 = ($5_1 + 80 | 0) + 8 | 0;
                i64toi32_i32$5 = HEAP32[i64toi32_i32$1 >> 2] | 0;
                i64toi32_i32$0 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
                $545 = i64toi32_i32$5;
                $545$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $541$hi;
                i64toi32_i32$1 = $368;
                i64toi32_i32$5 = $545$hi;
                i64toi32_i32$2 = $545;
                i64toi32_i32$3 = i64toi32_i32$1 - i64toi32_i32$2 | 0;
                i64toi32_i32$6 = i64toi32_i32$1 >>> 0 < i64toi32_i32$2 >>> 0;
                i64toi32_i32$4 = i64toi32_i32$6 + i64toi32_i32$5 | 0;
                i64toi32_i32$4 = i64toi32_i32$0 - i64toi32_i32$4 | 0;
                $546$hi = i64toi32_i32$4;
                i64toi32_i32$0 = $5_1;
                i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 80 | 0) >> 2] | 0;
                i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 84 | 0) >> 2] | 0;
                $1_1 = i64toi32_i32$4;
                $1$hi = i64toi32_i32$1;
                i64toi32_i32$0 = i64toi32_i32$4;
                i64toi32_i32$4 = 0;
                i64toi32_i32$2 = 0;
                $550 = (i64toi32_i32$0 | 0) != (i64toi32_i32$2 | 0) | (i64toi32_i32$1 | 0) != (i64toi32_i32$4 | 0) | 0;
                i64toi32_i32$0 = 0;
                $551$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $546$hi;
                i64toi32_i32$2 = i64toi32_i32$3;
                i64toi32_i32$1 = $551$hi;
                i64toi32_i32$4 = $550;
                i64toi32_i32$5 = i64toi32_i32$3 - i64toi32_i32$4 | 0;
                i64toi32_i32$6 = i64toi32_i32$3 >>> 0 < i64toi32_i32$4 >>> 0;
                i64toi32_i32$3 = i64toi32_i32$6 + i64toi32_i32$1 | 0;
                i64toi32_i32$3 = i64toi32_i32$0 - i64toi32_i32$3 | 0;
                $10_1 = i64toi32_i32$5;
                $10$hi = i64toi32_i32$3;
                $6_1 = $6_1 + 16382 | 0;
                i64toi32_i32$3 = $1$hi;
                i64toi32_i32$3 = 0;
                i64toi32_i32$0 = 0;
                i64toi32_i32$2 = $1$hi;
                i64toi32_i32$4 = $1_1;
                i64toi32_i32$1 = i64toi32_i32$0 - i64toi32_i32$4 | 0;
                i64toi32_i32$6 = i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0;
                i64toi32_i32$5 = i64toi32_i32$6 + i64toi32_i32$2 | 0;
                i64toi32_i32$5 = i64toi32_i32$3 - i64toi32_i32$5 | 0;
                $11_1 = i64toi32_i32$1;
                $11$hi = i64toi32_i32$5;
                break label$12;
              }
              $558 = $5_1 + 96 | 0;
              i64toi32_i32$5 = $2$hi;
              i64toi32_i32$3 = $2_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$4 = 1;
              i64toi32_i32$2 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $369 = i64toi32_i32$5 >>> i64toi32_i32$2 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$5 >>> i64toi32_i32$2 | 0;
                $369 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$2 | 0) | 0;
              }
              $560 = $369;
              $560$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $4$hi;
              i64toi32_i32$5 = $4_1;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = 63;
              i64toi32_i32$2 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$3 = i64toi32_i32$5 << i64toi32_i32$2 | 0;
                $371 = 0;
              } else {
                i64toi32_i32$3 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$2 | 0) | 0;
                $371 = i64toi32_i32$5 << i64toi32_i32$2 | 0;
              }
              $562$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $560$hi;
              i64toi32_i32$0 = $560;
              i64toi32_i32$5 = $562$hi;
              i64toi32_i32$4 = $371;
              i64toi32_i32$5 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
              $2_1 = i64toi32_i32$0 | i64toi32_i32$4 | 0;
              $2$hi = i64toi32_i32$5;
              $564 = $2_1;
              $564$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $4$hi;
              i64toi32_i32$3 = $4_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$4 = 1;
              i64toi32_i32$2 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $372 = i64toi32_i32$5 >>> i64toi32_i32$2 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$5 >>> i64toi32_i32$2 | 0;
                $372 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$2 | 0) | 0;
              }
              $4_1 = $372;
              $4$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $3$hi;
              i64toi32_i32$0 = $14$hi;
              i64toi32_i32$0 = $564$hi;
              i64toi32_i32$3 = $4$hi;
              i64toi32_i32$5 = $3$hi;
              i64toi32_i32$4 = $14$hi;
              $98($558 | 0, $564 | 0, i64toi32_i32$0 | 0, $4_1 | 0, i64toi32_i32$3 | 0, $3_1 | 0, i64toi32_i32$5 | 0, $14_1 | 0, i64toi32_i32$4 | 0);
              i64toi32_i32$4 = $1$hi;
              i64toi32_i32$3 = $1_1;
              i64toi32_i32$5 = 0;
              i64toi32_i32$0 = 48;
              i64toi32_i32$2 = i64toi32_i32$0 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                i64toi32_i32$5 = i64toi32_i32$3 << i64toi32_i32$2 | 0;
                $374 = 0;
              } else {
                i64toi32_i32$5 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$2 | 0) | 0;
                $374 = i64toi32_i32$3 << i64toi32_i32$2 | 0;
              }
              $571$hi = i64toi32_i32$5;
              i64toi32_i32$4 = ($5_1 + 96 | 0) + 8 | 0;
              i64toi32_i32$5 = HEAP32[i64toi32_i32$4 >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
              $575 = i64toi32_i32$5;
              $575$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $571$hi;
              i64toi32_i32$4 = $374;
              i64toi32_i32$5 = $575$hi;
              i64toi32_i32$0 = $575;
              i64toi32_i32$2 = i64toi32_i32$4 - i64toi32_i32$0 | 0;
              i64toi32_i32$6 = i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0;
              i64toi32_i32$1 = i64toi32_i32$6 + i64toi32_i32$5 | 0;
              i64toi32_i32$1 = i64toi32_i32$3 - i64toi32_i32$1 | 0;
              $576$hi = i64toi32_i32$1;
              i64toi32_i32$3 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 96 | 0) >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 100 | 0) >> 2] | 0;
              $11_1 = i64toi32_i32$1;
              $11$hi = i64toi32_i32$4;
              i64toi32_i32$3 = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              i64toi32_i32$0 = 0;
              $580 = (i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | (i64toi32_i32$4 | 0) != (i64toi32_i32$1 | 0) | 0;
              i64toi32_i32$3 = 0;
              $581$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $576$hi;
              i64toi32_i32$0 = i64toi32_i32$2;
              i64toi32_i32$4 = $581$hi;
              i64toi32_i32$1 = $580;
              i64toi32_i32$5 = i64toi32_i32$0 - i64toi32_i32$1 | 0;
              i64toi32_i32$6 = i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0;
              i64toi32_i32$2 = i64toi32_i32$6 + i64toi32_i32$4 | 0;
              i64toi32_i32$2 = i64toi32_i32$3 - i64toi32_i32$2 | 0;
              $10_1 = i64toi32_i32$5;
              $10$hi = i64toi32_i32$2;
              $6_1 = $6_1 + 16383 | 0;
              i64toi32_i32$2 = $11$hi;
              i64toi32_i32$2 = 0;
              i64toi32_i32$3 = 0;
              i64toi32_i32$0 = $11$hi;
              i64toi32_i32$1 = $11_1;
              i64toi32_i32$4 = i64toi32_i32$3 - i64toi32_i32$1 | 0;
              i64toi32_i32$6 = i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0;
              i64toi32_i32$5 = i64toi32_i32$6 + i64toi32_i32$0 | 0;
              i64toi32_i32$5 = i64toi32_i32$2 - i64toi32_i32$5 | 0;
              $11_1 = i64toi32_i32$4;
              $11$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $1$hi;
              $22_1 = $1_1;
              $22$hi = i64toi32_i32$5;
            }
            label$14: {
              if (($6_1 | 0) < (32767 | 0)) {
                break label$14;
              }
              i64toi32_i32$5 = $12$hi;
              i64toi32_i32$2 = $12_1;
              i64toi32_i32$3 = 2147418112;
              i64toi32_i32$1 = 0;
              i64toi32_i32$3 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
              $12_1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
              $12$hi = i64toi32_i32$3;
              i64toi32_i32$3 = 0;
              $1_1 = 0;
              $1$hi = i64toi32_i32$3;
              break label$1;
            }
            label$15: {
              label$16: {
                if (($6_1 | 0) < (1 | 0)) {
                  break label$16;
                }
                i64toi32_i32$3 = $10$hi;
                i64toi32_i32$5 = $10_1;
                i64toi32_i32$2 = 0;
                i64toi32_i32$1 = 1;
                i64toi32_i32$0 = i64toi32_i32$1 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$5 << i64toi32_i32$0 | 0;
                  $375 = 0;
                } else {
                  i64toi32_i32$2 = ((1 << i64toi32_i32$0 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$0 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$0 | 0) | 0;
                  $375 = i64toi32_i32$5 << i64toi32_i32$0 | 0;
                }
                $595 = $375;
                $595$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $11$hi;
                i64toi32_i32$3 = $11_1;
                i64toi32_i32$5 = 0;
                i64toi32_i32$1 = 63;
                i64toi32_i32$0 = i64toi32_i32$1 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                  i64toi32_i32$5 = 0;
                  $376 = i64toi32_i32$2 >>> i64toi32_i32$0 | 0;
                } else {
                  i64toi32_i32$5 = i64toi32_i32$2 >>> i64toi32_i32$0 | 0;
                  $376 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$0 | 0) | 0;
                }
                $597$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $595$hi;
                i64toi32_i32$2 = $595;
                i64toi32_i32$3 = $597$hi;
                i64toi32_i32$1 = $376;
                i64toi32_i32$3 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
                $1_1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
                $1$hi = i64toi32_i32$3;
                i64toi32_i32$3 = 0;
                i64toi32_i32$5 = $6_1;
                i64toi32_i32$2 = 0;
                i64toi32_i32$1 = 48;
                i64toi32_i32$0 = i64toi32_i32$1 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$5 << i64toi32_i32$0 | 0;
                  $377 = 0;
                } else {
                  i64toi32_i32$2 = ((1 << i64toi32_i32$0 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$0 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$0 | 0) | 0;
                  $377 = i64toi32_i32$5 << i64toi32_i32$0 | 0;
                }
                $601$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $4$hi;
                i64toi32_i32$3 = $4_1;
                i64toi32_i32$5 = 65535;
                i64toi32_i32$1 = -1;
                i64toi32_i32$5 = i64toi32_i32$2 & i64toi32_i32$5 | 0;
                $603 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
                $603$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $601$hi;
                i64toi32_i32$2 = $377;
                i64toi32_i32$3 = $603$hi;
                i64toi32_i32$1 = $603;
                i64toi32_i32$3 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
                $10_1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
                $10$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $11$hi;
                i64toi32_i32$5 = $11_1;
                i64toi32_i32$2 = 0;
                i64toi32_i32$1 = 1;
                i64toi32_i32$0 = i64toi32_i32$1 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$5 << i64toi32_i32$0 | 0;
                  $378 = 0;
                } else {
                  i64toi32_i32$2 = ((1 << i64toi32_i32$0 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$0 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$0 | 0) | 0;
                  $378 = i64toi32_i32$5 << i64toi32_i32$0 | 0;
                }
                $4_1 = $378;
                $4$hi = i64toi32_i32$2;
                break label$15;
              }
              label$17: {
                if (($6_1 | 0) > (-113 | 0)) {
                  break label$17;
                }
                i64toi32_i32$2 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$2;
                break label$1;
              }
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$2 = $4$hi;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$5 = $4$hi;
              $96($5_1 + 64 | 0 | 0, $2_1 | 0, i64toi32_i32$2 | 0, $4_1 | 0, i64toi32_i32$5 | 0, 1 - $6_1 | 0 | 0);
              i64toi32_i32$5 = $22$hi;
              i64toi32_i32$5 = $19$hi;
              i64toi32_i32$5 = $22$hi;
              i64toi32_i32$2 = $19$hi;
              $86($5_1 + 48 | 0 | 0, $22_1 | 0, i64toi32_i32$5 | 0, $19_1 | 0, i64toi32_i32$2 | 0, $6_1 + 112 | 0 | 0);
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$2 = $14$hi;
              i64toi32_i32$3 = $5_1;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 64 | 0) >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$3 + 68 | 0) >> 2] | 0;
              $2_1 = i64toi32_i32$2;
              $2$hi = i64toi32_i32$5;
              i64toi32_i32$3 = (i64toi32_i32$3 + 64 | 0) + 8 | 0;
              i64toi32_i32$5 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$2 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $10_1 = i64toi32_i32$5;
              $10$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $3$hi;
              i64toi32_i32$5 = $14$hi;
              i64toi32_i32$3 = $2$hi;
              i64toi32_i32$1 = $10$hi;
              $98($5_1 + 32 | 0 | 0, $3_1 | 0, i64toi32_i32$2 | 0, $14_1 | 0, i64toi32_i32$5 | 0, $2_1 | 0, i64toi32_i32$3 | 0, $10_1 | 0, i64toi32_i32$1 | 0);
              i64toi32_i32$5 = ($5_1 + 48 | 0) + 8 | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$5 >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
              $636 = i64toi32_i32$1;
              $636$hi = i64toi32_i32$3;
              i64toi32_i32$5 = ($5_1 + 32 | 0) + 8 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$5 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
              i64toi32_i32$5 = i64toi32_i32$3;
              i64toi32_i32$3 = 0;
              i64toi32_i32$2 = 1;
              i64toi32_i32$0 = i64toi32_i32$2 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                i64toi32_i32$3 = i64toi32_i32$5 << i64toi32_i32$0 | 0;
                $380 = 0;
              } else {
                i64toi32_i32$3 = ((1 << i64toi32_i32$0 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$0 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$0 | 0) | 0;
                $380 = i64toi32_i32$5 << i64toi32_i32$0 | 0;
              }
              $641 = $380;
              $641$hi = i64toi32_i32$3;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$1 + 32 | 0) >> 2] | 0;
              i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 36 | 0) >> 2] | 0;
              $1_1 = i64toi32_i32$3;
              $1$hi = i64toi32_i32$5;
              i64toi32_i32$1 = i64toi32_i32$3;
              i64toi32_i32$3 = 0;
              i64toi32_i32$2 = 63;
              i64toi32_i32$0 = i64toi32_i32$2 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                i64toi32_i32$3 = 0;
                $381 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
              } else {
                i64toi32_i32$3 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
                $381 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$0 | 0) | 0;
              }
              $645$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $641$hi;
              i64toi32_i32$5 = $641;
              i64toi32_i32$1 = $645$hi;
              i64toi32_i32$2 = $381;
              i64toi32_i32$1 = i64toi32_i32$3 | i64toi32_i32$1 | 0;
              $646 = i64toi32_i32$5 | i64toi32_i32$2 | 0;
              $646$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $636$hi;
              i64toi32_i32$3 = $636;
              i64toi32_i32$5 = $646$hi;
              i64toi32_i32$2 = $646;
              i64toi32_i32$0 = i64toi32_i32$3 - i64toi32_i32$2 | 0;
              i64toi32_i32$6 = i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0;
              i64toi32_i32$4 = i64toi32_i32$6 + i64toi32_i32$5 | 0;
              i64toi32_i32$4 = i64toi32_i32$1 - i64toi32_i32$4 | 0;
              $647 = i64toi32_i32$0;
              $647$hi = i64toi32_i32$4;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$1 + 48 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$1 + 52 | 0) >> 2] | 0;
              $4_1 = i64toi32_i32$4;
              $4$hi = i64toi32_i32$3;
              $650 = i64toi32_i32$4;
              $650$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $1$hi;
              i64toi32_i32$1 = $1_1;
              i64toi32_i32$4 = 0;
              i64toi32_i32$2 = 1;
              i64toi32_i32$5 = i64toi32_i32$2 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                i64toi32_i32$4 = i64toi32_i32$1 << i64toi32_i32$5 | 0;
                $382 = 0;
              } else {
                i64toi32_i32$4 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$5 | 0) | 0;
                $382 = i64toi32_i32$1 << i64toi32_i32$5 | 0;
              }
              $11_1 = $382;
              $11$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $650$hi;
              i64toi32_i32$3 = $650;
              i64toi32_i32$1 = $11$hi;
              i64toi32_i32$2 = $11_1;
              $654 = i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
              i64toi32_i32$3 = 0;
              $655$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $647$hi;
              i64toi32_i32$2 = $647;
              i64toi32_i32$4 = $655$hi;
              i64toi32_i32$1 = $654;
              i64toi32_i32$5 = i64toi32_i32$2 - i64toi32_i32$1 | 0;
              i64toi32_i32$6 = i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0;
              i64toi32_i32$0 = i64toi32_i32$6 + i64toi32_i32$4 | 0;
              i64toi32_i32$0 = i64toi32_i32$3 - i64toi32_i32$0 | 0;
              $1_1 = i64toi32_i32$5;
              $1$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $4$hi;
              i64toi32_i32$0 = $11$hi;
              i64toi32_i32$0 = $4$hi;
              i64toi32_i32$3 = $4_1;
              i64toi32_i32$2 = $11$hi;
              i64toi32_i32$1 = $11_1;
              i64toi32_i32$4 = i64toi32_i32$3 - i64toi32_i32$1 | 0;
              i64toi32_i32$6 = i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0;
              i64toi32_i32$5 = i64toi32_i32$6 + i64toi32_i32$2 | 0;
              i64toi32_i32$5 = i64toi32_i32$0 - i64toi32_i32$5 | 0;
              $4_1 = i64toi32_i32$4;
              $4$hi = i64toi32_i32$5;
            }
            i64toi32_i32$5 = $3$hi;
            i64toi32_i32$5 = $14$hi;
            i64toi32_i32$5 = $3$hi;
            i64toi32_i32$3 = $14$hi;
            i64toi32_i32$0 = 0;
            i64toi32_i32$1 = 0;
            $98($5_1 + 16 | 0 | 0, $3_1 | 0, i64toi32_i32$5 | 0, $14_1 | 0, i64toi32_i32$3 | 0, 3 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$1 | 0);
            i64toi32_i32$1 = i64toi32_i32$5;
            i64toi32_i32$1 = i64toi32_i32$3;
            i64toi32_i32$1 = i64toi32_i32$5;
            i64toi32_i32$0 = i64toi32_i32$3;
            i64toi32_i32$3 = 0;
            i64toi32_i32$5 = 0;
            $98($5_1 | 0, $3_1 | 0, i64toi32_i32$1 | 0, $14_1 | 0, i64toi32_i32$0 | 0, 5 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$5 | 0);
            i64toi32_i32$5 = $10$hi;
            $667 = $10_1;
            $667$hi = i64toi32_i32$5;
            i64toi32_i32$5 = $2$hi;
            $668 = $2_1;
            $668$hi = i64toi32_i32$5;
            i64toi32_i32$0 = $2_1;
            i64toi32_i32$3 = 0;
            i64toi32_i32$1 = 1;
            i64toi32_i32$3 = i64toi32_i32$5 & i64toi32_i32$3 | 0;
            $11_1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
            $11$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $4$hi;
            i64toi32_i32$3 = $11$hi;
            i64toi32_i32$5 = $11_1;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$1 = $4_1;
            i64toi32_i32$2 = i64toi32_i32$5 + i64toi32_i32$1 | 0;
            i64toi32_i32$4 = i64toi32_i32$3 + i64toi32_i32$0 | 0;
            if (i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0) {
              i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
            }
            $4_1 = i64toi32_i32$2;
            $4$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $3$hi;
            i64toi32_i32$4 = $4$hi;
            i64toi32_i32$3 = i64toi32_i32$2;
            i64toi32_i32$5 = $3$hi;
            i64toi32_i32$1 = $3_1;
            $676 = i64toi32_i32$4 >>> 0 > i64toi32_i32$5 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$3 >>> 0 > i64toi32_i32$1 >>> 0 | 0) | 0;
            i64toi32_i32$3 = $1$hi;
            i64toi32_i32$3 = i64toi32_i32$4;
            i64toi32_i32$3 = $11$hi;
            i64toi32_i32$3 = i64toi32_i32$4;
            i64toi32_i32$1 = i64toi32_i32$2;
            i64toi32_i32$4 = $11$hi;
            i64toi32_i32$5 = $11_1;
            $680 = i64toi32_i32$3 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
            i64toi32_i32$1 = 0;
            $681$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$5 = $1_1;
            i64toi32_i32$3 = $681$hi;
            i64toi32_i32$4 = $680;
            i64toi32_i32$0 = i64toi32_i32$5 + i64toi32_i32$4 | 0;
            i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
            if (i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
            }
            $1_1 = i64toi32_i32$0;
            $1$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $14$hi;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$1 = i64toi32_i32$0;
            i64toi32_i32$5 = $14$hi;
            i64toi32_i32$4 = $14_1;
            $685 = i64toi32_i32$2 >>> 0 > i64toi32_i32$5 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$0 >>> 0 > i64toi32_i32$4 >>> 0 | 0) | 0;
            i64toi32_i32$1 = i64toi32_i32$2;
            i64toi32_i32$1 = i64toi32_i32$5;
            i64toi32_i32$1 = i64toi32_i32$2;
            i64toi32_i32$4 = i64toi32_i32$0;
            i64toi32_i32$2 = i64toi32_i32$5;
            i64toi32_i32$5 = $14_1;
            $689 = (i64toi32_i32$0 | 0) == (i64toi32_i32$5 | 0) & (i64toi32_i32$1 | 0) == (i64toi32_i32$2 | 0) | 0 ? $676 : $685;
            i64toi32_i32$4 = 0;
            $690$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $668$hi;
            i64toi32_i32$5 = $668;
            i64toi32_i32$1 = $690$hi;
            i64toi32_i32$2 = $689;
            i64toi32_i32$3 = i64toi32_i32$5 + i64toi32_i32$2 | 0;
            i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
            if (i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
            }
            $3_1 = i64toi32_i32$3;
            $3$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$0 = $3$hi;
            i64toi32_i32$4 = i64toi32_i32$3;
            i64toi32_i32$5 = $2$hi;
            i64toi32_i32$2 = $2_1;
            $694 = i64toi32_i32$0 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
            i64toi32_i32$4 = 0;
            $695$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $667$hi;
            i64toi32_i32$2 = $667;
            i64toi32_i32$0 = $695$hi;
            i64toi32_i32$5 = $694;
            i64toi32_i32$1 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
            i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
            if (i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0) {
              i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
            }
            $2_1 = i64toi32_i32$1;
            $2$hi = i64toi32_i32$3;
            $697 = i64toi32_i32$1;
            $697$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $3$hi;
            i64toi32_i32$3 = $2$hi;
            i64toi32_i32$4 = i64toi32_i32$1;
            i64toi32_i32$2 = 2147418112;
            i64toi32_i32$5 = 0;
            $700 = i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
            i64toi32_i32$4 = $4$hi;
            i64toi32_i32$5 = $5_1;
            i64toi32_i32$4 = HEAP32[(i64toi32_i32$5 + 16 | 0) >> 2] | 0;
            i64toi32_i32$3 = HEAP32[(i64toi32_i32$5 + 20 | 0) >> 2] | 0;
            $703 = i64toi32_i32$4;
            $703$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $4$hi;
            i64toi32_i32$5 = $4_1;
            i64toi32_i32$4 = $703$hi;
            i64toi32_i32$2 = $703;
            $704 = i64toi32_i32$3 >>> 0 > i64toi32_i32$4 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$5 >>> 0 > i64toi32_i32$2 >>> 0 | 0) | 0;
            i64toi32_i32$5 = $1$hi;
            i64toi32_i32$2 = ($5_1 + 16 | 0) + 8 | 0;
            i64toi32_i32$5 = HEAP32[i64toi32_i32$2 >> 2] | 0;
            i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
            $2_1 = i64toi32_i32$5;
            $2$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $1$hi;
            i64toi32_i32$2 = $1_1;
            i64toi32_i32$5 = $2$hi;
            i64toi32_i32$4 = $2_1;
            $711 = i64toi32_i32$3 >>> 0 > i64toi32_i32$5 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$2 >>> 0 > i64toi32_i32$4 >>> 0 | 0) | 0;
            i64toi32_i32$2 = i64toi32_i32$3;
            i64toi32_i32$2 = i64toi32_i32$5;
            i64toi32_i32$2 = i64toi32_i32$3;
            i64toi32_i32$4 = $1_1;
            i64toi32_i32$3 = i64toi32_i32$5;
            i64toi32_i32$5 = $2_1;
            $716 = $700 & ((i64toi32_i32$4 | 0) == (i64toi32_i32$5 | 0) & (i64toi32_i32$2 | 0) == (i64toi32_i32$3 | 0) | 0 ? $704 : $711) | 0;
            i64toi32_i32$4 = 0;
            $717$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $3$hi;
            i64toi32_i32$5 = $3_1;
            i64toi32_i32$2 = $717$hi;
            i64toi32_i32$3 = $716;
            i64toi32_i32$0 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
            i64toi32_i32$1 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
            if (i64toi32_i32$0 >>> 0 < i64toi32_i32$3 >>> 0) {
              i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
            }
            $2_1 = i64toi32_i32$0;
            $2$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$4 = i64toi32_i32$0;
            i64toi32_i32$5 = $3$hi;
            i64toi32_i32$3 = $3_1;
            $721 = i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$0 >>> 0 < i64toi32_i32$3 >>> 0 | 0) | 0;
            i64toi32_i32$4 = 0;
            $722$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $697$hi;
            i64toi32_i32$3 = $697;
            i64toi32_i32$1 = $722$hi;
            i64toi32_i32$5 = $721;
            i64toi32_i32$2 = i64toi32_i32$3 + i64toi32_i32$5 | 0;
            i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
            if (i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
            }
            $3_1 = i64toi32_i32$2;
            $3$hi = i64toi32_i32$0;
            $724 = i64toi32_i32$2;
            $724$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $2$hi;
            i64toi32_i32$0 = $3$hi;
            i64toi32_i32$4 = i64toi32_i32$2;
            i64toi32_i32$3 = 2147418112;
            i64toi32_i32$5 = 0;
            $727 = i64toi32_i32$0 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
            i64toi32_i32$4 = $4$hi;
            i64toi32_i32$5 = $5_1;
            i64toi32_i32$4 = HEAP32[i64toi32_i32$5 >> 2] | 0;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
            $730 = i64toi32_i32$4;
            $730$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$5 = $4_1;
            i64toi32_i32$4 = $730$hi;
            i64toi32_i32$3 = $730;
            $731 = i64toi32_i32$0 >>> 0 > i64toi32_i32$4 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$5 >>> 0 > i64toi32_i32$3 >>> 0 | 0) | 0;
            i64toi32_i32$5 = $1$hi;
            i64toi32_i32$3 = $5_1 + 8 | 0;
            i64toi32_i32$5 = HEAP32[i64toi32_i32$3 >> 2] | 0;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
            $4_1 = i64toi32_i32$5;
            $4$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$3 = $1_1;
            i64toi32_i32$5 = $4$hi;
            i64toi32_i32$4 = $4_1;
            $737 = i64toi32_i32$0 >>> 0 > i64toi32_i32$5 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$3 >>> 0 > i64toi32_i32$4 >>> 0 | 0) | 0;
            i64toi32_i32$3 = i64toi32_i32$0;
            i64toi32_i32$3 = i64toi32_i32$5;
            i64toi32_i32$3 = i64toi32_i32$0;
            i64toi32_i32$4 = $1_1;
            i64toi32_i32$0 = i64toi32_i32$5;
            i64toi32_i32$5 = $4_1;
            $742 = $727 & ((i64toi32_i32$4 | 0) == (i64toi32_i32$5 | 0) & (i64toi32_i32$3 | 0) == (i64toi32_i32$0 | 0) | 0 ? $731 : $737) | 0;
            i64toi32_i32$4 = 0;
            $743$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $2$hi;
            i64toi32_i32$5 = $2_1;
            i64toi32_i32$3 = $743$hi;
            i64toi32_i32$0 = $742;
            i64toi32_i32$1 = i64toi32_i32$5 + i64toi32_i32$0 | 0;
            i64toi32_i32$2 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
            if (i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
            }
            $1_1 = i64toi32_i32$1;
            $1$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$4 = i64toi32_i32$1;
            i64toi32_i32$5 = $2$hi;
            i64toi32_i32$0 = $2_1;
            $747 = i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0;
            i64toi32_i32$4 = 0;
            $748$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $724$hi;
            i64toi32_i32$0 = $724;
            i64toi32_i32$2 = $748$hi;
            i64toi32_i32$5 = $747;
            i64toi32_i32$3 = i64toi32_i32$0 + i64toi32_i32$5 | 0;
            i64toi32_i32$1 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
            if (i64toi32_i32$3 >>> 0 < i64toi32_i32$5 >>> 0) {
              i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
            }
            $749$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $12$hi;
            i64toi32_i32$1 = $749$hi;
            i64toi32_i32$4 = i64toi32_i32$3;
            i64toi32_i32$0 = $12$hi;
            i64toi32_i32$5 = $12_1;
            i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
            $12_1 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
            $12$hi = i64toi32_i32$0;
          }
          i64toi32_i32$0 = $1$hi;
          i64toi32_i32$4 = $0_1;
          HEAP32[i64toi32_i32$4 >> 2] = $1_1;
          HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] = i64toi32_i32$0;
          i64toi32_i32$0 = $12$hi;
          HEAP32[(i64toi32_i32$4 + 8 | 0) >> 2] = $12_1;
          HEAP32[(i64toi32_i32$4 + 12 | 0) >> 2] = i64toi32_i32$0;
          global$0 = $5_1 + 336 | 0;
        }

        function $90($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = +$1_1;
          var i64toi32_i32$3 = 0,i64toi32_i32$4 = 0,i64toi32_i32$5 = 0,i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,i64toi32_i32$2 = 0,$5_1 = 0,$5$hi = 0,$2_1 = 0,$4_1 = 0,$6_1 = 0,$6$hi = 0,$4$hi = 0,$26_1 = 0,$27_1 = 0,$28_1 = 0,$29_1 = 0,$30_1 = 0,$3_1 = 0,$31_1 = 0,$32_1 = 0,$33_1 = 0,$33$hi = 0,$37_1 = 0,$50_1 = 0,$50$hi = 0,$54$hi = 0,$63_1 = 0,$63$hi = 0,$64_1 = 0;
          $2_1 = global$0 - 16 | 0;
          global$0 = $2_1;
          label$1: {
            label$2: {
              wasm2js_scratch_store_f64(+$1_1);
              i64toi32_i32$0 = wasm2js_scratch_load_i32(1 | 0) | 0;
              $4_1 = wasm2js_scratch_load_i32(0 | 0) | 0;
              $4$hi = i64toi32_i32$0;
              i64toi32_i32$2 = $4_1;
              i64toi32_i32$1 = 2147483647;
              i64toi32_i32$3 = -1;
              i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
              $5_1 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
              $5$hi = i64toi32_i32$1;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$2 = -1048576;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
              i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
              }
              i64toi32_i32$1 = i64toi32_i32$4;
              i64toi32_i32$0 = 2145386495;
              i64toi32_i32$3 = -1;
              if (i64toi32_i32$5 >>> 0 > i64toi32_i32$0 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$4 >>> 0 > i64toi32_i32$3 >>> 0 | 0) | 0) {
                break label$2;
              }
              i64toi32_i32$1 = $5$hi;
              i64toi32_i32$3 = $5_1;
              i64toi32_i32$5 = 0;
              i64toi32_i32$0 = 60;
              i64toi32_i32$2 = i64toi32_i32$0 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                i64toi32_i32$5 = i64toi32_i32$3 << i64toi32_i32$2 | 0;
                $26_1 = 0;
              } else {
                i64toi32_i32$5 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$2 | 0) | 0;
                $26_1 = i64toi32_i32$3 << i64toi32_i32$2 | 0;
              }
              $6_1 = $26_1;
              $6$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $5$hi;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$3 = 0;
              i64toi32_i32$0 = 4;
              i64toi32_i32$2 = i64toi32_i32$0 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                i64toi32_i32$3 = 0;
                $27_1 = i64toi32_i32$5 >>> i64toi32_i32$2 | 0;
              } else {
                i64toi32_i32$3 = i64toi32_i32$5 >>> i64toi32_i32$2 | 0;
                $27_1 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$2 | 0) | 0;
              }
              i64toi32_i32$5 = $27_1;
              i64toi32_i32$1 = 1006632960;
              i64toi32_i32$0 = 0;
              i64toi32_i32$2 = i64toi32_i32$5 + i64toi32_i32$0 | 0;
              i64toi32_i32$4 = i64toi32_i32$3 + i64toi32_i32$1 | 0;
              if (i64toi32_i32$2 >>> 0 < i64toi32_i32$0 >>> 0) {
                i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
              }
              $5_1 = i64toi32_i32$2;
              $5$hi = i64toi32_i32$4;
              break label$1;
            }
            label$3: {
              i64toi32_i32$4 = $5$hi;
              i64toi32_i32$3 = $5_1;
              i64toi32_i32$5 = 2146435072;
              i64toi32_i32$0 = 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0) {
                break label$3;
              }
              i64toi32_i32$3 = $4$hi;
              i64toi32_i32$0 = $4_1;
              i64toi32_i32$4 = 0;
              i64toi32_i32$5 = 60;
              i64toi32_i32$1 = i64toi32_i32$5 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                i64toi32_i32$4 = i64toi32_i32$0 << i64toi32_i32$1 | 0;
                $28_1 = 0;
              } else {
                i64toi32_i32$4 = ((1 << i64toi32_i32$1 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$1 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$1 | 0) | 0;
                $28_1 = i64toi32_i32$0 << i64toi32_i32$1 | 0;
              }
              $6_1 = $28_1;
              $6$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $4$hi;
              i64toi32_i32$3 = $4_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$5 = 4;
              i64toi32_i32$1 = i64toi32_i32$5 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $29_1 = i64toi32_i32$4 >>> i64toi32_i32$1 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$4 >>> i64toi32_i32$1 | 0;
                $29_1 = (((1 << i64toi32_i32$1 | 0) - 1 | 0) & i64toi32_i32$4 | 0) << (32 - i64toi32_i32$1 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$1 | 0) | 0;
              }
              i64toi32_i32$4 = $29_1;
              i64toi32_i32$3 = 2147418112;
              i64toi32_i32$5 = 0;
              i64toi32_i32$3 = i64toi32_i32$0 | i64toi32_i32$3 | 0;
              $5_1 = i64toi32_i32$4 | i64toi32_i32$5 | 0;
              $5$hi = i64toi32_i32$3;
              break label$1;
            }
            label$4: {
              i64toi32_i32$3 = $5$hi;
              if (!!($5_1 | i64toi32_i32$3 | 0)) {
                break label$4;
              }
              i64toi32_i32$3 = 0;
              $6_1 = 0;
              $6$hi = i64toi32_i32$3;
              i64toi32_i32$3 = 0;
              $5_1 = 0;
              $5$hi = i64toi32_i32$3;
              break label$1;
            }
            $32_1 = $2_1;
            i64toi32_i32$3 = $5$hi;
            $33_1 = $5_1;
            $33$hi = i64toi32_i32$3;
            $37_1 = Math_clz32($5_1) + 32 | 0;
            i64toi32_i32$0 = $5_1;
            i64toi32_i32$4 = 0;
            i64toi32_i32$5 = 32;
            i64toi32_i32$1 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$4 = 0;
              $30_1 = i64toi32_i32$3 >>> i64toi32_i32$1 | 0;
            } else {
              i64toi32_i32$4 = i64toi32_i32$3 >>> i64toi32_i32$1 | 0;
              $30_1 = (((1 << i64toi32_i32$1 | 0) - 1 | 0) & i64toi32_i32$3 | 0) << (32 - i64toi32_i32$1 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$1 | 0) | 0;
            }
            i64toi32_i32$4 = $5$hi;
            i64toi32_i32$3 = $5_1;
            i64toi32_i32$0 = 1;
            i64toi32_i32$5 = 0;
            $3_1 = i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0 ? $37_1 : Math_clz32($30_1);
            i64toi32_i32$3 = $33$hi;
            i64toi32_i32$4 = 0;
            $86($32_1 | 0, $33_1 | 0, i64toi32_i32$3 | 0, 0 | 0, i64toi32_i32$4 | 0, $3_1 + 49 | 0 | 0);
            i64toi32_i32$5 = $2_1 + 8 | 0;
            i64toi32_i32$4 = HEAP32[i64toi32_i32$5 >> 2] | 0;
            i64toi32_i32$3 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
            i64toi32_i32$5 = i64toi32_i32$4;
            i64toi32_i32$4 = 65536;
            i64toi32_i32$0 = 0;
            i64toi32_i32$4 = i64toi32_i32$3 ^ i64toi32_i32$4 | 0;
            $50_1 = i64toi32_i32$5 ^ i64toi32_i32$0 | 0;
            $50$hi = i64toi32_i32$4;
            i64toi32_i32$4 = 0;
            i64toi32_i32$3 = 15372 - $3_1 | 0;
            i64toi32_i32$5 = 0;
            i64toi32_i32$0 = 48;
            i64toi32_i32$1 = i64toi32_i32$0 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
              i64toi32_i32$5 = i64toi32_i32$3 << i64toi32_i32$1 | 0;
              $31_1 = 0;
            } else {
              i64toi32_i32$5 = ((1 << i64toi32_i32$1 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$1 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$1 | 0) | 0;
              $31_1 = i64toi32_i32$3 << i64toi32_i32$1 | 0;
            }
            $54$hi = i64toi32_i32$5;
            i64toi32_i32$5 = $50$hi;
            i64toi32_i32$4 = $50_1;
            i64toi32_i32$3 = $54$hi;
            i64toi32_i32$0 = $31_1;
            i64toi32_i32$3 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
            $5_1 = i64toi32_i32$4 | i64toi32_i32$0 | 0;
            $5$hi = i64toi32_i32$3;
            i64toi32_i32$5 = $2_1;
            i64toi32_i32$3 = HEAP32[i64toi32_i32$5 >> 2] | 0;
            i64toi32_i32$4 = HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] | 0;
            $6_1 = i64toi32_i32$3;
            $6$hi = i64toi32_i32$4;
          }
          i64toi32_i32$4 = $6$hi;
          i64toi32_i32$3 = $0_1;
          HEAP32[i64toi32_i32$3 >> 2] = $6_1;
          HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] = i64toi32_i32$4;
          i64toi32_i32$4 = $5$hi;
          i64toi32_i32$4 = $4$hi;
          i64toi32_i32$5 = $4_1;
          i64toi32_i32$3 = -2147483648;
          i64toi32_i32$0 = 0;
          i64toi32_i32$3 = i64toi32_i32$4 & i64toi32_i32$3 | 0;
          $63_1 = i64toi32_i32$5 & i64toi32_i32$0 | 0;
          $63$hi = i64toi32_i32$3;
          i64toi32_i32$3 = $5$hi;
          i64toi32_i32$4 = $5_1;
          i64toi32_i32$5 = $63$hi;
          i64toi32_i32$0 = $63_1;
          i64toi32_i32$5 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
          $64_1 = i64toi32_i32$4 | i64toi32_i32$0 | 0;
          i64toi32_i32$4 = $0_1;
          HEAP32[(i64toi32_i32$4 + 8 | 0) >> 2] = $64_1;
          HEAP32[(i64toi32_i32$4 + 12 | 0) >> 2] = i64toi32_i32$5;
          global$0 = $2_1 + 16 | 0;
        }

        function $91($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = Math_fround($1_1);
          var i64toi32_i32$1 = 0,i64toi32_i32$5 = 0,i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$3 = 0,$4_1 = 0,i64toi32_i32$4 = 0,$2_1 = 0,$5_1 = 0,$5$hi = 0,$6_1 = 0,$6$hi = 0,$3_1 = 0,$24_1 = 0,$25_1 = 0,$26_1 = 0,$27_1 = 0,$30_1 = 0,$38_1 = 0,$38$hi = 0,$42$hi = 0,$48_1 = 0,$49_1 = 0,$49$hi = 0,$53$hi = 0,$54_1 = 0;
          $2_1 = global$0 - 16 | 0;
          global$0 = $2_1;
          label$1: {
            label$2: {
              $3_1 = (wasm2js_scratch_store_f32($1_1), wasm2js_scratch_load_i32(2));
              $4_1 = $3_1 & 2147483647 | 0;
              if (($4_1 + -8388608 | 0) >>> 0 > 2130706431 >>> 0) {
                break label$2;
              }
              i64toi32_i32$0 = 0;
              i64toi32_i32$2 = $4_1;
              i64toi32_i32$1 = 0;
              i64toi32_i32$3 = 25;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                $24_1 = 0;
              } else {
                i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$4 | 0) | 0;
                $24_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
              }
              i64toi32_i32$0 = $24_1;
              i64toi32_i32$2 = 1065353216;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
              i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
              }
              $5_1 = i64toi32_i32$4;
              $5$hi = i64toi32_i32$5;
              i64toi32_i32$5 = 0;
              $6_1 = 0;
              $6$hi = i64toi32_i32$5;
              break label$1;
            }
            label$3: {
              if ($4_1 >>> 0 < 2139095040 >>> 0) {
                break label$3;
              }
              i64toi32_i32$5 = 0;
              i64toi32_i32$1 = $3_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$3 = 25;
              i64toi32_i32$2 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = i64toi32_i32$1 << i64toi32_i32$2 | 0;
                $25_1 = 0;
              } else {
                i64toi32_i32$0 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$2 | 0) | 0;
                $25_1 = i64toi32_i32$1 << i64toi32_i32$2 | 0;
              }
              i64toi32_i32$5 = $25_1;
              i64toi32_i32$1 = 2147418112;
              i64toi32_i32$3 = 0;
              i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
              $5_1 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
              $5$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $6_1 = 0;
              $6$hi = i64toi32_i32$1;
              break label$1;
            }
            label$4: {
              if ($4_1) {
                break label$4;
              }
              i64toi32_i32$1 = 0;
              $6_1 = 0;
              $6$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $5_1 = 0;
              $5$hi = i64toi32_i32$1;
              break label$1;
            }
            i64toi32_i32$1 = 0;
            $30_1 = $4_1;
            $4_1 = Math_clz32($4_1);
            i64toi32_i32$5 = 0;
            $86($2_1 | 0, $30_1 | 0, i64toi32_i32$1 | 0, 0 | 0, i64toi32_i32$5 | 0, $4_1 + 81 | 0 | 0);
            i64toi32_i32$0 = $2_1 + 8 | 0;
            i64toi32_i32$5 = HEAP32[i64toi32_i32$0 >> 2] | 0;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
            i64toi32_i32$0 = i64toi32_i32$5;
            i64toi32_i32$5 = 65536;
            i64toi32_i32$3 = 0;
            i64toi32_i32$5 = i64toi32_i32$1 ^ i64toi32_i32$5 | 0;
            $38_1 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
            $38$hi = i64toi32_i32$5;
            i64toi32_i32$5 = 0;
            i64toi32_i32$1 = 16265 - $4_1 | 0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$3 = 48;
            i64toi32_i32$2 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$1 << i64toi32_i32$2 | 0;
              $26_1 = 0;
            } else {
              i64toi32_i32$0 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$2 | 0) | 0;
              $26_1 = i64toi32_i32$1 << i64toi32_i32$2 | 0;
            }
            $42$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $38$hi;
            i64toi32_i32$5 = $38_1;
            i64toi32_i32$1 = $42$hi;
            i64toi32_i32$3 = $26_1;
            i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
            $5_1 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
            $5$hi = i64toi32_i32$1;
            i64toi32_i32$0 = $2_1;
            i64toi32_i32$1 = HEAP32[i64toi32_i32$0 >> 2] | 0;
            i64toi32_i32$5 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
            $6_1 = i64toi32_i32$1;
            $6$hi = i64toi32_i32$5;
          }
          i64toi32_i32$5 = $6$hi;
          i64toi32_i32$1 = $0_1;
          HEAP32[i64toi32_i32$1 >> 2] = $6_1;
          HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$5;
          $48_1 = i64toi32_i32$1;
          i64toi32_i32$5 = $5$hi;
          $49_1 = $5_1;
          $49$hi = i64toi32_i32$5;
          i64toi32_i32$5 = 0;
          i64toi32_i32$0 = $3_1 & -2147483648 | 0;
          i64toi32_i32$1 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$2 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$1 = i64toi32_i32$0 << i64toi32_i32$2 | 0;
            $27_1 = 0;
          } else {
            i64toi32_i32$1 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$2 | 0) | 0;
            $27_1 = i64toi32_i32$0 << i64toi32_i32$2 | 0;
          }
          $53$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $49$hi;
          i64toi32_i32$5 = $49_1;
          i64toi32_i32$0 = $53$hi;
          i64toi32_i32$3 = $27_1;
          i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
          $54_1 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
          i64toi32_i32$5 = $48_1;
          HEAP32[(i64toi32_i32$5 + 8 | 0) >> 2] = $54_1;
          HEAP32[(i64toi32_i32$5 + 12 | 0) >> 2] = i64toi32_i32$0;
          global$0 = $2_1 + 16 | 0;
        }

        function $92($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$5 = 0,i64toi32_i32$3 = 0,$3_1 = 0,i64toi32_i32$4 = 0,$2_1 = 0,$4_1 = 0,$4$hi = 0,$5_1 = 0,$5$hi = 0,$21_1 = 0,$22_1 = 0,$19_1 = 0,$27_1 = 0,$27$hi = 0,$31$hi = 0,$32_1 = 0,$32$hi = 0,$36$hi = 0;
          $2_1 = global$0 - 16 | 0;
          global$0 = $2_1;
          label$1: {
            label$2: {
              if ($1_1) {
                break label$2;
              }
              i64toi32_i32$0 = 0;
              $4_1 = 0;
              $4$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $5_1 = 0;
              $5$hi = i64toi32_i32$0;
              break label$1;
            }
            $3_1 = $1_1 >> 31 | 0;
            $3_1 = ($1_1 ^ $3_1 | 0) - $3_1 | 0;
            i64toi32_i32$0 = 0;
            $19_1 = $3_1;
            $3_1 = Math_clz32($3_1);
            i64toi32_i32$1 = 0;
            $86($2_1 | 0, $19_1 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$1 | 0, $3_1 + 81 | 0 | 0);
            i64toi32_i32$2 = $2_1 + 8 | 0;
            i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
            i64toi32_i32$2 = i64toi32_i32$1;
            i64toi32_i32$1 = 65536;
            i64toi32_i32$3 = 0;
            i64toi32_i32$1 = i64toi32_i32$0 ^ i64toi32_i32$1 | 0;
            $27_1 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
            $27$hi = i64toi32_i32$1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$0 = 16414 - $3_1 | 0;
            i64toi32_i32$2 = 0;
            i64toi32_i32$3 = 48;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
              $21_1 = 0;
            } else {
              i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
              $21_1 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
            }
            $31$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $27$hi;
            i64toi32_i32$1 = $27_1;
            i64toi32_i32$0 = $31$hi;
            i64toi32_i32$3 = $21_1;
            i64toi32_i32$4 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
            i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
            if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
              i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
            }
            $32_1 = i64toi32_i32$4;
            $32$hi = i64toi32_i32$5;
            i64toi32_i32$5 = 0;
            i64toi32_i32$2 = $1_1 & -2147483648 | 0;
            i64toi32_i32$1 = 0;
            i64toi32_i32$3 = 32;
            i64toi32_i32$0 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$0 | 0;
              $22_1 = 0;
            } else {
              i64toi32_i32$1 = ((1 << i64toi32_i32$0 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$0 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$0 | 0) | 0;
              $22_1 = i64toi32_i32$2 << i64toi32_i32$0 | 0;
            }
            $36$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $32$hi;
            i64toi32_i32$5 = $32_1;
            i64toi32_i32$2 = $36$hi;
            i64toi32_i32$3 = $22_1;
            i64toi32_i32$2 = i64toi32_i32$1 | i64toi32_i32$2 | 0;
            $5_1 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
            $5$hi = i64toi32_i32$2;
            i64toi32_i32$1 = $2_1;
            i64toi32_i32$2 = HEAP32[i64toi32_i32$1 >> 2] | 0;
            i64toi32_i32$5 = HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] | 0;
            $4_1 = i64toi32_i32$2;
            $4$hi = i64toi32_i32$5;
          }
          i64toi32_i32$5 = $4$hi;
          i64toi32_i32$2 = $0_1;
          HEAP32[i64toi32_i32$2 >> 2] = $4_1;
          HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] = i64toi32_i32$5;
          i64toi32_i32$5 = $5$hi;
          HEAP32[(i64toi32_i32$2 + 8 | 0) >> 2] = $5_1;
          HEAP32[(i64toi32_i32$2 + 12 | 0) >> 2] = i64toi32_i32$5;
          global$0 = $2_1 + 16 | 0;
        }

        function $93($0_1, $1_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          var i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$5 = 0,i64toi32_i32$4 = 0,i64toi32_i32$3 = 0,$2_1 = 0,$3_1 = 0,$3$hi = 0,$4_1 = 0,$4$hi = 0,$17_1 = 0,$11_1 = 0,$20_1 = 0,$20$hi = 0,$24$hi = 0;
          $2_1 = global$0 - 16 | 0;
          global$0 = $2_1;
          label$1: {
            label$2: {
              if ($1_1) {
                break label$2;
              }
              i64toi32_i32$0 = 0;
              $3_1 = 0;
              $3$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $4_1 = 0;
              $4$hi = i64toi32_i32$0;
              break label$1;
            }
            i64toi32_i32$0 = 0;
            $11_1 = $1_1;
            $1_1 = Math_clz32($1_1);
            i64toi32_i32$1 = 0;
            $86($2_1 | 0, $11_1 | 0, i64toi32_i32$0 | 0, 0 | 0, i64toi32_i32$1 | 0, 112 - ($1_1 ^ 31 | 0) | 0 | 0);
            i64toi32_i32$2 = $2_1 + 8 | 0;
            i64toi32_i32$1 = HEAP32[i64toi32_i32$2 >> 2] | 0;
            i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
            i64toi32_i32$2 = i64toi32_i32$1;
            i64toi32_i32$1 = 65536;
            i64toi32_i32$3 = 0;
            i64toi32_i32$1 = i64toi32_i32$0 ^ i64toi32_i32$1 | 0;
            $20_1 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
            $20$hi = i64toi32_i32$1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$0 = 16414 - $1_1 | 0;
            i64toi32_i32$2 = 0;
            i64toi32_i32$3 = 48;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
              $17_1 = 0;
            } else {
              i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
              $17_1 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
            }
            $24$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $20$hi;
            i64toi32_i32$1 = $20_1;
            i64toi32_i32$0 = $24$hi;
            i64toi32_i32$3 = $17_1;
            i64toi32_i32$4 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
            i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
            if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
              i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
            }
            $4_1 = i64toi32_i32$4;
            $4$hi = i64toi32_i32$5;
            i64toi32_i32$2 = $2_1;
            i64toi32_i32$5 = HEAP32[i64toi32_i32$2 >> 2] | 0;
            i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
            $3_1 = i64toi32_i32$5;
            $3$hi = i64toi32_i32$1;
          }
          i64toi32_i32$1 = $3$hi;
          i64toi32_i32$5 = $0_1;
          HEAP32[i64toi32_i32$5 >> 2] = $3_1;
          HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] = i64toi32_i32$1;
          i64toi32_i32$1 = $4$hi;
          HEAP32[(i64toi32_i32$5 + 8 | 0) >> 2] = $4_1;
          HEAP32[(i64toi32_i32$5 + 12 | 0) >> 2] = i64toi32_i32$1;
          global$0 = $2_1 + 16 | 0;
        }

        function $94() {
          return 0 | 0;
        }

        function $95() {
          return 0 | 0;
        }

        function $96($0_1, $1_1, $1$hi, $2_1, $2$hi, $3_1) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$4 = 0,i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$3 = 0,$4$hi = 0,$18_1 = 0,$20_1 = 0,$21_1 = 0,$22_1 = 0,$11$hi = 0,$18$hi = 0,$19_1 = 0,$19$hi = 0,$4_1 = 0,$24$hi = 0;
          label$1: {
            label$2: {
              if (!($3_1 & 64 | 0)) {
                break label$2;
              }
              i64toi32_i32$0 = $2$hi;
              i64toi32_i32$0 = 0;
              $11$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $2$hi;
              i64toi32_i32$2 = $2_1;
              i64toi32_i32$1 = $11$hi;
              i64toi32_i32$3 = $3_1 + -64 | 0;
              i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $18_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                $18_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
              }
              $1_1 = $18_1;
              $1$hi = i64toi32_i32$1;
              i64toi32_i32$1 = 0;
              $2_1 = 0;
              $2$hi = i64toi32_i32$1;
              break label$1;
            }
            if (!$3_1) {
              break label$1;
            }
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$1 = 0;
            $18$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$0 = $2_1;
            i64toi32_i32$2 = $18$hi;
            i64toi32_i32$3 = 64 - $3_1 | 0;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
              $20_1 = 0;
            } else {
              i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
              $20_1 = i64toi32_i32$0 << i64toi32_i32$4 | 0;
            }
            $19_1 = $20_1;
            $19$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$2 = 0;
            $4_1 = $3_1;
            $4$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$1 = $1_1;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$3 = $3_1;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = 0;
              $21_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
            } else {
              i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
              $21_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
            }
            $24$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $19$hi;
            i64toi32_i32$2 = $19_1;
            i64toi32_i32$1 = $24$hi;
            i64toi32_i32$3 = $21_1;
            i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
            $1_1 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
            $1$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$0 = $2_1;
            i64toi32_i32$2 = $4$hi;
            i64toi32_i32$3 = $4_1;
            i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = 0;
              $22_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
            } else {
              i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
              $22_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
            }
            $2_1 = $22_1;
            $2$hi = i64toi32_i32$2;
          }
          i64toi32_i32$2 = $1$hi;
          i64toi32_i32$0 = $0_1;
          HEAP32[i64toi32_i32$0 >> 2] = $1_1;
          HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$2;
          i64toi32_i32$2 = $2$hi;
          HEAP32[(i64toi32_i32$0 + 8 | 0) >> 2] = $2_1;
          HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] = i64toi32_i32$2;
        }

        function $97($0_1, $1_1, $1$hi, $2_1, $2$hi, $3_1, $3$hi, $4_1, $4$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          $3$hi = $3$hi | 0;
          $4_1 = $4_1 | 0;
          $4$hi = $4$hi | 0;
          var i64toi32_i32$3 = 0,i64toi32_i32$2 = 0,i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,i64toi32_i32$5 = 0,i64toi32_i32$4 = 0,$14$hi = 0,$5_1 = 0,$11$hi = 0,$11_1 = 0,$14_1 = 0,$10$hi = 0,$12$hi = 0,$6_1 = 0,$18$hi = 0,$12_1 = 0,$10_1 = 0,$8_1 = 0,$15$hi = 0,$18_1 = 0,$7_1 = 0,$16$hi = 0,$17$hi = 0,$20$hi = 0,$13_1 = 0,$13$hi = 0,$16_1 = 0,$17_1 = 0,$20_1 = 0,$15_1 = 0,$21$hi = 0,$9_1 = 0,$19$hi = 0,$22$hi = 0,$23$hi = 0,$24$hi = 0,$220 = 0,$221 = 0,$223 = 0,$224 = 0,$226 = 0,$228 = 0,$229 = 0,$230 = 0,$231 = 0,$232 = 0,$19_1 = 0,$233 = 0,$234 = 0,$21_1 = 0,$235 = 0,$237 = 0,$22_1 = 0,$239 = 0,$240 = 0,$24_1 = 0,$241 = 0,$242 = 0,$243 = 0,$245 = 0,$246 = 0,$247 = 0,$248 = 0,$250 = 0,$251 = 0,$252 = 0,$253 = 0,$254 = 0,$255 = 0,$256 = 0,$257 = 0,$258 = 0,$53_1 = 0,$57_1 = 0,$64_1 = 0,$68_1 = 0,$77_1 = 0,$77$hi = 0,$89_1 = 0,$89$hi = 0,$111_1 = 0,$112_1 = 0,$112$hi = 0,$113 = 0,$113$hi = 0,$120$hi = 0,$123$hi = 0,$140 = 0,$141 = 0,$141$hi = 0,$142 = 0,$142$hi = 0,$149$hi = 0,$152$hi = 0,$170 = 0,$170$hi = 0,$175 = 0,$175$hi = 0,$182 = 0,$182$hi = 0,$189 = 0,$189$hi = 0,$194 = 0,$194$hi = 0,$203 = 0,$203$hi = 0,$205 = 0,$205$hi = 0,$207 = 0,$207$hi = 0,$215 = 0,$215$hi = 0,$217 = 0,$217$hi = 0,$219 = 0,$219$hi = 0,$222 = 0,$224$hi = 0,$225 = 0,$225$hi = 0,$227 = 0,$227$hi = 0,$236 = 0,$236$hi = 0,$238 = 0,$238$hi = 0,$244 = 0,$244$hi = 0,$249 = 0,$249$hi = 0,$252$hi = 0,$23_1 = 0,$268 = 0,$268$hi = 0,$272 = 0,$273 = 0,$273$hi = 0,$277 = 0,$277$hi = 0,$281 = 0,$282$hi = 0,$283$hi = 0,$286 = 0,$286$hi = 0,$287 = 0,$287$hi = 0,$288 = 0,$288$hi = 0,$291 = 0,$292$hi = 0,$295 = 0,$296$hi = 0,$297$hi = 0,$301 = 0,$302$hi = 0,$303 = 0,$303$hi = 0,$310 = 0,$310$hi = 0,$314 = 0,$316 = 0,$316$hi = 0,$318$hi = 0,$319 = 0,$319$hi = 0,$320 = 0,$320$hi = 0,$321 = 0,$321$hi = 0,$323$hi = 0,$327 = 0,$328$hi = 0,$329 = 0,$329$hi = 0,$330 = 0,$330$hi = 0,$332 = 0,$332$hi = 0,$335 = 0,$336$hi = 0,$339 = 0,$340$hi = 0,$341$hi = 0,$344 = 0,$345$hi = 0,$347$hi = 0,$348 = 0,$348$hi = 0,$352 = 0,$353$hi = 0,$354 = 0,$354$hi = 0,$355 = 0,$355$hi = 0,$358 = 0,$359$hi = 0,$362 = 0,$363$hi = 0,$364$hi = 0,$368 = 0,$369$hi = 0,$379 = 0,$379$hi = 0,$381$hi = 0,$384 = 0,$384$hi = 0,$386$hi = 0,$390 = 0,$390$hi = 0,$392$hi = 0,$426 = 0,$426$hi = 0,$428 = 0,$428$hi = 0,$429 = 0,$429$hi = 0,$431 = 0,$431$hi = 0,$435 = 0,$435$hi = 0,$437 = 0,$438$hi = 0,$443 = 0,$443$hi = 0,$447 = 0,$447$hi = 0,$456$hi = 0,$458 = 0,$458$hi = 0,$464 = 0,$470 = 0,$470$hi = 0,$474 = 0,$475$hi = 0,$479 = 0,$479$hi = 0,$483 = 0,$483$hi = 0,$486 = 0,$486$hi = 0,$490 = 0,$491$hi = 0;
          $5_1 = global$0 - 96 | 0;
          global$0 = $5_1;
          i64toi32_i32$0 = $4$hi;
          i64toi32_i32$2 = $4_1;
          i64toi32_i32$1 = 65535;
          i64toi32_i32$3 = -1;
          i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
          $10_1 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
          $10$hi = i64toi32_i32$1;
          i64toi32_i32$1 = i64toi32_i32$0;
          i64toi32_i32$1 = $2$hi;
          i64toi32_i32$1 = i64toi32_i32$0;
          i64toi32_i32$0 = i64toi32_i32$2;
          i64toi32_i32$2 = $2$hi;
          i64toi32_i32$3 = $2_1;
          i64toi32_i32$2 = i64toi32_i32$1 ^ i64toi32_i32$2 | 0;
          i64toi32_i32$1 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
          i64toi32_i32$0 = -2147483648;
          i64toi32_i32$3 = 0;
          i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
          $11_1 = i64toi32_i32$1 & i64toi32_i32$3 | 0;
          $11$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $2$hi;
          i64toi32_i32$2 = $2_1;
          i64toi32_i32$1 = 65535;
          i64toi32_i32$3 = -1;
          i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
          $12_1 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
          $12$hi = i64toi32_i32$1;
          i64toi32_i32$0 = $12_1;
          i64toi32_i32$2 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$2 = 0;
            $220 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
          } else {
            i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
            $220 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
          }
          $13_1 = $220;
          $13$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $4$hi;
          i64toi32_i32$1 = $4_1;
          i64toi32_i32$0 = 0;
          i64toi32_i32$3 = 48;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$0 = 0;
            $221 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
          } else {
            i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
            $221 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;
          }
          $6_1 = $221 & 32767 | 0;
          label$1: {
            label$2: {
              label$3: {
                i64toi32_i32$0 = $2$hi;
                i64toi32_i32$2 = $2_1;
                i64toi32_i32$1 = 0;
                i64toi32_i32$3 = 48;
                i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                  i64toi32_i32$1 = 0;
                  $223 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                } else {
                  i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                  $223 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
                }
                $7_1 = $223 & 32767 | 0;
                if (($7_1 + -32767 | 0) >>> 0 < -32766 >>> 0) {
                  break label$3;
                }
                $8_1 = 0;
                if (($6_1 + -32767 | 0) >>> 0 > -32767 >>> 0) {
                  break label$2;
                }
              }
              label$4: {
                i64toi32_i32$1 = $1$hi;
                $53_1 = !($1_1 | i64toi32_i32$1 | 0);
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$0 = $2_1;
                i64toi32_i32$2 = 2147483647;
                i64toi32_i32$3 = -1;
                i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
                $14_1 = i64toi32_i32$0 & i64toi32_i32$3 | 0;
                $14$hi = i64toi32_i32$2;
                i64toi32_i32$1 = $14_1;
                i64toi32_i32$0 = 2147418112;
                i64toi32_i32$3 = 0;
                $57_1 = i64toi32_i32$2 >>> 0 < i64toi32_i32$0 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0 | 0) | 0;
                i64toi32_i32$1 = i64toi32_i32$2;
                i64toi32_i32$1 = i64toi32_i32$2;
                i64toi32_i32$3 = $14_1;
                i64toi32_i32$2 = 2147418112;
                i64toi32_i32$0 = 0;
                if ((i64toi32_i32$3 | 0) == (i64toi32_i32$0 | 0) & (i64toi32_i32$1 | 0) == (i64toi32_i32$2 | 0) | 0 ? $53_1 : $57_1) {
                  break label$4;
                }
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$0 = $2_1;
                i64toi32_i32$1 = 32768;
                i64toi32_i32$2 = 0;
                i64toi32_i32$1 = i64toi32_i32$3 | i64toi32_i32$1 | 0;
                $11_1 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
                $11$hi = i64toi32_i32$1;
                break label$1;
              }
              label$5: {
                i64toi32_i32$1 = $3$hi;
                $64_1 = !($3_1 | i64toi32_i32$1 | 0);
                i64toi32_i32$1 = $4$hi;
                i64toi32_i32$3 = $4_1;
                i64toi32_i32$0 = 2147483647;
                i64toi32_i32$2 = -1;
                i64toi32_i32$0 = i64toi32_i32$1 & i64toi32_i32$0 | 0;
                $2_1 = i64toi32_i32$3 & i64toi32_i32$2 | 0;
                $2$hi = i64toi32_i32$0;
                i64toi32_i32$1 = $2_1;
                i64toi32_i32$3 = 2147418112;
                i64toi32_i32$2 = 0;
                $68_1 = i64toi32_i32$0 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
                i64toi32_i32$1 = i64toi32_i32$0;
                i64toi32_i32$1 = i64toi32_i32$0;
                i64toi32_i32$2 = $2_1;
                i64toi32_i32$0 = 2147418112;
                i64toi32_i32$3 = 0;
                if ((i64toi32_i32$2 | 0) == (i64toi32_i32$3 | 0) & (i64toi32_i32$1 | 0) == (i64toi32_i32$0 | 0) | 0 ? $64_1 : $68_1) {
                  break label$5;
                }
                i64toi32_i32$2 = $4$hi;
                i64toi32_i32$3 = $4_1;
                i64toi32_i32$1 = 32768;
                i64toi32_i32$0 = 0;
                i64toi32_i32$1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
                $11_1 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
                $11$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $3$hi;
                $1_1 = $3_1;
                $1$hi = i64toi32_i32$1;
                break label$1;
              }
              label$6: {
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$1 = $14$hi;
                i64toi32_i32$2 = $14_1;
                i64toi32_i32$3 = 2147418112;
                i64toi32_i32$0 = 0;
                i64toi32_i32$3 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
                $77_1 = i64toi32_i32$2 ^ i64toi32_i32$0 | 0;
                $77$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $1$hi;
                i64toi32_i32$1 = $1_1;
                i64toi32_i32$2 = $77$hi;
                i64toi32_i32$0 = $77_1;
                i64toi32_i32$2 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
                i64toi32_i32$3 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
                i64toi32_i32$1 = 0;
                i64toi32_i32$0 = 0;
                if ((i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$1 | 0) | 0) {
                  break label$6;
                }
                label$7: {
                  i64toi32_i32$3 = $3$hi;
                  i64toi32_i32$3 = $2$hi;
                  i64toi32_i32$3 = $3$hi;
                  i64toi32_i32$0 = $3_1;
                  i64toi32_i32$2 = $2$hi;
                  i64toi32_i32$1 = $2_1;
                  i64toi32_i32$2 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
                  if (!!(i64toi32_i32$0 | i64toi32_i32$1 | 0 | i64toi32_i32$2 | 0)) {
                    break label$7;
                  }
                  i64toi32_i32$2 = 2147450880;
                  $11_1 = 0;
                  $11$hi = i64toi32_i32$2;
                  i64toi32_i32$2 = 0;
                  $1_1 = 0;
                  $1$hi = i64toi32_i32$2;
                  break label$1;
                }
                i64toi32_i32$2 = $11$hi;
                i64toi32_i32$3 = $11_1;
                i64toi32_i32$0 = 2147418112;
                i64toi32_i32$1 = 0;
                i64toi32_i32$0 = i64toi32_i32$2 | i64toi32_i32$0 | 0;
                $11_1 = i64toi32_i32$3 | i64toi32_i32$1 | 0;
                $11$hi = i64toi32_i32$0;
                i64toi32_i32$0 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$0;
                break label$1;
              }
              label$8: {
                i64toi32_i32$0 = $3$hi;
                i64toi32_i32$0 = $2$hi;
                i64toi32_i32$2 = $2_1;
                i64toi32_i32$3 = 2147418112;
                i64toi32_i32$1 = 0;
                i64toi32_i32$3 = i64toi32_i32$0 ^ i64toi32_i32$3 | 0;
                $89_1 = i64toi32_i32$2 ^ i64toi32_i32$1 | 0;
                $89$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $3$hi;
                i64toi32_i32$0 = $3_1;
                i64toi32_i32$2 = $89$hi;
                i64toi32_i32$1 = $89_1;
                i64toi32_i32$2 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
                i64toi32_i32$3 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
                i64toi32_i32$0 = 0;
                i64toi32_i32$1 = 0;
                if ((i64toi32_i32$3 | 0) != (i64toi32_i32$1 | 0) | (i64toi32_i32$2 | 0) != (i64toi32_i32$0 | 0) | 0) {
                  break label$8;
                }
                i64toi32_i32$3 = $1$hi;
                i64toi32_i32$3 = $14$hi;
                i64toi32_i32$3 = $1$hi;
                i64toi32_i32$1 = $1_1;
                i64toi32_i32$2 = $14$hi;
                i64toi32_i32$0 = $14_1;
                i64toi32_i32$2 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
                $2_1 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
                $2$hi = i64toi32_i32$2;
                i64toi32_i32$2 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$2;
                label$9: {
                  i64toi32_i32$2 = $2$hi;
                  if (!!($2_1 | i64toi32_i32$2 | 0)) {
                    break label$9;
                  }
                  i64toi32_i32$2 = 2147450880;
                  $11_1 = 0;
                  $11$hi = i64toi32_i32$2;
                  break label$1;
                }
                i64toi32_i32$2 = $11$hi;
                i64toi32_i32$3 = $11_1;
                i64toi32_i32$1 = 2147418112;
                i64toi32_i32$0 = 0;
                i64toi32_i32$1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
                $11_1 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
                $11$hi = i64toi32_i32$1;
                break label$1;
              }
              label$10: {
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$1 = $14$hi;
                i64toi32_i32$1 = $1$hi;
                i64toi32_i32$2 = $1_1;
                i64toi32_i32$3 = $14$hi;
                i64toi32_i32$0 = $14_1;
                i64toi32_i32$3 = i64toi32_i32$1 | i64toi32_i32$3 | 0;
                i64toi32_i32$1 = i64toi32_i32$2 | i64toi32_i32$0 | 0;
                i64toi32_i32$2 = 0;
                i64toi32_i32$0 = 0;
                if ((i64toi32_i32$1 | 0) != (i64toi32_i32$0 | 0) | (i64toi32_i32$3 | 0) != (i64toi32_i32$2 | 0) | 0) {
                  break label$10;
                }
                i64toi32_i32$1 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$1;
                break label$1;
              }
              label$11: {
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$1 = $2$hi;
                i64toi32_i32$1 = $3$hi;
                i64toi32_i32$0 = $3_1;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$2 = $2_1;
                i64toi32_i32$3 = i64toi32_i32$1 | i64toi32_i32$3 | 0;
                i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
                i64toi32_i32$0 = 0;
                i64toi32_i32$2 = 0;
                if ((i64toi32_i32$1 | 0) != (i64toi32_i32$2 | 0) | (i64toi32_i32$3 | 0) != (i64toi32_i32$0 | 0) | 0) {
                  break label$11;
                }
                i64toi32_i32$1 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$1;
                break label$1;
              }
              $8_1 = 0;
              label$12: {
                i64toi32_i32$1 = $14$hi;
                i64toi32_i32$2 = $14_1;
                i64toi32_i32$3 = 65535;
                i64toi32_i32$0 = -1;
                if (i64toi32_i32$1 >>> 0 > i64toi32_i32$3 >>> 0 | ((i64toi32_i32$1 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$2 >>> 0 > i64toi32_i32$0 >>> 0 | 0) | 0) {
                  break label$12;
                }
                $111_1 = $5_1 + 80 | 0;
                i64toi32_i32$2 = $1$hi;
                $112_1 = $1_1;
                $112$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $12$hi;
                $113 = $12_1;
                $113$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $1$hi;
                i64toi32_i32$2 = $12$hi;
                $8_1 = !($12_1 | i64toi32_i32$2 | 0);
                i64toi32_i32$4 = $8_1;
                i64toi32_i32$2 = $1$hi;
                i64toi32_i32$1 = $12$hi;
                i64toi32_i32$3 = i64toi32_i32$4 ? $1_1 : $12_1;
                i64toi32_i32$0 = i64toi32_i32$4 ? i64toi32_i32$2 : i64toi32_i32$1;
                i64toi32_i32$2 = Math_clz32(i64toi32_i32$0);
                i64toi32_i32$4 = 0;
                if ((i64toi32_i32$2 | 0) == (32 | 0)) {
                  $224 = Math_clz32(i64toi32_i32$3) + 32 | 0;
                } else {
                  $224 = i64toi32_i32$2;
                }
                $120$hi = i64toi32_i32$4;
                i64toi32_i32$4 = 0;
                $123$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $120$hi;
                i64toi32_i32$3 = $224;
                i64toi32_i32$0 = $123$hi;
                i64toi32_i32$2 = $8_1 << 6 | 0;
                i64toi32_i32$1 = i64toi32_i32$3 + i64toi32_i32$2 | 0;
                i64toi32_i32$5 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$1 >>> 0 < i64toi32_i32$2 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $8_1 = i64toi32_i32$1;
                i64toi32_i32$5 = $112$hi;
                i64toi32_i32$3 = $113$hi;
                $86($111_1 | 0, $112_1 | 0, i64toi32_i32$5 | 0, $113 | 0, i64toi32_i32$3 | 0, i64toi32_i32$1 + -15 | 0 | 0);
                $8_1 = 16 - i64toi32_i32$1 | 0;
                i64toi32_i32$4 = $5_1 + 88 | 0;
                i64toi32_i32$3 = HEAP32[i64toi32_i32$4 >> 2] | 0;
                i64toi32_i32$5 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
                $12_1 = i64toi32_i32$3;
                $12$hi = i64toi32_i32$5;
                i64toi32_i32$4 = i64toi32_i32$3;
                i64toi32_i32$3 = 0;
                i64toi32_i32$2 = 32;
                i64toi32_i32$0 = i64toi32_i32$2 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                  i64toi32_i32$3 = 0;
                  $226 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
                } else {
                  i64toi32_i32$3 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
                  $226 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$0 | 0) | 0;
                }
                $13_1 = $226;
                $13$hi = i64toi32_i32$3;
                i64toi32_i32$5 = $5_1;
                i64toi32_i32$3 = HEAP32[(i64toi32_i32$5 + 80 | 0) >> 2] | 0;
                i64toi32_i32$4 = HEAP32[(i64toi32_i32$5 + 84 | 0) >> 2] | 0;
                $1_1 = i64toi32_i32$3;
                $1$hi = i64toi32_i32$4;
              }
              i64toi32_i32$4 = $2$hi;
              i64toi32_i32$5 = $2_1;
              i64toi32_i32$3 = 65535;
              i64toi32_i32$2 = -1;
              if (i64toi32_i32$4 >>> 0 > i64toi32_i32$3 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$5 >>> 0 > i64toi32_i32$2 >>> 0 | 0) | 0) {
                break label$2;
              }
              $140 = $5_1 + 64 | 0;
              i64toi32_i32$5 = $3$hi;
              $141 = $3_1;
              $141$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $10$hi;
              $142 = $10_1;
              $142$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $3$hi;
              i64toi32_i32$5 = $10$hi;
              $9_1 = !($10_1 | i64toi32_i32$5 | 0);
              i64toi32_i32$0 = $9_1;
              i64toi32_i32$5 = $3$hi;
              i64toi32_i32$4 = $10$hi;
              i64toi32_i32$3 = i64toi32_i32$0 ? $3_1 : $10_1;
              i64toi32_i32$2 = i64toi32_i32$0 ? i64toi32_i32$5 : i64toi32_i32$4;
              i64toi32_i32$5 = Math_clz32(i64toi32_i32$2);
              i64toi32_i32$0 = 0;
              if ((i64toi32_i32$5 | 0) == (32 | 0)) {
                $228 = Math_clz32(i64toi32_i32$3) + 32 | 0;
              } else {
                $228 = i64toi32_i32$5;
              }
              $149$hi = i64toi32_i32$0;
              i64toi32_i32$0 = 0;
              $152$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $149$hi;
              i64toi32_i32$3 = $228;
              i64toi32_i32$2 = $152$hi;
              i64toi32_i32$5 = $9_1 << 6 | 0;
              i64toi32_i32$4 = i64toi32_i32$3 + i64toi32_i32$5 | 0;
              i64toi32_i32$1 = i64toi32_i32$0 + i64toi32_i32$2 | 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$5 >>> 0) {
                i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
              }
              $9_1 = i64toi32_i32$4;
              i64toi32_i32$1 = $141$hi;
              i64toi32_i32$3 = $142$hi;
              $86($140 | 0, $141 | 0, i64toi32_i32$1 | 0, $142 | 0, i64toi32_i32$3 | 0, i64toi32_i32$4 + -15 | 0 | 0);
              $8_1 = ($8_1 - i64toi32_i32$4 | 0) + 16 | 0;
              i64toi32_i32$0 = $5_1 + 72 | 0;
              i64toi32_i32$3 = HEAP32[i64toi32_i32$0 >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
              $10_1 = i64toi32_i32$3;
              $10$hi = i64toi32_i32$1;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$0 + 64 | 0) >> 2] | 0;
              i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 68 | 0) >> 2] | 0;
              $3_1 = i64toi32_i32$1;
              $3$hi = i64toi32_i32$3;
            }
            i64toi32_i32$3 = $3$hi;
            i64toi32_i32$0 = $3_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$5 = 15;
            i64toi32_i32$2 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = i64toi32_i32$0 << i64toi32_i32$2 | 0;
              $229 = 0;
            } else {
              i64toi32_i32$1 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$2 | 0) | 0;
              $229 = i64toi32_i32$0 << i64toi32_i32$2 | 0;
            }
            $14_1 = $229;
            $14$hi = i64toi32_i32$1;
            i64toi32_i32$3 = $14_1;
            i64toi32_i32$0 = 0;
            i64toi32_i32$5 = -32768;
            i64toi32_i32$0 = i64toi32_i32$1 & i64toi32_i32$0 | 0;
            $2_1 = i64toi32_i32$3 & i64toi32_i32$5 | 0;
            $2$hi = i64toi32_i32$0;
            $170 = $2_1;
            $170$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$1 = $1_1;
            i64toi32_i32$3 = 0;
            i64toi32_i32$5 = 32;
            i64toi32_i32$2 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$3 = 0;
              $230 = i64toi32_i32$0 >>> i64toi32_i32$2 | 0;
            } else {
              i64toi32_i32$3 = i64toi32_i32$0 >>> i64toi32_i32$2 | 0;
              $230 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$2 | 0) | 0;
            }
            $4_1 = $230;
            $4$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $170$hi;
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$1 = __wasm_i64_mul($170 | 0, i64toi32_i32$3 | 0, $4_1 | 0, i64toi32_i32$1 | 0) | 0;
            i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
            $15_1 = i64toi32_i32$1;
            $15$hi = i64toi32_i32$3;
            $175 = i64toi32_i32$1;
            $175$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $14$hi;
            i64toi32_i32$0 = $14_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$5 = 32;
            i64toi32_i32$2 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = 0;
              $231 = i64toi32_i32$3 >>> i64toi32_i32$2 | 0;
            } else {
              i64toi32_i32$1 = i64toi32_i32$3 >>> i64toi32_i32$2 | 0;
              $231 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$3 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$2 | 0) | 0;
            }
            $14_1 = $231;
            $14$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$3 = $1_1;
            i64toi32_i32$0 = 0;
            i64toi32_i32$5 = -1;
            i64toi32_i32$0 = i64toi32_i32$1 & i64toi32_i32$0 | 0;
            $1_1 = i64toi32_i32$3 & i64toi32_i32$5 | 0;
            $1$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $14$hi;
            i64toi32_i32$3 = $1$hi;
            i64toi32_i32$3 = __wasm_i64_mul($14_1 | 0, i64toi32_i32$0 | 0, $1_1 | 0, i64toi32_i32$3 | 0) | 0;
            i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
            $182 = i64toi32_i32$3;
            $182$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $175$hi;
            i64toi32_i32$1 = $175;
            i64toi32_i32$3 = $182$hi;
            i64toi32_i32$5 = $182;
            i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
            i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
            if (i64toi32_i32$2 >>> 0 < i64toi32_i32$5 >>> 0) {
              i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
            }
            $16_1 = i64toi32_i32$2;
            $16$hi = i64toi32_i32$4;
            i64toi32_i32$0 = i64toi32_i32$2;
            i64toi32_i32$1 = 0;
            i64toi32_i32$5 = 32;
            i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
              $232 = 0;
            } else {
              i64toi32_i32$1 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$3 | 0) | 0;
              $232 = i64toi32_i32$0 << i64toi32_i32$3 | 0;
            }
            $17_1 = $232;
            $17$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$0 = $1$hi;
            i64toi32_i32$0 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$1 | 0, $1_1 | 0, i64toi32_i32$0 | 0) | 0;
            i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
            $189 = i64toi32_i32$0;
            $189$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $17$hi;
            i64toi32_i32$4 = $17_1;
            i64toi32_i32$0 = $189$hi;
            i64toi32_i32$5 = $189;
            i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$5 | 0;
            i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$0 | 0;
            if (i64toi32_i32$3 >>> 0 < i64toi32_i32$5 >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
            }
            $18_1 = i64toi32_i32$3;
            $18$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $17$hi;
            i64toi32_i32$2 = $18$hi;
            i64toi32_i32$1 = i64toi32_i32$3;
            i64toi32_i32$4 = $17$hi;
            i64toi32_i32$5 = $17_1;
            i64toi32_i32$1 = 0;
            $194 = i64toi32_i32$2 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
            $194$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $2$hi;
            i64toi32_i32$1 = $12$hi;
            i64toi32_i32$5 = $12_1;
            i64toi32_i32$2 = 0;
            i64toi32_i32$4 = -1;
            i64toi32_i32$2 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
            $12_1 = i64toi32_i32$5 & i64toi32_i32$4 | 0;
            $12$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$5 = $12$hi;
            i64toi32_i32$5 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$2 | 0, $12_1 | 0, i64toi32_i32$5 | 0) | 0;
            i64toi32_i32$2 = i64toi32_i32$HIGH_BITS;
            $19_1 = i64toi32_i32$5;
            $19$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $14$hi;
            i64toi32_i32$2 = $4$hi;
            i64toi32_i32$2 = $14$hi;
            i64toi32_i32$5 = $4$hi;
            i64toi32_i32$5 = __wasm_i64_mul($14_1 | 0, i64toi32_i32$2 | 0, $4_1 | 0, i64toi32_i32$5 | 0) | 0;
            i64toi32_i32$2 = i64toi32_i32$HIGH_BITS;
            $203 = i64toi32_i32$5;
            $203$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $19$hi;
            i64toi32_i32$1 = $19_1;
            i64toi32_i32$5 = $203$hi;
            i64toi32_i32$4 = $203;
            i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$4 | 0;
            i64toi32_i32$3 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
            if (i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0) {
              i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
            }
            $17_1 = i64toi32_i32$0;
            $17$hi = i64toi32_i32$3;
            $205 = i64toi32_i32$0;
            $205$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $3$hi;
            i64toi32_i32$2 = $3_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$4 = 49;
            i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = 0;
              $233 = i64toi32_i32$3 >>> i64toi32_i32$5 | 0;
            } else {
              i64toi32_i32$1 = i64toi32_i32$3 >>> i64toi32_i32$5 | 0;
              $233 = (((1 << i64toi32_i32$5 | 0) - 1 | 0) & i64toi32_i32$3 | 0) << (32 - i64toi32_i32$5 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$5 | 0) | 0;
            }
            $207 = $233;
            $207$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $10$hi;
            i64toi32_i32$3 = $10_1;
            i64toi32_i32$2 = 0;
            i64toi32_i32$4 = 15;
            i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
              $234 = 0;
            } else {
              i64toi32_i32$2 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$5 | 0) | 0;
              $234 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
            }
            $20_1 = $234;
            $20$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $207$hi;
            i64toi32_i32$1 = $207;
            i64toi32_i32$3 = $20$hi;
            i64toi32_i32$4 = $20_1;
            i64toi32_i32$3 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
            i64toi32_i32$2 = i64toi32_i32$1 | i64toi32_i32$4 | 0;
            i64toi32_i32$1 = 0;
            i64toi32_i32$4 = -1;
            i64toi32_i32$1 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
            $3_1 = i64toi32_i32$2 & i64toi32_i32$4 | 0;
            $3$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $1$hi;
            i64toi32_i32$1 = $3$hi;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$2 = __wasm_i64_mul($3_1 | 0, i64toi32_i32$1 | 0, $1_1 | 0, i64toi32_i32$2 | 0) | 0;
            i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
            $215 = i64toi32_i32$2;
            $215$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $205$hi;
            i64toi32_i32$3 = $205;
            i64toi32_i32$2 = $215$hi;
            i64toi32_i32$4 = $215;
            i64toi32_i32$5 = i64toi32_i32$3 + i64toi32_i32$4 | 0;
            i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
            if (i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
            }
            $21_1 = i64toi32_i32$5;
            $21$hi = i64toi32_i32$0;
            $217 = i64toi32_i32$5;
            $217$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $16$hi;
            i64toi32_i32$1 = $16_1;
            i64toi32_i32$3 = 0;
            i64toi32_i32$4 = 32;
            i64toi32_i32$2 = i64toi32_i32$4 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
              i64toi32_i32$3 = 0;
              $235 = i64toi32_i32$0 >>> i64toi32_i32$2 | 0;
            } else {
              i64toi32_i32$3 = i64toi32_i32$0 >>> i64toi32_i32$2 | 0;
              $235 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$2 | 0) | 0;
            }
            $219 = $235;
            $219$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $16$hi;
            i64toi32_i32$3 = $15$hi;
            i64toi32_i32$3 = $16$hi;
            i64toi32_i32$0 = $16_1;
            i64toi32_i32$1 = $15$hi;
            i64toi32_i32$4 = $15_1;
            $222 = i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0 | 0) | 0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$4 = $222;
            i64toi32_i32$3 = 0;
            i64toi32_i32$1 = 32;
            i64toi32_i32$2 = i64toi32_i32$1 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
              i64toi32_i32$3 = i64toi32_i32$4 << i64toi32_i32$2 | 0;
              $237 = 0;
            } else {
              i64toi32_i32$3 = ((1 << i64toi32_i32$2 | 0) - 1 | 0) & (i64toi32_i32$4 >>> (32 - i64toi32_i32$2 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$2 | 0) | 0;
              $237 = i64toi32_i32$4 << i64toi32_i32$2 | 0;
            }
            $224$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $219$hi;
            i64toi32_i32$0 = $219;
            i64toi32_i32$4 = $224$hi;
            i64toi32_i32$1 = $237;
            i64toi32_i32$4 = i64toi32_i32$3 | i64toi32_i32$4 | 0;
            $225 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
            $225$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $217$hi;
            i64toi32_i32$3 = $217;
            i64toi32_i32$0 = $225$hi;
            i64toi32_i32$1 = $225;
            i64toi32_i32$2 = i64toi32_i32$3 + i64toi32_i32$1 | 0;
            i64toi32_i32$5 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
            if (i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0) {
              i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
            }
            $16_1 = i64toi32_i32$2;
            $16$hi = i64toi32_i32$5;
            $227 = i64toi32_i32$2;
            $227$hi = i64toi32_i32$5;
            i64toi32_i32$5 = $2$hi;
            i64toi32_i32$5 = $13$hi;
            i64toi32_i32$4 = $13_1;
            i64toi32_i32$3 = 0;
            i64toi32_i32$1 = 65536;
            i64toi32_i32$3 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
            $10_1 = i64toi32_i32$4 | i64toi32_i32$1 | 0;
            $10$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $2$hi;
            i64toi32_i32$4 = $10$hi;
            i64toi32_i32$4 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$3 | 0, $10_1 | 0, i64toi32_i32$4 | 0) | 0;
            i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
            $22_1 = i64toi32_i32$4;
            $22$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $14$hi;
            i64toi32_i32$3 = $12$hi;
            i64toi32_i32$3 = $14$hi;
            i64toi32_i32$4 = $12$hi;
            i64toi32_i32$4 = __wasm_i64_mul($14_1 | 0, i64toi32_i32$3 | 0, $12_1 | 0, i64toi32_i32$4 | 0) | 0;
            i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
            $236 = i64toi32_i32$4;
            $236$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $22$hi;
            i64toi32_i32$5 = $22_1;
            i64toi32_i32$4 = $236$hi;
            i64toi32_i32$1 = $236;
            i64toi32_i32$0 = i64toi32_i32$5 + i64toi32_i32$1 | 0;
            i64toi32_i32$2 = i64toi32_i32$3 + i64toi32_i32$4 | 0;
            if (i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
            }
            $13_1 = i64toi32_i32$0;
            $13$hi = i64toi32_i32$2;
            $238 = i64toi32_i32$0;
            $238$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $20$hi;
            i64toi32_i32$3 = $20_1;
            i64toi32_i32$5 = 0;
            i64toi32_i32$1 = 32;
            i64toi32_i32$4 = i64toi32_i32$1 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
              i64toi32_i32$5 = 0;
              $239 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
            } else {
              i64toi32_i32$5 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
              $239 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$4 | 0) | 0;
            }
            i64toi32_i32$2 = $239;
            i64toi32_i32$3 = 0;
            i64toi32_i32$1 = -2147483648;
            i64toi32_i32$3 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
            $2_1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
            $2$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $1$hi;
            i64toi32_i32$3 = $2$hi;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$2 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$3 | 0, $1_1 | 0, i64toi32_i32$2 | 0) | 0;
            i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
            $244 = i64toi32_i32$2;
            $244$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $238$hi;
            i64toi32_i32$5 = $238;
            i64toi32_i32$2 = $244$hi;
            i64toi32_i32$1 = $244;
            i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$1 | 0;
            i64toi32_i32$0 = i64toi32_i32$3 + i64toi32_i32$2 | 0;
            if (i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
            }
            $15_1 = i64toi32_i32$4;
            $15$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $3$hi;
            i64toi32_i32$0 = $4$hi;
            i64toi32_i32$0 = $3$hi;
            i64toi32_i32$5 = $4$hi;
            i64toi32_i32$5 = __wasm_i64_mul($3_1 | 0, i64toi32_i32$0 | 0, $4_1 | 0, i64toi32_i32$5 | 0) | 0;
            i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
            $249 = i64toi32_i32$5;
            $249$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $15$hi;
            i64toi32_i32$3 = i64toi32_i32$4;
            i64toi32_i32$5 = $249$hi;
            i64toi32_i32$1 = $249;
            i64toi32_i32$2 = i64toi32_i32$3 + i64toi32_i32$1 | 0;
            i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$5 | 0;
            if (i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0) {
              i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
            }
            $20_1 = i64toi32_i32$2;
            $20$hi = i64toi32_i32$4;
            i64toi32_i32$0 = i64toi32_i32$2;
            i64toi32_i32$3 = 0;
            i64toi32_i32$1 = 32;
            i64toi32_i32$5 = i64toi32_i32$1 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
              i64toi32_i32$3 = i64toi32_i32$2 << i64toi32_i32$5 | 0;
              $240 = 0;
            } else {
              i64toi32_i32$3 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$5 | 0) | 0;
              $240 = i64toi32_i32$0 << i64toi32_i32$5 | 0;
            }
            $252$hi = i64toi32_i32$3;
            i64toi32_i32$3 = $227$hi;
            i64toi32_i32$4 = $227;
            i64toi32_i32$0 = $252$hi;
            i64toi32_i32$1 = $240;
            i64toi32_i32$5 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
            i64toi32_i32$2 = i64toi32_i32$3 + i64toi32_i32$0 | 0;
            if (i64toi32_i32$5 >>> 0 < i64toi32_i32$1 >>> 0) {
              i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
            }
            $23_1 = i64toi32_i32$5;
            $23$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $194$hi;
            i64toi32_i32$3 = $194;
            i64toi32_i32$4 = $23$hi;
            i64toi32_i32$1 = i64toi32_i32$5;
            i64toi32_i32$0 = i64toi32_i32$3 + i64toi32_i32$5 | 0;
            i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$4 | 0;
            if (i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0) {
              i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
            }
            $1_1 = i64toi32_i32$0;
            $1$hi = i64toi32_i32$5;
            $6_1 = (($7_1 + $6_1 | 0) + $8_1 | 0) + -16383 | 0;
            label$13: {
              label$14: {
                i64toi32_i32$5 = $2$hi;
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$5 = $2$hi;
                i64toi32_i32$3 = $4$hi;
                i64toi32_i32$3 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$5 | 0, $4_1 | 0, i64toi32_i32$3 | 0) | 0;
                i64toi32_i32$5 = i64toi32_i32$HIGH_BITS;
                $24_1 = i64toi32_i32$3;
                $24$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $14$hi;
                i64toi32_i32$5 = $10$hi;
                i64toi32_i32$5 = $14$hi;
                i64toi32_i32$3 = $10$hi;
                i64toi32_i32$3 = __wasm_i64_mul($14_1 | 0, i64toi32_i32$5 | 0, $10_1 | 0, i64toi32_i32$3 | 0) | 0;
                i64toi32_i32$5 = i64toi32_i32$HIGH_BITS;
                $268 = i64toi32_i32$3;
                $268$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $24$hi;
                i64toi32_i32$2 = $24_1;
                i64toi32_i32$3 = $268$hi;
                i64toi32_i32$1 = $268;
                i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$1 | 0;
                i64toi32_i32$0 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                $4_1 = i64toi32_i32$4;
                $4$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $24$hi;
                i64toi32_i32$0 = $4$hi;
                i64toi32_i32$5 = i64toi32_i32$4;
                i64toi32_i32$2 = $24$hi;
                i64toi32_i32$1 = $24_1;
                $272 = i64toi32_i32$0 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$5 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$5 = 0;
                $273 = $272;
                $273$hi = i64toi32_i32$5;
                i64toi32_i32$5 = i64toi32_i32$0;
                i64toi32_i32$5 = $3$hi;
                i64toi32_i32$5 = $12$hi;
                i64toi32_i32$5 = $3$hi;
                i64toi32_i32$0 = $12$hi;
                i64toi32_i32$0 = __wasm_i64_mul($3_1 | 0, i64toi32_i32$5 | 0, $12_1 | 0, i64toi32_i32$0 | 0) | 0;
                i64toi32_i32$5 = i64toi32_i32$HIGH_BITS;
                $277 = i64toi32_i32$0;
                $277$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$1 = i64toi32_i32$4;
                i64toi32_i32$0 = $277$hi;
                i64toi32_i32$2 = $277;
                i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
                i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                }
                $14_1 = i64toi32_i32$3;
                $14$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $4$hi;
                i64toi32_i32$4 = $14$hi;
                i64toi32_i32$5 = i64toi32_i32$3;
                i64toi32_i32$1 = $4$hi;
                i64toi32_i32$2 = $4_1;
                $281 = i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
                i64toi32_i32$5 = 0;
                $282$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $273$hi;
                i64toi32_i32$2 = $273;
                i64toi32_i32$4 = $282$hi;
                i64toi32_i32$1 = $281;
                i64toi32_i32$0 = i64toi32_i32$2 + i64toi32_i32$1 | 0;
                i64toi32_i32$3 = i64toi32_i32$5 + i64toi32_i32$4 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $283$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$3 = $10$hi;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$2 = $10$hi;
                i64toi32_i32$2 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$3 | 0, $10_1 | 0, i64toi32_i32$2 | 0) | 0;
                i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
                $286 = i64toi32_i32$2;
                $286$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $283$hi;
                i64toi32_i32$5 = i64toi32_i32$0;
                i64toi32_i32$2 = $286$hi;
                i64toi32_i32$1 = $286;
                i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
                i64toi32_i32$0 = i64toi32_i32$3 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                $287 = i64toi32_i32$4;
                $287$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $14$hi;
                $288 = $14_1;
                $288$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $17$hi;
                i64toi32_i32$0 = $19$hi;
                i64toi32_i32$0 = $17$hi;
                i64toi32_i32$3 = $17_1;
                i64toi32_i32$5 = $19$hi;
                i64toi32_i32$1 = $19_1;
                $291 = i64toi32_i32$0 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$3 = 0;
                $292$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $21$hi;
                i64toi32_i32$3 = i64toi32_i32$0;
                i64toi32_i32$3 = $21$hi;
                i64toi32_i32$1 = $21_1;
                i64toi32_i32$5 = $17_1;
                $295 = i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
                i64toi32_i32$1 = 0;
                $296$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $292$hi;
                i64toi32_i32$5 = $291;
                i64toi32_i32$3 = $296$hi;
                i64toi32_i32$0 = $295;
                i64toi32_i32$2 = i64toi32_i32$5 + i64toi32_i32$0 | 0;
                i64toi32_i32$4 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$0 >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
                }
                $297$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $288$hi;
                i64toi32_i32$1 = $288;
                i64toi32_i32$5 = $297$hi;
                i64toi32_i32$0 = i64toi32_i32$2;
                i64toi32_i32$3 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
                i64toi32_i32$2 = i64toi32_i32$4 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $4_1 = i64toi32_i32$3;
                $4$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $14$hi;
                i64toi32_i32$2 = $4$hi;
                i64toi32_i32$4 = i64toi32_i32$3;
                i64toi32_i32$1 = $14$hi;
                i64toi32_i32$0 = $14_1;
                $301 = i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$0 >>> 0 | 0) | 0;
                i64toi32_i32$4 = 0;
                $302$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $287$hi;
                i64toi32_i32$0 = $287;
                i64toi32_i32$2 = $302$hi;
                i64toi32_i32$1 = $301;
                i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
                i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $303 = i64toi32_i32$5;
                $303$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $3$hi;
                i64toi32_i32$3 = $10$hi;
                i64toi32_i32$3 = $3$hi;
                i64toi32_i32$0 = $10$hi;
                i64toi32_i32$0 = __wasm_i64_mul($3_1 | 0, i64toi32_i32$3 | 0, $10_1 | 0, i64toi32_i32$0 | 0) | 0;
                i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
                $3_1 = i64toi32_i32$0;
                $3$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$3 = $12$hi;
                i64toi32_i32$3 = $2$hi;
                i64toi32_i32$0 = $12$hi;
                i64toi32_i32$0 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$3 | 0, $12_1 | 0, i64toi32_i32$0 | 0) | 0;
                i64toi32_i32$3 = i64toi32_i32$HIGH_BITS;
                $310 = i64toi32_i32$0;
                $310$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $3$hi;
                i64toi32_i32$4 = $3_1;
                i64toi32_i32$0 = $310$hi;
                i64toi32_i32$1 = $310;
                i64toi32_i32$2 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
                i64toi32_i32$5 = i64toi32_i32$3 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $2_1 = i64toi32_i32$2;
                $2$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $3$hi;
                i64toi32_i32$5 = $2$hi;
                i64toi32_i32$3 = i64toi32_i32$2;
                i64toi32_i32$4 = $3$hi;
                i64toi32_i32$1 = $3_1;
                $314 = i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$3 = 0;
                i64toi32_i32$1 = $314;
                i64toi32_i32$5 = 0;
                i64toi32_i32$4 = 32;
                i64toi32_i32$0 = i64toi32_i32$4 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$1 << i64toi32_i32$0 | 0;
                  $241 = 0;
                } else {
                  i64toi32_i32$5 = ((1 << i64toi32_i32$0 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$0 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$0 | 0) | 0;
                  $241 = i64toi32_i32$1 << i64toi32_i32$0 | 0;
                }
                $316 = $241;
                $316$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $2$hi;
                i64toi32_i32$3 = $2_1;
                i64toi32_i32$1 = 0;
                i64toi32_i32$4 = 32;
                i64toi32_i32$0 = i64toi32_i32$4 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                  i64toi32_i32$1 = 0;
                  $242 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
                } else {
                  i64toi32_i32$1 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
                  $242 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$0 | 0) | 0;
                }
                $318$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $316$hi;
                i64toi32_i32$5 = $316;
                i64toi32_i32$3 = $318$hi;
                i64toi32_i32$4 = $242;
                i64toi32_i32$3 = i64toi32_i32$1 | i64toi32_i32$3 | 0;
                $319 = i64toi32_i32$5 | i64toi32_i32$4 | 0;
                $319$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $303$hi;
                i64toi32_i32$1 = $303;
                i64toi32_i32$5 = $319$hi;
                i64toi32_i32$4 = $319;
                i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$4 | 0;
                i64toi32_i32$2 = i64toi32_i32$3 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $320 = i64toi32_i32$0;
                $320$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $4$hi;
                $321 = $4_1;
                $321$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $2$hi;
                i64toi32_i32$3 = $2_1;
                i64toi32_i32$1 = 0;
                i64toi32_i32$4 = 32;
                i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                  i64toi32_i32$1 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
                  $243 = 0;
                } else {
                  i64toi32_i32$1 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$5 | 0) | 0;
                  $243 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
                }
                $323$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $321$hi;
                i64toi32_i32$2 = $321;
                i64toi32_i32$3 = $323$hi;
                i64toi32_i32$4 = $243;
                i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$4 | 0;
                i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                $2_1 = i64toi32_i32$5;
                $2$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $4$hi;
                i64toi32_i32$0 = $2$hi;
                i64toi32_i32$1 = i64toi32_i32$5;
                i64toi32_i32$2 = $4$hi;
                i64toi32_i32$4 = $4_1;
                $327 = i64toi32_i32$0 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0 | 0) | 0;
                i64toi32_i32$1 = 0;
                $328$hi = i64toi32_i32$1;
                i64toi32_i32$1 = $320$hi;
                i64toi32_i32$4 = $320;
                i64toi32_i32$0 = $328$hi;
                i64toi32_i32$2 = $327;
                i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
                i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $329 = i64toi32_i32$3;
                $329$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $2$hi;
                $330 = $2_1;
                $330$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $20$hi;
                i64toi32_i32$1 = $20_1;
                i64toi32_i32$4 = 0;
                i64toi32_i32$2 = 32;
                i64toi32_i32$0 = i64toi32_i32$2 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                  i64toi32_i32$4 = 0;
                  $245 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
                } else {
                  i64toi32_i32$4 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
                  $245 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$0 | 0) | 0;
                }
                $332 = $245;
                $332$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $13$hi;
                i64toi32_i32$4 = $22$hi;
                i64toi32_i32$4 = $13$hi;
                i64toi32_i32$5 = $13_1;
                i64toi32_i32$1 = $22$hi;
                i64toi32_i32$2 = $22_1;
                $335 = i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$5 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0;
                i64toi32_i32$5 = 0;
                $336$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $15$hi;
                i64toi32_i32$5 = i64toi32_i32$4;
                i64toi32_i32$5 = $15$hi;
                i64toi32_i32$2 = $15_1;
                i64toi32_i32$1 = $13_1;
                $339 = i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$2 = 0;
                $340$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $336$hi;
                i64toi32_i32$1 = $335;
                i64toi32_i32$5 = $340$hi;
                i64toi32_i32$4 = $339;
                i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$4 | 0;
                i64toi32_i32$3 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $341$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $20$hi;
                i64toi32_i32$3 = $15$hi;
                i64toi32_i32$3 = $20$hi;
                i64toi32_i32$2 = $20_1;
                i64toi32_i32$1 = $15$hi;
                i64toi32_i32$4 = $15_1;
                $344 = i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$4 >>> 0 | 0) | 0;
                i64toi32_i32$2 = 0;
                $345$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $341$hi;
                i64toi32_i32$4 = i64toi32_i32$0;
                i64toi32_i32$3 = $345$hi;
                i64toi32_i32$1 = $344;
                i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
                i64toi32_i32$0 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                i64toi32_i32$2 = i64toi32_i32$5;
                i64toi32_i32$4 = 0;
                i64toi32_i32$1 = 32;
                i64toi32_i32$3 = i64toi32_i32$1 & 31 | 0;
                if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                  i64toi32_i32$4 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
                  $246 = 0;
                } else {
                  i64toi32_i32$4 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$3 | 0) | 0;
                  $246 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
                }
                $347$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $332$hi;
                i64toi32_i32$0 = $332;
                i64toi32_i32$2 = $347$hi;
                i64toi32_i32$1 = $246;
                i64toi32_i32$2 = i64toi32_i32$4 | i64toi32_i32$2 | 0;
                $348 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
                $348$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $330$hi;
                i64toi32_i32$4 = $330;
                i64toi32_i32$0 = $348$hi;
                i64toi32_i32$1 = $348;
                i64toi32_i32$3 = i64toi32_i32$4 + i64toi32_i32$1 | 0;
                i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$0 | 0;
                if (i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $4_1 = i64toi32_i32$3;
                $4$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $2$hi;
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$2 = i64toi32_i32$3;
                i64toi32_i32$4 = $2$hi;
                i64toi32_i32$1 = $2_1;
                $352 = i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$2 = 0;
                $353$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $329$hi;
                i64toi32_i32$1 = $329;
                i64toi32_i32$5 = $353$hi;
                i64toi32_i32$4 = $352;
                i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$4 | 0;
                i64toi32_i32$3 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
                }
                $354 = i64toi32_i32$0;
                $354$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $4$hi;
                $355 = $4_1;
                $355$hi = i64toi32_i32$3;
                i64toi32_i32$3 = $16$hi;
                i64toi32_i32$3 = $21$hi;
                i64toi32_i32$3 = $16$hi;
                i64toi32_i32$2 = $16_1;
                i64toi32_i32$1 = $21$hi;
                i64toi32_i32$4 = $21_1;
                $358 = i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$4 >>> 0 | 0) | 0;
                i64toi32_i32$2 = 0;
                $359$hi = i64toi32_i32$2;
                i64toi32_i32$2 = $23$hi;
                i64toi32_i32$2 = i64toi32_i32$3;
                i64toi32_i32$2 = $23$hi;
                i64toi32_i32$4 = $23_1;
                i64toi32_i32$1 = $16_1;
                $362 = i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$4 = 0;
                $363$hi = i64toi32_i32$4;
                i64toi32_i32$4 = $359$hi;
                i64toi32_i32$1 = $358;
                i64toi32_i32$2 = $363$hi;
                i64toi32_i32$3 = $362;
                i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
                i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
                if (i64toi32_i32$5 >>> 0 < i64toi32_i32$3 >>> 0) {
                  i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
                }
                $364$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $355$hi;
                i64toi32_i32$4 = $355;
                i64toi32_i32$1 = $364$hi;
                i64toi32_i32$3 = i64toi32_i32$5;
                i64toi32_i32$2 = i64toi32_i32$4 + i64toi32_i32$3 | 0;
                i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
                if (i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0) {
                  i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                }
                $2_1 = i64toi32_i32$2;
                $2$hi = i64toi32_i32$5;
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$5 = $2$hi;
                i64toi32_i32$0 = i64toi32_i32$2;
                i64toi32_i32$4 = $4$hi;
                i64toi32_i32$3 = $4_1;
                $368 = i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0 | 0) | 0;
                i64toi32_i32$0 = 0;
                $369$hi = i64toi32_i32$0;
                i64toi32_i32$0 = $354$hi;
                i64toi32_i32$3 = $354;
                i64toi32_i32$5 = $369$hi;
                i64toi32_i32$4 = $368;
                i64toi32_i32$1 = i64toi32_i32$3 + i64toi32_i32$4 | 0;
                i64toi32_i32$2 = i64toi32_i32$0 + i64toi32_i32$5 | 0;
                if (i64toi32_i32$1 >>> 0 < i64toi32_i32$4 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $4_1 = i64toi32_i32$1;
                $4$hi = i64toi32_i32$2;
                i64toi32_i32$0 = i64toi32_i32$1;
                i64toi32_i32$3 = 65536;
                i64toi32_i32$4 = 0;
                i64toi32_i32$3 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
                if (!(i64toi32_i32$0 & i64toi32_i32$4 | 0 | i64toi32_i32$3 | 0)) {
                  break label$14;
                }
                $6_1 = $6_1 + 1 | 0;
                break label$13;
              }
              i64toi32_i32$3 = $18$hi;
              i64toi32_i32$2 = $18_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$4 = 63;
              i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $247 = i64toi32_i32$3 >>> i64toi32_i32$5 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$3 >>> i64toi32_i32$5 | 0;
                $247 = (((1 << i64toi32_i32$5 | 0) - 1 | 0) & i64toi32_i32$3 | 0) << (32 - i64toi32_i32$5 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$5 | 0) | 0;
              }
              $3_1 = $247;
              $3$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $4$hi;
              i64toi32_i32$3 = $4_1;
              i64toi32_i32$2 = 0;
              i64toi32_i32$4 = 1;
              i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
                $248 = 0;
              } else {
                i64toi32_i32$2 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$5 | 0) | 0;
                $248 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
              }
              $379 = $248;
              $379$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$0 = $2_1;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = 63;
              i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$3 = 0;
                $250 = i64toi32_i32$2 >>> i64toi32_i32$5 | 0;
              } else {
                i64toi32_i32$3 = i64toi32_i32$2 >>> i64toi32_i32$5 | 0;
                $250 = (((1 << i64toi32_i32$5 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$5 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$5 | 0) | 0;
              }
              $381$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $379$hi;
              i64toi32_i32$2 = $379;
              i64toi32_i32$0 = $381$hi;
              i64toi32_i32$4 = $250;
              i64toi32_i32$0 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
              $4_1 = i64toi32_i32$2 | i64toi32_i32$4 | 0;
              $4$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $2$hi;
              i64toi32_i32$3 = $2_1;
              i64toi32_i32$2 = 0;
              i64toi32_i32$4 = 1;
              i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
                $251 = 0;
              } else {
                i64toi32_i32$2 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$5 | 0) | 0;
                $251 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
              }
              $384 = $251;
              $384$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $1$hi;
              i64toi32_i32$0 = $1_1;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = 63;
              i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$3 = 0;
                $252 = i64toi32_i32$2 >>> i64toi32_i32$5 | 0;
              } else {
                i64toi32_i32$3 = i64toi32_i32$2 >>> i64toi32_i32$5 | 0;
                $252 = (((1 << i64toi32_i32$5 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$5 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$5 | 0) | 0;
              }
              $386$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $384$hi;
              i64toi32_i32$2 = $384;
              i64toi32_i32$0 = $386$hi;
              i64toi32_i32$4 = $252;
              i64toi32_i32$0 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
              $2_1 = i64toi32_i32$2 | i64toi32_i32$4 | 0;
              $2$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $18$hi;
              i64toi32_i32$3 = $18_1;
              i64toi32_i32$2 = 0;
              i64toi32_i32$4 = 1;
              i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
                $253 = 0;
              } else {
                i64toi32_i32$2 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$5 | 0) | 0;
                $253 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
              }
              $18_1 = $253;
              $18$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $3$hi;
              $390 = $3_1;
              $390$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $1$hi;
              i64toi32_i32$0 = $1_1;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = 1;
              i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$3 = i64toi32_i32$0 << i64toi32_i32$5 | 0;
                $254 = 0;
              } else {
                i64toi32_i32$3 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$5 | 0) | 0;
                $254 = i64toi32_i32$0 << i64toi32_i32$5 | 0;
              }
              $392$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $390$hi;
              i64toi32_i32$2 = $390;
              i64toi32_i32$0 = $392$hi;
              i64toi32_i32$4 = $254;
              i64toi32_i32$0 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
              $1_1 = i64toi32_i32$2 | i64toi32_i32$4 | 0;
              $1$hi = i64toi32_i32$0;
            }
            label$15: {
              if (($6_1 | 0) < (32767 | 0)) {
                break label$15;
              }
              i64toi32_i32$0 = $11$hi;
              i64toi32_i32$3 = $11_1;
              i64toi32_i32$2 = 2147418112;
              i64toi32_i32$4 = 0;
              i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
              $11_1 = i64toi32_i32$3 | i64toi32_i32$4 | 0;
              $11$hi = i64toi32_i32$2;
              i64toi32_i32$2 = 0;
              $1_1 = 0;
              $1$hi = i64toi32_i32$2;
              break label$1;
            }
            label$16: {
              label$17: {
                if (($6_1 | 0) > (0 | 0)) {
                  break label$17;
                }
                label$18: {
                  $7_1 = 1 - $6_1 | 0;
                  if ($7_1 >>> 0 > 127 >>> 0) {
                    break label$18;
                  }
                  i64toi32_i32$2 = $18$hi;
                  i64toi32_i32$2 = $1$hi;
                  $6_1 = $6_1 + 127 | 0;
                  i64toi32_i32$2 = $18$hi;
                  i64toi32_i32$3 = $1$hi;
                  $86($5_1 + 48 | 0 | 0, $18_1 | 0, i64toi32_i32$2 | 0, $1_1 | 0, i64toi32_i32$3 | 0, $6_1 | 0);
                  i64toi32_i32$3 = $2$hi;
                  i64toi32_i32$3 = $4$hi;
                  i64toi32_i32$3 = $2$hi;
                  i64toi32_i32$2 = $4$hi;
                  $86($5_1 + 32 | 0 | 0, $2_1 | 0, i64toi32_i32$3 | 0, $4_1 | 0, i64toi32_i32$2 | 0, $6_1 | 0);
                  i64toi32_i32$2 = $18$hi;
                  i64toi32_i32$2 = $1$hi;
                  i64toi32_i32$2 = $18$hi;
                  i64toi32_i32$3 = $1$hi;
                  $96($5_1 + 16 | 0 | 0, $18_1 | 0, i64toi32_i32$2 | 0, $1_1 | 0, i64toi32_i32$3 | 0, $7_1 | 0);
                  i64toi32_i32$3 = $2$hi;
                  i64toi32_i32$3 = $4$hi;
                  i64toi32_i32$3 = $2$hi;
                  i64toi32_i32$2 = $4$hi;
                  $96($5_1 | 0, $2_1 | 0, i64toi32_i32$3 | 0, $4_1 | 0, i64toi32_i32$2 | 0, $7_1 | 0);
                  i64toi32_i32$0 = $5_1;
                  i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 32 | 0) >> 2] | 0;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 36 | 0) >> 2] | 0;
                  $426 = i64toi32_i32$2;
                  $426$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 16 | 0) >> 2] | 0;
                  i64toi32_i32$2 = HEAP32[(i64toi32_i32$0 + 20 | 0) >> 2] | 0;
                  $428 = i64toi32_i32$3;
                  $428$hi = i64toi32_i32$2;
                  i64toi32_i32$2 = $426$hi;
                  i64toi32_i32$0 = $426;
                  i64toi32_i32$3 = $428$hi;
                  i64toi32_i32$4 = $428;
                  i64toi32_i32$3 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
                  $429 = i64toi32_i32$0 | i64toi32_i32$4 | 0;
                  $429$hi = i64toi32_i32$3;
                  i64toi32_i32$2 = $5_1;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 48 | 0) >> 2] | 0;
                  i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 52 | 0) >> 2] | 0;
                  $431 = i64toi32_i32$3;
                  $431$hi = i64toi32_i32$0;
                  i64toi32_i32$2 = (i64toi32_i32$2 + 48 | 0) + 8 | 0;
                  i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
                  $435 = i64toi32_i32$0;
                  $435$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = $431$hi;
                  i64toi32_i32$2 = $431;
                  i64toi32_i32$0 = $435$hi;
                  i64toi32_i32$4 = $435;
                  i64toi32_i32$0 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
                  i64toi32_i32$3 = i64toi32_i32$2 | i64toi32_i32$4 | 0;
                  i64toi32_i32$2 = 0;
                  i64toi32_i32$4 = 0;
                  $437 = (i64toi32_i32$3 | 0) != (i64toi32_i32$4 | 0) | (i64toi32_i32$0 | 0) != (i64toi32_i32$2 | 0) | 0;
                  i64toi32_i32$3 = 0;
                  $438$hi = i64toi32_i32$3;
                  i64toi32_i32$3 = $429$hi;
                  i64toi32_i32$4 = $429;
                  i64toi32_i32$0 = $438$hi;
                  i64toi32_i32$2 = $437;
                  i64toi32_i32$0 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
                  $18_1 = i64toi32_i32$4 | i64toi32_i32$2 | 0;
                  $18$hi = i64toi32_i32$0;
                  i64toi32_i32$3 = ($5_1 + 32 | 0) + 8 | 0;
                  i64toi32_i32$0 = HEAP32[i64toi32_i32$3 >> 2] | 0;
                  i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
                  $443 = i64toi32_i32$0;
                  $443$hi = i64toi32_i32$4;
                  i64toi32_i32$3 = ($5_1 + 16 | 0) + 8 | 0;
                  i64toi32_i32$4 = HEAP32[i64toi32_i32$3 >> 2] | 0;
                  i64toi32_i32$0 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
                  $447 = i64toi32_i32$4;
                  $447$hi = i64toi32_i32$0;
                  i64toi32_i32$0 = $443$hi;
                  i64toi32_i32$3 = $443;
                  i64toi32_i32$4 = $447$hi;
                  i64toi32_i32$2 = $447;
                  i64toi32_i32$4 = i64toi32_i32$0 | i64toi32_i32$4 | 0;
                  $1_1 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
                  $1$hi = i64toi32_i32$4;
                  i64toi32_i32$0 = $5_1 + 8 | 0;
                  i64toi32_i32$4 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                  i64toi32_i32$3 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                  $4_1 = i64toi32_i32$4;
                  $4$hi = i64toi32_i32$3;
                  i64toi32_i32$0 = $5_1;
                  i64toi32_i32$3 = HEAP32[i64toi32_i32$0 >> 2] | 0;
                  i64toi32_i32$4 = HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] | 0;
                  $2_1 = i64toi32_i32$3;
                  $2$hi = i64toi32_i32$4;
                  break label$16;
                }
                i64toi32_i32$4 = 0;
                $1_1 = 0;
                $1$hi = i64toi32_i32$4;
                break label$1;
              }
              i64toi32_i32$4 = 0;
              i64toi32_i32$0 = $6_1;
              i64toi32_i32$3 = 0;
              i64toi32_i32$2 = 48;
              i64toi32_i32$5 = i64toi32_i32$2 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$2 & 63 | 0) >>> 0) {
                i64toi32_i32$3 = i64toi32_i32$0 << i64toi32_i32$5 | 0;
                $255 = 0;
              } else {
                i64toi32_i32$3 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$0 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$5 | 0) | 0;
                $255 = i64toi32_i32$0 << i64toi32_i32$5 | 0;
              }
              $456$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $4$hi;
              i64toi32_i32$4 = $4_1;
              i64toi32_i32$0 = 65535;
              i64toi32_i32$2 = -1;
              i64toi32_i32$0 = i64toi32_i32$3 & i64toi32_i32$0 | 0;
              $458 = i64toi32_i32$4 & i64toi32_i32$2 | 0;
              $458$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $456$hi;
              i64toi32_i32$3 = $255;
              i64toi32_i32$4 = $458$hi;
              i64toi32_i32$2 = $458;
              i64toi32_i32$4 = i64toi32_i32$0 | i64toi32_i32$4 | 0;
              $4_1 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
              $4$hi = i64toi32_i32$4;
            }
            i64toi32_i32$4 = $4$hi;
            i64toi32_i32$4 = $11$hi;
            i64toi32_i32$4 = $4$hi;
            i64toi32_i32$0 = $4_1;
            i64toi32_i32$3 = $11$hi;
            i64toi32_i32$2 = $11_1;
            i64toi32_i32$3 = i64toi32_i32$4 | i64toi32_i32$3 | 0;
            $11_1 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
            $11$hi = i64toi32_i32$3;
            label$19: {
              i64toi32_i32$3 = $18$hi;
              $464 = !($18_1 | i64toi32_i32$3 | 0);
              i64toi32_i32$3 = $1$hi;
              i64toi32_i32$4 = $1_1;
              i64toi32_i32$0 = -1;
              i64toi32_i32$2 = -1;
              if ((i64toi32_i32$3 | 0) > (i64toi32_i32$0 | 0)) {
                $256 = 1;
              } else {
                if ((i64toi32_i32$3 | 0) >= (i64toi32_i32$0 | 0)) {
                  if (i64toi32_i32$4 >>> 0 <= i64toi32_i32$2 >>> 0) {
                    $257 = 0;
                  } else {
                    $257 = 1;
                  }
                  $258 = $257;
                } else {
                  $258 = 0;
                }
                $256 = $258;
              }
              i64toi32_i32$4 = $1$hi;
              i64toi32_i32$2 = $1_1;
              i64toi32_i32$3 = -2147483648;
              i64toi32_i32$0 = 0;
              if ((i64toi32_i32$2 | 0) == (i64toi32_i32$0 | 0) & (i64toi32_i32$4 | 0) == (i64toi32_i32$3 | 0) | 0 ? $464 : $256) {
                break label$19;
              }
              i64toi32_i32$2 = $11$hi;
              $470 = $11_1;
              $470$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $2$hi;
              i64toi32_i32$0 = $2_1;
              i64toi32_i32$4 = 0;
              i64toi32_i32$3 = 1;
              i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
              i64toi32_i32$1 = i64toi32_i32$2 + i64toi32_i32$4 | 0;
              if (i64toi32_i32$5 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
              }
              $1_1 = i64toi32_i32$5;
              $1$hi = i64toi32_i32$1;
              $474 = !(i64toi32_i32$5 | i64toi32_i32$1 | 0);
              i64toi32_i32$1 = 0;
              $475$hi = i64toi32_i32$1;
              i64toi32_i32$1 = $470$hi;
              i64toi32_i32$2 = $470;
              i64toi32_i32$0 = $475$hi;
              i64toi32_i32$3 = $474;
              i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
              i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$0 | 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
              }
              $11_1 = i64toi32_i32$4;
              $11$hi = i64toi32_i32$5;
              break label$1;
            }
            label$20: {
              i64toi32_i32$5 = $18$hi;
              i64toi32_i32$5 = $1$hi;
              i64toi32_i32$1 = $1_1;
              i64toi32_i32$2 = -2147483648;
              i64toi32_i32$3 = 0;
              i64toi32_i32$2 = i64toi32_i32$5 ^ i64toi32_i32$2 | 0;
              $479 = i64toi32_i32$1 ^ i64toi32_i32$3 | 0;
              $479$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $18$hi;
              i64toi32_i32$5 = $18_1;
              i64toi32_i32$1 = $479$hi;
              i64toi32_i32$3 = $479;
              i64toi32_i32$1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
              i64toi32_i32$2 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
              i64toi32_i32$5 = 0;
              i64toi32_i32$3 = 0;
              if ((i64toi32_i32$2 | 0) == (i64toi32_i32$3 | 0) & (i64toi32_i32$1 | 0) == (i64toi32_i32$5 | 0) | 0) {
                break label$20;
              }
              i64toi32_i32$2 = $2$hi;
              $1_1 = $2_1;
              $1$hi = i64toi32_i32$2;
              break label$1;
            }
            i64toi32_i32$2 = $11$hi;
            $483 = $11_1;
            $483$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$3 = $2_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$5 = 1;
            i64toi32_i32$1 = i64toi32_i32$2 & i64toi32_i32$1 | 0;
            $486 = i64toi32_i32$3 & i64toi32_i32$5 | 0;
            $486$hi = i64toi32_i32$1;
            i64toi32_i32$1 = i64toi32_i32$2;
            i64toi32_i32$2 = i64toi32_i32$3;
            i64toi32_i32$3 = $486$hi;
            i64toi32_i32$5 = $486;
            i64toi32_i32$0 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
            i64toi32_i32$4 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
            if (i64toi32_i32$0 >>> 0 < i64toi32_i32$5 >>> 0) {
              i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
            }
            $1_1 = i64toi32_i32$0;
            $1$hi = i64toi32_i32$4;
            i64toi32_i32$4 = $2$hi;
            i64toi32_i32$4 = $1$hi;
            i64toi32_i32$1 = i64toi32_i32$0;
            i64toi32_i32$2 = $2$hi;
            i64toi32_i32$5 = $2_1;
            $490 = i64toi32_i32$4 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$0 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
            i64toi32_i32$1 = 0;
            $491$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $483$hi;
            i64toi32_i32$5 = $483;
            i64toi32_i32$4 = $491$hi;
            i64toi32_i32$2 = $490;
            i64toi32_i32$3 = i64toi32_i32$5 + i64toi32_i32$2 | 0;
            i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$4 | 0;
            if (i64toi32_i32$3 >>> 0 < i64toi32_i32$2 >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
            }
            $11_1 = i64toi32_i32$3;
            $11$hi = i64toi32_i32$0;
          }
          i64toi32_i32$0 = $1$hi;
          i64toi32_i32$5 = $0_1;
          HEAP32[i64toi32_i32$5 >> 2] = $1_1;
          HEAP32[(i64toi32_i32$5 + 4 | 0) >> 2] = i64toi32_i32$0;
          i64toi32_i32$0 = $11$hi;
          HEAP32[(i64toi32_i32$5 + 8 | 0) >> 2] = $11_1;
          HEAP32[(i64toi32_i32$5 + 12 | 0) >> 2] = i64toi32_i32$0;
          global$0 = $5_1 + 96 | 0;
        }

        function $98($0_1, $1_1, $1$hi, $2_1, $2$hi, $3_1, $3$hi, $4_1, $4$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          $3$hi = $3$hi | 0;
          $4_1 = $4_1 | 0;
          $4$hi = $4$hi | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$1 = 0,i64toi32_i32$5 = 0,i64toi32_i32$4 = 0,i64toi32_i32$3 = 0,$46_1 = 0,$48_1 = 0,$49_1 = 0,$50_1 = 0,$53_1 = 0,$54_1 = 0,$6_1 = 0,$9_1 = 0,$9$hi = 0,$12_1 = 0,$12$hi = 0,$13_1 = 0,$13$hi = 0,$16_1 = 0,$16$hi = 0,$20_1 = 0,$20$hi = 0,$21_1 = 0,$21$hi = 0,$5_1 = 0,$5$hi = 0,$30$hi = 0,$33_1 = 0,$33$hi = 0,$36$hi = 0,$37_1 = 0,$37$hi = 0,$39_1 = 0,$39$hi = 0,$42_1 = 0,$42$hi = 0,$45$hi = 0,$47_1 = 0,$49$hi = 0,$51_1 = 0,$51$hi = 0,$52_1 = 0;
          $6_1 = $0_1;
          i64toi32_i32$0 = $4$hi;
          i64toi32_i32$0 = $1$hi;
          i64toi32_i32$0 = $4$hi;
          i64toi32_i32$1 = $1$hi;
          i64toi32_i32$1 = __wasm_i64_mul($4_1 | 0, i64toi32_i32$0 | 0, $1_1 | 0, i64toi32_i32$1 | 0) | 0;
          i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
          $9_1 = i64toi32_i32$1;
          $9$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $2$hi;
          i64toi32_i32$0 = $3$hi;
          i64toi32_i32$0 = $2$hi;
          i64toi32_i32$1 = $3$hi;
          i64toi32_i32$1 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$0 | 0, $3_1 | 0, i64toi32_i32$1 | 0) | 0;
          i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
          $12_1 = i64toi32_i32$1;
          $12$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $9$hi;
          i64toi32_i32$2 = $9_1;
          i64toi32_i32$1 = $12$hi;
          i64toi32_i32$3 = $12_1;
          i64toi32_i32$4 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
          i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$1 | 0;
          if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
            i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
          }
          $13_1 = i64toi32_i32$4;
          $13$hi = i64toi32_i32$5;
          i64toi32_i32$5 = $3$hi;
          i64toi32_i32$0 = $3_1;
          i64toi32_i32$2 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$1 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$2 = 0;
            $46_1 = i64toi32_i32$5 >>> i64toi32_i32$1 | 0;
          } else {
            i64toi32_i32$2 = i64toi32_i32$5 >>> i64toi32_i32$1 | 0;
            $46_1 = (((1 << i64toi32_i32$1 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$1 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$1 | 0) | 0;
          }
          $2_1 = $46_1;
          $2$hi = i64toi32_i32$2;
          $16_1 = $2_1;
          $16$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $1$hi;
          i64toi32_i32$5 = $1_1;
          i64toi32_i32$0 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$1 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$0 = 0;
            $48_1 = i64toi32_i32$2 >>> i64toi32_i32$1 | 0;
          } else {
            i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$1 | 0;
            $48_1 = (((1 << i64toi32_i32$1 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$1 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$1 | 0) | 0;
          }
          $4_1 = $48_1;
          $4$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $16$hi;
          i64toi32_i32$5 = $4$hi;
          i64toi32_i32$5 = __wasm_i64_mul($16_1 | 0, i64toi32_i32$0 | 0, $4_1 | 0, i64toi32_i32$5 | 0) | 0;
          i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
          $20_1 = i64toi32_i32$5;
          $20$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $13$hi;
          i64toi32_i32$2 = $13_1;
          i64toi32_i32$5 = $20$hi;
          i64toi32_i32$3 = $20_1;
          i64toi32_i32$1 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
          i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$5 | 0;
          if (i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0) {
            i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
          }
          $21_1 = i64toi32_i32$1;
          $21$hi = i64toi32_i32$4;
          i64toi32_i32$4 = $3$hi;
          i64toi32_i32$0 = $3_1;
          i64toi32_i32$2 = 0;
          i64toi32_i32$3 = -1;
          i64toi32_i32$2 = i64toi32_i32$4 & i64toi32_i32$2 | 0;
          $3_1 = i64toi32_i32$0 & i64toi32_i32$3 | 0;
          $3$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $1$hi;
          i64toi32_i32$4 = $1_1;
          i64toi32_i32$0 = 0;
          i64toi32_i32$3 = -1;
          i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
          $1_1 = i64toi32_i32$4 & i64toi32_i32$3 | 0;
          $1$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $3$hi;
          i64toi32_i32$4 = $1$hi;
          i64toi32_i32$4 = __wasm_i64_mul($3_1 | 0, i64toi32_i32$0 | 0, $1_1 | 0, i64toi32_i32$4 | 0) | 0;
          i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
          $5_1 = i64toi32_i32$4;
          $5$hi = i64toi32_i32$0;
          i64toi32_i32$2 = i64toi32_i32$4;
          i64toi32_i32$4 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$5 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$4 = 0;
            $49_1 = i64toi32_i32$0 >>> i64toi32_i32$5 | 0;
          } else {
            i64toi32_i32$4 = i64toi32_i32$0 >>> i64toi32_i32$5 | 0;
            $49_1 = (((1 << i64toi32_i32$5 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$5 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$5 | 0) | 0;
          }
          $30$hi = i64toi32_i32$4;
          i64toi32_i32$4 = $3$hi;
          i64toi32_i32$4 = $4$hi;
          i64toi32_i32$4 = $3$hi;
          i64toi32_i32$2 = $4$hi;
          i64toi32_i32$2 = __wasm_i64_mul($3_1 | 0, i64toi32_i32$4 | 0, $4_1 | 0, i64toi32_i32$2 | 0) | 0;
          i64toi32_i32$4 = i64toi32_i32$HIGH_BITS;
          $33_1 = i64toi32_i32$2;
          $33$hi = i64toi32_i32$4;
          i64toi32_i32$4 = $30$hi;
          i64toi32_i32$0 = $49_1;
          i64toi32_i32$2 = $33$hi;
          i64toi32_i32$3 = $33_1;
          i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
          i64toi32_i32$1 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
          if (i64toi32_i32$5 >>> 0 < i64toi32_i32$3 >>> 0) {
            i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
          }
          $3_1 = i64toi32_i32$5;
          $3$hi = i64toi32_i32$1;
          i64toi32_i32$4 = i64toi32_i32$5;
          i64toi32_i32$0 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$2 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$0 = 0;
            $50_1 = i64toi32_i32$1 >>> i64toi32_i32$2 | 0;
          } else {
            i64toi32_i32$0 = i64toi32_i32$1 >>> i64toi32_i32$2 | 0;
            $50_1 = (((1 << i64toi32_i32$2 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$2 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$2 | 0) | 0;
          }
          $36$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $21$hi;
          i64toi32_i32$1 = $21_1;
          i64toi32_i32$4 = $36$hi;
          i64toi32_i32$3 = $50_1;
          i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
          i64toi32_i32$5 = i64toi32_i32$0 + i64toi32_i32$4 | 0;
          if (i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0) {
            i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
          }
          $37_1 = i64toi32_i32$2;
          $37$hi = i64toi32_i32$5;
          i64toi32_i32$5 = $3$hi;
          i64toi32_i32$0 = $3_1;
          i64toi32_i32$1 = 0;
          i64toi32_i32$3 = -1;
          i64toi32_i32$1 = i64toi32_i32$5 & i64toi32_i32$1 | 0;
          $39_1 = i64toi32_i32$0 & i64toi32_i32$3 | 0;
          $39$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $2$hi;
          i64toi32_i32$1 = $1$hi;
          i64toi32_i32$1 = $2$hi;
          i64toi32_i32$0 = $1$hi;
          i64toi32_i32$0 = __wasm_i64_mul($2_1 | 0, i64toi32_i32$1 | 0, $1_1 | 0, i64toi32_i32$0 | 0) | 0;
          i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
          $42_1 = i64toi32_i32$0;
          $42$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $39$hi;
          i64toi32_i32$5 = $39_1;
          i64toi32_i32$0 = $42$hi;
          i64toi32_i32$3 = $42_1;
          i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
          i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$0 | 0;
          if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
            i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
          }
          $1_1 = i64toi32_i32$4;
          $1$hi = i64toi32_i32$2;
          i64toi32_i32$1 = i64toi32_i32$4;
          i64toi32_i32$5 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$0 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$5 = 0;
            $53_1 = i64toi32_i32$2 >>> i64toi32_i32$0 | 0;
          } else {
            i64toi32_i32$5 = i64toi32_i32$2 >>> i64toi32_i32$0 | 0;
            $53_1 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$0 | 0) | 0;
          }
          $45$hi = i64toi32_i32$5;
          i64toi32_i32$5 = $37$hi;
          i64toi32_i32$2 = $37_1;
          i64toi32_i32$1 = $45$hi;
          i64toi32_i32$3 = $53_1;
          i64toi32_i32$0 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
          i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$1 | 0;
          if (i64toi32_i32$0 >>> 0 < i64toi32_i32$3 >>> 0) {
            i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
          }
          i64toi32_i32$2 = $6_1;
          HEAP32[(i64toi32_i32$2 + 8 | 0) >> 2] = i64toi32_i32$0;
          HEAP32[(i64toi32_i32$2 + 12 | 0) >> 2] = i64toi32_i32$4;
          $47_1 = $0_1;
          i64toi32_i32$4 = $1$hi;
          i64toi32_i32$5 = $1_1;
          i64toi32_i32$2 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$1 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$2 = i64toi32_i32$5 << i64toi32_i32$1 | 0;
            $54_1 = 0;
          } else {
            i64toi32_i32$2 = ((1 << i64toi32_i32$1 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$1 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$1 | 0) | 0;
            $54_1 = i64toi32_i32$5 << i64toi32_i32$1 | 0;
          }
          $49$hi = i64toi32_i32$2;
          i64toi32_i32$2 = $5$hi;
          i64toi32_i32$4 = $5_1;
          i64toi32_i32$5 = 0;
          i64toi32_i32$3 = -1;
          i64toi32_i32$5 = i64toi32_i32$2 & i64toi32_i32$5 | 0;
          $51_1 = i64toi32_i32$4 & i64toi32_i32$3 | 0;
          $51$hi = i64toi32_i32$5;
          i64toi32_i32$5 = $49$hi;
          i64toi32_i32$2 = $54_1;
          i64toi32_i32$4 = $51$hi;
          i64toi32_i32$3 = $51_1;
          i64toi32_i32$4 = i64toi32_i32$5 | i64toi32_i32$4 | 0;
          $52_1 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
          i64toi32_i32$2 = $47_1;
          HEAP32[i64toi32_i32$2 >> 2] = $52_1;
          HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] = i64toi32_i32$4;
        }

        function $99($0_1, $1_1, $1$hi, $2_1, $2$hi, $3_1, $3$hi, $4_1, $4$hi) {
          $0_1 = $0_1 | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          $2_1 = $2_1 | 0;
          $2$hi = $2$hi | 0;
          $3_1 = $3_1 | 0;
          $3$hi = $3$hi | 0;
          $4_1 = $4_1 | 0;
          $4$hi = $4$hi | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$3 = 0,i64toi32_i32$1 = 0,$5_1 = 0,$14_1 = 0,$14$hi = 0,$20_1 = 0;
          $5_1 = global$0 - 16 | 0;
          global$0 = $5_1;
          i64toi32_i32$0 = $1$hi;
          i64toi32_i32$0 = $2$hi;
          i64toi32_i32$0 = $3$hi;
          i64toi32_i32$0 = $4$hi;
          i64toi32_i32$2 = $4_1;
          i64toi32_i32$1 = -2147483648;
          i64toi32_i32$3 = 0;
          i64toi32_i32$1 = i64toi32_i32$0 ^ i64toi32_i32$1 | 0;
          $14_1 = i64toi32_i32$2 ^ i64toi32_i32$3 | 0;
          $14$hi = i64toi32_i32$1;
          i64toi32_i32$1 = $1$hi;
          i64toi32_i32$2 = $2$hi;
          i64toi32_i32$0 = $3$hi;
          i64toi32_i32$3 = $14$hi;
          $85($5_1 | 0, $1_1 | 0, i64toi32_i32$1 | 0, $2_1 | 0, i64toi32_i32$2 | 0, $3_1 | 0, i64toi32_i32$0 | 0, $14_1 | 0, i64toi32_i32$3 | 0);
          i64toi32_i32$2 = $5_1;
          i64toi32_i32$3 = HEAP32[i64toi32_i32$2 >> 2] | 0;
          i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $4_1 = i64toi32_i32$3;
          $4$hi = i64toi32_i32$0;
          i64toi32_i32$2 = i64toi32_i32$2 + 8 | 0;
          i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
          i64toi32_i32$3 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
          $20_1 = i64toi32_i32$0;
          i64toi32_i32$0 = $0_1;
          HEAP32[(i64toi32_i32$0 + 8 | 0) >> 2] = $20_1;
          HEAP32[(i64toi32_i32$0 + 12 | 0) >> 2] = i64toi32_i32$3;
          i64toi32_i32$3 = $4$hi;
          HEAP32[i64toi32_i32$0 >> 2] = $4_1;
          HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$3;
          global$0 = $5_1 + 16 | 0;
        }

        function $100($0_1, $0$hi, $1_1, $1$hi) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$2 = 0,i64toi32_i32$4 = 0,i64toi32_i32$5 = 0,i64toi32_i32$3 = 0,i64toi32_i32$1 = 0,$4_1 = 0,$4$hi = 0,$5$hi = 0,$5_1 = 0,$2_1 = 0,$3_1 = 0,$44_1 = 0,$45_1 = 0,$46_1 = 0,$47_1 = 0,$48_1 = 0,$49_1 = 0,$50_1 = 0,$12_1 = 0,$12$hi = 0,$14$hi = 0,$17_1 = 0,$17$hi = 0,$19$hi = 0,$33_1 = 0,$33$hi = 0,$36_1 = 0,$38_1 = 0,$43_1 = 0,$43$hi = 0,$45$hi = 0,$73_1 = 0,$73$hi = 0,$77$hi = 0,$80_1 = 0,$80$hi = 0,$82_1 = 0,$82$hi = 0,$86_1 = 0,$86$hi = 0,$88_1 = 0,$89$hi = 0,$98$hi = 0,$105_1 = 0,$105$hi = 0;
          $2_1 = global$0 - 32 | 0;
          global$0 = $2_1;
          label$1: {
            label$2: {
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$2 = $1_1;
              i64toi32_i32$1 = 2147483647;
              i64toi32_i32$3 = -1;
              i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
              $4_1 = i64toi32_i32$2 & i64toi32_i32$3 | 0;
              $4$hi = i64toi32_i32$1;
              i64toi32_i32$0 = $4_1;
              i64toi32_i32$2 = -1006698496;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
              i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
              }
              $12_1 = i64toi32_i32$4;
              $12$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $4$hi;
              i64toi32_i32$1 = $4_1;
              i64toi32_i32$0 = -1140785152;
              i64toi32_i32$3 = 0;
              i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
              i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$0 | 0;
              if (i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
              }
              $14$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $12$hi;
              i64toi32_i32$5 = $12_1;
              i64toi32_i32$1 = $14$hi;
              i64toi32_i32$3 = i64toi32_i32$2;
              if (i64toi32_i32$4 >>> 0 > i64toi32_i32$1 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$5 >>> 0 >= i64toi32_i32$2 >>> 0 | 0) | 0) {
                break label$2;
              }
              i64toi32_i32$5 = $0$hi;
              i64toi32_i32$3 = $0_1;
              i64toi32_i32$4 = 0;
              i64toi32_i32$1 = 60;
              i64toi32_i32$0 = i64toi32_i32$1 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                i64toi32_i32$4 = 0;
                $44_1 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
              } else {
                i64toi32_i32$4 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
                $44_1 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$0 | 0) | 0;
              }
              $17_1 = $44_1;
              $17$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $1$hi;
              i64toi32_i32$5 = $1_1;
              i64toi32_i32$3 = 0;
              i64toi32_i32$1 = 4;
              i64toi32_i32$0 = i64toi32_i32$1 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                i64toi32_i32$3 = i64toi32_i32$5 << i64toi32_i32$0 | 0;
                $45_1 = 0;
              } else {
                i64toi32_i32$3 = ((1 << i64toi32_i32$0 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$0 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$0 | 0) | 0;
                $45_1 = i64toi32_i32$5 << i64toi32_i32$0 | 0;
              }
              $19$hi = i64toi32_i32$3;
              i64toi32_i32$3 = $17$hi;
              i64toi32_i32$4 = $17_1;
              i64toi32_i32$5 = $19$hi;
              i64toi32_i32$1 = $45_1;
              i64toi32_i32$5 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
              $4_1 = i64toi32_i32$4 | i64toi32_i32$1 | 0;
              $4$hi = i64toi32_i32$5;
              label$3: {
                i64toi32_i32$5 = $0$hi;
                i64toi32_i32$3 = $0_1;
                i64toi32_i32$4 = 268435455;
                i64toi32_i32$1 = -1;
                i64toi32_i32$4 = i64toi32_i32$5 & i64toi32_i32$4 | 0;
                $0_1 = i64toi32_i32$3 & i64toi32_i32$1 | 0;
                $0$hi = i64toi32_i32$4;
                i64toi32_i32$5 = $0_1;
                i64toi32_i32$3 = 134217728;
                i64toi32_i32$1 = 1;
                if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$3 | 0) & i64toi32_i32$5 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0) {
                  break label$3;
                }
                i64toi32_i32$5 = $4$hi;
                i64toi32_i32$1 = $4_1;
                i64toi32_i32$4 = 1073741824;
                i64toi32_i32$3 = 1;
                i64toi32_i32$0 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
                i64toi32_i32$2 = i64toi32_i32$5 + i64toi32_i32$4 | 0;
                if (i64toi32_i32$0 >>> 0 < i64toi32_i32$3 >>> 0) {
                  i64toi32_i32$2 = i64toi32_i32$2 + 1 | 0;
                }
                $5_1 = i64toi32_i32$0;
                $5$hi = i64toi32_i32$2;
                break label$1;
              }
              i64toi32_i32$2 = $4$hi;
              i64toi32_i32$5 = $4_1;
              i64toi32_i32$1 = 1073741824;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$3 | 0;
              i64toi32_i32$0 = i64toi32_i32$2 + i64toi32_i32$1 | 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$0 = i64toi32_i32$0 + 1 | 0;
              }
              $5_1 = i64toi32_i32$4;
              $5$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $0$hi;
              i64toi32_i32$2 = $0_1;
              i64toi32_i32$5 = 134217728;
              i64toi32_i32$3 = 0;
              if ((i64toi32_i32$2 | 0) != (i64toi32_i32$3 | 0) | (i64toi32_i32$0 | 0) != (i64toi32_i32$5 | 0) | 0) {
                break label$1;
              }
              i64toi32_i32$2 = $5$hi;
              i64toi32_i32$2 = $4$hi;
              i64toi32_i32$3 = $4_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$5 = 1;
              i64toi32_i32$0 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
              $33_1 = i64toi32_i32$3 & i64toi32_i32$5 | 0;
              $33$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $5$hi;
              i64toi32_i32$2 = i64toi32_i32$4;
              i64toi32_i32$3 = $33$hi;
              i64toi32_i32$5 = $33_1;
              i64toi32_i32$1 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
              i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
              if (i64toi32_i32$1 >>> 0 < i64toi32_i32$5 >>> 0) {
                i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
              }
              $5_1 = i64toi32_i32$1;
              $5$hi = i64toi32_i32$4;
              break label$1;
            }
            label$4: {
              i64toi32_i32$4 = $0$hi;
              $36_1 = !($0_1 | i64toi32_i32$4 | 0);
              i64toi32_i32$4 = $4$hi;
              i64toi32_i32$0 = $4_1;
              i64toi32_i32$2 = 2147418112;
              i64toi32_i32$5 = 0;
              $38_1 = i64toi32_i32$4 >>> 0 < i64toi32_i32$2 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$2 | 0) & i64toi32_i32$0 >>> 0 < i64toi32_i32$5 >>> 0 | 0) | 0;
              i64toi32_i32$0 = i64toi32_i32$4;
              i64toi32_i32$0 = i64toi32_i32$4;
              i64toi32_i32$5 = $4_1;
              i64toi32_i32$4 = 2147418112;
              i64toi32_i32$2 = 0;
              if ((i64toi32_i32$5 | 0) == (i64toi32_i32$2 | 0) & (i64toi32_i32$0 | 0) == (i64toi32_i32$4 | 0) | 0 ? $36_1 : $38_1) {
                break label$4;
              }
              i64toi32_i32$5 = $0$hi;
              i64toi32_i32$2 = $0_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$4 = 60;
              i64toi32_i32$3 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$0 = 0;
                $46_1 = i64toi32_i32$5 >>> i64toi32_i32$3 | 0;
              } else {
                i64toi32_i32$0 = i64toi32_i32$5 >>> i64toi32_i32$3 | 0;
                $46_1 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$3 | 0) | 0;
              }
              $43_1 = $46_1;
              $43$hi = i64toi32_i32$0;
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$5 = $1_1;
              i64toi32_i32$2 = 0;
              i64toi32_i32$4 = 4;
              i64toi32_i32$3 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = i64toi32_i32$5 << i64toi32_i32$3 | 0;
                $47_1 = 0;
              } else {
                i64toi32_i32$2 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$3 | 0) | 0;
                $47_1 = i64toi32_i32$5 << i64toi32_i32$3 | 0;
              }
              $45$hi = i64toi32_i32$2;
              i64toi32_i32$2 = $43$hi;
              i64toi32_i32$0 = $43_1;
              i64toi32_i32$5 = $45$hi;
              i64toi32_i32$4 = $47_1;
              i64toi32_i32$5 = i64toi32_i32$2 | i64toi32_i32$5 | 0;
              i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$4 | 0;
              i64toi32_i32$0 = 524287;
              i64toi32_i32$4 = -1;
              i64toi32_i32$0 = i64toi32_i32$5 & i64toi32_i32$0 | 0;
              i64toi32_i32$5 = i64toi32_i32$2 & i64toi32_i32$4 | 0;
              i64toi32_i32$2 = 2146959360;
              i64toi32_i32$4 = 0;
              i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
              $5_1 = i64toi32_i32$5 | i64toi32_i32$4 | 0;
              $5$hi = i64toi32_i32$2;
              break label$1;
            }
            i64toi32_i32$2 = 2146435072;
            $5_1 = 0;
            $5$hi = i64toi32_i32$2;
            i64toi32_i32$2 = $4$hi;
            i64toi32_i32$0 = $4_1;
            i64toi32_i32$5 = 1140785151;
            i64toi32_i32$4 = -1;
            if (i64toi32_i32$2 >>> 0 > i64toi32_i32$5 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$0 >>> 0 > i64toi32_i32$4 >>> 0 | 0) | 0) {
              break label$1;
            }
            i64toi32_i32$0 = 0;
            $5_1 = 0;
            $5$hi = i64toi32_i32$0;
            i64toi32_i32$0 = i64toi32_i32$2;
            i64toi32_i32$0 = i64toi32_i32$2;
            i64toi32_i32$4 = $4_1;
            i64toi32_i32$2 = 0;
            i64toi32_i32$5 = 48;
            i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$2 = 0;
              $48_1 = i64toi32_i32$0 >>> i64toi32_i32$3 | 0;
            } else {
              i64toi32_i32$2 = i64toi32_i32$0 >>> i64toi32_i32$3 | 0;
              $48_1 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$3 | 0) | 0;
            }
            $3_1 = $48_1;
            if ($3_1 >>> 0 < 15249 >>> 0) {
              break label$1;
            }
            i64toi32_i32$2 = $0$hi;
            i64toi32_i32$2 = $1$hi;
            i64toi32_i32$0 = $1_1;
            i64toi32_i32$4 = 65535;
            i64toi32_i32$5 = -1;
            i64toi32_i32$4 = i64toi32_i32$2 & i64toi32_i32$4 | 0;
            i64toi32_i32$2 = i64toi32_i32$0 & i64toi32_i32$5 | 0;
            i64toi32_i32$0 = 65536;
            i64toi32_i32$5 = 0;
            i64toi32_i32$0 = i64toi32_i32$4 | i64toi32_i32$0 | 0;
            $4_1 = i64toi32_i32$2 | i64toi32_i32$5 | 0;
            $4$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $0$hi;
            i64toi32_i32$2 = $4$hi;
            $86($2_1 + 16 | 0 | 0, $0_1 | 0, i64toi32_i32$0 | 0, $4_1 | 0, i64toi32_i32$2 | 0, $3_1 + -15233 | 0 | 0);
            i64toi32_i32$2 = i64toi32_i32$0;
            i64toi32_i32$2 = $4$hi;
            i64toi32_i32$2 = i64toi32_i32$0;
            i64toi32_i32$0 = $4$hi;
            $96($2_1 | 0, $0_1 | 0, i64toi32_i32$2 | 0, $4_1 | 0, i64toi32_i32$0 | 0, 15361 - $3_1 | 0 | 0);
            i64toi32_i32$4 = $2_1;
            i64toi32_i32$0 = HEAP32[i64toi32_i32$4 >> 2] | 0;
            i64toi32_i32$2 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
            $4_1 = i64toi32_i32$0;
            $4$hi = i64toi32_i32$2;
            i64toi32_i32$4 = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$5 = 60;
            i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = 0;
              $49_1 = i64toi32_i32$2 >>> i64toi32_i32$3 | 0;
            } else {
              i64toi32_i32$0 = i64toi32_i32$2 >>> i64toi32_i32$3 | 0;
              $49_1 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$3 | 0) | 0;
            }
            $73_1 = $49_1;
            $73$hi = i64toi32_i32$0;
            i64toi32_i32$2 = $2_1 + 8 | 0;
            i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
            i64toi32_i32$4 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
            i64toi32_i32$2 = i64toi32_i32$0;
            i64toi32_i32$0 = 0;
            i64toi32_i32$5 = 4;
            i64toi32_i32$3 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$0 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
              $50_1 = 0;
            } else {
              i64toi32_i32$0 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$4 << i64toi32_i32$3 | 0) | 0;
              $50_1 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
            }
            $77$hi = i64toi32_i32$0;
            i64toi32_i32$0 = $73$hi;
            i64toi32_i32$4 = $73_1;
            i64toi32_i32$2 = $77$hi;
            i64toi32_i32$5 = $50_1;
            i64toi32_i32$2 = i64toi32_i32$0 | i64toi32_i32$2 | 0;
            $5_1 = i64toi32_i32$4 | i64toi32_i32$5 | 0;
            $5$hi = i64toi32_i32$2;
            label$5: {
              i64toi32_i32$2 = $4$hi;
              i64toi32_i32$0 = $4_1;
              i64toi32_i32$4 = 268435455;
              i64toi32_i32$5 = -1;
              i64toi32_i32$4 = i64toi32_i32$2 & i64toi32_i32$4 | 0;
              $80_1 = i64toi32_i32$0 & i64toi32_i32$5 | 0;
              $80$hi = i64toi32_i32$4;
              i64toi32_i32$2 = $2_1;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$2 + 16 | 0) >> 2] | 0;
              i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 20 | 0) >> 2] | 0;
              $82_1 = i64toi32_i32$4;
              $82$hi = i64toi32_i32$0;
              i64toi32_i32$2 = (i64toi32_i32$2 + 16 | 0) + 8 | 0;
              i64toi32_i32$0 = HEAP32[i64toi32_i32$2 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$2 + 4 | 0) >> 2] | 0;
              $86_1 = i64toi32_i32$0;
              $86$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $82$hi;
              i64toi32_i32$2 = $82_1;
              i64toi32_i32$0 = $86$hi;
              i64toi32_i32$5 = $86_1;
              i64toi32_i32$0 = i64toi32_i32$4 | i64toi32_i32$0 | 0;
              i64toi32_i32$4 = i64toi32_i32$2 | i64toi32_i32$5 | 0;
              i64toi32_i32$2 = 0;
              i64toi32_i32$5 = 0;
              $88_1 = (i64toi32_i32$4 | 0) != (i64toi32_i32$5 | 0) | (i64toi32_i32$0 | 0) != (i64toi32_i32$2 | 0) | 0;
              i64toi32_i32$4 = 0;
              $89$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $80$hi;
              i64toi32_i32$5 = $80_1;
              i64toi32_i32$0 = $89$hi;
              i64toi32_i32$2 = $88_1;
              i64toi32_i32$0 = i64toi32_i32$4 | i64toi32_i32$0 | 0;
              $4_1 = i64toi32_i32$5 | i64toi32_i32$2 | 0;
              $4$hi = i64toi32_i32$0;
              i64toi32_i32$4 = $4_1;
              i64toi32_i32$5 = 134217728;
              i64toi32_i32$2 = 1;
              if (i64toi32_i32$0 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$0 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$4 >>> 0 < i64toi32_i32$2 >>> 0 | 0) | 0) {
                break label$5;
              }
              i64toi32_i32$4 = $5$hi;
              i64toi32_i32$2 = $5_1;
              i64toi32_i32$0 = 0;
              i64toi32_i32$5 = 1;
              i64toi32_i32$3 = i64toi32_i32$2 + i64toi32_i32$5 | 0;
              i64toi32_i32$1 = i64toi32_i32$4 + i64toi32_i32$0 | 0;
              if (i64toi32_i32$3 >>> 0 < i64toi32_i32$5 >>> 0) {
                i64toi32_i32$1 = i64toi32_i32$1 + 1 | 0;
              }
              $5_1 = i64toi32_i32$3;
              $5$hi = i64toi32_i32$1;
              break label$1;
            }
            i64toi32_i32$1 = $4$hi;
            i64toi32_i32$4 = $4_1;
            i64toi32_i32$2 = 134217728;
            i64toi32_i32$5 = 0;
            if ((i64toi32_i32$4 | 0) != (i64toi32_i32$5 | 0) | (i64toi32_i32$1 | 0) != (i64toi32_i32$2 | 0) | 0) {
              break label$1;
            }
            i64toi32_i32$4 = $5$hi;
            i64toi32_i32$5 = $5_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$2 = 1;
            i64toi32_i32$1 = i64toi32_i32$4 & i64toi32_i32$1 | 0;
            $98$hi = i64toi32_i32$1;
            i64toi32_i32$1 = i64toi32_i32$4;
            i64toi32_i32$1 = $98$hi;
            i64toi32_i32$4 = i64toi32_i32$5 & i64toi32_i32$2 | 0;
            i64toi32_i32$5 = $5$hi;
            i64toi32_i32$2 = $5_1;
            i64toi32_i32$0 = i64toi32_i32$4 + i64toi32_i32$2 | 0;
            i64toi32_i32$3 = i64toi32_i32$1 + i64toi32_i32$5 | 0;
            if (i64toi32_i32$0 >>> 0 < i64toi32_i32$2 >>> 0) {
              i64toi32_i32$3 = i64toi32_i32$3 + 1 | 0;
            }
            $5_1 = i64toi32_i32$0;
            $5$hi = i64toi32_i32$3;
          }
          global$0 = $2_1 + 32 | 0;
          i64toi32_i32$3 = $5$hi;
          i64toi32_i32$3 = $1$hi;
          i64toi32_i32$1 = $1_1;
          i64toi32_i32$4 = -2147483648;
          i64toi32_i32$2 = 0;
          i64toi32_i32$4 = i64toi32_i32$3 & i64toi32_i32$4 | 0;
          $105_1 = i64toi32_i32$1 & i64toi32_i32$2 | 0;
          $105$hi = i64toi32_i32$4;
          i64toi32_i32$4 = $5$hi;
          i64toi32_i32$3 = $5_1;
          i64toi32_i32$1 = $105$hi;
          i64toi32_i32$2 = $105_1;
          i64toi32_i32$1 = i64toi32_i32$4 | i64toi32_i32$1 | 0;
          wasm2js_scratch_store_i32(0 | 0, i64toi32_i32$3 | i64toi32_i32$2 | 0 | 0);
          wasm2js_scratch_store_i32(1 | 0, i64toi32_i32$1 | 0);
          return + +wasm2js_scratch_load_f64();
        }

        function $101($0_1, $0$hi, $1_1, $1$hi) {
          $0_1 = $0_1 | 0;
          $0$hi = $0$hi | 0;
          $1_1 = $1_1 | 0;
          $1$hi = $1$hi | 0;
          var i64toi32_i32$1 = 0,i64toi32_i32$3 = 0,i64toi32_i32$4 = 0,i64toi32_i32$5 = 0,i64toi32_i32$0 = 0,$5_1 = 0,$5$hi = 0,$4_1 = 0,$3_1 = 0,$2_1 = 0,i64toi32_i32$2 = 0,$37_1 = 0,$38_1 = 0,$39_1 = 0,$40_1 = 0,$41_1 = 0,$12_1 = 0,$12$hi = 0,$14$hi = 0,$20_1 = 0,$24_1 = 0,$34_1 = 0,$34$hi = 0,$42_1 = 0,$44_1 = 0,$81_1 = 0,$81$hi = 0,$83_1 = 0,$83$hi = 0,$87_1 = 0,$87$hi = 0,$89_1 = 0,$90$hi = 0,$93_1 = 0,$97_1 = 0,$105_1 = 0,$105$hi = 0,$114 = 0;
          $2_1 = global$0 - 32 | 0;
          global$0 = $2_1;
          label$1: {
            label$2: {
              i64toi32_i32$0 = $1$hi;
              i64toi32_i32$2 = $1_1;
              i64toi32_i32$1 = 2147483647;
              i64toi32_i32$3 = -1;
              i64toi32_i32$1 = i64toi32_i32$0 & i64toi32_i32$1 | 0;
              $5_1 = $1_1 & i64toi32_i32$3 | 0;
              $5$hi = i64toi32_i32$1;
              i64toi32_i32$0 = $5_1;
              i64toi32_i32$2 = -1065418752;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = i64toi32_i32$0 + i64toi32_i32$3 | 0;
              i64toi32_i32$5 = i64toi32_i32$1 + i64toi32_i32$2 | 0;
              if (i64toi32_i32$4 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
              }
              $12_1 = i64toi32_i32$4;
              $12$hi = i64toi32_i32$5;
              i64toi32_i32$5 = $5$hi;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$0 = -1082064896;
              i64toi32_i32$3 = 0;
              i64toi32_i32$2 = i64toi32_i32$1 + i64toi32_i32$3 | 0;
              i64toi32_i32$4 = i64toi32_i32$5 + i64toi32_i32$0 | 0;
              if (i64toi32_i32$2 >>> 0 < i64toi32_i32$3 >>> 0) {
                i64toi32_i32$4 = i64toi32_i32$4 + 1 | 0;
              }
              $14$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $12$hi;
              i64toi32_i32$5 = $12_1;
              i64toi32_i32$1 = $14$hi;
              i64toi32_i32$3 = i64toi32_i32$2;
              if (i64toi32_i32$4 >>> 0 > i64toi32_i32$1 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$1 | 0) & i64toi32_i32$5 >>> 0 >= i64toi32_i32$3 >>> 0 | 0) | 0) {
                break label$2;
              }
              i64toi32_i32$5 = $1$hi;
              i64toi32_i32$3 = $1_1;
              i64toi32_i32$4 = 0;
              i64toi32_i32$1 = 25;
              i64toi32_i32$0 = i64toi32_i32$1 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$1 & 63 | 0) >>> 0) {
                i64toi32_i32$4 = 0;
                $37_1 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
              } else {
                i64toi32_i32$4 = i64toi32_i32$5 >>> i64toi32_i32$0 | 0;
                $37_1 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$5 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$0 | 0) | 0;
              }
              $3_1 = $37_1;
              label$3: {
                i64toi32_i32$4 = $0$hi;
                $20_1 = !($0_1 | i64toi32_i32$4 | 0);
                i64toi32_i32$4 = $1$hi;
                i64toi32_i32$5 = $1_1;
                i64toi32_i32$3 = 0;
                i64toi32_i32$1 = 33554431;
                i64toi32_i32$3 = i64toi32_i32$4 & i64toi32_i32$3 | 0;
                $5_1 = i64toi32_i32$5 & i64toi32_i32$1 | 0;
                $5$hi = i64toi32_i32$3;
                i64toi32_i32$4 = $5_1;
                i64toi32_i32$5 = 0;
                i64toi32_i32$1 = 16777216;
                $24_1 = i64toi32_i32$3 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$4 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
                i64toi32_i32$4 = i64toi32_i32$3;
                i64toi32_i32$4 = i64toi32_i32$3;
                i64toi32_i32$1 = $5_1;
                i64toi32_i32$3 = 0;
                i64toi32_i32$5 = 16777216;
                if ((i64toi32_i32$1 | 0) == (i64toi32_i32$5 | 0) & (i64toi32_i32$4 | 0) == (i64toi32_i32$3 | 0) | 0 ? $20_1 : $24_1) {
                  break label$3;
                }
                $4_1 = $3_1 + 1073741825 | 0;
                break label$1;
              }
              $4_1 = $3_1 + 1073741824 | 0;
              i64toi32_i32$1 = $0$hi;
              i64toi32_i32$1 = $5$hi;
              i64toi32_i32$5 = $5_1;
              i64toi32_i32$4 = 0;
              i64toi32_i32$3 = 16777216;
              i64toi32_i32$4 = i64toi32_i32$1 ^ i64toi32_i32$4 | 0;
              $34_1 = i64toi32_i32$5 ^ i64toi32_i32$3 | 0;
              $34$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $0$hi;
              i64toi32_i32$1 = $0_1;
              i64toi32_i32$5 = $34$hi;
              i64toi32_i32$3 = $34_1;
              i64toi32_i32$5 = i64toi32_i32$4 | i64toi32_i32$5 | 0;
              i64toi32_i32$4 = i64toi32_i32$1 | i64toi32_i32$3 | 0;
              i64toi32_i32$1 = 0;
              i64toi32_i32$3 = 0;
              if ((i64toi32_i32$4 | 0) != (i64toi32_i32$3 | 0) | (i64toi32_i32$5 | 0) != (i64toi32_i32$1 | 0) | 0) {
                break label$1;
              }
              $4_1 = $4_1 + ($3_1 & 1 | 0) | 0;
              break label$1;
            }
            label$4: {
              i64toi32_i32$4 = $0$hi;
              $42_1 = !($0_1 | i64toi32_i32$4 | 0);
              i64toi32_i32$4 = $5$hi;
              i64toi32_i32$3 = $5_1;
              i64toi32_i32$5 = 2147418112;
              i64toi32_i32$1 = 0;
              $44_1 = i64toi32_i32$4 >>> 0 < i64toi32_i32$5 >>> 0 | ((i64toi32_i32$4 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$3 >>> 0 < i64toi32_i32$1 >>> 0 | 0) | 0;
              i64toi32_i32$3 = i64toi32_i32$4;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$4 = 2147418112;
              i64toi32_i32$5 = 0;
              if ((i64toi32_i32$1 | 0) == (i64toi32_i32$5 | 0) & (i64toi32_i32$3 | 0) == (i64toi32_i32$4 | 0) | 0 ? $42_1 : $44_1) {
                break label$4;
              }
              i64toi32_i32$1 = $1$hi;
              i64toi32_i32$5 = $1_1;
              i64toi32_i32$3 = 0;
              i64toi32_i32$4 = 25;
              i64toi32_i32$0 = i64toi32_i32$4 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
                i64toi32_i32$3 = 0;
                $38_1 = i64toi32_i32$1 >>> i64toi32_i32$0 | 0;
              } else {
                i64toi32_i32$3 = i64toi32_i32$1 >>> i64toi32_i32$0 | 0;
                $38_1 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$0 | 0) | 0;
              }
              $4_1 = $38_1 & 4194303 | 0 | 2143289344 | 0;
              break label$1;
            }
            $4_1 = 2139095040;
            i64toi32_i32$3 = $5$hi;
            i64toi32_i32$1 = $5_1;
            i64toi32_i32$5 = 1082064895;
            i64toi32_i32$4 = -1;
            if (i64toi32_i32$3 >>> 0 > i64toi32_i32$5 >>> 0 | ((i64toi32_i32$3 | 0) == (i64toi32_i32$5 | 0) & i64toi32_i32$1 >>> 0 > i64toi32_i32$4 >>> 0 | 0) | 0) {
              break label$1;
            }
            $4_1 = 0;
            i64toi32_i32$1 = i64toi32_i32$3;
            i64toi32_i32$4 = $5_1;
            i64toi32_i32$3 = 0;
            i64toi32_i32$5 = 48;
            i64toi32_i32$0 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$3 = 0;
              $39_1 = i64toi32_i32$1 >>> i64toi32_i32$0 | 0;
            } else {
              i64toi32_i32$3 = i64toi32_i32$1 >>> i64toi32_i32$0 | 0;
              $39_1 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$0 | 0) | 0;
            }
            $3_1 = $39_1;
            if ($3_1 >>> 0 < 16145 >>> 0) {
              break label$1;
            }
            i64toi32_i32$3 = $0$hi;
            i64toi32_i32$3 = $1$hi;
            i64toi32_i32$1 = $1_1;
            i64toi32_i32$4 = 65535;
            i64toi32_i32$5 = -1;
            i64toi32_i32$4 = i64toi32_i32$3 & i64toi32_i32$4 | 0;
            i64toi32_i32$3 = i64toi32_i32$1 & i64toi32_i32$5 | 0;
            i64toi32_i32$1 = 65536;
            i64toi32_i32$5 = 0;
            i64toi32_i32$1 = i64toi32_i32$4 | i64toi32_i32$1 | 0;
            $5_1 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
            $5$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $0$hi;
            i64toi32_i32$3 = $5$hi;
            $86($2_1 + 16 | 0 | 0, $0_1 | 0, i64toi32_i32$1 | 0, $5_1 | 0, i64toi32_i32$3 | 0, $3_1 + -16129 | 0 | 0);
            i64toi32_i32$3 = i64toi32_i32$1;
            i64toi32_i32$3 = $5$hi;
            i64toi32_i32$3 = i64toi32_i32$1;
            i64toi32_i32$1 = $5$hi;
            $96($2_1 | 0, $0_1 | 0, i64toi32_i32$3 | 0, $5_1 | 0, i64toi32_i32$1 | 0, 16257 - $3_1 | 0 | 0);
            i64toi32_i32$4 = $2_1 + 8 | 0;
            i64toi32_i32$1 = HEAP32[i64toi32_i32$4 >> 2] | 0;
            i64toi32_i32$3 = HEAP32[(i64toi32_i32$4 + 4 | 0) >> 2] | 0;
            $5_1 = i64toi32_i32$1;
            $5$hi = i64toi32_i32$3;
            i64toi32_i32$4 = i64toi32_i32$1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$5 = 25;
            i64toi32_i32$0 = i64toi32_i32$5 & 31 | 0;
            if (32 >>> 0 <= (i64toi32_i32$5 & 63 | 0) >>> 0) {
              i64toi32_i32$1 = 0;
              $40_1 = i64toi32_i32$3 >>> i64toi32_i32$0 | 0;
            } else {
              i64toi32_i32$1 = i64toi32_i32$3 >>> i64toi32_i32$0 | 0;
              $40_1 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$3 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$4 >>> i64toi32_i32$0 | 0) | 0;
            }
            $4_1 = $40_1;
            label$5: {
              i64toi32_i32$3 = $2_1;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $81_1 = i64toi32_i32$1;
              $81$hi = i64toi32_i32$4;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 16 | 0) >> 2] | 0;
              i64toi32_i32$1 = HEAP32[(i64toi32_i32$3 + 20 | 0) >> 2] | 0;
              $83_1 = i64toi32_i32$4;
              $83$hi = i64toi32_i32$1;
              i64toi32_i32$3 = (i64toi32_i32$3 + 16 | 0) + 8 | 0;
              i64toi32_i32$1 = HEAP32[i64toi32_i32$3 >> 2] | 0;
              i64toi32_i32$4 = HEAP32[(i64toi32_i32$3 + 4 | 0) >> 2] | 0;
              $87_1 = i64toi32_i32$1;
              $87$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $83$hi;
              i64toi32_i32$3 = $83_1;
              i64toi32_i32$1 = $87$hi;
              i64toi32_i32$5 = $87_1;
              i64toi32_i32$1 = i64toi32_i32$4 | i64toi32_i32$1 | 0;
              i64toi32_i32$4 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
              i64toi32_i32$3 = 0;
              i64toi32_i32$5 = 0;
              $89_1 = (i64toi32_i32$4 | 0) != (i64toi32_i32$5 | 0) | (i64toi32_i32$1 | 0) != (i64toi32_i32$3 | 0) | 0;
              i64toi32_i32$4 = 0;
              $90$hi = i64toi32_i32$4;
              i64toi32_i32$4 = $81$hi;
              i64toi32_i32$5 = $81_1;
              i64toi32_i32$1 = $90$hi;
              i64toi32_i32$3 = $89_1;
              i64toi32_i32$1 = i64toi32_i32$4 | i64toi32_i32$1 | 0;
              $0_1 = i64toi32_i32$5 | i64toi32_i32$3 | 0;
              $0$hi = i64toi32_i32$1;
              $93_1 = !($0_1 | i64toi32_i32$1 | 0);
              i64toi32_i32$1 = $5$hi;
              i64toi32_i32$4 = $5_1;
              i64toi32_i32$5 = 0;
              i64toi32_i32$3 = 33554431;
              i64toi32_i32$5 = i64toi32_i32$1 & i64toi32_i32$5 | 0;
              $5_1 = i64toi32_i32$4 & i64toi32_i32$3 | 0;
              $5$hi = i64toi32_i32$5;
              i64toi32_i32$1 = $5_1;
              i64toi32_i32$4 = 0;
              i64toi32_i32$3 = 16777216;
              $97_1 = i64toi32_i32$5 >>> 0 < i64toi32_i32$4 >>> 0 | ((i64toi32_i32$5 | 0) == (i64toi32_i32$4 | 0) & i64toi32_i32$1 >>> 0 < i64toi32_i32$3 >>> 0 | 0) | 0;
              i64toi32_i32$1 = i64toi32_i32$5;
              i64toi32_i32$3 = $5_1;
              i64toi32_i32$5 = 0;
              i64toi32_i32$4 = 16777216;
              if ((i64toi32_i32$3 | 0) == (i64toi32_i32$4 | 0) & (i64toi32_i32$1 | 0) == (i64toi32_i32$5 | 0) | 0 ? $93_1 : $97_1) {
                break label$5;
              }
              $4_1 = $4_1 + 1 | 0;
              break label$1;
            }
            i64toi32_i32$3 = $0$hi;
            i64toi32_i32$3 = $5$hi;
            i64toi32_i32$4 = $5_1;
            i64toi32_i32$1 = 0;
            i64toi32_i32$5 = 16777216;
            i64toi32_i32$1 = i64toi32_i32$3 ^ i64toi32_i32$1 | 0;
            $105_1 = i64toi32_i32$4 ^ i64toi32_i32$5 | 0;
            $105$hi = i64toi32_i32$1;
            i64toi32_i32$1 = $0$hi;
            i64toi32_i32$3 = $0_1;
            i64toi32_i32$4 = $105$hi;
            i64toi32_i32$5 = $105_1;
            i64toi32_i32$4 = i64toi32_i32$1 | i64toi32_i32$4 | 0;
            i64toi32_i32$1 = i64toi32_i32$3 | i64toi32_i32$5 | 0;
            i64toi32_i32$3 = 0;
            i64toi32_i32$5 = 0;
            if ((i64toi32_i32$1 | 0) != (i64toi32_i32$5 | 0) | (i64toi32_i32$4 | 0) != (i64toi32_i32$3 | 0) | 0) {
              break label$1;
            }
            $4_1 = ($4_1 & 1 | 0) + $4_1 | 0;
          }
          global$0 = $2_1 + 32 | 0;
          $114 = $4_1;
          i64toi32_i32$1 = $1$hi;
          i64toi32_i32$5 = $1_1;
          i64toi32_i32$4 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$0 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$4 = 0;
            $41_1 = i64toi32_i32$1 >>> i64toi32_i32$0 | 0;
          } else {
            i64toi32_i32$4 = i64toi32_i32$1 >>> i64toi32_i32$0 | 0;
            $41_1 = (((1 << i64toi32_i32$0 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$0 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$0 | 0) | 0;
          }
          return Math_fround((wasm2js_scratch_store_i32(2, $114 | ($41_1 & -2147483648 | 0) | 0), wasm2js_scratch_load_f32()));
        }

        function $104() {
          global$3 = 65536;
          global$2 = (0 + 15 | 0) & -16 | 0;
        }

        function $105() {
          return global$0 - global$2 | 0 | 0;
        }

        function $106() {
          return global$3 | 0;
        }

        function $107() {
          return global$2 | 0;
        }

        function $108() {
          return global$0 | 0;
        }

        function $109($0_1) {
          $0_1 = $0_1 | 0;
          global$0 = $0_1;
        }

        function $110($0_1) {
          $0_1 = $0_1 | 0;
          var $1_1 = 0;
          $1_1 = (global$0 - $0_1 | 0) & -16 | 0;
          global$0 = $1_1;
          return $1_1 | 0;
        }

        function $111() {
          return global$0 | 0;
        }

        function $112($0_1) {
          $0_1 = $0_1 | 0;
          var $1_1 = 0,i64toi32_i32$1 = 0,$2_1 = 0,i64toi32_i32$0 = 0,$3_1 = 0;
          label$1: {
            if ($0_1) {
              break label$1;
            }
            $1_1 = 0;
            label$2: {
              if (!(HEAP32[(0 + 99436 | 0) >> 2] | 0)) {
                break label$2;
              }
              $1_1 = $112(HEAP32[(0 + 99436 | 0) >> 2] | 0 | 0) | 0;
            }
            label$3: {
              if (!(HEAP32[(0 + 99436 | 0) >> 2] | 0)) {
                break label$3;
              }
              $1_1 = $112(HEAP32[(0 + 99436 | 0) >> 2] | 0 | 0) | 0 | $1_1 | 0;
            }
            label$4: {
              $0_1 = HEAP32[($22() | 0) >> 2] | 0;
              if (!$0_1) {
                break label$4;
              }
              label$5: while (1) {
                $2_1 = 0;
                label$6: {
                  if ((HEAP32[($0_1 + 76 | 0) >> 2] | 0 | 0) < (0 | 0)) {
                    break label$6;
                  }
                  $2_1 = $18($0_1 | 0) | 0;
                }
                label$7: {
                  if ((HEAP32[($0_1 + 20 | 0) >> 2] | 0 | 0) == (HEAP32[($0_1 + 28 | 0) >> 2] | 0 | 0)) {
                    break label$7;
                  }
                  $1_1 = $112($0_1 | 0) | 0 | $1_1 | 0;
                }
                label$8: {
                  if (!$2_1) {
                    break label$8;
                  }
                  $19($0_1 | 0);
                }
                $0_1 = HEAP32[($0_1 + 56 | 0) >> 2] | 0;
                if ($0_1) {
                  continue label$5;
                }
                break label$5;
              };
            }
            $23();
            return $1_1 | 0;
          }
          label$9: {
            label$10: {
              if ((HEAP32[($0_1 + 76 | 0) >> 2] | 0 | 0) >= (0 | 0)) {
                break label$10;
              }
              $2_1 = 1;
              break label$9;
            }
            $2_1 = !($18($0_1 | 0) | 0);
          }
          label$11: {
            label$12: {
              label$13: {
                if ((HEAP32[($0_1 + 20 | 0) >> 2] | 0 | 0) == (HEAP32[($0_1 + 28 | 0) >> 2] | 0 | 0)) {
                  break label$13;
                }
                FUNCTION_TABLE[HEAP32[($0_1 + 36 | 0) >> 2] | 0 | 0]($0_1, 0, 0) | 0;
                if (HEAP32[($0_1 + 20 | 0) >> 2] | 0) {
                  break label$13;
                }
                $1_1 = -1;
                if (!$2_1) {
                  break label$12;
                }
                break label$11;
              }
              label$14: {
                $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;
                $3_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;
                if (($1_1 | 0) == ($3_1 | 0)) {
                  break label$14;
                }
                i64toi32_i32$1 = $1_1 - $3_1 | 0;
                i64toi32_i32$0 = i64toi32_i32$1 >> 31 | 0;
                i64toi32_i32$0 = FUNCTION_TABLE[HEAP32[($0_1 + 40 | 0) >> 2] | 0 | 0]($0_1, i64toi32_i32$1, i64toi32_i32$0, 1) | 0;
                i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;
              }
              $1_1 = 0;
              HEAP32[($0_1 + 28 | 0) >> 2] = 0;
              i64toi32_i32$0 = $0_1;
              i64toi32_i32$1 = 0;
              HEAP32[($0_1 + 16 | 0) >> 2] = 0;
              HEAP32[($0_1 + 20 | 0) >> 2] = i64toi32_i32$1;
              i64toi32_i32$0 = $0_1;
              i64toi32_i32$1 = 0;
              HEAP32[($0_1 + 4 | 0) >> 2] = 0;
              HEAP32[($0_1 + 8 | 0) >> 2] = i64toi32_i32$1;
              if ($2_1) {
                break label$11;
              }
            }
            $19($0_1 | 0);
          }
          return $1_1 | 0;
        }

        function _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE(var$0, var$0$hi, var$1, var$1$hi) {
          var$0 = var$0 | 0;
          var$0$hi = var$0$hi | 0;
          var$1 = var$1 | 0;
          var$1$hi = var$1$hi | 0;
          var i64toi32_i32$4 = 0,i64toi32_i32$0 = 0,i64toi32_i32$1 = 0,var$2 = 0,i64toi32_i32$2 = 0,i64toi32_i32$3 = 0,var$3 = 0,var$4 = 0,var$5 = 0,$21_1 = 0,$22_1 = 0,var$6 = 0,$24_1 = 0,$17_1 = 0,$18_1 = 0,$23_1 = 0,$29_1 = 0,$45_1 = 0,$56$hi = 0,$62$hi = 0;
          i64toi32_i32$0 = var$1$hi;
          var$2 = var$1;
          var$4 = var$2 >>> 16 | 0;
          i64toi32_i32$0 = var$0$hi;
          var$3 = var$0;
          var$5 = var$3 >>> 16 | 0;
          $17_1 = Math_imul(var$4, var$5);
          $18_1 = var$2;
          i64toi32_i32$2 = var$3;
          i64toi32_i32$1 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$1 = 0;
            $21_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
          } else {
            i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
            $21_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
          }
          $23_1 = $17_1 + Math_imul($18_1, $21_1) | 0;
          i64toi32_i32$1 = var$1$hi;
          i64toi32_i32$0 = var$1;
          i64toi32_i32$2 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$2 = 0;
            $22_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
          } else {
            i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
            $22_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
          }
          $29_1 = $23_1 + Math_imul($22_1, var$3) | 0;
          var$2 = var$2 & 65535 | 0;
          var$3 = var$3 & 65535 | 0;
          var$6 = Math_imul(var$2, var$3);
          var$2 = (var$6 >>> 16 | 0) + Math_imul(var$2, var$5) | 0;
          $45_1 = $29_1 + (var$2 >>> 16 | 0) | 0;
          var$2 = (var$2 & 65535 | 0) + Math_imul(var$4, var$3) | 0;
          i64toi32_i32$2 = 0;
          i64toi32_i32$1 = $45_1 + (var$2 >>> 16 | 0) | 0;
          i64toi32_i32$0 = 0;
          i64toi32_i32$3 = 32;
          i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
          if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
            i64toi32_i32$0 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
            $24_1 = 0;
          } else {
            i64toi32_i32$0 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$4 | 0) | 0;
            $24_1 = i64toi32_i32$1 << i64toi32_i32$4 | 0;
          }
          $56$hi = i64toi32_i32$0;
          i64toi32_i32$0 = 0;
          $62$hi = i64toi32_i32$0;
          i64toi32_i32$0 = $56$hi;
          i64toi32_i32$2 = $24_1;
          i64toi32_i32$1 = $62$hi;
          i64toi32_i32$3 = var$2 << 16 | 0 | (var$6 & 65535 | 0) | 0;
          i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;
          i64toi32_i32$2 = i64toi32_i32$2 | i64toi32_i32$3 | 0;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$1;
          return i64toi32_i32$2 | 0;
        }

        function _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E(var$0, var$0$hi, var$1, var$1$hi) {
          var$0 = var$0 | 0;
          var$0$hi = var$0$hi | 0;
          var$1 = var$1 | 0;
          var$1$hi = var$1$hi | 0;
          var i64toi32_i32$2 = 0,i64toi32_i32$3 = 0,i64toi32_i32$4 = 0,i64toi32_i32$1 = 0,i64toi32_i32$0 = 0,i64toi32_i32$5 = 0,var$2 = 0,var$3 = 0,var$4 = 0,var$5 = 0,var$5$hi = 0,var$6 = 0,var$6$hi = 0,i64toi32_i32$6 = 0,$37_1 = 0,$38_1 = 0,$39_1 = 0,$40_1 = 0,$41_1 = 0,$42_1 = 0,$43_1 = 0,$44_1 = 0,var$8$hi = 0,$45_1 = 0,$46_1 = 0,$47_1 = 0,$48_1 = 0,var$7$hi = 0,$49_1 = 0,$63$hi = 0,$65_1 = 0,$65$hi = 0,$120$hi = 0,$129$hi = 0,$134$hi = 0,var$8 = 0,$140 = 0,$140$hi = 0,$142$hi = 0,$144 = 0,$144$hi = 0,$151 = 0,$151$hi = 0,$154$hi = 0,var$7 = 0,$165$hi = 0;
          label$1: {
            label$2: {
              label$3: {
                label$4: {
                  label$5: {
                    label$6: {
                      label$7: {
                        label$8: {
                          label$9: {
                            label$10: {
                              label$11: {
                                i64toi32_i32$0 = var$0$hi;
                                i64toi32_i32$2 = var$0;
                                i64toi32_i32$1 = 0;
                                i64toi32_i32$3 = 32;
                                i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
                                if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                                  i64toi32_i32$1 = 0;
                                  $37_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                                } else {
                                  i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;
                                  $37_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
                                }
                                var$2 = $37_1;
                                if (var$2) {
                                  i64toi32_i32$1 = var$1$hi;
                                  var$3 = var$1;
                                  if (!var$3) {
                                    break label$11;
                                  }
                                  i64toi32_i32$0 = var$3;
                                  i64toi32_i32$2 = 0;
                                  i64toi32_i32$3 = 32;
                                  i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
                                  if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
                                    i64toi32_i32$2 = 0;
                                    $38_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                                  } else {
                                    i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;
                                    $38_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;
                                  }
                                  var$4 = $38_1;
                                  if (!var$4) {
                                    break label$9;
                                  }
                                  var$2 = Math_clz32(var$4) - Math_clz32(var$2) | 0;
                                  if (var$2 >>> 0 <= 31 >>> 0) {
                                    break label$8;
                                  }
                                  break label$2;
                                }
                                i64toi32_i32$2 = var$1$hi;
                                i64toi32_i32$1 = var$1;
                                i64toi32_i32$0 = 1;
                                i64toi32_i32$3 = 0;
                                if (i64toi32_i32$2 >>> 0 > i64toi32_i32$0 >>> 0 | ((i64toi32_i32$2 | 0) == (i64toi32_i32$0 | 0) & i64toi32_i32$1 >>> 0 >= i64toi32_i32$3 >>> 0 | 0) | 0) {
                                  break label$2;
                                }
                                i64toi32_i32$1 = var$0$hi;
                                var$2 = var$0;
                                i64toi32_i32$1 = i64toi32_i32$2;
                                i64toi32_i32$1 = i64toi32_i32$2;
                                var$3 = var$1;
                                var$2 = (var$2 >>> 0) / (var$3 >>> 0) | 0;
                                i64toi32_i32$1 = 0;
                                __wasm_intrinsics_temp_i64 = var$0 - Math_imul(var$2, var$3) | 0;
                                __wasm_intrinsics_temp_i64$hi = i64toi32_i32$1;
                                i64toi32_i32$1 = 0;
                                i64toi32_i32$2 = var$2;
                                i64toi32_i32$HIGH_BITS = i64toi32_i32$1;
                                return i64toi32_i32$2 | 0;
                              }
                              i64toi32_i32$2 = var$1$hi;
                              i64toi32_i32$3 = var$1;
                              i64toi32_i32$1 = 0;
                              i64toi32_i32$0 = 32;
                              i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                              if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                                i64toi32_i32$1 = 0;
                                $39_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                              } else {
                                i64toi32_i32$1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                                $39_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$4 | 0) | 0;
                              }
                              var$3 = $39_1;
                              i64toi32_i32$1 = var$0$hi;
                              if (!var$0) {
                                break label$7;
                              }
                              if (!var$3) {
                                break label$6;
                              }
                              var$4 = var$3 + -1 | 0;
                              if (var$4 & var$3 | 0) {
                                break label$6;
                              }
                              i64toi32_i32$1 = 0;
                              i64toi32_i32$2 = var$4 & var$2 | 0;
                              i64toi32_i32$3 = 0;
                              i64toi32_i32$0 = 32;
                              i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                              if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                                i64toi32_i32$3 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                                $40_1 = 0;
                              } else {
                                i64toi32_i32$3 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
                                $40_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                              }
                              $63$hi = i64toi32_i32$3;
                              i64toi32_i32$3 = var$0$hi;
                              i64toi32_i32$1 = var$0;
                              i64toi32_i32$2 = 0;
                              i64toi32_i32$0 = -1;
                              i64toi32_i32$2 = i64toi32_i32$3 & i64toi32_i32$2 | 0;
                              $65_1 = i64toi32_i32$1 & i64toi32_i32$0 | 0;
                              $65$hi = i64toi32_i32$2;
                              i64toi32_i32$2 = $63$hi;
                              i64toi32_i32$3 = $40_1;
                              i64toi32_i32$1 = $65$hi;
                              i64toi32_i32$0 = $65_1;
                              i64toi32_i32$1 = i64toi32_i32$2 | i64toi32_i32$1 | 0;
                              __wasm_intrinsics_temp_i64 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
                              __wasm_intrinsics_temp_i64$hi = i64toi32_i32$1;
                              i64toi32_i32$1 = 0;
                              i64toi32_i32$3 = var$2 >>> ((__wasm_ctz_i32(var$3 | 0) | 0) & 31 | 0) | 0;
                              i64toi32_i32$HIGH_BITS = i64toi32_i32$1;
                              return i64toi32_i32$3 | 0;
                            }
                          }
                          var$4 = var$3 + -1 | 0;
                          if (!(var$4 & var$3 | 0)) {
                            break label$5;
                          }
                          var$2 = (Math_clz32(var$3) + 33 | 0) - Math_clz32(var$2) | 0;
                          var$3 = 0 - var$2 | 0;
                          break label$3;
                        }
                        var$3 = 63 - var$2 | 0;
                        var$2 = var$2 + 1 | 0;
                        break label$3;
                      }
                      var$4 = (var$2 >>> 0) / (var$3 >>> 0) | 0;
                      i64toi32_i32$3 = 0;
                      i64toi32_i32$2 = var$2 - Math_imul(var$4, var$3) | 0;
                      i64toi32_i32$1 = 0;
                      i64toi32_i32$0 = 32;
                      i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                      if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                        i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                        $41_1 = 0;
                      } else {
                        i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$4 | 0) | 0;
                        $41_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
                      }
                      __wasm_intrinsics_temp_i64 = $41_1;
                      __wasm_intrinsics_temp_i64$hi = i64toi32_i32$1;
                      i64toi32_i32$1 = 0;
                      i64toi32_i32$2 = var$4;
                      i64toi32_i32$HIGH_BITS = i64toi32_i32$1;
                      return i64toi32_i32$2 | 0;
                    }
                    var$2 = Math_clz32(var$3) - Math_clz32(var$2) | 0;
                    if (var$2 >>> 0 < 31 >>> 0) {
                      break label$4;
                    }
                    break label$2;
                  }
                  i64toi32_i32$2 = var$0$hi;
                  i64toi32_i32$2 = 0;
                  __wasm_intrinsics_temp_i64 = var$4 & var$0 | 0;
                  __wasm_intrinsics_temp_i64$hi = i64toi32_i32$2;
                  if ((var$3 | 0) == (1 | 0)) {
                    break label$1;
                  }
                  i64toi32_i32$2 = var$0$hi;
                  i64toi32_i32$2 = 0;
                  $120$hi = i64toi32_i32$2;
                  i64toi32_i32$2 = var$0$hi;
                  i64toi32_i32$3 = var$0;
                  i64toi32_i32$1 = $120$hi;
                  i64toi32_i32$0 = __wasm_ctz_i32(var$3 | 0) | 0;
                  i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                  if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                    i64toi32_i32$1 = 0;
                    $42_1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                  } else {
                    i64toi32_i32$1 = i64toi32_i32$2 >>> i64toi32_i32$4 | 0;
                    $42_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$2 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$3 >>> i64toi32_i32$4 | 0) | 0;
                  }
                  i64toi32_i32$3 = $42_1;
                  i64toi32_i32$HIGH_BITS = i64toi32_i32$1;
                  return i64toi32_i32$3 | 0;
                }
                var$3 = 63 - var$2 | 0;
                var$2 = var$2 + 1 | 0;
              }
              i64toi32_i32$3 = var$0$hi;
              i64toi32_i32$3 = 0;
              $129$hi = i64toi32_i32$3;
              i64toi32_i32$3 = var$0$hi;
              i64toi32_i32$2 = var$0;
              i64toi32_i32$1 = $129$hi;
              i64toi32_i32$0 = var$2 & 63 | 0;
              i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                i64toi32_i32$1 = 0;
                $43_1 = i64toi32_i32$3 >>> i64toi32_i32$4 | 0;
              } else {
                i64toi32_i32$1 = i64toi32_i32$3 >>> i64toi32_i32$4 | 0;
                $43_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$3 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;
              }
              var$5 = $43_1;
              var$5$hi = i64toi32_i32$1;
              i64toi32_i32$1 = var$0$hi;
              i64toi32_i32$1 = 0;
              $134$hi = i64toi32_i32$1;
              i64toi32_i32$1 = var$0$hi;
              i64toi32_i32$3 = var$0;
              i64toi32_i32$2 = $134$hi;
              i64toi32_i32$0 = var$3 & 63 | 0;
              i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = i64toi32_i32$3 << i64toi32_i32$4 | 0;
                $44_1 = 0;
              } else {
                i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$1 << i64toi32_i32$4 | 0) | 0;
                $44_1 = i64toi32_i32$3 << i64toi32_i32$4 | 0;
              }
              var$0 = $44_1;
              var$0$hi = i64toi32_i32$2;
              label$13: {
                if (var$2) {
                  i64toi32_i32$2 = var$1$hi;
                  i64toi32_i32$1 = var$1;
                  i64toi32_i32$3 = -1;
                  i64toi32_i32$0 = -1;
                  i64toi32_i32$4 = i64toi32_i32$1 + i64toi32_i32$0 | 0;
                  i64toi32_i32$5 = i64toi32_i32$2 + i64toi32_i32$3 | 0;
                  if (i64toi32_i32$4 >>> 0 < i64toi32_i32$0 >>> 0) {
                    i64toi32_i32$5 = i64toi32_i32$5 + 1 | 0;
                  }
                  var$8 = i64toi32_i32$4;
                  var$8$hi = i64toi32_i32$5;
                  label$15: while (1) {
                    i64toi32_i32$5 = var$5$hi;
                    i64toi32_i32$2 = var$5;
                    i64toi32_i32$1 = 0;
                    i64toi32_i32$0 = 1;
                    i64toi32_i32$3 = i64toi32_i32$0 & 31 | 0;
                    if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                      i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
                      $45_1 = 0;
                    } else {
                      i64toi32_i32$1 = ((1 << i64toi32_i32$3 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$3 | 0) | 0) | 0 | (i64toi32_i32$5 << i64toi32_i32$3 | 0) | 0;
                      $45_1 = i64toi32_i32$2 << i64toi32_i32$3 | 0;
                    }
                    $140 = $45_1;
                    $140$hi = i64toi32_i32$1;
                    i64toi32_i32$1 = var$0$hi;
                    i64toi32_i32$5 = var$0;
                    i64toi32_i32$2 = 0;
                    i64toi32_i32$0 = 63;
                    i64toi32_i32$3 = i64toi32_i32$0 & 31 | 0;
                    if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                      i64toi32_i32$2 = 0;
                      $46_1 = i64toi32_i32$1 >>> i64toi32_i32$3 | 0;
                    } else {
                      i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$3 | 0;
                      $46_1 = (((1 << i64toi32_i32$3 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$3 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$3 | 0) | 0;
                    }
                    $142$hi = i64toi32_i32$2;
                    i64toi32_i32$2 = $140$hi;
                    i64toi32_i32$1 = $140;
                    i64toi32_i32$5 = $142$hi;
                    i64toi32_i32$0 = $46_1;
                    i64toi32_i32$5 = i64toi32_i32$2 | i64toi32_i32$5 | 0;
                    var$5 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
                    var$5$hi = i64toi32_i32$5;
                    $144 = var$5;
                    $144$hi = i64toi32_i32$5;
                    i64toi32_i32$5 = var$8$hi;
                    i64toi32_i32$5 = var$5$hi;
                    i64toi32_i32$5 = var$8$hi;
                    i64toi32_i32$2 = var$8;
                    i64toi32_i32$1 = var$5$hi;
                    i64toi32_i32$0 = var$5;
                    i64toi32_i32$3 = i64toi32_i32$2 - i64toi32_i32$0 | 0;
                    i64toi32_i32$6 = i64toi32_i32$2 >>> 0 < i64toi32_i32$0 >>> 0;
                    i64toi32_i32$4 = i64toi32_i32$6 + i64toi32_i32$1 | 0;
                    i64toi32_i32$4 = i64toi32_i32$5 - i64toi32_i32$4 | 0;
                    i64toi32_i32$5 = i64toi32_i32$3;
                    i64toi32_i32$2 = 0;
                    i64toi32_i32$0 = 63;
                    i64toi32_i32$1 = i64toi32_i32$0 & 31 | 0;
                    if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                      i64toi32_i32$2 = i64toi32_i32$4 >> 31 | 0;
                      $47_1 = i64toi32_i32$4 >> i64toi32_i32$1 | 0;
                    } else {
                      i64toi32_i32$2 = i64toi32_i32$4 >> i64toi32_i32$1 | 0;
                      $47_1 = (((1 << i64toi32_i32$1 | 0) - 1 | 0) & i64toi32_i32$4 | 0) << (32 - i64toi32_i32$1 | 0) | 0 | (i64toi32_i32$5 >>> i64toi32_i32$1 | 0) | 0;
                    }
                    var$6 = $47_1;
                    var$6$hi = i64toi32_i32$2;
                    i64toi32_i32$2 = var$1$hi;
                    i64toi32_i32$2 = var$6$hi;
                    i64toi32_i32$4 = var$6;
                    i64toi32_i32$5 = var$1$hi;
                    i64toi32_i32$0 = var$1;
                    i64toi32_i32$5 = i64toi32_i32$2 & i64toi32_i32$5 | 0;
                    $151 = i64toi32_i32$4 & i64toi32_i32$0 | 0;
                    $151$hi = i64toi32_i32$5;
                    i64toi32_i32$5 = $144$hi;
                    i64toi32_i32$2 = $144;
                    i64toi32_i32$4 = $151$hi;
                    i64toi32_i32$0 = $151;
                    i64toi32_i32$1 = i64toi32_i32$2 - i64toi32_i32$0 | 0;
                    i64toi32_i32$6 = i64toi32_i32$2 >>> 0 < i64toi32_i32$0 >>> 0;
                    i64toi32_i32$3 = i64toi32_i32$6 + i64toi32_i32$4 | 0;
                    i64toi32_i32$3 = i64toi32_i32$5 - i64toi32_i32$3 | 0;
                    var$5 = i64toi32_i32$1;
                    var$5$hi = i64toi32_i32$3;
                    i64toi32_i32$3 = var$0$hi;
                    i64toi32_i32$5 = var$0;
                    i64toi32_i32$2 = 0;
                    i64toi32_i32$0 = 1;
                    i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
                    if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                      i64toi32_i32$2 = i64toi32_i32$5 << i64toi32_i32$4 | 0;
                      $48_1 = 0;
                    } else {
                      i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$4 | 0) | 0;
                      $48_1 = i64toi32_i32$5 << i64toi32_i32$4 | 0;
                    }
                    $154$hi = i64toi32_i32$2;
                    i64toi32_i32$2 = var$7$hi;
                    i64toi32_i32$2 = $154$hi;
                    i64toi32_i32$3 = $48_1;
                    i64toi32_i32$5 = var$7$hi;
                    i64toi32_i32$0 = var$7;
                    i64toi32_i32$5 = i64toi32_i32$2 | i64toi32_i32$5 | 0;
                    var$0 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
                    var$0$hi = i64toi32_i32$5;
                    i64toi32_i32$5 = var$6$hi;
                    i64toi32_i32$2 = var$6;
                    i64toi32_i32$3 = 0;
                    i64toi32_i32$0 = 1;
                    i64toi32_i32$3 = i64toi32_i32$5 & i64toi32_i32$3 | 0;
                    var$6 = i64toi32_i32$2 & i64toi32_i32$0 | 0;
                    var$6$hi = i64toi32_i32$3;
                    var$7 = var$6;
                    var$7$hi = i64toi32_i32$3;
                    var$2 = var$2 + -1 | 0;
                    if (var$2) {
                      continue label$15;
                    }
                    break label$15;
                  };
                  break label$13;
                }
              }
              i64toi32_i32$3 = var$5$hi;
              __wasm_intrinsics_temp_i64 = var$5;
              __wasm_intrinsics_temp_i64$hi = i64toi32_i32$3;
              i64toi32_i32$3 = var$0$hi;
              i64toi32_i32$5 = var$0;
              i64toi32_i32$2 = 0;
              i64toi32_i32$0 = 1;
              i64toi32_i32$4 = i64toi32_i32$0 & 31 | 0;
              if (32 >>> 0 <= (i64toi32_i32$0 & 63 | 0) >>> 0) {
                i64toi32_i32$2 = i64toi32_i32$5 << i64toi32_i32$4 | 0;
                $49_1 = 0;
              } else {
                i64toi32_i32$2 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$5 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$3 << i64toi32_i32$4 | 0) | 0;
                $49_1 = i64toi32_i32$5 << i64toi32_i32$4 | 0;
              }
              $165$hi = i64toi32_i32$2;
              i64toi32_i32$2 = var$6$hi;
              i64toi32_i32$2 = $165$hi;
              i64toi32_i32$3 = $49_1;
              i64toi32_i32$5 = var$6$hi;
              i64toi32_i32$0 = var$6;
              i64toi32_i32$5 = i64toi32_i32$2 | i64toi32_i32$5 | 0;
              i64toi32_i32$3 = i64toi32_i32$3 | i64toi32_i32$0 | 0;
              i64toi32_i32$HIGH_BITS = i64toi32_i32$5;
              return i64toi32_i32$3 | 0;
            }
            i64toi32_i32$3 = var$0$hi;
            __wasm_intrinsics_temp_i64 = var$0;
            __wasm_intrinsics_temp_i64$hi = i64toi32_i32$3;
            i64toi32_i32$3 = 0;
            var$0 = 0;
            var$0$hi = i64toi32_i32$3;
          }
          i64toi32_i32$3 = var$0$hi;
          i64toi32_i32$5 = var$0;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$3;
          return i64toi32_i32$5 | 0;
        }

        function __wasm_ctz_i32(var$0) {
          var$0 = var$0 | 0;
          if (var$0) {
            return 31 - Math_clz32((var$0 + -1 | 0) ^ var$0 | 0) | 0 | 0;
          }
          return 32 | 0;
        }

        function __wasm_i64_mul(var$0, var$0$hi, var$1, var$1$hi) {
          var$0 = var$0 | 0;
          var$0$hi = var$0$hi | 0;
          var$1 = var$1 | 0;
          var$1$hi = var$1$hi | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$1 = 0;
          i64toi32_i32$0 = var$0$hi;
          i64toi32_i32$0 = var$1$hi;
          i64toi32_i32$0 = var$0$hi;
          i64toi32_i32$1 = var$1$hi;
          i64toi32_i32$1 = _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE(var$0 | 0, i64toi32_i32$0 | 0, var$1 | 0, i64toi32_i32$1 | 0) | 0;
          i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$0;
          return i64toi32_i32$1 | 0;
        }

        function __wasm_i64_udiv(var$0, var$0$hi, var$1, var$1$hi) {
          var$0 = var$0 | 0;
          var$0$hi = var$0$hi | 0;
          var$1 = var$1 | 0;
          var$1$hi = var$1$hi | 0;
          var i64toi32_i32$0 = 0,i64toi32_i32$1 = 0;
          i64toi32_i32$0 = var$0$hi;
          i64toi32_i32$0 = var$1$hi;
          i64toi32_i32$0 = var$0$hi;
          i64toi32_i32$1 = var$1$hi;
          i64toi32_i32$1 = _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E(var$0 | 0, i64toi32_i32$0 | 0, var$1 | 0, i64toi32_i32$1 | 0) | 0;
          i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;
          i64toi32_i32$HIGH_BITS = i64toi32_i32$0;
          return i64toi32_i32$1 | 0;
        }

        function __wasm_rotl_i32(var$0, var$1) {
          var$0 = var$0 | 0;
          var$1 = var$1 | 0;
          var var$2 = 0;
          var$2 = var$1 & 31 | 0;
          var$1 = (0 - var$1 | 0) & 31 | 0;
          return ((-1 >>> var$2 | 0) & var$0 | 0) << var$2 | 0 | (((-1 << var$1 | 0) & var$0 | 0) >>> var$1 | 0) | 0 | 0;
        }

        // EMSCRIPTEN_END_FUNCS
        ;
        bufferView = HEAPU8;
        initActiveSegments(imports);
        var FUNCTION_TABLE = Table([null, $40, $41, $44, $74]);
        function __wasm_memory_size() {
          return buffer.byteLength / 65536 | 0;
        }

        function __wasm_memory_grow(pagesToAdd) {
          pagesToAdd = pagesToAdd | 0;
          var oldPages = __wasm_memory_size() | 0;
          var newPages = oldPages + pagesToAdd | 0;
          if (oldPages < newPages && newPages < 65536) {
            var newBuffer = new ArrayBuffer(Math_imul(newPages, 65536));
            var newHEAP8 = new Int8Array(newBuffer);
            newHEAP8.set(HEAP8);
            HEAP8 = new Int8Array(newBuffer);
            HEAP16 = new Int16Array(newBuffer);
            HEAP32 = new Int32Array(newBuffer);
            HEAPU8 = new Uint8Array(newBuffer);
            HEAPU16 = new Uint16Array(newBuffer);
            HEAPU32 = new Uint32Array(newBuffer);
            HEAPF32 = new Float32Array(newBuffer);
            HEAPF64 = new Float64Array(newBuffer);
            buffer = newBuffer;
            bufferView = HEAPU8;
          }
          return oldPages;
        }

        return {
          "memory": Object.create(Object.prototype, {
            "grow": {
              "value": __wasm_memory_grow
            },
            "buffer": {
              "get": function () {
                return buffer;
              }

            }
          }),
          "__wasm_call_ctors": $0,
          "crc64_init": $1,
          "crc64": $6,
          "str_to_uint64": $9,
          "uint64_to_str": $10,
          "combine_crc64": $11,
          "fflush": $112,
          "__indirect_function_table": FUNCTION_TABLE,
          "malloc": $79,
          "free": $81,
          "emscripten_stack_init": $104,
          "emscripten_stack_get_free": $105,
          "emscripten_stack_get_base": $106,
          "emscripten_stack_get_end": $107,
          "stackSave": $108,
          "stackRestore": $109,
          "stackAlloc": $110,
          "emscripten_stack_get_current": $111
        };
      }

      return asmFunc(info);
    }(

      info);
  },

  instantiate: /** @suppress{checkTypes} */function (binary, info) {
    return {
      then: function (ok) {
        var module = new WebAssembly.Module(binary);
        ok({
          'instance': new WebAssembly.Instance(module, info)
        });
        // Emulate a simple WebAssembly.instantiate(..).then(()=>{}).catch(()=>{}) syntax.
        return { catch: function () {} };
      }
    };
  },

  RuntimeError: Error
};

// We don't need to actually download a wasm binary, mark it as present but empty.
wasmBinary = [];
// end include: wasm2js.js
if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}

// include: base64Utils.js
// Converts a string of base64 into a byte array (Uint8Array).
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE != 'undefined' && ENVIRONMENT_IS_NODE) {
    var buf = Buffer.from(s, 'base64');
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
  }

  var decoded = atob(s);
  var bytes = new Uint8Array(decoded.length);
  for (var i = 0; i < decoded.length; ++i) {
    bytes[i] = decoded.charCodeAt(i);
  }
  return bytes;
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}
// end include: base64Utils.js
// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we
// don't define it at all in release modes.  This matches the behaviour of
// MINIMAL_RUNTIME.
// TODO(sbc): Make this the default even without STRICT enabled.
/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed' + (text ? ': ' + text : ''));
  }
}

// We used to include malloc/free by default in the past. Show a helpful error in
// builds with assertions.

// Memory management

var HEAP,
  /** @type {!Int8Array} */
  HEAP8,
  /** @type {!Uint8Array} */
  HEAPU8,
  /** @type {!Int16Array} */
  HEAP16,
  /** @type {!Uint16Array} */
  HEAPU16,
  /** @type {!Int32Array} */
  HEAP32,
  /** @type {!Uint32Array} */
  HEAPU32,
  /** @type {!Float32Array} */
  HEAPF32,
  /** @type {!Float64Array} */
  HEAPF64;

function updateMemoryViews() {
  var b = wasmMemory.buffer;
  Module['HEAP8'] = HEAP8 = new Int8Array(b);
  Module['HEAP16'] = HEAP16 = new Int16Array(b);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
  Module['HEAP32'] = HEAP32 = new Int32Array(b);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
}

assert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time');

assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,
'JS engine does not provide full typed array support');

// If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
assert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');
assert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');

// include: runtime_stack_check.js
// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  var max = _emscripten_stack_get_end();
  assert((max & 3) == 0);
  // If the stack ends at address zero we write our cookies 4 bytes into the
  // stack.  This prevents interference with SAFE_HEAP and ASAN which also
  // monitor writes to address zero.
  if (max == 0) {
    max += 4;
  }
  // The stack grow downwards towards _emscripten_stack_get_end.
  // We write cookies to the final two words in the stack and detect if they are
  // ever overwritten.
  HEAPU32[max >> 2] = 0x02135467;
  HEAPU32[max + 4 >> 2] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  HEAPU32[0 >> 2] = 1668509029;
}

function checkStackCookie() {
  if (ABORT) return;
  var max = _emscripten_stack_get_end();
  // See writeStackCookie().
  if (max == 0) {
    max += 4;
  }
  var cookie1 = HEAPU32[max >> 2];
  var cookie2 = HEAPU32[max + 4 >> 2];
  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {
    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
  }
  // Also test the global address 0 for integrity.
  if (HEAPU32[0 >> 2] != 0x63736d65 /* 'emsc' */) {
    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
  }
}
// end include: runtime_stack_check.js
// include: runtime_assertions.js
// Endianness check
(function () {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';
})();

// end include: runtime_assertions.js
var __ATPRERUN__ = []; // functions called before the runtime is initialized
var __ATINIT__ = []; // functions called during startup
var __ATEXIT__ = (/* unused pure expression or super */ null && ([])); // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;

function preRun() {
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  assert(!runtimeInitialized);
  runtimeInitialized = true;

  checkStackCookie();


  callRuntimeCallbacks(__ATINIT__);
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
}

function addRunDependency(id) {var _Module$monitorRunDep;
  runDependencies++;

  (_Module$monitorRunDep = Module['monitorRunDependencies']) === null || _Module$monitorRunDep === void 0 || _Module$monitorRunDep.call(Module, runDependencies);

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(() => {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err(`dependency: ${dep}`);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {var _Module$monitorRunDep2;
  runDependencies--;

  (_Module$monitorRunDep2 = Module['monitorRunDependencies']) === null || _Module$monitorRunDep2 === void 0 || _Module$monitorRunDep2.call(Module, runDependencies);

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {var _Module$onAbort;
  (_Module$onAbort = Module['onAbort']) === null || _Module$onAbort === void 0 || _Module$onAbort.call(Module, what);

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // defintion for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// include: memoryprofiler.js
// end include: memoryprofiler.js
// show errors on likely calls to FS when it was not included
var FS = {
  error() {
    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');
  },
  init() {FS.error();},
  createDataFile() {FS.error();},
  createPreloadedFile() {FS.error();},
  createLazyFile() {FS.error();},
  open() {FS.error();},
  mkdev() {FS.error();},
  registerDevice() {FS.error();},
  analyzePath() {FS.error();},

  ErrnoError() {FS.error();}
};
Module['FS_createDataFile'] = FS.createDataFile;
Module['FS_createPreloadedFile'] = FS.createPreloadedFile;

// include: URIUtils.js
// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

/**
 * Indicates whether filename is a base64 data URI.
 * @noinline
 */
var isDataURI = (filename) => filename.startsWith(dataURIPrefix);

/**
 * Indicates whether filename is delivered via file protocol (as opposed to http/https)
 * @noinline
 */
var isFileURI = (filename) => filename.startsWith('file://');
// end include: URIUtils.js
function createExportWrapper(name) {
  return (...args) => {
    assert(runtimeInitialized, `native function \`${name}\` called before runtime initialization`);
    var f = wasmExports[name];
    assert(f, `exported native function \`${name}\` not found`);
    return f(...args);
  };
}

// include: runtime_exceptions.js
// end include: runtime_exceptions.js
var wasmBinaryFile;
wasmBinaryFile = 'crc.wasm';
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinarySync(file) {
  if (file == wasmBinaryFile && wasmBinary) {
    return new Uint8Array(wasmBinary);
  }
  var binary = tryParseAsDataURI(file);
  if (binary) {
    return binary;
  }
  if (readBinary) {
    return readBinary(file);
  }
  throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
}

function getBinaryPromise(binaryFile) {
  // If we don't have the binary yet, try to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary &&
  !isDataURI(binaryFile) && (
  ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function' &&
    !isFileURI(binaryFile))
    {
      return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {
        if (!response['ok']) {
          throw `failed to load wasm binary file at '${binaryFile}'`;
        }
        return response['arrayBuffer']();
      }).catch(() => getBinarySync(binaryFile));
    } else
    if (readAsync) {
      // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array( /** @type{!ArrayBuffer} */response)), reject);
      });
    }
  }

  // Otherwise, getBinarySync should be able to get it synchronously
  return Promise.resolve().then(() => getBinarySync(binaryFile));
}

function instantiateSync(file, info) {
  var module;
  var binary = getBinarySync(file);
  module = new WebAssembly.Module(binary);
  var instance = new WebAssembly.Instance(module, info);
  return [instance, module];
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': wasmImports,
    'wasi_snapshot_preview1': wasmImports
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    wasmExports = instance.exports;



    wasmMemory = wasmExports['memory'];

    assert(wasmMemory, 'memory not found in wasm exports');
    // This assertion doesn't hold when emscripten is run in --post-link
    // mode.
    // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.
    //assert(wasmMemory.buffer.byteLength === 16777216);
    updateMemoryViews();

    addOnInit(wasmExports['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');
    return wasmExports;
  }
  // wait for the pthread pool (if any)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to
  // run the instantiation parallel to any other async startup actions they are
  // performing.
  // Also pthreads and wasm workers initialize the wasm instance through this
  // path.
  if (Module['instantiateWasm']) {

    try {
      return Module['instantiateWasm'](info, receiveInstance);
    } catch (e) {
      err(`Module.instantiateWasm callback failed with error: ${e}`);
      return false;
    }
  }

  var result = instantiateSync(wasmBinaryFile, info);
  // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193,
  // the above line no longer optimizes out down to the following line.
  // When the regression is fixed, we can remove this if/else.
  return receiveInstance(result[0]);
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// include: runtime_debug.js
function legacyModuleProp(prop, newName, incomming = true) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      get() {
        let extra = incomming ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)' : '';
        abort(`\`Module.${prop}\` has been replaced by \`${newName}\`` + extra);

      }
    });
  }
}

function ignoredModuleProp(prop) {
  if (Object.getOwnPropertyDescriptor(Module, prop)) {
    abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
  }
}

// forcing the filesystem exports a few things by default
function isExportedByForceFilesystem(name) {
  return name === 'FS_createPath' ||
  name === 'FS_createDataFile' ||
  name === 'FS_createPreloadedFile' ||
  name === 'FS_unlink' ||
  name === 'addRunDependency' ||
  // The old FS has some functionality that WasmFS lacks.
  name === 'FS_createLazyFile' ||
  name === 'FS_createDevice' ||
  name === 'removeRunDependency';
}

function missingGlobal(sym, msg) {
  if (typeof globalThis !== 'undefined') {
    Object.defineProperty(globalThis, sym, {
      configurable: true,
      get() {
        warnOnce(`\`${sym}\` is not longer defined by emscripten. ${msg}`);
        return undefined;
      }
    });
  }
}

missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');
missingGlobal('asm', 'Please use wasmExports instead');

function missingLibrarySymbol(sym) {
  if (typeof globalThis !== 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
    Object.defineProperty(globalThis, sym, {
      configurable: true,
      get() {
        // Can't `abort()` here because it would break code that does runtime
        // checks.  e.g. `if (typeof SDL === 'undefined')`.
        var msg = `\`${sym}\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;
        // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in
        // library.js, which means $name for a JS name with no prefix, or name
        // for a JS name like _name.
        var librarySymbol = sym;
        if (!librarySymbol.startsWith('_')) {
          librarySymbol = '$' + sym;
        }
        msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;
        if (isExportedByForceFilesystem(sym)) {
          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
        }
        warnOnce(msg);
        return undefined;
      }
    });
  }
  // Any symbol that is not included from the JS libary is also (by definition)
  // not exported on the Module object.
  unexportedRuntimeSymbol(sym);
}

function unexportedRuntimeSymbol(sym) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Object.defineProperty(Module, sym, {
      configurable: true,
      get() {
        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;
        if (isExportedByForceFilesystem(sym)) {
          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
        }
        abort(msg);
      }
    });
  }
}

// Used by XXXXX_DEBUG settings to output debug messages.
function dbg(...args) {
  // TODO(sbc): Make this configurable somehow.  Its not always convenient for
  // logging to show up as warnings.
  console.warn(...args);
}
// end include: runtime_debug.js
// === Body ===

// end include: preamble.js

/** @constructor */
function ExitStatus(status) {
  this.name = 'ExitStatus';
  this.message = `Program terminated with exit(${status})`;
  this.status = status;
}

var callRuntimeCallbacks = (callbacks) => {
  while (callbacks.length > 0) {
    // Pass the module as the first argument.
    callbacks.shift()(Module);
  }
};


/**
 * @param {number} ptr
 * @param {string} type
 */
function getValue(ptr, type = 'i8') {
  if (type.endsWith('*')) type = '*';
  switch (type) {
    case 'i1':return HEAP8[ptr];
    case 'i8':return HEAP8[ptr];
    case 'i16':return HEAP16[ptr >> 1];
    case 'i32':return HEAP32[ptr >> 2];
    case 'i64':abort('to do getValue(i64) use WASM_BIGINT');
    case 'float':return HEAPF32[ptr >> 2];
    case 'double':return HEAPF64[ptr >> 3];
    case '*':return HEAPU32[ptr >> 2];
    default:abort(`invalid type for getValue: ${type}`);
  }
}

var noExitRuntime = Module['noExitRuntime'] || true;

var ptrToString = (ptr) => {
  assert(typeof ptr === 'number');
  // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
  ptr >>>= 0;
  return '0x' + ptr.toString(16).padStart(8, '0');
};


/**
 * @param {number} ptr
 * @param {number} value
 * @param {string} type
 */
function setValue(ptr, value, type = 'i8') {
  if (type.endsWith('*')) type = '*';
  switch (type) {
    case 'i1':HEAP8[ptr] = value;break;
    case 'i8':HEAP8[ptr] = value;break;
    case 'i16':HEAP16[ptr >> 1] = value;break;
    case 'i32':HEAP32[ptr >> 2] = value;break;
    case 'i64':abort('to do setValue(i64) use WASM_BIGINT');
    case 'float':HEAPF32[ptr >> 2] = value;break;
    case 'double':HEAPF64[ptr >> 3] = value;break;
    case '*':HEAPU32[ptr >> 2] = value;break;
    default:abort(`invalid type for setValue: ${type}`);
  }
}

var warnOnce = (text) => {
  warnOnce.shown || (warnOnce.shown = {});
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;
    err(text);
  }
};

var _emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);

var getHeapMax = () =>
// Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
// full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
// for any code that deals with heap sizes, which would require special
// casing all heap size related code to treat 0 specially.
2147483648;

var growMemory = (size) => {
  var b = wasmMemory.buffer;
  var pages = (size - b.byteLength + 65535) / 65536;
  try {
    // round size grow request up to wasm page size (fixed 64KB per spec)
    wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size
    updateMemoryViews();
    return 1 /*success*/;
  } catch (e) {
    err(`growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
  }
  // implicit 0 return to save code size (caller will cast "undefined" into 0
  // anyhow)
};
var _emscripten_resize_heap = (requestedSize) => {
  var oldSize = HEAPU8.length;
  // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
  requestedSize >>>= 0;
  // With multithreaded builds, races can happen (another thread might increase the size
  // in between), so return a failure, and let the caller retry.
  assert(requestedSize > oldSize);

  // Memory resize rules:
  // 1.  Always increase heap size to at least the requested size, rounded up
  //     to next page multiple.
  // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
  //     geometrically: increase the heap size according to
  //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
  //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
  // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
  //     linearly: increase the heap size by at least
  //     MEMORY_GROWTH_LINEAR_STEP bytes.
  // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
  //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
  // 4.  If we were unable to allocate as much memory, it may be due to
  //     over-eager decision to excessively reserve due to (3) above.
  //     Hence if an allocation fails, cut down on the amount of excess
  //     growth, in an attempt to succeed to perform a smaller allocation.

  // A limit is set for how much we can grow. We should not exceed that
  // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
  var maxHeapSize = getHeapMax();
  if (requestedSize > maxHeapSize) {
    err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
    return false;
  }

  var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;

  // Loop through potential heap size increases. If we attempt a too eager
  // reservation that fails, cut down on the attempted size and reserve a
  // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
    var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
    // but limit overreserving (default to capping at +96MB overgrowth at most)
    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);

    var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));

    var replacement = growMemory(newSize);
    if (replacement) {
      err('Warning: Enlarging memory arrays, this is not fast! ' + [oldSize, newSize]);

      return true;
    }
  }
  err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
  return false;
};

var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
  assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);
  // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
  // undefined and false each don't write out any bytes.
  if (!(maxBytesToWrite > 0))
  return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
    // unit, not a Unicode code point of the character! So decode
    // UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
    // and https://www.ietf.org/rfc/rfc2279.txt
    // and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | u >> 6;
      heap[outIdx++] = 0x80 | u & 63;
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | u >> 12;
      heap[outIdx++] = 0x80 | u >> 6 & 63;
      heap[outIdx++] = 0x80 | u & 63;
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
      heap[outIdx++] = 0xF0 | u >> 18;
      heap[outIdx++] = 0x80 | u >> 12 & 63;
      heap[outIdx++] = 0x80 | u >> 6 & 63;
      heap[outIdx++] = 0x80 | u & 63;
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
};
var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
};

var writeArrayToMemory = (array, buffer) => {
  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');
  HEAP8.set(array, buffer);
};

var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
 * array that contains uint8 values, returns a copy of that string as a
 * Javascript String object.
 * heapOrArray is either a regular array, or a JavaScript typed array view.
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on
  // null terminator by itself.  Also, use the length info to avoid running tiny
  // strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation,
  // so that undefined means Infinity)
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  }
  var str = '';
  // If building with TextDecoder, we have already computed the string length
  // above, so test loop end condition against that
  while (idx < endPtr) {
    // For UTF8 byte structure, see:
    // http://en.wikipedia.org/wiki/UTF-8#Description
    // https://www.ietf.org/rfc/rfc2279.txt
    // https://tools.ietf.org/html/rfc3629
    var u0 = heapOrArray[idx++];
    if (!(u0 & 0x80)) {str += String.fromCharCode(u0);continue;}
    var u1 = heapOrArray[idx++] & 63;
    if ((u0 & 0xE0) == 0xC0) {str += String.fromCharCode((u0 & 31) << 6 | u1);continue;}
    var u2 = heapOrArray[idx++] & 63;
    if ((u0 & 0xF0) == 0xE0) {
      u0 = (u0 & 15) << 12 | u1 << 6 | u2;
    } else {
      if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
      u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
    }

    if (u0 < 0x10000) {
      str += String.fromCharCode(u0);
    } else {
      var ch = u0 - 0x10000;
      str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);
    }
  }
  return str;
};

/**
 * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
 * emscripten HEAP, returns a copy of that string as a Javascript String object.
 *
 * @param {number} ptr
 * @param {number=} maxBytesToRead - An optional length that specifies the
 *   maximum number of bytes to read. You can omit this parameter to scan the
 *   string until the first 0 byte. If maxBytesToRead is passed, and the string
 *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
 *   string will cut short at that byte index (i.e. maxBytesToRead will not
 *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
 *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
 *   JS JIT optimizations off, so it is worth to consider consistently using one
 * @return {string}
 */
var UTF8ToString = (ptr, maxBytesToRead) => {
  assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
};
function checkIncomingModuleAPI() {
  ignoredModuleProp('fetchSettings');
}
var wasmImports = {
  /** @export */
  emscripten_memcpy_js: _emscripten_memcpy_js,
  /** @export */
  emscripten_resize_heap: _emscripten_resize_heap
};
var wasmExports = createWasm();
var ___wasm_call_ctors = createExportWrapper('__wasm_call_ctors');
var _crc64_init = Module['_crc64_init'] = createExportWrapper('crc64_init');
var _crc64 = Module['_crc64'] = createExportWrapper('crc64');
var _str_to_uint64 = Module['_str_to_uint64'] = createExportWrapper('str_to_uint64');
var _uint64_to_str = Module['_uint64_to_str'] = createExportWrapper('uint64_to_str');
var _combine_crc64 = Module['_combine_crc64'] = createExportWrapper('combine_crc64');
var _fflush = createExportWrapper('fflush');
var _malloc = Module['_malloc'] = createExportWrapper('malloc');
var _free = Module['_free'] = createExportWrapper('free');
var _emscripten_stack_init = wasmExports['emscripten_stack_init'];
var _emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'];
var _emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'];
var _emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'];
var stackSave = createExportWrapper('stackSave');
var stackRestore = createExportWrapper('stackRestore');
var stackAlloc = createExportWrapper('stackAlloc');
var _emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'];


// include: postamble.js
// === Auto-generated postamble setup entry stuff ===

Module['UTF8ToString'] = UTF8ToString;
Module['stringToUTF8'] = stringToUTF8;
Module['writeArrayToMemory'] = writeArrayToMemory;
var missingLibrarySymbols = [
'writeI53ToI64',
'writeI53ToI64Clamped',
'writeI53ToI64Signaling',
'writeI53ToU64Clamped',
'writeI53ToU64Signaling',
'readI53FromI64',
'readI53FromU64',
'convertI32PairToI53',
'convertI32PairToI53Checked',
'convertU32PairToI53',
'zeroMemory',
'exitJS',
'isLeapYear',
'ydayFromDate',
'arraySum',
'addDays',
'inetPton4',
'inetNtop4',
'inetPton6',
'inetNtop6',
'readSockaddr',
'writeSockaddr',
'initRandomFill',
'randomFill',
'getCallstack',
'emscriptenLog',
'convertPCtoSourceLocation',
'readEmAsmArgs',
'jstoi_q',
'getExecutableName',
'listenOnce',
'autoResumeAudioContext',
'dynCallLegacy',
'getDynCaller',
'dynCall',
'handleException',
'keepRuntimeAlive',
'runtimeKeepalivePush',
'runtimeKeepalivePop',
'callUserCallback',
'maybeExit',
'asmjsMangle',
'asyncLoad',
'alignMemory',
'mmapAlloc',
'HandleAllocator',
'getNativeTypeSize',
'STACK_SIZE',
'STACK_ALIGN',
'POINTER_SIZE',
'ASSERTIONS',
'getCFunc',
'ccall',
'cwrap',
'uleb128Encode',
'sigToWasmTypes',
'generateFuncType',
'convertJsFunctionToWasm',
'getEmptyTableSlot',
'updateTableMap',
'getFunctionAddress',
'addFunction',
'removeFunction',
'reallyNegative',
'unSign',
'strLen',
'reSign',
'formatString',
'lengthBytesUTF8',
'intArrayFromString',
'intArrayToString',
'AsciiToString',
'stringToAscii',
'UTF16ToString',
'stringToUTF16',
'lengthBytesUTF16',
'UTF32ToString',
'stringToUTF32',
'lengthBytesUTF32',
'stringToNewUTF8',
'stringToUTF8OnStack',
'registerKeyEventCallback',
'maybeCStringToJsString',
'findEventTarget',
'getBoundingClientRect',
'fillMouseEventData',
'registerMouseEventCallback',
'registerWheelEventCallback',
'registerUiEventCallback',
'registerFocusEventCallback',
'fillDeviceOrientationEventData',
'registerDeviceOrientationEventCallback',
'fillDeviceMotionEventData',
'registerDeviceMotionEventCallback',
'screenOrientation',
'fillOrientationChangeEventData',
'registerOrientationChangeEventCallback',
'fillFullscreenChangeEventData',
'registerFullscreenChangeEventCallback',
'JSEvents_requestFullscreen',
'JSEvents_resizeCanvasForFullscreen',
'registerRestoreOldStyle',
'hideEverythingExceptGivenElement',
'restoreHiddenElements',
'setLetterbox',
'softFullscreenResizeWebGLRenderTarget',
'doRequestFullscreen',
'fillPointerlockChangeEventData',
'registerPointerlockChangeEventCallback',
'registerPointerlockErrorEventCallback',
'requestPointerLock',
'fillVisibilityChangeEventData',
'registerVisibilityChangeEventCallback',
'registerTouchEventCallback',
'fillGamepadEventData',
'registerGamepadEventCallback',
'registerBeforeUnloadEventCallback',
'fillBatteryEventData',
'battery',
'registerBatteryEventCallback',
'setCanvasElementSize',
'getCanvasElementSize',
'jsStackTrace',
'stackTrace',
'getEnvStrings',
'checkWasiClock',
'flush_NO_FILESYSTEM',
'wasiRightsToMuslOFlags',
'wasiOFlagsToMuslOFlags',
'createDyncallWrapper',
'safeSetTimeout',
'setImmediateWrapped',
'clearImmediateWrapped',
'polyfillSetImmediate',
'getPromise',
'makePromise',
'idsToPromises',
'makePromiseCallback',
'ExceptionInfo',
'findMatchingCatch',
'Browser_asyncPrepareDataCounter',
'setMainLoop',
'getSocketFromFD',
'getSocketAddress',
'FS_createPreloadedFile',
'FS_modeStringToFlags',
'FS_getMode',
'FS_stdin_getChar',
'FS_createDataFile',
'FS_unlink',
'FS_mkdirTree',
'_setNetworkCallback',
'heapObjectForWebGLType',
'toTypedArrayIndex',
'webgl_enable_ANGLE_instanced_arrays',
'webgl_enable_OES_vertex_array_object',
'webgl_enable_WEBGL_draw_buffers',
'webgl_enable_WEBGL_multi_draw',
'emscriptenWebGLGet',
'computeUnpackAlignedImageSize',
'colorChannelsInGlTextureFormat',
'emscriptenWebGLGetTexPixelData',
'emscriptenWebGLGetUniform',
'webglGetUniformLocation',
'webglPrepareUniformLocationsBeforeFirstUse',
'webglGetLeftBracePos',
'emscriptenWebGLGetVertexAttrib',
'__glGetActiveAttribOrUniform',
'writeGLArray',
'registerWebGlEventCallback',
'runAndAbortIfError',
'SDL_unicode',
'SDL_ttfContext',
'SDL_audio',
'ALLOC_NORMAL',
'ALLOC_STACK',
'allocate',
'writeStringToMemory',
'writeAsciiToMemory',
'setErrNo',
'demangle'];

missingLibrarySymbols.forEach(missingLibrarySymbol);

var unexportedSymbols = [
'run',
'addOnPreRun',
'addOnInit',
'addOnPreMain',
'addOnExit',
'addOnPostRun',
'addRunDependency',
'removeRunDependency',
'FS_createFolder',
'FS_createPath',
'FS_createLazyFile',
'FS_createLink',
'FS_createDevice',
'FS_readFile',
'out',
'err',
'callMain',
'abort',
'wasmMemory',
'wasmExports',
'stackAlloc',
'stackSave',
'stackRestore',
'getTempRet0',
'setTempRet0',
'writeStackCookie',
'checkStackCookie',
'intArrayFromBase64',
'tryParseAsDataURI',
'ptrToString',
'getHeapMax',
'growMemory',
'ENV',
'MONTH_DAYS_REGULAR',
'MONTH_DAYS_LEAP',
'MONTH_DAYS_REGULAR_CUMULATIVE',
'MONTH_DAYS_LEAP_CUMULATIVE',
'ERRNO_CODES',
'ERRNO_MESSAGES',
'DNS',
'Protocols',
'Sockets',
'timers',
'warnOnce',
'UNWIND_CACHE',
'readEmAsmArgsArray',
'jstoi_s',
'wasmTable',
'noExitRuntime',
'freeTableIndexes',
'functionsInTableMap',
'setValue',
'getValue',
'PATH',
'PATH_FS',
'UTF8Decoder',
'UTF8ArrayToString',
'stringToUTF8Array',
'UTF16Decoder',
'JSEvents',
'specialHTMLTargets',
'findCanvasEventTarget',
'currentFullscreenStrategy',
'restoreOldWindowedStyle',
'ExitStatus',
'promiseMap',
'uncaughtExceptionCount',
'exceptionLast',
'exceptionCaught',
'Browser',
'getPreloadedImageData__data',
'wget',
'SYSCALLS',
'preloadPlugins',
'FS_stdin_getChar_buffer',
'FS',
'MEMFS',
'TTY',
'PIPEFS',
'SOCKFS',
'tempFixedLengthArray',
'miniTempWebGLFloatBuffers',
'miniTempWebGLIntBuffers',
'GL',
'AL',
'GLUT',
'EGL',
'GLEW',
'IDBStore',
'SDL',
'SDL_gfx',
'allocateUTF8',
'allocateUTF8OnStack'];

unexportedSymbols.forEach(unexportedRuntimeSymbol);



var calledRun;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  _emscripten_stack_init();
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  writeStackCookie();
}

function run() {

  if (runDependencies > 0) {
    return;
  }

  stackCheckInit();

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function () {
      setTimeout(function () {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  };
  try {// it doesn't matter if it fails
    _fflush(0);
  } catch (e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');
    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');
  }
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

run();


// end include: postamble.js


/***/ }),

/***/ 4294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(4219);


/***/ }),

/***/ 4219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(1808);
var tls = __nccwpck_require__(4404);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var events = __nccwpck_require__(2361);
var assert = __nccwpck_require__(9491);
var util = __nccwpck_require__(3837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 2155:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var v1 = __nccwpck_require__(8749);
var v4 = __nccwpck_require__(824);

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ 2707:
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ 5859:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.

var crypto = __nccwpck_require__(6113);

module.exports = function nodeRNG() {
  return crypto.randomBytes(16);
};


/***/ }),

/***/ 8749:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var rng = __nccwpck_require__(5859);
var bytesToUuid = __nccwpck_require__(2707);

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ 824:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var rng = __nccwpck_require__(5859);
var bytesToUuid = __nccwpck_require__(2707);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ 4810:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// https://github.com/actions/toolkit/blob/main/packages/cache/src/cache.ts
// 6c4e082c181a51609197e536ef5255a0c9baeef7
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.saveCache = exports.restoreCache = exports.isFeatureAvailable = exports.ReserveCacheError = exports.ValidationError = void 0;
const core = __importStar(__nccwpck_require__(2186));
const path = __importStar(__nccwpck_require__(1017));
const utils = __importStar(__nccwpck_require__(4875));
const cacheHttpClient = __importStar(__nccwpck_require__(966));
const tar_1 = __nccwpck_require__(148);
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ValidationError';
        Object.setPrototypeOf(this, ValidationError.prototype);
    }
}
exports.ValidationError = ValidationError;
class ReserveCacheError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ReserveCacheError';
        Object.setPrototypeOf(this, ReserveCacheError.prototype);
    }
}
exports.ReserveCacheError = ReserveCacheError;
function checkPaths(paths) {
    if (!paths || paths.length === 0) {
        throw new ValidationError(`Path Validation Error: At least one directory or file path is required`);
    }
}
function checkKey(key) {
    if (key.length > 512) {
        throw new ValidationError(`Key Validation Error: ${key} cannot be larger than 512 characters.`);
    }
    const regex = /^[^,]*$/;
    if (!regex.test(key)) {
        throw new ValidationError(`Key Validation Error: ${key} cannot contain commas.`);
    }
}
/**
 * isFeatureAvailable to check the presence of Actions cache service
 *
 * @returns boolean return true if Actions cache service feature is available, otherwise false
 */
function isFeatureAvailable() {
    return !!process.env['ACTIONS_CACHE_URL'];
}
exports.isFeatureAvailable = isFeatureAvailable;
/**
 * Restores cache from keys
 *
 * @param paths a list of file paths to restore from the cache
 * @param primaryKey an explicit key for restoring the cache
 * @param restoreKeys an optional ordered list of keys to use for restoring the cache if no cache hit occurred for key
 * @param downloadOptions cache download options
 * @param enableCrossOsArchive an optional boolean enabled to restore on windows any cache created on any platform
 * @returns string returns the key for the cache hit, otherwise returns undefined
 */
function restoreCache(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
    return __awaiter(this, void 0, void 0, function* () {
        checkPaths(paths);
        restoreKeys = restoreKeys || [];
        const keys = [primaryKey, ...restoreKeys];
        core.debug('Resolved Keys:');
        core.debug(JSON.stringify(keys));
        if (keys.length > 10) {
            throw new ValidationError(`Key Validation Error: Keys are limited to a maximum of 10.`);
        }
        for (const key of keys) {
            checkKey(key);
        }
        const compressionMethod = yield utils.getCompressionMethod();
        let archivePath = '';
        try {
            // path are needed to compute version
            const cacheEntry = yield cacheHttpClient.getCacheEntry(keys, paths, {
                compressionMethod,
                enableCrossOsArchive
            });
            if (!(cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.objectKey)) {
                // Cache not found
                return undefined;
            }
            if (options === null || options === void 0 ? void 0 : options.lookupOnly) {
                core.info('Lookup only - skipping download');
                return cacheEntry.cacheKey;
            }
            archivePath = path.join(yield utils.createTempDirectory(), utils.getCacheFileName(compressionMethod));
            core.debug(`Archive Path: ${archivePath}`);
            // Download the cache from the cache entry
            yield cacheHttpClient.downloadCache(cacheEntry.objectKey, archivePath, options);
            if (core.isDebug()) {
                yield (0, tar_1.listTar)(archivePath, compressionMethod);
            }
            const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
            core.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
            yield (0, tar_1.extractTar)(archivePath, compressionMethod);
            core.info('Cache restored successfully');
            return cacheEntry.cacheKey;
        }
        catch (error) {
            const typedError = error;
            if (typedError.name === ValidationError.name) {
                throw error;
            }
            else {
                // Supress all non-validation cache related errors because caching should be optional
                core.warning(`Failed to restore: ${error.message}`);
            }
        }
        finally {
            // Try to delete the archive to save space
            try {
                yield utils.unlinkFile(archivePath);
            }
            catch (error) {
                core.debug(`Failed to delete archive: ${error}`);
            }
        }
        return undefined;
    });
}
exports.restoreCache = restoreCache;
/**
 * Saves a list of files with the specified key
 *
 * @param paths a list of file paths to be cached
 * @param key an explicit key for restoring the cache
 * @param enableCrossOsArchive an optional boolean enabled to save cache on windows which could be restored on any platform
 * @param options cache upload options
 * @returns number returns cacheId if the cache was saved successfully and throws an error if save fails
 */
function saveCache(paths, key, options, enableCrossOsArchive = false) {
    return __awaiter(this, void 0, void 0, function* () {
        checkPaths(paths);
        checkKey(key);
        const compressionMethod = yield utils.getCompressionMethod();
        let cacheId = key;
        const cachePaths = yield utils.resolvePaths(paths);
        core.debug('Cache Paths:');
        core.debug(`${JSON.stringify(cachePaths)}`);
        if (cachePaths.length === 0) {
            throw new Error(`Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.`);
        }
        const archiveFolder = yield utils.createTempDirectory();
        const archivePath = path.join(archiveFolder, utils.getCacheFileName(compressionMethod));
        core.debug(`Archive Path: ${archivePath}`);
        try {
            yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
            if (core.isDebug()) {
                yield (0, tar_1.listTar)(archivePath, compressionMethod);
            }
            const fileSizeLimit = 10 * 1024 * 1024 * 1024; // 10GB per repo limit
            const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
            core.debug(`File Size: ${archiveFileSize}`);
            // For GHES, this check will take place in ReserveCache API with enterprise file size limit
            if (archiveFileSize > fileSizeLimit && !utils.isGhes()) {
                throw new Error(`Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the 10GB limit, not saving cache.`);
            }
            core.debug(`Saving Cache (ID: ${cacheId})`);
            yield cacheHttpClient.saveCache(cacheId, archivePath, options);
        }
        catch (error) {
            const typedError = error;
            if (typedError.name === ValidationError.name) {
                throw error;
            }
            else if (typedError.name === ReserveCacheError.name) {
                core.info(`Failed to save: ${typedError.message}`);
            }
            else {
                core.warning(`Failed to save: ${typedError.message}`);
            }
        }
        finally {
            // Try to delete the archive to save space
            try {
                yield utils.unlinkFile(archivePath);
            }
            catch (error) {
                core.debug(`Failed to delete archive: ${error}`);
            }
        }
        return cacheId;
    });
}
exports.saveCache = saveCache;


/***/ }),

/***/ 9042:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RefKey = exports.Events = exports.State = exports.Outputs = exports.Inputs = void 0;
var Inputs;
(function (Inputs) {
    Inputs["Key"] = "key";
    Inputs["Path"] = "path";
    Inputs["RestoreKeys"] = "restore-keys";
    Inputs["UploadChunkSize"] = "upload-chunk-size";
    Inputs["EnableCrossOsArchive"] = "enableCrossOsArchive";
    Inputs["FailOnCacheMiss"] = "fail-on-cache-miss";
    Inputs["LookupOnly"] = "lookup-only"; // Input for cache, restore action
})(Inputs = exports.Inputs || (exports.Inputs = {}));
var Outputs;
(function (Outputs) {
    Outputs["CacheHit"] = "cache-hit";
    Outputs["CachePrimaryKey"] = "cache-primary-key";
    Outputs["CacheMatchedKey"] = "cache-matched-key"; // Output from restore action
})(Outputs = exports.Outputs || (exports.Outputs = {}));
var State;
(function (State) {
    State["CachePrimaryKey"] = "CACHE_KEY";
    State["CacheMatchedKey"] = "CACHE_RESULT";
})(State = exports.State || (exports.State = {}));
var Events;
(function (Events) {
    Events["Key"] = "GITHUB_EVENT_NAME";
    Events["Push"] = "push";
    Events["PullRequest"] = "pull_request";
})(Events = exports.Events || (exports.Events = {}));
exports.RefKey = "GITHUB_REF";


/***/ }),

/***/ 4875:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// https://github.com/actions/toolkit/blob/main/packages/cache/src/cache.ts
// 6c4e082c181a51609197e536ef5255a0c9baeef7
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isGhes = exports.assertDefined = exports.getGnuTarPathOnWindows = exports.getCacheFileName = exports.getCompressionMethod = exports.unlinkFile = exports.resolvePaths = exports.getArchiveFileSizeInBytes = exports.createTempDirectory = void 0;
const core = __importStar(__nccwpck_require__(2186));
const exec = __importStar(__nccwpck_require__(1514));
const glob = __importStar(__nccwpck_require__(8090));
const io = __importStar(__nccwpck_require__(7436));
const fs = __importStar(__nccwpck_require__(7147));
const path = __importStar(__nccwpck_require__(1017));
const semver = __importStar(__nccwpck_require__(5911));
const util = __importStar(__nccwpck_require__(3837));
const uuid_1 = __nccwpck_require__(2155);
const constants_1 = __nccwpck_require__(9801);
// From https://github.com/actions/toolkit/blob/main/packages/tool-cache/src/tool-cache.ts#L23
function createTempDirectory() {
    return __awaiter(this, void 0, void 0, function* () {
        const IS_WINDOWS = process.platform === 'win32';
        let tempDirectory = process.env['RUNNER_TEMP'] || '';
        if (!tempDirectory) {
            let baseLocation;
            if (IS_WINDOWS) {
                // On Windows use the USERPROFILE env variable
                baseLocation = process.env['USERPROFILE'] || 'C:\\';
            }
            else {
                if (process.platform === 'darwin') {
                    baseLocation = '/Users';
                }
                else {
                    baseLocation = '/home';
                }
            }
            tempDirectory = path.join(baseLocation, 'actions', 'temp');
        }
        const dest = path.join(tempDirectory, (0, uuid_1.v4)());
        yield io.mkdirP(dest);
        return dest;
    });
}
exports.createTempDirectory = createTempDirectory;
function getArchiveFileSizeInBytes(filePath) {
    return fs.statSync(filePath).size;
}
exports.getArchiveFileSizeInBytes = getArchiveFileSizeInBytes;
function resolvePaths(patterns) {
    var _a, e_1, _b, _c;
    var _d;
    return __awaiter(this, void 0, void 0, function* () {
        const paths = [];
        const workspace = (_d = process.env['GITHUB_WORKSPACE']) !== null && _d !== void 0 ? _d : process.cwd();
        const globber = yield glob.create(patterns.join('\n'), {
            implicitDescendants: false
        });
        try {
            for (var _e = true, _f = __asyncValues(globber.globGenerator()), _g; _g = yield _f.next(), _a = _g.done, !_a;) {
                _c = _g.value;
                _e = false;
                try {
                    const file = _c;
                    const relativeFile = path
                        .relative(workspace, file)
                        .replace(new RegExp(`\\${path.sep}`, 'g'), '/');
                    core.debug(`Matched: ${relativeFile}`);
                    // Paths are made relative so the tar entries are all relative to the root of the workspace.
                    if (relativeFile === '') {
                        // path.relative returns empty string if workspace and file are equal
                        paths.push('.');
                    }
                    else {
                        paths.push(`${relativeFile}`);
                    }
                }
                finally {
                    _e = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return paths;
    });
}
exports.resolvePaths = resolvePaths;
function unlinkFile(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        return util.promisify(fs.unlink)(filePath);
    });
}
exports.unlinkFile = unlinkFile;
function getVersion(app, additionalArgs = []) {
    return __awaiter(this, void 0, void 0, function* () {
        let versionOutput = '';
        additionalArgs.push('--version');
        core.debug(`Checking ${app} ${additionalArgs.join(' ')}`);
        try {
            yield exec.exec(`${app}`, additionalArgs, {
                ignoreReturnCode: true,
                silent: true,
                listeners: {
                    stdout: (data) => (versionOutput += data.toString()),
                    stderr: (data) => (versionOutput += data.toString())
                }
            });
        }
        catch (err) {
            core.debug(err.message);
        }
        versionOutput = versionOutput.trim();
        core.debug(versionOutput);
        return versionOutput;
    });
}
// Use zstandard if possible to maximize cache performance
function getCompressionMethod() {
    return __awaiter(this, void 0, void 0, function* () {
        const versionOutput = yield getVersion('zstd', ['--quiet']);
        const version = semver.clean(versionOutput);
        core.debug(`zstd version: ${version}`);
        if (versionOutput === '') {
            return constants_1.CompressionMethod.Gzip;
        }
        else {
            return constants_1.CompressionMethod.ZstdWithoutLong;
        }
    });
}
exports.getCompressionMethod = getCompressionMethod;
function getCacheFileName(compressionMethod) {
    return compressionMethod === constants_1.CompressionMethod.Gzip
        ? constants_1.CacheFilename.Gzip
        : constants_1.CacheFilename.Zstd;
}
exports.getCacheFileName = getCacheFileName;
function getGnuTarPathOnWindows() {
    return __awaiter(this, void 0, void 0, function* () {
        if (fs.existsSync(constants_1.GnuTarPathOnWindows)) {
            return constants_1.GnuTarPathOnWindows;
        }
        const versionOutput = yield getVersion('tar');
        return versionOutput.toLowerCase().includes('gnu tar') ? io.which('tar') : '';
    });
}
exports.getGnuTarPathOnWindows = getGnuTarPathOnWindows;
function assertDefined(name, value) {
    if (value === undefined) {
        throw Error(`Expected ${name} but value was undefiend`);
    }
    return value;
}
exports.assertDefined = assertDefined;
function isGhes() {
    const ghUrl = new URL(process.env['GITHUB_SERVER_URL'] || 'https://github.com');
    const hostname = ghUrl.hostname.trimEnd().toUpperCase();
    const isGitHubHost = hostname === 'GITHUB.COM';
    const isGheHost = hostname.endsWith('.GHE.COM') || hostname.endsWith('.GHE.LOCALHOST');
    return !isGitHubHost && !isGheHost;
}
exports.isGhes = isGhes;


/***/ }),

/***/ 9801:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// https://github.com/actions/toolkit/blob/main/packages/cache/src/cache.ts
// 6c4e082c181a51609197e536ef5255a0c9baeef7
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ManifestFilename = exports.TarFilename = exports.SystemTarPathOnWindows = exports.GnuTarPathOnWindows = exports.SocketTimeout = exports.DefaultRetryDelay = exports.DefaultRetryAttempts = exports.ArchiveToolType = exports.CompressionMethod = exports.CacheFilename = void 0;
var CacheFilename;
(function (CacheFilename) {
    CacheFilename["Gzip"] = "cache.tgz";
    CacheFilename["Zstd"] = "cache.tzst";
})(CacheFilename = exports.CacheFilename || (exports.CacheFilename = {}));
var CompressionMethod;
(function (CompressionMethod) {
    CompressionMethod["Gzip"] = "gzip";
    // Long range mode was added to zstd in v1.3.2.
    // This enum is for earlier version of zstd that does not have --long support
    CompressionMethod["ZstdWithoutLong"] = "zstd-without-long";
    CompressionMethod["Zstd"] = "zstd";
})(CompressionMethod = exports.CompressionMethod || (exports.CompressionMethod = {}));
var ArchiveToolType;
(function (ArchiveToolType) {
    ArchiveToolType["GNU"] = "gnu";
    ArchiveToolType["BSD"] = "bsd";
})(ArchiveToolType = exports.ArchiveToolType || (exports.ArchiveToolType = {}));
// The default number of retry attempts.
exports.DefaultRetryAttempts = 2;
// The default delay in milliseconds between retry attempts.
exports.DefaultRetryDelay = 5000;
// Socket timeout in milliseconds during download.  If no traffic is received
// over the socket during this period, the socket is destroyed and the download
// is aborted.
exports.SocketTimeout = 5000;
// The default path of GNUtar on hosted Windows runners
exports.GnuTarPathOnWindows = `${process.env['PROGRAMFILES']}\\Git\\usr\\bin\\tar.exe`;
// The default path of BSDtar on hosted Windows runners
exports.SystemTarPathOnWindows = `${process.env['SYSTEMDRIVE']}\\Windows\\System32\\tar.exe`;
exports.TarFilename = 'cache.tar';
exports.ManifestFilename = 'manifest.txt';


/***/ }),

/***/ 966:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// https://github.com/actions/toolkit/blob/main/packages/cache/src/cache.ts
// 6c4e082c181a51609197e536ef5255a0c9baeef7
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.saveCache = exports.downloadCache = exports.getCacheEntry = exports.getCacheVersion = void 0;
const core = __importStar(__nccwpck_require__(2186));
const tos_sdk_1 = __nccwpck_require__(5235);
const crypto = __importStar(__nccwpck_require__(6113));
const utils = __importStar(__nccwpck_require__(4875));
const versionSalt = "1.0";
const bucket = process.env["BUCKET_NAME"];
const repo = process.env["GITHUB_REPOSITORY"];
const workflowHash = process.env["GITHUB_WORKFLOW_SHA"];
const ref = process.env["GITHUB_REF"];
function createObjectStorageClient() {
    return new tos_sdk_1.TosClient({
        accessKeyId: process.env["ACCESS_KEY"],
        accessKeySecret: process.env["SECRET_KEY"],
        region: process.env["REGION"]
    });
}
function getCacheVersion(paths, compressionMethod, enableCrossOsArchive = false) {
    // don't pass changes upstream
    const components = paths.slice();
    // Add compression method to cache version to restore
    // compressed cache as per compression method
    if (compressionMethod) {
        components.push(compressionMethod);
    }
    // Only check for windows platforms if enableCrossOsArchive is false
    if (process.platform === "win32" && !enableCrossOsArchive) {
        components.push("windows-only");
    }
    // Add salt to cache version to support breaking changes in cache entry
    components.push(versionSalt);
    return crypto
        .createHash("sha256")
        .update(components.join("|"))
        .digest("hex");
}
exports.getCacheVersion = getCacheVersion;
function getCacheEntry(keys, paths, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = createObjectStorageClient();
        const version = getCacheVersion(paths, options === null || options === void 0 ? void 0 : options.compressionMethod, options === null || options === void 0 ? void 0 : options.enableCrossOsArchive);
        for (const key of keys) {
            const objectKey = `caches/${repo}/${ref}/${workflowHash}/${key}`;
            try {
                yield client.headObject({
                    bucket: bucket,
                    key: objectKey
                });
                const entry = {
                    cacheKey: key,
                    cacheVersion: version,
                    objectKey: objectKey
                };
                return entry;
            }
            catch (error) {
                if (error instanceof tos_sdk_1.TosServerError && error.statusCode === 404) {
                    console.warn(`Unable to find cache with key ${objectKey}.`);
                }
            }
        }
        const entry = {
            cacheVersion: version
        };
        console.warn(`Failed to find cache that matches keys: ${keys}`);
        return entry;
    });
}
exports.getCacheEntry = getCacheEntry;
function downloadCache(objectKey, archivePath, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = createObjectStorageClient();
        yield client.getObjectToFile({
            bucket: bucket,
            key: objectKey,
            filePath: archivePath
        });
    });
}
exports.downloadCache = downloadCache;
function handleError(error) {
    if (error instanceof tos_sdk_1.TosClientError) {
        console.log("Client Err Msg:", error.message);
        console.log("Client Err Stack:", error.stack);
    }
    else if (error instanceof tos_sdk_1.TosServerError) {
        console.log("Request ID:", error.requestId);
        console.log("Response Status Code:", error.statusCode);
        console.log("Response Header:", error.headers);
        console.log("Response Err Code:", error.code);
        console.log("Response Err Msg:", error.message);
    }
    else {
        console.log("unexpected exception, message: ", error);
    }
}
function uploadFile(client, cacheId, archivePath, options) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const objectName = `caches/${repo}/${ref}/${workflowHash}/${cacheId}`;
            yield client.putObjectFromFile({
                bucket: bucket,
                key: objectName,
                filePath: archivePath
            });
        }
        catch (error) {
            handleError(error);
        }
    });
}
function saveCache(cacheId, archivePath, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = createObjectStorageClient();
        core.debug("Upload cache");
        yield uploadFile(client, cacheId, archivePath, options);
        // Commit Cache
        core.debug("Commiting cache");
        const cacheSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.info(`Cache Size: ~${Math.round(cacheSize / (1024 * 1024))} MB (${cacheSize} B)`);
        core.info("Cache saved successfully");
    });
}
exports.saveCache = saveCache;


/***/ }),

/***/ 148:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// https://github.com/actions/toolkit/blob/main/packages/cache/src/cache.ts
// 6c4e082c181a51609197e536ef5255a0c9baeef7
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createTar = exports.extractTar = exports.listTar = void 0;
const exec_1 = __nccwpck_require__(1514);
const io = __importStar(__nccwpck_require__(7436));
const fs_1 = __nccwpck_require__(7147);
const path = __importStar(__nccwpck_require__(1017));
const utils = __importStar(__nccwpck_require__(4875));
const constants_1 = __nccwpck_require__(9801);
const IS_WINDOWS = process.platform === 'win32';
// Returns tar path and type: BSD or GNU
function getTarPath() {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case 'win32': {
                const gnuTar = yield utils.getGnuTarPathOnWindows();
                const systemTar = constants_1.SystemTarPathOnWindows;
                if (gnuTar) {
                    // Use GNUtar as default on windows
                    return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
                }
                else if ((0, fs_1.existsSync)(systemTar)) {
                    return { path: systemTar, type: constants_1.ArchiveToolType.BSD };
                }
                break;
            }
            case 'darwin': {
                const gnuTar = yield io.which('gtar', false);
                if (gnuTar) {
                    // fix permission denied errors when extracting BSD tar archive with GNU tar - https://github.com/actions/cache/issues/527
                    return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
                }
                else {
                    return {
                        path: yield io.which('tar', true),
                        type: constants_1.ArchiveToolType.BSD
                    };
                }
            }
            default:
                break;
        }
        // Default assumption is GNU tar is present in path
        return {
            path: yield io.which('tar', true),
            type: constants_1.ArchiveToolType.GNU
        };
    });
}
// Return arguments for tar as per tarPath, compressionMethod, method type and os
function getTarArgs(tarPath, compressionMethod, type, archivePath = '') {
    return __awaiter(this, void 0, void 0, function* () {
        const args = [`"${tarPath.path}"`];
        const cacheFileName = utils.getCacheFileName(compressionMethod);
        const tarFile = 'cache.tar';
        const workingDirectory = getWorkingDirectory();
        // Speficic args for BSD tar on windows for workaround
        const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD &&
            compressionMethod !== constants_1.CompressionMethod.Gzip &&
            IS_WINDOWS;
        // Method specific args
        switch (type) {
            case 'create':
                args.push('--posix', '-cf', BSD_TAR_ZSTD
                    ? tarFile
                    : cacheFileName.replace(new RegExp(`\\${path.sep}`, 'g'), '/'), '--exclude', BSD_TAR_ZSTD
                    ? tarFile
                    : cacheFileName.replace(new RegExp(`\\${path.sep}`, 'g'), '/'), '-P', '-C', workingDirectory.replace(new RegExp(`\\${path.sep}`, 'g'), '/'), '--files-from', constants_1.ManifestFilename);
                break;
            case 'extract':
                args.push('-xf', BSD_TAR_ZSTD
                    ? tarFile
                    : archivePath.replace(new RegExp(`\\${path.sep}`, 'g'), '/'), '-P', '-C', workingDirectory.replace(new RegExp(`\\${path.sep}`, 'g'), '/'));
                break;
            case 'list':
                args.push('-tf', BSD_TAR_ZSTD
                    ? tarFile
                    : archivePath.replace(new RegExp(`\\${path.sep}`, 'g'), '/'), '-P');
                break;
        }
        // Platform specific args
        if (tarPath.type === constants_1.ArchiveToolType.GNU) {
            switch (process.platform) {
                case 'win32':
                    args.push('--force-local');
                    break;
                case 'darwin':
                    args.push('--delay-directory-restore');
                    break;
            }
        }
        return args;
    });
}
// Returns commands to run tar and compression program
function getCommands(compressionMethod, type, archivePath = '') {
    return __awaiter(this, void 0, void 0, function* () {
        let args;
        const tarPath = yield getTarPath();
        const tarArgs = yield getTarArgs(tarPath, compressionMethod, type, archivePath);
        const compressionArgs = type !== 'create'
            ? yield getDecompressionProgram(tarPath, compressionMethod, archivePath)
            : yield getCompressionProgram(tarPath, compressionMethod);
        const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD &&
            compressionMethod !== constants_1.CompressionMethod.Gzip &&
            IS_WINDOWS;
        if (BSD_TAR_ZSTD && type !== 'create') {
            args = [[...compressionArgs].join(' '), [...tarArgs].join(' ')];
        }
        else {
            args = [[...tarArgs].join(' '), [...compressionArgs].join(' ')];
        }
        if (BSD_TAR_ZSTD) {
            return args;
        }
        return [args.join(' ')];
    });
}
function getWorkingDirectory() {
    var _a;
    return (_a = process.env['GITHUB_WORKSPACE']) !== null && _a !== void 0 ? _a : process.cwd();
}
// Common function for extractTar and listTar to get the compression method
function getDecompressionProgram(tarPath, compressionMethod, archivePath) {
    return __awaiter(this, void 0, void 0, function* () {
        // -d: Decompress.
        // unzstd is equivalent to 'zstd -d'
        // --long=#: Enables long distance matching with # bits. Maximum is 30 (1GB) on 32-bit OS and 31 (2GB) on 64-bit.
        // Using 30 here because we also support 32-bit self-hosted runners.
        const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD &&
            compressionMethod !== constants_1.CompressionMethod.Gzip &&
            IS_WINDOWS;
        switch (compressionMethod) {
            case constants_1.CompressionMethod.Zstd:
                return BSD_TAR_ZSTD
                    ? [
                        'zstd -d --long=30 --force -o',
                        constants_1.TarFilename,
                        archivePath.replace(new RegExp(`\\${path.sep}`, 'g'), '/')
                    ]
                    : [
                        '--use-compress-program',
                        IS_WINDOWS ? '"zstd -d --long=30"' : 'unzstd --long=30'
                    ];
            case constants_1.CompressionMethod.ZstdWithoutLong:
                return BSD_TAR_ZSTD
                    ? [
                        'zstd -d --force -o',
                        constants_1.TarFilename,
                        archivePath.replace(new RegExp(`\\${path.sep}`, 'g'), '/')
                    ]
                    : ['--use-compress-program', IS_WINDOWS ? '"zstd -d"' : 'unzstd'];
            default:
                return ['-z'];
        }
    });
}
// Used for creating the archive
// -T#: Compress using # working thread. If # is 0, attempt to detect and use the number of physical CPU cores.
// zstdmt is equivalent to 'zstd -T0'
// --long=#: Enables long distance matching with # bits. Maximum is 30 (1GB) on 32-bit OS and 31 (2GB) on 64-bit.
// Using 30 here because we also support 32-bit self-hosted runners.
// Long range mode is added to zstd in v1.3.2 release, so we will not use --long in older version of zstd.
function getCompressionProgram(tarPath, compressionMethod) {
    return __awaiter(this, void 0, void 0, function* () {
        const cacheFileName = utils.getCacheFileName(compressionMethod);
        const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD &&
            compressionMethod !== constants_1.CompressionMethod.Gzip &&
            IS_WINDOWS;
        switch (compressionMethod) {
            case constants_1.CompressionMethod.Zstd:
                return BSD_TAR_ZSTD
                    ? [
                        'zstd -T0 --long=30 --force -o',
                        cacheFileName.replace(new RegExp(`\\${path.sep}`, 'g'), '/'),
                        constants_1.TarFilename
                    ]
                    : [
                        '--use-compress-program',
                        IS_WINDOWS ? '"zstd -T0 --long=30"' : 'zstdmt --long=30'
                    ];
            case constants_1.CompressionMethod.ZstdWithoutLong:
                return BSD_TAR_ZSTD
                    ? [
                        'zstd -T0 --force -o',
                        cacheFileName.replace(new RegExp(`\\${path.sep}`, 'g'), '/'),
                        constants_1.TarFilename
                    ]
                    : ['--use-compress-program', IS_WINDOWS ? '"zstd -T0"' : 'zstdmt'];
            default:
                return ['-z'];
        }
    });
}
// Executes all commands as separate processes
function execCommands(commands, cwd) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const command of commands) {
            try {
                yield (0, exec_1.exec)(command, undefined, {
                    cwd,
                    env: Object.assign(Object.assign({}, process.env), { MSYS: 'winsymlinks:nativestrict' })
                });
            }
            catch (error) {
                throw new Error(`${command.split(' ')[0]} failed with error: ${error === null || error === void 0 ? void 0 : error.message}`);
            }
        }
    });
}
// List the contents of a tar
function listTar(archivePath, compressionMethod) {
    return __awaiter(this, void 0, void 0, function* () {
        const commands = yield getCommands(compressionMethod, 'list', archivePath);
        yield execCommands(commands);
    });
}
exports.listTar = listTar;
// Extract a tar
function extractTar(archivePath, compressionMethod) {
    return __awaiter(this, void 0, void 0, function* () {
        // Create directory to extract tar into
        const workingDirectory = getWorkingDirectory();
        yield io.mkdirP(workingDirectory);
        const commands = yield getCommands(compressionMethod, 'extract', archivePath);
        yield execCommands(commands);
    });
}
exports.extractTar = extractTar;
// Create a tar
function createTar(archiveFolder, sourceDirectories, compressionMethod) {
    return __awaiter(this, void 0, void 0, function* () {
        // Write source directories to manifest.txt to avoid command length limits
        (0, fs_1.writeFileSync)(path.join(archiveFolder, constants_1.ManifestFilename), sourceDirectories.join('\n'));
        const commands = yield getCommands(compressionMethod, 'create');
        yield execCommands(commands, archiveFolder);
    });
}
exports.createTar = createTar;


/***/ }),

/***/ 2357:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.restoreRun = exports.restoreOnlyRun = exports.restoreImpl = void 0;
const cache = __importStar(__nccwpck_require__(4810));
const core = __importStar(__nccwpck_require__(2186));
const constants_1 = __nccwpck_require__(9042);
const stateProvider_1 = __nccwpck_require__(1527);
const utils = __importStar(__nccwpck_require__(6850));
function restoreImpl(stateProvider, earlyExit) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (!utils.isCacheFeatureAvailable()) {
                core.setOutput(constants_1.Outputs.CacheHit, "false");
                return;
            }
            // Validate inputs, this can cause task failure
            if (!utils.isValidEvent()) {
                utils.logWarning(`Event Validation Error: The event type ${process.env[constants_1.Events.Key]} is not supported because it's not tied to a branch or tag ref.`);
                return;
            }
            const primaryKey = core.getInput(constants_1.Inputs.Key, { required: true });
            stateProvider.setState(constants_1.State.CachePrimaryKey, primaryKey);
            const restoreKeys = utils.getInputAsArray(constants_1.Inputs.RestoreKeys);
            const cachePaths = utils.getInputAsArray(constants_1.Inputs.Path, {
                required: true
            });
            const enableCrossOsArchive = utils.getInputAsBool(constants_1.Inputs.EnableCrossOsArchive);
            const failOnCacheMiss = utils.getInputAsBool(constants_1.Inputs.FailOnCacheMiss);
            const lookupOnly = utils.getInputAsBool(constants_1.Inputs.LookupOnly);
            const cacheKey = yield cache.restoreCache(cachePaths, primaryKey, restoreKeys, { lookupOnly: lookupOnly }, enableCrossOsArchive);
            if (!cacheKey) {
                core.setOutput(constants_1.Outputs.CacheHit, false.toString());
                if (failOnCacheMiss) {
                    throw new Error(`Failed to restore cache entry. Exiting as fail-on-cache-miss is set. Input key: ${primaryKey}`);
                }
                core.info(`Cache not found for input keys: ${[
                    primaryKey,
                    ...restoreKeys
                ].join(", ")}`);
                return;
            }
            // Store the matched cache key in states
            stateProvider.setState(constants_1.State.CacheMatchedKey, cacheKey);
            const isExactKeyMatch = utils.isExactKeyMatch(core.getInput(constants_1.Inputs.Key, { required: true }), cacheKey);
            core.setOutput(constants_1.Outputs.CacheHit, isExactKeyMatch.toString());
            if (lookupOnly) {
                core.info(`Cache found and can be restored from key: ${cacheKey}`);
            }
            else {
                core.info(`Cache restored from key: ${cacheKey}`);
            }
            return cacheKey;
        }
        catch (error) {
            core.setFailed(error.message);
            if (earlyExit) {
                process.exit(1);
            }
        }
    });
}
exports.restoreImpl = restoreImpl;
function run(stateProvider, earlyExit) {
    return __awaiter(this, void 0, void 0, function* () {
        yield restoreImpl(stateProvider, earlyExit);
        // node will stay alive if any promises are not resolved,
        // which is a possibility if HTTP requests are dangling
        // due to retries or timeouts. We know that if we got here
        // that all promises that we care about have successfully
        // resolved, so simply exit with success.
        if (earlyExit) {
            process.exit(0);
        }
    });
}
function restoreOnlyRun(earlyExit) {
    return __awaiter(this, void 0, void 0, function* () {
        yield run(new stateProvider_1.NullStateProvider(), earlyExit);
    });
}
exports.restoreOnlyRun = restoreOnlyRun;
function restoreRun(earlyExit) {
    return __awaiter(this, void 0, void 0, function* () {
        yield run(new stateProvider_1.StateProvider(), earlyExit);
    });
}
exports.restoreRun = restoreRun;


/***/ }),

/***/ 1527:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NullStateProvider = exports.StateProvider = void 0;
const core = __importStar(__nccwpck_require__(2186));
const constants_1 = __nccwpck_require__(9042);
class StateProviderBase {
    constructor() {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function
        this.setState = (key, value) => { };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.getState = (key) => "";
    }
    getCacheState() {
        const cacheKey = this.getState(constants_1.State.CacheMatchedKey);
        if (cacheKey) {
            core.debug(`Cache state/key: ${cacheKey}`);
            return cacheKey;
        }
        return undefined;
    }
}
class StateProvider extends StateProviderBase {
    constructor() {
        super(...arguments);
        this.setState = core.saveState;
        this.getState = core.getState;
    }
}
exports.StateProvider = StateProvider;
class NullStateProvider extends StateProviderBase {
    constructor() {
        super(...arguments);
        this.stateToOutputMap = new Map([
            [constants_1.State.CacheMatchedKey, constants_1.Outputs.CacheMatchedKey],
            [constants_1.State.CachePrimaryKey, constants_1.Outputs.CachePrimaryKey]
        ]);
        this.setState = (key, value) => {
            core.setOutput(this.stateToOutputMap.get(key), value);
        };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.getState = (key) => "";
    }
}
exports.NullStateProvider = NullStateProvider;


/***/ }),

/***/ 6850:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCacheFeatureAvailable = exports.getInputAsBool = exports.getInputAsInt = exports.getInputAsArray = exports.isValidEvent = exports.logWarning = exports.isExactKeyMatch = exports.isGhes = void 0;
const cache = __importStar(__nccwpck_require__(4810));
const core = __importStar(__nccwpck_require__(2186));
const constants_1 = __nccwpck_require__(9042);
function isGhes() {
    const ghUrl = new URL(process.env["GITHUB_SERVER_URL"] || "https://github.com");
    return ghUrl.hostname.toUpperCase() !== "GITHUB.COM";
}
exports.isGhes = isGhes;
function isExactKeyMatch(key, cacheKey) {
    return !!(cacheKey &&
        cacheKey.localeCompare(key, undefined, {
            sensitivity: "accent"
        }) === 0);
}
exports.isExactKeyMatch = isExactKeyMatch;
function logWarning(message) {
    const warningPrefix = "[warning]";
    core.info(`${warningPrefix}${message}`);
}
exports.logWarning = logWarning;
// Cache token authorized for all events that are tied to a ref
// See GitHub Context https://help.github.com/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context
function isValidEvent() {
    return constants_1.RefKey in process.env && Boolean(process.env[constants_1.RefKey]);
}
exports.isValidEvent = isValidEvent;
function getInputAsArray(name, options) {
    return core
        .getInput(name, options)
        .split("\n")
        .map(s => s.replace(/^!\s+/, "!").trim())
        .filter(x => x !== "");
}
exports.getInputAsArray = getInputAsArray;
function getInputAsInt(name, options) {
    const value = parseInt(core.getInput(name, options));
    if (isNaN(value) || value < 0) {
        return undefined;
    }
    return value;
}
exports.getInputAsInt = getInputAsInt;
function getInputAsBool(name, options) {
    const result = core.getInput(name, options);
    return result.toLowerCase() === "true";
}
exports.getInputAsBool = getInputAsBool;
function isCacheFeatureAvailable() {
    if (cache.isFeatureAvailable()) {
        return true;
    }
    if (isGhes()) {
        logWarning(`Cache action is only supported on GHES version >= 3.5. If you are on version >=3.5 Please check with GHES admin if Actions cache service is enabled or not.
Otherwise please upgrade to GHES version >= 3.5 and If you are also using Github Connect, please unretire the actions/cache namespace before upgrade (see https://docs.github.com/en/enterprise-server@3.5/admin/github-actions/managing-access-to-actions-from-githubcom/enabling-automatic-access-to-githubcom-actions-using-github-connect#automatic-retirement-of-namespaces-for-actions-accessed-on-githubcom)`);
        return false;
    }
    logWarning("An internal error has occurred in cache backend. Please check https://www.githubstatus.com/ for any ongoing issue in actions.");
    return false;
}
exports.isCacheFeatureAvailable = isCacheFeatureAvailable;


/***/ }),

/***/ 9491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 2081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 1576:
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ 9512:
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ 4404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 6224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 9796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 8593:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__nccwpck_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;

Object.defineProperty(exports, "__esModule", ({ value: true }));
const restoreImpl_1 = __nccwpck_require__(2357);
(0, restoreImpl_1.restoreRun)(true);

})();

module.exports = __webpack_exports__;
/******/ })()
;